[
  {
    "doc_id": "NIST.FIPS.203",
    "source_path": "data/raw_pdfs/NIST.FIPS.203.pdf",
    "page_number": 1,
    "text": "  FIPS 203\n\n  Federal Information Processing Standards Publication\n\n  Module-Lattice-Based\n  Key-Encapsulation Mechanism Standard\n\n  Category: Computer Security                         Subcategory: Cryptography\n\n  Information Technology Laboratory\n  National Institute of Standards and Technology\n  Gaithersburg, MD 20899-8900\n\n  This publication is available free of charge from:\n  https://doi.org/10.6028/NIST.FIPS.203\n\n  Published August 13, 2024\n\n  U.S. Department of Commerce\n  Gina M. Raimondo, Secretary\n\n 0 National Institute of Standards and Technology\n  Laurie E. Locascio, NIST Director and Under Secretary of Commerce for Standards and Technology\n\nCheck\n   for\nupdates"
  },
  {
    "doc_id": "NIST.FIPS.203",
    "source_path": "data/raw_pdfs/NIST.FIPS.203.pdf",
    "page_number": 2,
    "text": "        Foreword\n\nThe Federal Information Processing Standards (FIPS) Publication Series of the National Institute of Stan-\ndards and Technology is the official series of publications relating to standards and guidelines developed\nunder 15 U.S.C. 278g-3, and issued by the Secretary of Commerce under 40 U.S.C. 11331.\nComments concerning this Federal Information Processing Standard publication are welcomed and should\nbe submitted using the contact information in the â€œInquiries and Commentsâ€ clause of the announcement\nsection.\n\n                Kevin M. Stine, Director\n                Information Technology Laboratory"
  },
  {
    "doc_id": "NIST.FIPS.203",
    "source_path": "data/raw_pdfs/NIST.FIPS.203.pdf",
    "page_number": 3,
    "text": "FIPS 203     MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\n\n             Abstract\nA key-encapsulation mechanism (KEM) is a set of algorithms that, under certain conditions, can be\nused by two parties to establish a shared secret key over a public channel. A shared secret key that\nis securely established using a KEM can then be used with symmetric-key cryptographic algorithms\nto perform basic tasks in secure communications, such as encryption and authentication. This\nstandard specifies a key-encapsulation mechanism called ML-KEM. The security of ML-KEM is\nrelated to the computational difficulty of the Module Learning with Errors problem. At present,\nML-KEM is believed to be secure, even against adversaries who possess a quantum computer.\nThis standard specifies three parameter sets for ML-KEM. In order of increasing security strength\nand decreasing performance, these are ML-KEM-512, ML-KEM-768, and ML-KEM-1024.\n\nKeywords: computer security; cryptography; encryption; Federal Information Processing Stan-\ndards; key-encapsulation mechanism; lattice-based cryptography; post-quantum; public-key\ncryptography."
  },
  {
    "doc_id": "NIST.FIPS.203",
    "source_path": "data/raw_pdfs/NIST.FIPS.203.pdf",
    "page_number": 4,
    "text": "FIPS 203                            MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\n\n    Federal Information Processing Standards Publication 203\n\n    Published:                      August 13, 2024\n    Effective:                      August 13, 2024\n\n                Announcing the\n    Module-Lattice-Based Key-Encapsulation\n              Mechanism Standard\n\nFederal Information Processing Standards (FIPS) publications are developed by the National\nInstitute of Standards and Technology (NIST) under 15 U.S.C. 278g-3 and issued by the Secretary\nof Commerce under 40 U.S.C. 11331.\n1.  Name of Standard. Module-Lattice-Based Key-Encapsulation Mechanism Standard (FIPS\n    203).\n2.  Category of Standard. Computer Security. Subcategory. Cryptography.\n3.  Explanation. A cryptographic key (or simply â€œkeyâ€) is represented in a computer as a string of\n    bits. A shared secret key is a cryptographic key that is computed jointly by two parties (e.g.,\n    Alice and Bob) using a set of algorithms. Under certain conditions, these algorithms ensure\n    that both parties will produce the same key and that this key is secret from adversaries. Such\n    a shared secret key can then be used with symmetric-key cryptographic algorithms (specified\n    in other NIST standards) to perform tasks such as encryption and authentication of digital\n    information.\n    This standard specifies a set of algorithms for establishing a shared secret key. While there\n    are many methods for establishing a shared secret key, the particular method described in\n    this standard is a key-encapsulation mechanism (KEM).\n    In a KEM, the computation of the shared secret key begins with Alice generating a decapsu-\n    lation key and an encapsulation key. Alice keeps the decapsulation key private and makes\n    the encapsulation key available to Bob. Bob then uses Aliceâ€™s encapsulation key to generate\n    one copy of a shared secret key along with an associated ciphertext. Bob then sends the\n    ciphertext to Alice. Finally, Alice uses the ciphertext from Bob along with Aliceâ€™s private\n    decapsulation key to compute another copy of the shared secret key.\n    The security of the particular KEM specified in this standard is related to the computational\n    difficulty of solving certain systems of noisy linear equations, specifically the Module Learn-\n    ing With Errors (MLWE) problem. At present, it is believed that this particular method of\n    establishing a shared secret key is secure, even against adversaries who possess a quantum\n    computer. In the future, additional KEMs may be specified and approved in FIPS publications\n    or in NIST Special Publications.\n4.  Approving Authority. Secretary of Commerce.\n5.  Maintenance Agency. Department of Commerce, National Institute of Standards and Tech-\n    nology, Information Technology Laboratory (ITL).\n\n                                    i"
  },
  {
    "doc_id": "NIST.FIPS.203",
    "source_path": "data/raw_pdfs/NIST.FIPS.203.pdf",
    "page_number": 5,
    "text": "FIPS 203                               MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\n\n6.  Applicability. Federal Information Processing Standards apply to information systems used or\n    operated by federal agencies or by a contractor of an agency or other organization on behalf\n    of an agency. They do not apply to national security systems as defined in 44 U.S.C. 3552.\n    This standard, or other FIPS or NIST Special Publications that specify alternative mechanisms,\n    shall be used wherever the establishment of a shared secret key (or shared secret from which\n    keying material can be generated) is required for federal applications, including the use of\n    such a key with symmetric-key cryptographic algorithms, in accordance with applicable Office\n    of Management and Budget and agency policies.\n    The adoption and use of this standard are available to private and commercial organizations.\n7.  Implementations. A key-encapsulation mechanism may be implemented in software, firmware,\n    hardware, or any combination thereof. For every computational procedure that is specified\n    in this standard, a conforming implementation may replace the given set of steps with any\n    mathematically equivalent set of steps. In other words, different procedures that produce\n    the correct output for every input are permitted.\n    NIST will develop a validation program to test implementations for conformance to the\n    algorithms in this standard.  Information about validation programs is available at https:\n //csrc.nist.gov/projects/cmvp. Example values will be available at https://csrc.nist.gov/proj\n    ects/cryptographic-standards-and-guidelines/example-values.\n8.  Other Approved Security Functions. Implementations that comply with this standard\n    shall employ cryptographic algorithms that have been approved for protecting Federal\n    Government-sensitive information.         Approved cryptographic algorithms and techniques\n    include those that are either:\n    (a)  Specified in a Federal Information Processing Standards (FIPS) publication,\n    (b)  Adopted in a FIPS or NIST recommendation, or\n    (c)  Specified in the list of approved security functions in SP 800-140C.\n9.  Export Control. Certain cryptographic devices and technical data regarding them are subject\n    to federal export controls. Exports of cryptographic modules that implement this standard\n    and technical data regarding them must comply with all federal laws and regulations and\n    be licensed by the Bureau of Industry and Security of the U.S. Department of Commerce.\n    Information about export regulations is available at https://www.bis.doc.gov.\n10. Patents. NIST has entered into two patent license agreements to facilitate the adoption of\n    NISTâ€™s announced selection of the PQC key-encapsulation mechanism CRYSTALS-KYBER. NIST\n    and the licensing parties share a desire, in the public interest, the licensed patents be freely\n    available to be practiced by any implementer of the ML-KEM algorithm as published by NIST.\n    ML-KEM is the name given to the algorithm in this standard derived from CRYSTALS-KYBER.\n    For a summary and extracts from the license, please see https://csrc.nist.gov/csrc/media/P\n    rojects/post-quantum-cryptography/documents/selected-algos-2022/nist-pqc-license-sum\n    mary-and-excerpts.pdf. Implementation of the algorithm specified in the standard may be\n    covered by U.S. and foreign patents of which NIST is not aware.\n\nii"
  },
  {
    "doc_id": "NIST.FIPS.203",
    "source_path": "data/raw_pdfs/NIST.FIPS.203.pdf",
    "page_number": 6,
    "text": "FIPS 203                                  MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\n\n11. Implementation Schedule. This standard becomes effective immediately upon final publica-\n tion.\n12. Specifications. Federal Information Processing Standards (FIPS) 203, Module-Lattice-Based\n Key-Encapsulation Mechanism Standard (affixed).\n13. Qualifications. In applications, the security guarantees of a KEM only hold under certain\n conditions (see SP 800-227 [1]). One such condition is the secrecy of several values, including\n the randomness used by the two parties, the decapsulation key, and the shared secret key\n itself. Users shall, therefore, guard against the disclosure of these values.\nWhile it is the intent of this standard to specify general requirements for implementing\n ML-KEM algorithms, conformance to this standard does not ensure that a particular imple-\n mentation is secure. It is the responsibility of the implementer to ensure that any module\n that implements a key establishment capability is designed and built in a secure manner.\n Similarly, the use of a product containing an implementation that conforms to this standard\n does not guarantee the security of the overall system in which the product is used. The re-\n sponsible authority in each agency or department shall ensure that an overall implementation\n provides an acceptable level of security.\n NIST will continue to follow developments in the analysis of the ML-KEM algorithm. As with\n its other cryptographic algorithm standards, NIST will formally reevaluate this standard every\n five years.\n Both this standard and possible threats that reduce the security provided through the use of\n this standard will undergo review by NIST as appropriate, taking into account newly available\n analysis and technology. In addition, the awareness of any breakthrough in technology or\n any mathematical weakness of the algorithm will cause NIST to reevaluate this standard and\n provide necessary revisions.\n14. Waiver Procedure. The Federal Information Security Management Act (FISMA) does not allow\n for waivers to Federal Information Processing Standards (FIPS) that are made mandatory by\n the Secretary of Commerce.\n15. Where to Obtain Copies of the Standard. This publication is available by accessing https:\n//csrc.nist.gov/publications. Other computer security publications are available at the same\nwebsite.\n16. How to Cite This Publication. NIST has assigned NIST FIPS 203 as the publication identifier\n for this FIPS, per the NIST Technical Series Publication Identifier Syntax. NIST recommends\n that it be cited as follows:\n            National Institute of Standards and Technology (2024) Module-Lattice-Based Key-\n            Encapsulation Mechanism Standard. (Department of Commerce, Washington,\n            D.C.), Federal Information Processing Standards Publication (FIPS) NIST FIPS 203.\n            https://doi.org/10.6028/NIST.FIPS.203\n17. Inquiries and Comments. Inquiries and comments about this FIPS may be submitted to\n fips-203-comments@nist.gov.\n\niii"
  },
  {
    "doc_id": "NIST.FIPS.203",
    "source_path": "data/raw_pdfs/NIST.FIPS.203.pdf",
    "page_number": 7,
    "text": "    FIPS 203    MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\n\nFederal Information Processing Standards Publication 203\n\n                 Specification for the\n         Module-Lattice-Based Key-Encapsulation\n                   Mechanism Standard\n\n                                          Table of Contents\n\n    1  Introduction                                                              1\n       1.1     Purpose and Scope                                                 1\n       1.2     Context                                                           1\n\n    2  Terms, Acronyms, and Notation                                             2\n       2.1     Terms and Definitions                                             2\n       2.2     Acronyms                                                          4\n       2.3     Mathematical Symbols                                              5\n       2.4     Interpreting the Pseudocode                                       6\n               2.4.1      Data Types                                             7\n               2.4.2      Loop Syntax                                            7\n               2.4.3      Arithmetic With Arrays of Integers                     7\n               2.4.4      Representations of Algebraic Objects                   8\n               2.4.5      Arithmetic With Polynomials and NTT Representations    9\n               2.4.6      Matrices and Vectors                                   9\n               2.4.7      Arithmetic With Matrices and Vectors                  10\n               2.4.8      Applying Algorithms to Arrays, Examples               11\n\n    3  Overview of the ML-KEM Scheme                                            12\n       3.1     Key-Encapsulation Mechanisms                                     12\n       3.2     The ML-KEM Scheme                                                13\n       3.3     Requirements for ML-KEM Implementations                          15\n\n    4  Auxiliary Algorithms                                                     18\n       4.1     Cryptographic Functions                                          18\n       4.2     General Algorithms                                               20\n               4.2.1      Conversion and Compression Algorithms                 20\n               4.2.2      Sampling Algorithms                                   22\n       4.3     The Number-Theoretic Transform                                    24\n\n                                                  iv"
  },
  {
    "doc_id": "NIST.FIPS.203",
    "source_path": "data/raw_pdfs/NIST.FIPS.203.pdf",
    "page_number": 8,
    "text": "FIPS 203                               MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\n\n            4.3.1  Multiplication in the NTT Domain                                 27\n\n5  The K-PKE Component Scheme                                                       28\n   5.1      K-PKE Key Generation                                                    28\n   5.2      K-PKE Encryption                                                        29\n   5.3      K-PKE Decryption                                                        31\n\n6  Main Internal Algorithms                                                         32\n   6.1      Internal Key Generation                                                 32\n   6.2      Internal Encapsulation                                                  32\n   6.3      Internal Decapsulation                                                  33\n\n7  The ML-KEM Key-Encapsulation Mechanism                                           35\n   7.1      ML-KEM Key Generation                                                   35\n   7.2      ML-KEM Encapsulation                                                    36\n   7.3      ML-KEM Decapsulation                                                    37\n\n8  Parameter Sets                                                                   39\n\nReferences                                                                          41\n\nAppendix A â€” Precomputed Values for the NTT                                         44\n\nAppendix B â€” SampleNTT Loop Bounds                                                  46\n\nAppendix C â€” Differences From the CRYSTALS-KYBER Submission                         47\n   C.1      Differences Between CRYSTALS-KYBER and FIPS 203 Initial Public Draft    47\n   C.2      Changes From FIPS 203 Initial Public Draft                              47\n\nv"
  },
  {
    "doc_id": "NIST.FIPS.203",
    "source_path": "data/raw_pdfs/NIST.FIPS.203.pdf",
    "page_number": 9,
    "text": "FIPS 203                                              MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\n\n                                    List of Tables\n\nTable 1     Decapsulation failure rates for ML-KEM                                                  15\nTable 2     Approved parameter sets for ML-KEM                                                      39\nTable 3     Sizes (in bytes) of keys and ciphertexts of ML-KEM                                      39\nTable 4     While-loop limits and probabilities of occurrence for SampleNTT                         46\n\n                                    List of Figures\n\nFigure 1        A simple view of key establishment using a KEM                                      12\n\n                                    List of Algorithms\nAlgorithm 1      ForExample()          . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     8\nAlgorithm 2      SHAKE128example(strâ‚, â€¦ , strğ‘š , ğ‘â‚, â€¦ , ğ‘â„“)       . . . . . . . . . . . . .    19\nAlgorithm 3      BitsToBytes(ğ‘)         . . . . . . . . . . . . . . . . . . . . . . . . . . . .    20\nAlgorithm 4      BytesToBits(ğµ)         . . . . . . . . . . . . . . . . . . . . . . . . . . . .    20\nAlgorithm 5      ByteEncodeğ‘‘(ğ¹ ) . . . . . . . . . . . . . . . . . . . . . . . . . . . .          22\nAlgorithm 6      ByteDecodeğ‘‘(ğµ) . . . . . . . . . . . . . . . . . . . . . . . . . . . .           22\nAlgorithm 7      SampleNTT(ğµ)           . . . . . . . . . . . . . . . . . . . . . . . . . . . .    23\nAlgorithm 8      SamplePolyCBDğœ‚(ğµ)           . . . . . . . . . . . . . . . . . . . . . . . . .    23\nAlgorithm 9      NTT(ğ‘“)         . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .    26\nAlgorithm 10     NTTâˆ’1(ğ‘“)         . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .    26\nAlgorithm 11     MultiplyNTTs(ğ‘“, ğ‘”)Ì‚       . . . . . . . . . . . . . . . . . . . . . . . . . .    27\nAlgorithm 12     BaseCaseMultiply(ğ‘â‚€, ğ‘â‚, ğ‘â‚€, ğ‘â‚, ğ›¾)    . . . . . . . . . . . . . . . . . .    27\nAlgorithm 13     K-PKE.KeyGen(ğ‘‘)          . . . . . . . . . . . . . . . . . . . . . . . . . . .    29\nAlgorithm 14     K-PKE.Encrypt(ekPKE, ğ‘š, ğ‘Ÿ) . . . . . . . . . . . . . . . . . . . . . . .         30\nAlgorithm 15     K-PKE.Decrypt(dkPKE, ğ‘)        . . . . . . . . . . . . . . . . . . . . . . . .    31\nAlgorithm 16     ML-KEM.KeyGen_internal(ğ‘‘, ğ‘§)          . . . . . . . . . . . . . . . . . . . .    32\nAlgorithm 17     ML-KEM.Encaps_internal(ek, ğ‘š)            . . . . . . . . . . . . . . . . . . .    33\nAlgorithm 18     ML-KEM.Decaps_internal(dk, ğ‘)          . . . . . . . . . . . . . . . . . . . .    34\nAlgorithm 19     ML-KEM.KeyGen() . . . . . . . . . . . . . . . . . . . . . . . . . . .              35\nAlgorithm 20     ML-KEM.Encaps(ek) . . . . . . . . . . . . . . . . . . . . . . . . . .              37\nAlgorithm 21     ML-KEM.Decaps(dk, ğ‘)           . . . . . . . . . . . . . . . . . . . . . . . .    38\n\nvi"
  },
  {
    "doc_id": "NIST.FIPS.203",
    "source_path": "data/raw_pdfs/NIST.FIPS.203.pdf",
    "page_number": 10,
    "text": "FIPS 203                               MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\n\n1.   Introduction\n\n1.1  Purpose and Scope\nThis standard specifies the Module-Lattice-Based Key-Encapsulation Mechanism (ML-KEM). A\nkey-encapsulation mechanism (KEM) is a set of algorithms that can be used to establish a shared\nsecret key between two parties communicating over a public channel. A KEM is a particular type\nof key establishment scheme. Other NIST-approved key establishment schemes are specified\nin NIST Special Publication (SP) 800-56A, Recommendation for Pair-Wise Key-Establishment\nSchemes Using Discrete Logarithm-Based Cryptography [2], and SP 800-56B, Recommendation\nfor Pair-Wise Key Establishment Schemes Using Integer Factorization Cryptography [3].\nThe key establishment schemes specified in SP 800-56A and SP 800-56B are vulnerable to\nattacks that use sufficiently-capable quantum computers. ML-KEM is an approved alternative\nthat is presently believed to be secure, even against adversaries in possession of a large-scale\nfault-tolerant quantum computer.       ML-KEM is derived from the round-three version of the\nCRYSTALS-KYBER KEM [4], a submission in the NIST Post-Quantum Cryptography Standardization\nproject. For the differences between ML-KEM and CRYSTALS-KYBER, see Appendix C.\nThis standard specifies the algorithms and parameter sets of the ML-KEM scheme.      It aims\nto provide sufficient information to implement ML-KEM in a manner that can pass validation\n(see https://csrc.nist.gov/projects/cryptographic- module- validation- program).        For\ngeneral definitions and properties of KEMs, including requirements for the secure use of KEMs\nin applications, see SP 800-227 [1].\nThis standard specifies three parameter sets for ML-KEM that offer different trade-offs in security\nstrength versus performance.      All three parameter sets of ML-KEM are approved to protect\nsensitive, non-classified communication systems of the U.S. Federal Government.\n\n1.2  Context\nOver the past several years, there has been steady progress toward building quantum computers.\nIf large-scale quantum computers are realized, the security of many commonly used public-key\ncryptosystems will be at risk. This would include key-establishment schemes and digital signature\nschemes whose security depends on the difficulty of solving the integer factorization and discrete\nlogarithm problems (both over finite fields and elliptic curves). As a result, in 2016, NIST initiated\na public Post-Quantum Cryptography (PQC) Standardization process to select quantum-resistant\npublic-key cryptographic algorithms. A total of 82 candidate algorithms were submitted to NIST\nfor consideration.\nAfter three rounds of evaluation and analysis, NIST selected the first four algorithms for stan-\ndardization. These algorithms are intended to protect sensitive U.S. Government information\nwell into the foreseeable future, including after the advent of cryptographically-relevant quan-\ntum computers. This standard specifies a variant of the selected algorithm CRYSTALS-KYBER, a\nlattice-based key-encapsulation mechanism (KEM) designed by Peter Schwabe, Roberto Avanzi,\nJoppe Bos, LÃ©o Ducas, Eike Kiltz, TancrÃ¨de Lepoint, Vadim Lyubashevsky, John Schanck, Gregor\nSeiler, Damien StehlÃ©, and Jintai Ding [4]. Throughout this standard, the KEM specified here will\nbe referred to as ML-KEM, as it is based on the Module Learning With Errors assumption.\n\n                                       1"
  },
  {
    "doc_id": "NIST.FIPS.203",
    "source_path": "data/raw_pdfs/NIST.FIPS.203.pdf",
    "page_number": 11,
    "text": "FIPS 203                                   MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\n\n2.   Terms, Acronyms, and Notation\n\n2.1  Terms and Definitions\n approved               FIPS-approved and/or NIST-recommended. An algorithm or technique\n                        that is either 1) specified in a FIPS or NIST recommendation, 2) adopted\n                        in a FIPS or NIST recommendation, or 3) specified in a list of NIST-approved\n                        security functions.\n(KEM) ciphertext        A bit string that is produced by encapsulation and used as an input to\n                        decapsulation.\n cryptographic          The set of hardware, software, and/or firmware that implements ap-\n module                 proved cryptographic functions (including key generation) that are con-\n                        tained within the cryptographic boundary of the module.\n decapsulation          The process of applying the Decaps algorithm of a KEM. This algorithm\n                        accepts a KEM ciphertext and the decapsulation key as input and pro-\n                        duces a shared secret key as output.\n decapsulation key      A cryptographic key produced by a KEM during key generation and used\n                        during the decapsulation process. The decapsulation key must be kept\n                        private and must be destroyed after it is no longer needed. (See Section\n                        3.3.)\n decryption key         A cryptographic key that is used with a PKE in order to decrypt cipher-\n                        texts into plaintexts. The decryption key must be kept private and must\n                        be destroyed after it is no longer needed.\n destroy                An action applied to a key or other piece of secret data. After a piece\n                        of secret data is destroyed, no information about its value can be re-\n                        covered.\n encapsulation          The process of applying the Encaps algorithm of a KEM. This algorithm\n                        accepts the encapsulation key as input, requires private randomness,\n                        and produces a shared secret key and an associated ciphertext as out-\n                        put.\n encapsulation key      A cryptographic key produced by a KEM during key generation and used\n                        during the encapsulation process. The encapsulation key can be made\n                        public. (See Section 3.3.)\n encryption key         A cryptographic key that is used with a PKE in order to encrypt plaintexts\n                        into ciphertexts. The encryption key can be made public.\n equivalent process     Two processes are equivalent if the same output is produced when the\n                        same values are input to each process (either as input parameters, as\n                        values made available during the process, or both).\n fresh random value     An output that was produced by a random bit generator and has not\n                        been previously used.\n\n                                           2"
  },
  {
    "doc_id": "NIST.FIPS.203",
    "source_path": "data/raw_pdfs/NIST.FIPS.203.pdf",
    "page_number": 12,
    "text": "FIPS 203                                MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\n\nhash function         A function on bit strings in which the length of the output is fixed.\n                      Approved hash functions (such as those specified in FIPS 180 [5] and\n                      FIPS 202 [6]) are designed to satisfy the following properties:\n                       1.  (One-way) It is computationally infeasible to find any input that\n                           maps to any new pre-specified output.\n                       2.  (Collision-resistant) It is computationally infeasible to find any two\n                           distinct inputs that map to the same output.\ninput checking        Examination of a potential input to an algorithm for the purpose of\n                      determining whether it conforms to certain requirements.\nkey                   A bit string that is used in conjunction with a cryptographic algorithm,\n                      such as the encapsulation and decapsulation keys (of a KEM), the shared\n                      secret key (produced by a KEM), and the encryption and decryption\n                      keys (of a PKE). (See Section 3.3.)\nkey-encapsulation     A set of three cryptographic algorithms (KeyGen, Encaps, and Decaps)\nmechanism (KEM)       that can be used by two parties to establish a shared secret key over a\n                      public channel.\nkey establishment     A procedure that results in secret keying material that is shared among\n                      different parties.\nkey pair              A set of two keys with the property that one key can be made public\n                      while the other key must be kept private. In this standard, this could\n                      refer to either the (encapsulation key, decapsulation key) key pair of a\n                      KEM or the (encryption key, decryption key) key pair of a PKE.\nlittle-endian         The property of a byte string having its bytes positioned in order of\n                      increasing significance. In particular, the leftmost (first) byte is the\n                      least significant, and the rightmost (last) byte is the most significant.\n                      The term â€œlittle-endianâ€ may also be applied in the same manner to\n                      bit strings (e.g., the 8-bit string 11010001 corresponds to the byte\n                      2â° + 2Â¹ + 2Â³ + 2â· = 139).\nparty                 An individual person, organization, device, or process. In this specifica-\n                      tion, there are two parties (e.g., Party A and Party B, or Alice and Bob)\n                      who jointly perform the key establishment process using a KEM.\npseudorandom          A process (or data produced by a process) is said to be pseudorandom\n                      when the outcome is deterministic yet also appears random as long\n                      as the internal action of the process is hidden from observation. For\n                      cryptographic purposes, â€œeffectively randomâ€ means â€œcomputationally\n                      indistinguishable from random within the limits of the intended security\n                      strength.â€\npublic channel        A communication channel between two parties. Such a channel can be\n                      observed and possibly also corrupted by third parties.\n\n3"
  },
  {
    "doc_id": "NIST.FIPS.203",
    "source_path": "data/raw_pdfs/NIST.FIPS.203.pdf",
    "page_number": 13,
    "text": "FIPS 203                      MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\n\npublic-key            A set of three cryptographic algorithms (KeyGen, Encrypt, and Decrypt)\nencryption scheme     that can be used by two parties to send secret data over a public channel.\n(PKE)                 Also known as an asymmetric encryption scheme.\nshared secret         A secret value that has been computed during a key-establishment\n                      scheme, is known by both participants, and is used as input to a key-\n                      derivation method to produce keying material.\nshared secret key     A shared secret that can be used directly as a cryptographic key in\n                      symmetric-key cryptography. It does not require additional key deriva-\n                      tion. The shared secret key must be kept private and must be destroyed\n                      when no longer needed.\nsecurity category     A number associated with the security strength of a post-quantum\n                      cryptographic algorithm, as specified by NIST (see [7]).\nsecurity strength     A number associated with the amount of work (i.e., the number of op-\n                      erations) that is required to break a cryptographic algorithm or system.\nshall                 Used to indicate a requirement of this standard.\nshould                Used to indicate a strong recommendation but not a requirement of\n                      this standard. Ignoring the recommendation could lead to undesirable\n                      results.\n\n2.2    Acronyms\nAES        Advanced Encryption Standard\nCBD        Centered Binomial Distribution\nFIPS       Federal Information Processing Standard\nKEM        Key-Encapsulation Mechanism\nLWE        Learning with Errors\nMLWE       Module Learning with Errors\nNIST       National Institute of Standards and Technology\nNISTIR     NIST Interagency or Internal Report\nNTT        Number-Theoretic Transform\nPKE        Public-Key Encryption\nPQC        Post-Quantum Cryptography\nPRF        Pseudorandom Function\nRBG        Random Bit Generator\nSHA        Secure Hash Algorithm\n                                4"
  },
  {
    "doc_id": "NIST.FIPS.203",
    "source_path": "data/raw_pdfs/NIST.FIPS.203.pdf",
    "page_number": 14,
    "text": "FIPS 203                       MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\n\nSHAKE       Secure Hash Algorithm KECCAK\nSP          Special Publication\nXOF         Extendable-Output Function\n\n2.3      Mathematical Symbols\nğ‘›             Denotes the integer 256 throughout this document.\nğ‘             Denotes the prime integer 3329 = 2â¸ â‹… 13 + 1 throughout this document.\nğœ             Denotes the integer 17, which is a primitive ğ‘›-th root of unity modulo ğ‘.\nğ”¹             The set {0, 1, â€¦ , 255} of unsigned 8-bit integers (bytes).\nâ„š              The set of rational numbers.\nâ„¤              The set of integers.\nâ„¤ğ‘š            The ring of integers modulo ğ‘š (i.e., the set {0, 1, â€¦ , ğ‘š âˆ’ 1} equipped with\n               the operations of addition and multiplication modulo ğ‘š.)\nâ„¤ğ‘›            The set of ğ‘›-tuples over â„¤  equipped with â„¤ -module structure. As a data\n      ğ‘š       type, this is the set of     ğ‘š          ğ‘š\n                                         length-ğ‘› arrays whose entries are in â„¤ğ‘š .\nğ‘…ğ‘           The ring â„¤ğ‘ [ğ‘‹]/(ğ‘‹ğ‘› + 1) consisting of polynomials of the form ğ‘“ = ğ‘“â‚€ +\n               ğ‘“â‚ğ‘‹ + â‹¯ + ğ‘“â‚‚â‚…â‚…ğ‘‹Â²âµâµ, where ğ‘“ğ‘— âˆˆ â„¤ğ‘ for all ğ‘—. The ring operations are addi-\n               tion and multiplication modulo ğ‘‹ğ‘› + 1.\nğ‘‡ğ‘           The image of ğ‘…ğ‘ under the number-theoretic transform. Its elements are\n               called â€œNTT representationsâ€ of polynomials in ğ‘…ğ‘ . (See Section 4.3.)\nDğœ‚(ğ‘…ğ‘ )     A certain distribution of polynomials in ğ‘…ğ‘ with small coefficients, from\n              which noise is sampled. The distribution is parameterized by ğœ‚ âˆˆ {2, 3}. (See\n               Section 4.2.2.)\nğ‘† âˆ—           If ğ‘† is a set, this denotes the set of finite-length tuples (or arrays) of elements\n               from the set ğ‘†, including the empty tuple (or empty array).\nğ‘† ğ‘˜          If ğ‘† is a set, this denotes the set of ğ‘˜-tuples (or length-ğ‘˜ arrays) of elements\n               from the set ğ‘†.\nğ‘“ğ‘—           The coefficient of ğ‘‹ğ‘— of a polynomial ğ‘“ = ğ‘“â‚€ + ğ‘“â‚ğ‘‹ + â‹¯ + ğ‘“â‚‚â‚…â‚…ğ‘‹Â²âµâµ âˆˆ ğ‘…ğ‘ .\n\nğ‘“             The element of ğ‘‡ğ‘ that is equal to the NTT representation of a polynomial\n               ğ‘“ âˆˆ ğ‘…ğ‘ . (See Sections 2.4.4 and 4.3.)\nğ¯ğ‘‡, ğ€ğ‘‡     The transpose of a row or column vector ğ¯. In general, the transpose of a\n               matrix ğ€.\n\n5"
  },
  {
    "doc_id": "NIST.FIPS.203",
    "source_path": "data/raw_pdfs/NIST.FIPS.203.pdf",
    "page_number": 15,
    "text": "FIPS 203                                 MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\n\n   âˆ˜                Denotes linear-algebraic composition with coefficients in ğ‘…ğ‘ or ğ‘‡ğ‘ (e.g.,\n                    ğ€ âˆ˜ ğ¯ denotes the vector resulting from applying matrix ğ€ to vector ğ¯). (See\n                    Section 2.4.7.)\n   Ã—ğ‘‡ğ‘            Denotes the operation on coefficient arrays that implements product in the\n                    ring ğ‘‡ğ‘ . (See Sections 2.4.5 and 4.3.1.)\n  ğ´â€–ğµ             The concatenation of two arrays or bit strings ğ´ and ğµ.\n  ğµ[ğ‘–]            The entry at index ğ‘– in the array ğµ. All arrays have indices that begin at zero.\n  ğµ[ğ‘˜ âˆ¶ ğ‘š]       The subarray (ğµ[ğ‘˜], ğµ[ğ‘˜ + 1], â€¦ , ğµ[ğ‘š âˆ’ 1]) of the array ğµ.\n  |ğµ|              If ğµ is a number, this denotes the absolute value of ğµ. If ğµ is an array, this\n                    denotes its length.\n  âŒˆğ‘¥âŒ‰              The ceiling of ğ‘¥ (i.e., the smallest integer greater than or equal to ğ‘¥).\n  âŒŠğ‘¥âŒ‹              The floor of ğ‘¥ (i.e., the largest integer less than or equal to ğ‘¥).\n  âŒˆğ‘¥âŒ‹              The rounding of ğ‘¥ to the nearest integer. If ğ‘¥ = ğ‘¦ + 1/2 for some ğ‘¦ âˆˆ â„¤, then\n                    âŒˆğ‘¥âŒ‹ = ğ‘¦ + 1.\n âˆ¶=                 Denotes that the left-hand side is defined to be the expression on the right-\n                    hand side.\n ğ‘Ÿ mod ğ‘š          The unique integer ğ‘Ÿâ€² in {0, 1, â€¦ , ğ‘š âˆ’ 1} such that ğ‘š divides ğ‘Ÿ âˆ’ ğ‘Ÿâ€² .\n  BitRevâ‚‡ (ğ‘Ÿ)      Bit reversal of a seven-bit integer ğ‘Ÿ. Specifically, if ğ‘Ÿ = ğ‘Ÿâ‚€ + 2ğ‘Ÿâ‚ + 4ğ‘Ÿâ‚‚ + â‹¯ +\n                    64ğ‘Ÿâ‚† with ğ‘Ÿğ‘– âˆˆ {0, 1}, then BitRevâ‚‡ (ğ‘Ÿ) = ğ‘Ÿâ‚† + 2ğ‘Ÿâ‚… + 4ğ‘Ÿâ‚„ + â‹¯ + 64ğ‘Ÿâ‚€.\n  ğ‘  â† ğ‘¥           In pseudocode, this notation means that the variable ğ‘  is assigned the value\n                    of the expression ğ‘¥.\n  ğ‘     $   ğ”¹â„“     In pseudocode, this notation means that the variable ğ‘  is assigned the value\n        âˆ’\n        â†\n                    of an array of â„“ random bytes. The bytes must be freshly generated using\n                    randomness from an approved RBG. (See Section 3.3.)\n  âŠ¥                 A symbol indicating failure or the lack of output from an algorithm.\n\n2.4       Interpreting the Pseudocode\nThis section outlines the conventions of the pseudocode used to describe the algorithms in\nthis standard.     All algorithms are understood to have access to two global integer constants:\nğ‘› = 256 and ğ‘ = 3329. There are also five global integer variables: ğ‘˜, ğœ‚â‚, ğœ‚â‚‚, ğ‘‘ğ‘¢, and ğ‘‘ğ‘£. All\nother variables are local. The five global variables are set to particular values when a parameter\nset is selected (see Section 8).\nWhen algorithms in this specification invoke other algorithms as subroutines, all arguments (i.e.,\ninputs) are passed by value. In other words, a copy of the inputs is created, and the subroutine\nis invoked with the copy. There is no â€œpassing by reference.â€\nPseudocode assignments are performed using the symbol â€œâ†.â€ For example, the statement\nğ‘§ â† ğ‘¦ means that the variable ğ‘§ is assigned the value of variable ğ‘¦. Pseudocode comparisons\n                                         6"
  },
  {
    "doc_id": "NIST.FIPS.203",
    "source_path": "data/raw_pdfs/NIST.FIPS.203.pdf",
    "page_number": 16,
    "text": "FIPS 203                                 MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\n\nare performed via the symbol â€œ==.â€ For example, the expression ğ‘¥ == ğ‘¤ is a boolean value\nthat is TRUE if and only if the variables ğ‘¥ and ğ‘¤ have the same value.\nIn regular text (i.e., outside of the pseudocode), a different convention is applied. There, the\n            â€œ=â€ symbol is used both for assigning values and for comparisons, in keeping with standard\nmathematical notation. When emphasis is needed, assignments will be made with â€œâˆ¶=â€ instead.\n       Variables will always have a valid value that is appropriate to their data type, with two exceptions:\n 1.    The outputs of a random bit generator (RBG) have the byte array data type but are also\n       allowed to have the special value NULL. This value indicates that randomness generation\n       failed. This can only occur in ML-KEM.KeyGen and ML-KEM.Encaps.\n 2.    The outputs of ML-KEM.KeyGen and ML-KEM.Encaps have the byte array data type but\n       are also allowed to have the special value âŠ¥. When ML-KEM.KeyGen or ML-KEM.Encaps\n       return the value âŠ¥, this indicates that the algorithm failed due to a failure of randomness\n       generation.\n\n2.4.1       Data Types\nFor variables that represent the input or output of an algorithm, the data type (e.g., bit, byte,\narray of bits) will be explicitly described at the start of the algorithm. For most local variables\nin the pseudocode, the data type is easily deduced from context. For all other variables, the\ndata type will be declared in a comment.         In a single algorithm, the data type of a variable is\ndetermined the first time that the variable is used and will not be changed. Variable names can\nand will be reused across different algorithms, including with different data types.\nIn addition to standard atomic data types (e.g., bits, bytes) and data structures (e.g., arrays),\nintegers modulo ğ‘š (i.e., elements of â„¤ğ‘š ) will also be used as an abstract data type. It is implicit\nthat reduction modulo ğ‘š takes place whenever an assignment is made to a variable in â„¤ğ‘š . For\nexample, for ğ‘§ âˆˆ â„¤ğ‘š and integers ğ‘¥ and ğ‘¦, the statement\n\n                                                     ğ‘§ â† ğ‘¥ + ğ‘¦                                (2.1)\n\nmeans that ğ‘§ is assigned the value ğ‘¥ + ğ‘¦ mod ğ‘š. The pseudocode is agnostic regarding how\nan integer modulo ğ‘š is represented in actual implementations or how modular reduction is\ncomputed.\n\n2.4.2       Loop Syntax\nThe pseudocode will make use of both â€œwhileâ€ and â€œforâ€ loops. The â€œwhileâ€ syntax is self-\nexplanatory. In the case of â€œforâ€ loops, the syntax will be in the style of the programming language\nC. Two simple examples are given in Algorithm 1. The standard mathematical expression (e.g.,\nâˆ‘ğ‘›    (ğ‘– + 3)) will be used for simple summations instead of a â€œforâ€ loop.\nğ‘–â†1\n\n2.4.3       Arithmetic With Arrays of Integers\nThis standard makes extensive use of arrays of integers modulo ğ‘š (i.e., elements of â„¤â„“ ). In a\ntypical case, the relevant values are ğ‘š = ğ‘ = 3329 and â„“ = ğ‘› = 256. Arithmetic with ğ‘š\n                                                                                       arrays in\n                                         7"
  },
  {
    "doc_id": "NIST.FIPS.203",
    "source_path": "data/raw_pdfs/NIST.FIPS.203.pdf",
    "page_number": 17,
    "text": "FIPS 203                                    MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\n\nAlgorithm 1 ForExample()\nPerforms two simple â€œforâ€ loops.\n 1:    for (ğ‘– â† 0; ğ‘– < 10; ğ‘– ++)\n 2:           ğ´[ğ‘–] â† ğ‘–                         â–· ğ´ is an integer array of length 10\n 3:    end for                                               â–· ğ´ now has the value (0, 1, 2, 3, 4, 5, 6, 7, 8, 9)\n 4:    ğ‘— â† 0\n 5:    for (ğ‘˜ â† 256; ğ‘˜ > 1; ğ‘˜ â† ğ‘˜/2)\n 6:           ğµ[ğ‘—] â† ğ‘˜                         â–· ğµ is an integer array of length 8\n 7:           ğ‘— â† ğ‘— + 1\n 8:    end for                                              â–· ğµ now has the value (256, 128, 64, 32, 16, 8, 4, 2)\n\nâ„¤â„“     will be done as follows. Let ğ‘ âˆˆ â„¤  and ğ‘‹, ğ‘Œ âˆˆ â„¤â„“ . The statements\n ğ‘š                                         ğ‘š    ğ‘š\n                                                  ğ‘ â† ğ‘ â‹… ğ‘‹                                              (2.2)\n                                                  ğ‘Š â† ğ‘‹ + ğ‘Œ                                              (2.3)\n\nwill result in two arrays ğ‘, ğ‘Š âˆˆ â„¤â„“           , with the property that ğ‘[ğ‘–] = ğ‘ â‹… ğ‘‹[ğ‘–] and ğ‘Š [ğ‘–] = ğ‘‹[ğ‘–] + ğ‘Œ [ğ‘–]\nfor all     . Multiplication of arrays ğ‘š â„“\nwhich ğ‘–                                             in â„¤ğ‘š will only be meaningful when ğ‘š = ğ‘ and â„“ = ğ‘› = 256, in\n        case it corresponds to multiplication in a particular ring. This operation will be described\nin (2.8).\n\n2.4.4         Representations of Algebraic Objects\nAn essential operation in ML-KEM is the number-theoretic transform (NTT), which maps a poly-\nnomial ğ‘“ in a certain ring ğ‘…ğ‘ to its â€œNTT representationâ€ ğ‘“ in an isomorphic ring ğ‘‡ğ‘ . The rings ğ‘…ğ‘\nand ğ‘‡ğ‘ and the NTT are discussed in detail in Section 4.3. This standard will represent elements\nof ğ‘…ğ‘ and ğ‘‡ğ‘ in pseudocode using arrays of integers modulo ğ‘ as follows.\nAn element ğ‘“ of ğ‘…ğ‘ is a polynomial of the form\n\n                                   ğ‘“ = ğ‘“â‚€ + ğ‘“â‚ğ‘‹ + â‹¯ + ğ‘“â‚‚â‚…â‚…ğ‘‹Â²âµâµ âˆˆ ğ‘…ğ‘                                 (2.4)\n\nand will be represented in pseudocode by the array\n\n                                          (ğ‘“â‚€, ğ‘“â‚, â€¦ , ğ‘“â‚‚â‚…â‚…) âˆˆ â„¤Â²âµâ¶,                                     (2.5)\n                                                                  ğ‘\n               whose entries contain the coefficients of ğ‘“. Overloading notation, the array in (2.5) will also be\ndenoted by ğ‘“. The ğ‘–-th entry of the array ğ‘“ will thus contain the ğ‘–-th coefficient of the polynomial\nğ‘“ (i.e., ğ‘“[ğ‘–] = ğ‘“ğ‘– ).\n                  An element (sometimes called â€œNTT representationâ€) ğ‘”Ì‚ of ğ‘‡ğ‘ is a tuple of 128 polynomials, each\nof degree at most one. Specifically,\n\n                             ğ‘” = (ğ‘”0,0 + ğ‘”0,1 ğ‘‹, ğ‘”1,0 + ğ‘”1,1 ğ‘‹, â€¦ , ğ‘”127,0 + ğ‘”127,1ğ‘‹) âˆˆ ğ‘‡ğ‘ .    (2.6)\n\n8"
  },
  {
    "doc_id": "NIST.FIPS.203",
    "source_path": "data/raw_pdfs/NIST.FIPS.203.pdf",
    "page_number": 18,
    "text": "FIPS 203                                     MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\n\nSuch an algebraic object will be represented in pseudocode by the array\n\n                       (ğ‘”0,0 , ğ‘”0,1 , ğ‘”1,0 , ğ‘”1,1 , â€¦ , ğ‘”127,0, ğ‘”127,1) âˆˆ â„¤Â²âµâ¶ .    (2.7)\n                                                                    ğ‘\nOverloading notation, the array in (2.7) will also be denoted by ğ‘”.  In this case, the mapping\nbetween array entries and coefficients is ğ‘”[2ğ‘–] = ğ‘”ğ‘–,0 and ğ‘”[2ğ‘– + 1] = ğ‘”ğ‘–,1 for ğ‘– âˆˆ {0, 1, â€¦ , 127}.\n\nConverting between a polynomial ğ‘“ âˆˆ ğ‘…ğ‘ and its NTT representation ğ‘“ âˆˆ ğ‘‡ğ‘ will be done via the\nalgorithms NTT (Algorithm 9) and NTTâˆ’1 (Algorithm 10). These algorithms act on arrays of\ncoefficients, as described above, and satisfy ğ‘“ = NTT(ğ‘“) and ğ‘“ = NTTâˆ’1(ğ‘“).\n\n2.4.5       Arithmetic With Polynomials and NTT Representations\n                   The algebraic operations of addition and scalar multiplication in ğ‘…ğ‘ and ğ‘‡ğ‘ are done coordinate-\nwise.                      For example, if ğ‘ âˆˆ â„¤ğ‘ and ğ‘“ âˆˆ ğ‘…ğ‘ , the ğ‘–-th coefficient of the polynomial ğ‘ â‹… ğ‘“ âˆˆ ğ‘…ğ‘ is\nequal to ğ‘ â‹… ğ‘“ğ‘–                  mod ğ‘. In pseudocode, elements of both ğ‘…ğ‘ and ğ‘‡ğ‘ are represented by coefficient\narrays (i.e., elements of â„¤Â²âµâ¶). The algebraic operations of addition and scalar multiplication are\nthus performed by      ğ‘\n                                        addition and scalar multiplication of the corresponding coefficient arrays,\nas in (2.3) and (2.2).                        For example, the addition of two NTT representations in pseudocode is\nperformed by a statement of the form â„ â† ğ‘“ + ğ‘”, where â„, ğ‘“, ğ‘” âˆˆ â„¤Â²âµâ¶ are coefficient arrays.\n                                                                      ğ‘\nThe algebraic operations of multiplication in ğ‘…ğ‘ and ğ‘‡ğ‘ are treated as follows.                  For efficiency\nreasons, multiplication in ğ‘…ğ‘ will not be used. The algebraic meaning of multiplication in ğ‘‡ğ‘ is\ndiscussed in Section 4.3.1. In pseudocode, it will be performed by the algorithm MultiplyNTTs\n(Algorithm 11). Specifically, if ğ‘“, ğ‘” âˆˆ â„¤Â²âµâ¶ are a pair of arrays (each representing the NTT of some\npolynomial), then               ğ‘\n\n                     â„ â† ğ‘“ Ã—ğ‘‡ğ‘ ğ‘”  means  â„ â† MultiplyNTTs(ğ‘“, ğ‘”) .                                       (2.8)\n\nThe result is an array â„ âˆˆ â„¤Â²âµâ¶.\n                         ğ‘\n\n2.4.6       Matrices and Vectors\nIn addition to arrays of integers modulo ğ‘, the pseudocode will also make use of arrays whose\nentries are themselves elements of â„¤Â²âµâ¶. For example, an element ğ¯ âˆˆ (â„¤Â²âµâ¶)Â³ will be a length-\n                                      ğ‘                                                  ğ‘\nthree array whose entries ğ¯[0], ğ¯[1], and ğ¯[2] are themselves elements of â„¤Â²âµâ¶ (i.e., arrays). One\ncan think of each of these entries as representing a polynomial in      so                ğ‘\n                                                                    ğ‘…ğ‘                  that ğ¯ itself represents\nan element of the module ğ‘…Â³.\n                           ğ‘\n When arrays are used to represent matrices and vectors whose entries are elements of ğ‘…ğ‘ , they\nwill be denoted with bold letters (e.g., ğ¯ for vectors and ğ€ for matrices). When arrays are used\nto represent matrices and vectors whose entries are elements of ğ‘‡ğ‘ , they will be denoted with a\nâ€œhatâ€ (e.g., ğ¯Ì‚ and ğ€). Unless an explicit transpose operation is performed, it is understood that\nvectors are column vectors. One can then view vectors as the special case of matrices with only\none column.\nConverting between matrices over ğ‘…ğ‘ and matrices over ğ‘‡ğ‘ will be done coordinate-wise. For\n\n                                               9"
  },
  {
    "doc_id": "NIST.FIPS.203",
    "source_path": "data/raw_pdfs/NIST.FIPS.203.pdf",
    "page_number": 19,
    "text": "FIPS 203                                     MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\n\nexample, if ğ¯ âˆˆ (â„¤Â²âµâ¶)ğ‘˜, then the statement\n                    ğ‘\n                      ğ¯ â† NTT(ğ¯)                                                                        (2.9)\n\nwill result in ğ¯ âˆˆ (â„¤Â²âµâ¶)ğ‘˜ such that ğ¯[ğ‘–]Ì‚ = NTT(ğ¯[ğ‘–]) for all ğ‘–. This involves running NTT a total\nof ğ‘˜ times.          ğ‘\n\n2.4.7       Arithmetic With Matrices and Vectors\nThe following describes how to perform arithmetic with matrices over ğ‘…ğ‘ and ğ‘‡ğ‘ with vectors as\na special case.\nAddition and scalar multiplication are performed coordinate-wise, so the addition of matrices\nover ğ‘…ğ‘ and ğ‘‡ğ‘ is straightforward. In the case of ğ‘‡ğ‘ , scalar multiplication is done via (2.8). For\nexample, if ğ‘“ âˆˆ â„¤Â²âµâ¶ and ğ®, ğ¯ âˆˆ (â„¤Â²âµâ¶)ğ‘˜, then\n                ğ‘      ğ‘\n\n                          ğ° â† ğ‘“ â‹… ğ®                                                                            (2.10)\n                          ğ³ â† ğ® + ğ¯                                                                            (2.11)\n\nwill result in ğ°, ğ³ âˆˆ (â„¤Â²âµâ¶)ğ‘˜ satisfying ğ°[ğ‘–] = ğ‘“ Ã—      ğ®[ğ‘–] and ğ³[ğ‘–] = ğ®[ğ‘–] + ğ¯[ğ‘–] for all ğ‘–. Here, the\nmultiplication and      ğ‘                                 ğ‘‡ğ‘\n                                           addition of individual entries are performed using the appropriate arithmetic\nfor coefficient arrays of elements of ğ‘‡ğ‘ (i.e., as in (2.3)).\nIt will also be necessary to multiply matrices with entries in ğ‘‡ğ‘ , which is done by using standard\nmatrix multiplication with the base-case multiplication (i.e., multiplication of individual entries)\nbeing multiplication in ğ‘‡ğ‘ . If ğ€ and ğ are two matrices with entries in ğ‘‡ğ‘ , their matrix product\n                               will be denoted ğ€ âˆ˜ ğ. Some example pseudocode statements involving matrix multiplication\nare given in (2.12), (2.13), and (2.14). In these examples, ğ€ is a ğ‘˜ Ã— ğ‘˜ matrix, while ğ®Ì‚ and ğ¯Ì‚ are\n                        vectors of length ğ‘˜. All three of these objects are represented in pseudocode by arrays: a ğ‘˜ Ã— ğ‘˜\narray for ğ€ and length-ğ‘˜ arrays for ğ®Ì‚ and ğ¯Ì‚. The entries of ğ€, ğ®Ì‚, and ğ¯Ì‚ are elements of â„¤Â²âµâ¶. In\n        and     , the pseudocode statement on the left produces a new length-                             vector ğ‘\n(2.12)          (2.13)                                                                                    ğ‘˜       whose\nentries are specified on the right. In (2.14), the pseudocode statement on the left computes a\ndot product. The result is in the base ring (i.e., ğ‘‡ğ‘ ) and is represented by an element ğ‘§ of â„¤Â²âµâ¶.\n                                                                                                                   ğ‘\n\nğ‘˜âˆ’1\n                          ğ° â† ğ€ âˆ˜ ğ®                              ğ°[ğ‘–] = âˆ‘ ğ€[ğ‘–, ğ‘—] Ã—ğ‘‡ğ‘ ğ®[ğ‘—]            (2.12)\nğ‘—=0\nğ‘˜âˆ’1\n                          ğ² â† ğ€âŠº âˆ˜ ğ®                             ğ²[ğ‘–] = âˆ‘ ğ€[ğ‘—, ğ‘–] Ã—ğ‘‡ğ‘ ğ®[ğ‘—]            (2.13)\nğ‘—=0\nğ‘˜âˆ’1\n                          ğ‘§ â† ğ®âŠº âˆ˜ ğ¯                        ğ‘§ = âˆ‘ ğ®[ğ‘—] Ã—ğ‘‡ğ‘ ğ¯[ğ‘—]                         (2.14)\nğ‘—=0\nThe multiplication Ã—ğ‘‡ğ‘ of individual entries above is performed using MultiplyNTTs, as described\nin (2.8).\n\n10"
  },
  {
    "doc_id": "NIST.FIPS.203",
    "source_path": "data/raw_pdfs/NIST.FIPS.203.pdf",
    "page_number": 20,
    "text": "FIPS 203                                            MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\n\n2.4.8       Applying Algorithms to Arrays, Examples\nIn the previous examples, arithmetic over â„¤ğ‘š was extended to arithmetic with arrays over â„¤ğ‘š\nand then further extended to arithmetic with matrices whose entries are themselves arrays over\nâ„¤ğ‘š . Similarly, algorithms defined with a given data type as input will be applied to arrays and\nmatrices over that data type. When the pseudocode invokes such an algorithm on an array or\nmatrix input, it is implied that the algorithm is invoked repeatedly and applied to each entry of\nthe input.\nFor example, consider the function Compressğ‘‘ âˆ¶ â„¤ğ‘ â†’ â„¤â‚‚ğ‘‘ defined in Section 4. It can be invoked\non an array input ğ¹ âˆˆ â„¤Â²âµâ¶ with the statement\n                        ğ‘\n                                    ğ¾ â† Compressğ‘‘(ğ¹ ) .                          (2.15)\n\nThe result will be an array ğ¾ âˆˆ â„¤Â²âµâ¶ such that ğ¾[ğ‘–] = Compress (ğ¹ [ğ‘–]) for every ğ‘– âˆˆ {0, 1, â€¦ , 255}.\nThe computation (2.15)    2ğ‘‘                                     ğ‘‘\n                         involves running the Compress algorithm 256 times.\nFor a second example, consider the algorithm NTT defined in Section 4.3. It takes an array ğ‘“ âˆˆ\nâ„¤Â²âµâ¶ (representing an element of ğ‘…       ) as input and outputs another array ğ‘“ âˆˆ â„¤Â²âµâ¶ (representing\n    ğ‘                              ğ‘                                              ğ‘\nan element of ğ‘‡ ). If the NTT algorithm is invoked on a vector ğ¬ âˆˆ (â„¤Â²âµâ¶)ğ‘˜ (representing an\n                 ğ‘                                                  ğ‘\nelement of ğ‘…ğ‘˜) with the pseudocode statement\n            ğ‘\n            ğ¬ â† NTT(ğ¬) ,                                                            (2.16)\n\nthe result is a vector ğ¬ âˆˆ (â„¤Â²âµâ¶)ğ‘˜ such that ğ¬[ğ‘–] = NTT(ğ¬[ğ‘–]) for all ğ‘– âˆˆ {0, 1, â€¦ , ğ‘˜ âˆ’ 1}. The vector\n                          ğ‘\nğ¬Ì‚ represents an element of ğ‘‡ ğ‘˜. The computation (2.16) involves running the NTT algorithm ğ‘˜\ntimes.                      ğ‘\nFor a third example, consider line 2 of K-PKE.Encrypt in Section 5.2:\n\nğ­ â† ByteDecodeâ‚â‚‚(ekPKE[0 âˆ¶ 384ğ‘˜]) .                                                                    (2.17)\n\nByteDecodeâ‚â‚‚ is defined to receive a byte array of length 32 â‹… 12 = 384 as input and produce\nan integer array in â„¤Â²âµâ¶ as output.       The computation (2.17) is run on the first 384ğ‘˜ bytes of\n                       ğ‘\nbyte array ekPKE and results in ğ­ âˆˆ (â„¤Â²âµâ¶)ğ‘˜. ByteDecode                will thus be applied ğ‘˜ times, once for\neach subarray                             ğ‘  , and will result 12                    256\n                 ekPKE[384 â‹… ğ‘—, 384 â‹… (ğ‘— + 1)]             in an integer array ğ­[ğ‘—] âˆˆ â„¤ğ‘         such that\nğ­[ğ‘—] = ByteDecodeâ‚â‚‚(ekPKE[384 â‹… ğ‘—, 384 â‹… (ğ‘— + 1)]) for each ğ‘— from 0 to ğ‘˜ âˆ’ 1.\n\n11"
  },
  {
    "doc_id": "NIST.FIPS.203",
    "source_path": "data/raw_pdfs/NIST.FIPS.203.pdf",
    "page_number": 21,
    "text": "    FIPS 203                   MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\n\n    3.   Overview of the ML-KEM Scheme\n\n    This section gives a high-level overview of the ML-KEM scheme.\n\n    3.1  Key-Encapsulation Mechanisms\n    The following is a high-level overview of key-encapsulation mechanisms (KEMs). For details, see\n    SP 800-227 [1].\n    A KEM is a cryptographic scheme that, under certain conditions, can be used to establish a shared\n    secret key between two communicating parties. This shared secret key can then be used for\n    symmetric-key cryptography.\n    A KEM consists of three algorithms and a collection of parameter sets. The three algorithms are:\n     1.  A probabilistic key generation algorithm denoted by KeyGen\n     2.  A probabilistic â€encapsulationâ€ algorithm denoted by Encaps\n     3.  A deterministic â€decapsulationâ€ algorithm denoted by Decaps\n    The collection of parameter sets is used to select a trade-off between security and efficiency.\n    Each parameter set in the collection is a list of specific (typically numerical) values, one for each\n    parameter required by the three algorithms.\n                   Alice                                            Bob\n\n    KeyGen\n\n    decapsulation key    encapsulation key\n\n    Decaps    ciphertext    Encaps\n\nAliceâ€™s copy of the    Bobâ€™s copy of the\n shared secret key     shared secret key\n    ğ¾â€²      ğ¾\n\n    Figure 1. A simple view of key establishment using a KEM\n\n           12"
  },
  {
    "doc_id": "NIST.FIPS.203",
    "source_path": "data/raw_pdfs/NIST.FIPS.203.pdf",
    "page_number": 22,
    "text": "FIPS 203                                  MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\n\nIn the typical application, a KEM is used to establish a shared secret key between two parties\n(here referred to as Alice and Bob) as described in Figure 1. Alice begins by running KeyGen in\norder to generate a (public) encapsulation key and a (private) decapsulation key. Upon obtaining\n  Aliceâ€™s encapsulation key, Bob runs the Encaps algorithm, which produces Bobâ€™s copy ğ¾ of the\nshared secret key along with an associated ciphertext. Bob sends the ciphertext to Alice, and\n  Alice completes the process by running the Decaps algorithm using her decapsulation key and\nthe ciphertext. This final step produces Aliceâ€™s copy ğ¾â€² of the shared secret key.\n After completing this process, Alice and Bob would like to conclude that their outputs satisfy\nğ¾â€² = ğ¾ and that this value is a secure, random, shared secret key. However, these properties\nonly hold if certain important conditions are satisfied, as discussed in SP 800-227 [1].\n\n3.2  The ML-KEM Scheme\nML-KEM is a key-encapsulation mechanism based on CRYSTALS-KYBER [4], a scheme that was\ninitially described in [8]. The following is a brief and informal description of the computational\nassumption underlying ML-KEM and how the ML-KEM scheme is constructed.\n\n     The computational assumption. The security of ML-KEM is based on the presumed hardness\nof the so-called Module Learning with Errors (MLWE) problem [9], which is a generalization of\nthe Learning With Errors (LWE) problem introduced by Regev in 2005 [10]. The hardness of the\nMLWE problem is itself based on the presumed hardness of certain computational problems in\nmodule lattices [9]. This motivates the name of the scheme ML-KEM.\nIn   the LWE problem, the input is a set of random â€œnoisyâ€ linear equations in some secret\nvariables ğ‘¥ âˆˆ â„¤ğ‘›, and the task is to recover ğ‘¥. The noise in the equations is such that standard\nalgorithms  ğ‘\n            (e.g., Gaussian elimination) are intractable. The LWE problem naturally lends itself to\ncryptographic applications. For example, if ğ‘¥ is interpreted as a secret key, then one can encrypt\na one-bit plaintext value by sampling either an approximately correct linear equation (if the\nplaintext is zero) or a far-from-correct linear equation (if the plaintext is one). Plausibly, only a\nparty in possession of ğ‘¥ can distinguish these two cases. Encryption can then be delegated to\nanother party by publishing a large collection of noisy linear equations, which can be combined\nappropriately by the encrypting party. The result is an asymmetric encryption scheme.\n  The MLWE problem is similar to the LWE problem. An important difference is that, in MLWE, â„¤ğ‘›\n                                                                                        ğ‘\nis replaced by a certain module ğ‘…ğ‘˜, which is constructed by taking the ğ‘˜-fold Cartesian product\nof a certain polynomial ring ğ‘…ğ‘ . Inğ‘particular, the secret in the MLWE problem is an element ğ± of\nthe module ğ‘…ğ‘˜. The ring ğ‘… is discussed in detail in Section 4.3.\n            ğ‘          ğ‘\n\n  The ML-KEM construction. At a high level, the construction of the scheme ML-KEM proceeds in\ntwo steps. First, the ideas discussed previously are used to construct a public-key encryption (PKE)\nscheme from the MLWE problem. Second, this PKE scheme is converted into a key-encapsulation\nmechanism using the so-called Fujisaki-Okamoto (FO) transform [11, 12]. Due to certain prop-\nerties of the FO transform, the resulting KEM provides security in a significantly more general\nattack model than the PKE scheme. As a result, ML-KEM is believed to satisfy so-called IND-CCA2\nsecurity [1, 4, 13, 14].\n\n                             13"
  },
  {
    "doc_id": "NIST.FIPS.203",
    "source_path": "data/raw_pdfs/NIST.FIPS.203.pdf",
    "page_number": 23,
    "text": "FIPS 203                               MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\n\nThe specification of the ML-KEM algorithms in this standard will follow the same pattern. Specif-\nically, this standard will first describe a public-key encryption scheme called K-PKE (in Section 5)\nand then use the algorithms of K-PKE as subroutines when describing the algorithms of ML-KEM\n(in Sections 6 and 7). The cryptographic transformation from K-PKE to ML-KEM is crucial for\nachieving IND-CCA2 security. The scheme K-PKE is not IND-CCA2-secure and shall not be used as\na stand-alone scheme (see Section 3.3).\nA notable feature of ML-KEM is the use of the number-theoretic transform (NTT). The NTT\nconverts a polynomial ğ‘“ âˆˆ ğ‘…ğ‘ to an alternative representation as a vector ğ‘“ of linear polynomials.\nWorking with NTT representations enables significantly faster multiplication of polynomials.\nOther operations (e.g., addition, rounding, and sampling) can be done in either representation.\nML-KEM satisfies the essential KEM property of correctness. This means that in the absence\nof corruption or interference, the process in Figure 1 will result in ğ¾â€² = ğ¾ with overwhelming\nprobability. ML-KEM also comes with a proof of asymptotic theoretical security in a certain\nheuristic model [4]. Each of the parameter sets of ML-KEM comes with an associated security\nstrength that was estimated based on current cryptanalysis (see Section 8 for details).\n\nParameter sets and algorithms. Recall that a KEM consists of algorithms KeyGen, Encaps, and\nDecaps, along with a collection of parameter sets. In the case of ML-KEM, the three aforemen-\ntioned algorithms are:\n 1.  ML-KEM.KeyGen (Algorithm 19)\n 2.  ML-KEM.Encaps (Algorithm 20)\n 3.  ML-KEM.Decaps (Algorithm 21)\nThese algorithms are described and discussed in detail in Section 7.\nML-KEM comes equipped with three parameter sets:\n  â€¢ ML-KEM-512 (security category 1)\n  â€¢ ML-KEM-768 (security category 3)\n  â€¢ ML-KEM-1024 (security category 5)\nThese parameter sets are described and discussed in detail in Section 8. The security categories\n1-5 are defined in SP 800-57, Part 1 [7]. Each parameter set assigns a particular numerical value\nto five integer variables: ğ‘˜, ğœ‚â‚, ğœ‚â‚‚, ğ‘‘ğ‘¢, and ğ‘‘ğ‘£. The values of these variables in each parameter\nset are given in Table 2 of Section 8. In addition to these five variable parameters, there are also\ntwo constants: ğ‘› = 256 and ğ‘ = 3329.\n\nDecapsulation failures. Provided that all inputs are well-formed and randomness generation is\nsuccessful, the key establishment procedure of ML-KEM will never explicitly fail, meaning that\nboth ML-KEM.Encaps and ML-KEM.Decaps will each output a 256-bit value. Moreover, if no\ncorruption or interference is present, the two 256-bit values produced by ML-KEM.Encaps and\nML-KEM.Decaps will be equal with overwhelming probability (i.e., ğ¾â€² will equal ğ¾ in the process\ndescribed in Figure 1). The event that ğ¾â€² â‰  ğ¾ under these conditions is called a decapsulation\n\n                                       14"
  },
  {
    "doc_id": "NIST.FIPS.203",
    "source_path": "data/raw_pdfs/NIST.FIPS.203.pdf",
    "page_number": 24,
    "text": "FIPS 203                            MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\n\nfailure. Formally, the decapsulation failure probability is defined to be the probability (conditioned\non no RGB failures) that the process\n\n                     1. (ek, dk) â† ML-KEM.KeyGen()                                          (3.1)\n                     2. (ğ‘, ğ¾) â† ML-KEM.Encaps(ek)                                        (3.2)\n                     3. ğ¾â€² â† ML-KEM.Decaps\n                                    (dk, ğ‘)                                                (3.3)\n\nresults in ğ¾â€² â‰  ğ¾. The probability is taken over uniformly random seeds ğ‘‘, ğ‘§ (sampled in\nML-KEM.KeyGen) and ğ‘š (sampled in ML-KEM.Encaps) and under the heuristic assumption that\nhash functions and XOFs behave like uniformly random functions. The decapsulation failure rates\nfor ML-KEM are listed in Table 1. For details, see Theorem 1 in [8] and the scripts in [15].\n\n                     Table 1. Decapsulation failure rates for ML-KEM\n\n                     Parameter set  Decapsulation failure rate\n                      ML-KEM-512             2âˆ’138.8\n                      ML-KEM-768             2âˆ’164.8\n                     ML-KEM-1024             2âˆ’174.8\n\nTerminology for keys. A KEM involves three different types of keys: encapsulation keys, de-\ncapsulation keys, and shared secret keys. ML-KEM is built on top of the component public-key\nencryption scheme K-PKE, which has two additional key types: encryption keys and decryption\nkeys. In the literature, encapsulation keys and encryption keys are sometimes referred to as\n  â€œpublic keys,â€ while decapsulation keys and decryption keys are sometimes referred to as â€œpri-\n  vate keys.â€ In order to reduce confusion, this standard will not use the terms â€œpublic keyâ€ or\nâ€œprivate key.â€ Instead, keys will be referred to only using the more specific terms, i.e., one of\n â€œencapsulation keyâ€, â€œdecapsulation keyâ€, â€œencryption keyâ€, â€œdecryption keyâ€, and â€œshared secret\nkeyâ€.\n\n3.3   Requirements for ML-KEM Implementations\n   This section describes several requirements for cryptographic modules that implement ML-KEM.\nImplementation requirements specific to particular algorithms will be described in later sections.\n    Additional requirements, including requirements for using ML-KEM in specific applications,\nare given in SP 800-227 [1]. While conforming implementations must adhere to all of these\nrequirements, adherence does not guarantee that the result will be secure (see Point 13 in the\nannouncement).\n\nK-PKE is only a component. The public-key encryption scheme K-PKE described in Section 5 shall\nnot be used as a stand-alone cryptographic scheme. Instead, the algorithms that comprise K-PKE\nmay only be used as subroutines in the algorithms of ML-KEM. In particular, the algorithms\nK-PKE.KeyGen (Algorithm 13), K-PKE.Encrypt (Algorithm 14), and K-PKE.Decrypt (Algorithm 15)\nare not approved for use as a public-key encryption scheme.\n\n                             15"
  },
  {
    "doc_id": "NIST.FIPS.203",
    "source_path": "data/raw_pdfs/NIST.FIPS.203.pdf",
    "page_number": 25,
    "text": "FIPS 203    MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\n\nControlled access to internal functions. The key-encapsulation mechanism ML-KEM makes use\nof internal, â€œderandomizedâ€ functions ML-KEM.KeyGen_internal, ML-KEM.Encaps_internal, and\nML-KEM.Decaps_internal, specified in Section 6. The interfaces for these functions should not\nbe made available to applications other than for testing purposes. In particular, the sampling of\nrandom values required for key generation (as specified in ML-KEM.KeyGen) and encapsulation\n(as specified in ML-KEM.Encaps) shall be performed by the cryptographic module.\n\nEquivalent implementations. For every algorithm that is specified in this standard, a conforming\nimplementation may replace the given set of steps with any mathematically equivalent set of\nsteps. In other words, the specified algorithm may be replaced with a different procedure that\nproduces the correct output for every input (where â€œinputâ€ includes the specified input as well\nas all parameter values and all randomness).\n\n   Approved usage of the shared secret key. If randomness generation is successful, the values\nğ¾ and ğ¾â€² returned by ML-KEM.Encaps and ML-KEM.Decaps, respectively, are always 256-bit\nvalues. Under appropriate conditions (see Sections 3.1 and 3.2, and SP 800-227 [1]), these values\nmatch (i.e., ğ¾â€² = ğ¾) and can be used directly as a shared secret key for symmetric cryptography.\nIf further key derivation is needed, the final symmetric keys shall be derived from this 256-bit\nshared secret key in an approved manner, as specified in SP 800-108 and SP 800-56C [16, 17].\n      As discussed in Section 3.2, ML-KEM is an IND-CCA2-secure KEM. However, a combined KEM\nthat includes ML-KEM as a component might not meet IND-CCA2 security. Implementers should\nassess the security of any procedure in which the key derivation methods of SP 800-56C are\napplied to ML-KEM in combination with another key establishment procedure. More guidance\nregarding combined KEMs is given in SP 800-227 [1].\n\nRandomness generation. Two algorithms in this standard require the generation of randomness\nas an internal step:         ML-KEM.KeyGen and ML-KEM.Encaps. In pseudocode, this randomness\ngeneration is denoted by a statement of the form ğ‘š  $   ğ”¹Â³Â². A fresh string of random bytes\n                                                    â†\n                                                     âˆ’\nmust be generated for every such invocation. These random bytes shall be generated using an\napproved RBG, as prescribed in SP 800-90A, SP 800-90B, and SP 800-90C [18, 19, 20]. Moreover,\nthis RBG shall have a security strength of at least 128 bits for ML-KEM-512, at least 192 bits for\nML-KEM-768, and at least 256 bits for ML-KEM-1024.\n\nInput checking. The algorithms ML-KEM.Encaps and ML-KEM.Decaps require input checking.\nImplementers shall ensure that ML-KEM.Encaps and ML-KEM.Decaps are only executed on\ninputs that have been checked, as described in Section 7.\n\nDestruction of intermediate values.       Data used in intermediate computation steps of KEM\nalgorithms could be used by an adversary to compromise security. Therefore, implementers\nshall ensure that intermediate data is destroyed as soon as it is no longer needed. In particular,\nfor ML-KEM.KeyGen, ML-KEM.Encaps, and ML-KEM.Decaps, only the designated output can be\nretained in memory after the algorithm terminates. All other data shall be destroyed prior to\n                                                16"
  },
  {
    "doc_id": "NIST.FIPS.203",
    "source_path": "data/raw_pdfs/NIST.FIPS.203.pdf",
    "page_number": 26,
    "text": "FIPS 203                              MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\n\nthe algorithm terminating.\nThere are two exceptions to this rule:\n 1.  The seed (ğ‘‘, ğ‘§) generated in steps 1 and 2 of ML-KEM.KeyGen can be stored for later\n     expansion using ML-KEM.KeyGen_internal.      As this seed can be used to compute the\n     decapsulation key, it is sensitive data and shall be treated with the same safeguards as a\n     decapsulation key (see SP 800-227 [1]).\n 2.  The matrix ğ€ generated in steps 3-7 of K-PKE.KeyGen (as a subroutine of ML-KEM.KeyGen)\n     can be stored so that it need not be recomputed in later operations (e.g., ML-KEM.Decaps).\n     The same matrix ğ€ is also generated in steps 4-8 of K-PKE.Encrypt (as a subroutine of\n     ML-KEM.Encaps or ML-KEM.Decaps); it can also then be stored. In either case, the matrix\n     ğ€ is data that is easily computed from the public encapsulation key and thus does not\n     require any special protections.\n\nNo floating-point arithmetic. Implementations of ML-KEM shall not use floating-point arithmetic,\nas rounding errors in floating-point operations may lead to incorrect results in some cases. In\nall pseudocode in this standard in which division is performed (e.g., ğ‘¥/ğ‘¦) and ğ‘¦ may not divide\nğ‘¥, either âŒŠğ‘¥/ğ‘¦âŒ‹, âŒˆğ‘¥/ğ‘¦âŒ‰, or âŒˆğ‘¥/ğ‘¦âŒ‹ is used. All of these can be computed without floating-point\narithmetic, as ordinary integer division ğ‘¥/ğ‘¦ computes âŒŠğ‘¥/ğ‘¦âŒ‹, and âŒˆğ‘¥/ğ‘¦âŒ‰ = âŒŠ(ğ‘¥ + ğ‘¦ âˆ’ 1)/ğ‘¦âŒ‹ for\nnon-negative integers ğ‘¥ and positive integers ğ‘¦.\n\n17"
  },
  {
    "doc_id": "NIST.FIPS.203",
    "source_path": "data/raw_pdfs/NIST.FIPS.203.pdf",
    "page_number": 27,
    "text": "FIPS 203                                   MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\n\n4.   Auxiliary Algorithms\n\n4.1  Cryptographic Functions\nThe algorithms specified in this publication require the use of several cryptographic functions.\nEach function shall be instantiated by means of an approved hash function or an approved\neXtendable-Output Function (XOF), as prescribed below. The relevant hash functions and XOFs\nare described in detail in FIPS 202 [6]. They will be used as follows.\nSHA3-256 and SHA3-512 are hash functions with one variable-length input and one fixed-length\noutput.     In this standard, invocations of these functions on an input ğ‘€ will be denoted by\nSHA3-256(ğ‘€) and SHA3-512(ğ‘€), respectively. The inputs and outputs for both SHA3-256 and\nSHA3-512 are always byte arrays.\nSHAKE128 and SHAKE256 are XOFs with one variable-length input and one variable-length output.\nThis standard will adhere to the following conventions [6]:\n    â€¢ The inputs and outputs for both SHAKE128 and SHAKE256 are always byte arrays.\n    â€¢ When invoking SHAKE128 or SHAKE256, desired output length is always specified in bits.\nFor example, the expression\n                                ğ‘Ÿ âˆ¶= SHAKE128(ğ‘€ , 8 â‹… 64)                              (4.1)\nimplies that ğ‘€ is an array of bytes and that ğ‘Ÿ is an array of 64 bytes.\nThe aforementioned functions play several different roles in the algorithms specified in this\nstandard and will only be invoked using the wrapper functions defined below. Importantly, these\nwrappers will avoid any potential â€œbyte arrayâ€ versus â€œbit-lengthâ€ confusion by only working with\nbytes and byte array lengths.\n\nPseudorandom function (PRF). The function PRF takes a parameter ğœ‚ âˆˆ {2, 3}, one 32-byte\ninput, and one 1-byte input. It produces one (64 â‹… ğœ‚)-byte output. It will be denoted by\n\n                               PRF âˆ¶ {2, 3} Ã— ğ”¹Â³Â² Ã— ğ”¹ â†’ ğ”¹64ğœ‚ ,                           (4.2)\n\nand it shall be instantiated as\n\n                       PRFğœ‚(ğ‘ , ğ‘) âˆ¶= SHAKE256(ğ‘ â€–ğ‘, 8 â‹… 64 â‹… ğœ‚) ,                       (4.3)\n\nwhere ğœ‚ âˆˆ {2, 3}, ğ‘  âˆˆ ğ”¹Â³Â², and ğ‘ âˆˆ ğ”¹. Note that ğœ‚ is only used to specify the desired output\nlength and not to perform domain separation.\n\nHash functions. The specification will also make use of three hash functions H, J and G, which\nare defined as follows.\nThe functions H and J each take one variable-length input and produce one 32-byte output. They\nwill be denoted by H âˆ¶ ğ”¹âˆ— â†’ ğ”¹Â³Â² and J âˆ¶ ğ”¹âˆ— â†’ ğ”¹Â³Â², respectively, and shall be instantiated as\n\n            H(ğ‘ ) âˆ¶= SHA3-256(ğ‘ )          and  J(ğ‘ ) âˆ¶= SHAKE256(ğ‘ , 8 â‹… 32)                (4.4)\n                                           18"
  },
  {
    "doc_id": "NIST.FIPS.203",
    "source_path": "data/raw_pdfs/NIST.FIPS.203.pdf",
    "page_number": 28,
    "text": "FIPS 203       MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\n\nwhere ğ‘  âˆˆ ğ”¹âˆ—.\nThe function G takes one variable-length input and produces two 32-byte outputs. It will be\ndenoted by G âˆ¶ ğ”¹âˆ— â†’ ğ”¹Â³Â² Ã— ğ”¹Â³Â². The two outputs of G will be denoted by (ğ‘, ğ‘) â† G(ğ‘), where\nğ‘, ğ‘ âˆˆ ğ”¹Â³Â², ğ‘ âˆˆ ğ”¹âˆ—, and G(ğ‘) = ğ‘â€–ğ‘. The function G shall be instantiated as\n\n               G(ğ‘) âˆ¶= SHA3-512(ğ‘) .                                             (4.5)\n\neXtendable-Output Function (XOF). This standard uses a XOF wrapper defined in terms of the\nincremental API for SHAKE128 in SP 800-185 [21]. This SHAKE128 API consists of three functions:\n     â€¢ ctx â† SHAKE128.Init()\n       Initializes a XOF â€œcontextâ€ ctx.\n     â€¢ ctx â† SHAKE128.Absorb(ctx, str)\n       Injects data to be used in the â€œabsorbingâ€ phase of SHAKE128 and updates the context\n       accordingly.\n     â€¢ (ctx, ğµ) â† SHAKE128.Squeeze(ctx, 8 â‹… ğ‘§)\n       Extracts ğ‘§ output bytes produced during the â€œsqueezingâ€ phase of SHAKE128 and updates\n       the context accordingly.\nWhile the above functions are constructed using the Keccak-ğ‘“ permutation rather than the XOF\nSHAKE128 directly, they are defined so that a single SHAKE128 call of the form\n\n                   output â† SHAKE128(strâ‚â€– â€¦ â€–strğ‘š , 8ğ‘â‚ + â€¦ + 8ğ‘â„“)        (4.6)\n\nis equivalent to performing Algorithm 2. This equivalence holds whether or not |strğ‘– | and ğ‘ğ‘— are\nmultiples of the SHAKE128 block length.\n\nAlgorithm 2 SHAKE128example(strâ‚, â€¦ , strğ‘š , ğ‘â‚, â€¦ , ğ‘â„“)\nPerforms a sequence of absorbing operations followed by a sequence of squeezing operations.\nInput: byte arrays strâ‚, â€¦ , strğ‘š .\nInput: positive integers ğ‘â‚, â€¦ , ğ‘â„“. â„“  ğ‘ .\nOutput: a byte array of length âˆ‘ğ‘—=1      ğ‘—\n 1:   ctx â† SHAKE128.Init()                                               â–· initialize context\n 2:   for (ğ‘– â† 1; ğ‘– â‰¤ ğ‘š; ğ‘– ++)\n 3:   endctx â† SHAKE128.Absorb(ctx, strğ‘– )                â–· absorb byte array strğ‘–\n 4:    for\n 5:   for (ğ‘— â† 1; ğ‘— â‰¤ â„“; ğ‘— ++)\n 6:   end(ctx, outğ‘—) â† SHAKE128.Squeeze(ctx, 8 â‹… ğ‘ğ‘—)    â–· squeeze ğ‘ğ‘—-many bytes\n 7:    for\n 8:   output â† outâ‚â€– â€¦ â€–outâ„“                    â–· return the concatenation of all the results\n\nIn this standard, the incremental API for SHAKE128 will only be invoked through a wrapper XOF,\n                                               19"
  },
  {
    "doc_id": "NIST.FIPS.203",
    "source_path": "data/raw_pdfs/NIST.FIPS.203.pdf",
    "page_number": 29,
    "text": "FIPS 203                                                  MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\n\nwhich is defined as follows.\n  1.    XOF.Init() = SHAKE128.Init().\n  2.    XOF.Absorb(ctx, str) = SHAKE128.Absorb(ctx, str).\n  3.    XOF.Squeeze(ctx, â„“) = SHAKE128.Squeeze(ctx, 8 â‹… â„“).\nNote that XOF.Squeeze requires the input length to be specified in bytes. This is consistent with\nthe convention that all wrapper functions treat inputs and outputs as byte arrays and measure\nthe lengths of all such arrays in terms of bytes.\n\n4.2     General Algorithms\nThis section specifies a number of algorithms that will be used as subroutines in ML-KEM.\n\n4.2.1       Conversion and Compression Algorithms\nThis section specifies several algorithms for converting between bit arrays, byte arrays, and arrays\nof integers modulo ğ‘š. It also specifies a certain operation for compressing integers modulo ğ‘,\nand the corresponding decompression operation.\n\nAlgorithm 3 BitsToBytes(ğ‘)\nConverts a bit array (of a length that is a multiple of eight) into an array of bytes.\nInput: bit array ğ‘ âˆˆ {0, 1}8â‹…â„“.\nOutput: byte array ğµ âˆˆ ğ”¹â„“.\n 1:    ğµ â† (0, â€¦ , 0)\n 2:    for (ğ‘– â† 0; ğ‘– < 8â„“; ğ‘– ++)\n 3:         ğµ [âŒŠğ‘–/8âŒ‹] â† ğµ [âŒŠğ‘–/8âŒ‹] + ğ‘[ğ‘–] â‹… 2ğ‘– mod 8\n 4:    end for\n 5:    return ğµ\n\nAlgorithm 4 BytesToBits(ğµ)\nPerforms the inverse of BitsToBytes, converting a byte array into a bit array.\nInput: byte array ğµ âˆˆ ğ”¹â„“.\nOutput: bit array ğ‘ âˆˆ {0, 1}8â‹…â„“.\n 1:    ğ¶ â† ğµ                                             â–· copy ğµ into array ğ¶ âˆˆ ğ”¹â„“\n 2:    for (ğ‘– â† 0; ğ‘– < â„“; ğ‘– ++)\n 3:      for (ğ‘— â† 0; ğ‘— < 8; ğ‘— ++)\n 4:         ğ‘[8ğ‘– + ğ‘—] â† ğ¶[ğ‘–] mod 2\n 5:         ğ¶[ğ‘–] â† âŒŠğ¶[ğ‘–]/2âŒ‹\n 6:      end for\n 7:    end for\n 8:    return ğ‘\n\n20"
  },
  {
    "doc_id": "NIST.FIPS.203",
    "source_path": "data/raw_pdfs/NIST.FIPS.203.pdf",
    "page_number": 30,
    "text": "FIPS 203                                 MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\n\nConverting between bits and bytes. The algorithms BitsToBytes (Algorithm 3) and BytesToBits\n(Algorithm 4) convert between bit arrays and byte arrays. The inputs to BitsToBytes and the\noutputs of BytesToBits are bit arrays, with each segment of eight bits representing a byte in\nlittle-endian order. As an example, the 8-bit string 11010001 corresponds to the byte 2â° + 2Â¹ +\n2Â³ + 2â· = 139.\n\nCompression and decompression. Recall that ğ‘ = 3329, and that the bit length of ğ‘ is 12. For\nğ‘‘ < 12, define\n\n                               Compressğ‘‘ âˆ¶ â„¤ğ‘ âŸ¶ â„¤â‚‚ğ‘‘                                       (4.7)\n                               ğ‘¥ âŸ¼ âŒˆ(2ğ‘‘/ğ‘) â‹… ğ‘¥âŒ‹ mod 2ğ‘‘ .\n                      Decompressğ‘‘ âˆ¶ â„¤â‚‚ğ‘‘ âŸ¶ â„¤ğ‘                                              (4.8)\n                               ğ‘¦ âŸ¼ âŒˆ(ğ‘/2ğ‘‘) â‹… ğ‘¦âŒ‹ .\n\nThe input and output types of these functions are integers modulo ğ‘š (see Section 2.4.1). Division\nand rounding in the computation of these functions are performed in the set of rational numbers.\nFloating-point computations shall not be used.\nThe Compress and Decompress algorithms satisfy two important properties. First, decompression\nfollowed by compression preserves the input.  That is, Compressğ‘‘(Decompressğ‘‘(ğ‘¦)) = ğ‘¦ for\nall ğ‘¦ âˆˆ â„¤â‚‚ğ‘‘ and all ğ‘‘ < 12. Second, if ğ‘‘ is large (i.e., close to 12), compression followed by\ndecompression does not significantly alter the value.\n\nEncoding and decoding. The algorithms ByteEncode (Algorithm 5) and ByteDecode (Algorithm\n6) will be used for conversion between integers modulo ğ‘š and bytes. The algorithm ByteEncode\nconverts an array of ğ‘› = 256 integers modulo ğ‘š into a corresponding array of bytes. ByteDecode\nperforms the inverse operation, converting an array of bytes into an array of integers modulo ğ‘š.\nSpecifying the modulus ğ‘š is done as described below.\nFor the following description, it is convenient to view ByteDecode and ByteEncode as converting\nbetween integers and bits. The conversion between bits and bytes is straightforward and done\nusing BitsToBytes and BytesToBits. The valid range of values for the parameter ğ‘‘ is 1 â‰¤ ğ‘‘ â‰¤ 12.\nBit arrays are divided into ğ‘‘-bit segments. The operations are performed in two different ways,\ndepending on the value of ğ‘‘:\n    â€¢ For ğ‘‘ satisfying 1 â‰¤ ğ‘‘ â‰¤ 11, the conversion is one-to-one. ByteDecodeğ‘‘ converts each\n    ğ‘‘-bit segment of its input into one integer modulo 2ğ‘‘, while ByteEncodeğ‘‘ performs the\n    inverse operation.\n      â€¢ For ğ‘‘ = 12, ByteDecodeâ‚â‚‚ produces integers modulo ğ‘ as output, while ByteEncodeâ‚â‚‚\n    receives integers modulo ğ‘ as input. Specifically, ByteDecodeâ‚â‚‚ converts each 12-bit\n    segment of its input into an integer modulo 2Â¹Â² = 4096 and then reduces the result\n    modulo ğ‘. This is no longer a one-to-one operation. Indeed, some 12-bit segments could\n    correspond to an integer greater than ğ‘ âˆ’ 1 = 3328 but less than 4096. However, this\n    cannot occur for arrays produced by ByteEncodeâ‚â‚‚. These aspects of ByteDecodeâ‚â‚‚ and\n\n                                          21"
  },
  {
    "doc_id": "NIST.FIPS.203",
    "source_path": "data/raw_pdfs/NIST.FIPS.203.pdf",
    "page_number": 31,
    "text": "FIPS 203                                                 MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\n\n        ByteEncodeâ‚â‚‚ will be important when considering checking of the ML-KEM encapsulation\n        key in Section 7.\n\nAlgorithm 5 ByteEncodeğ‘‘(ğ¹ )\nEncodes an array of ğ‘‘-bit integers into a byte array for 1 â‰¤ ğ‘‘ â‰¤ 12.\nInput: integer array ğ¹ âˆˆ â„¤Â²âµâ¶, where ğ‘š = 2ğ‘‘ if ğ‘‘ < 12, and ğ‘š = ğ‘ if ğ‘‘ = 12.\n                           ğ‘š\nOutput: byte array ğµ âˆˆ ğ”¹32ğ‘‘.\n 1:    for (ğ‘– â† 0; ğ‘– < 256; ğ‘– ++)\n 2:      ğ‘ â† ğ¹ [ğ‘–]            ++)                                              â–· ğ‘ âˆˆ â„¤ğ‘š\n 3:      for (ğ‘— â† 0; ğ‘— < ğ‘‘; ğ‘—\n 4:           ğ‘[ğ‘– â‹… ğ‘‘ + ğ‘—] â† ğ‘ mod 2                                         â–· ğ‘ âˆˆ {0, 1}256â‹…ğ‘‘\n 5:           ğ‘ â† (ğ‘ âˆ’ ğ‘[ğ‘– â‹… ğ‘‘ + ğ‘—])/2             â–· note ğ‘ âˆ’ ğ‘[ğ‘– â‹… ğ‘‘ + ğ‘—] is always even\n 6:      end for\n 7:    end for\n 8:    ğµ â† BitsToBytes(ğ‘)\n 9:    return ğµ\n\nAlgorithm 6 ByteDecodeğ‘‘(ğµ)\nDecodes a byte array into an array of ğ‘‘-bit integers for 1 â‰¤ ğ‘‘ â‰¤ 12.\nInput: byte array ğµ âˆˆ ğ”¹32ğ‘‘.\nOutput: integer array ğ¹ âˆˆ â„¤Â²âµâ¶, where ğ‘š = 2ğ‘‘ if ğ‘‘ < 12 and ğ‘š = ğ‘ if ğ‘‘ = 12.\n                                 ğ‘š\n 1:    ğ‘ â† BytesToBits(ğµ)\n 2:    for (ğ‘– â† 0; ğ‘– < 256; ğ‘– ++)\n 3:         ğ¹ [ğ‘–] â† âˆ‘ğ‘‘âˆ’1 ğ‘[ğ‘– â‹… ğ‘‘ + ğ‘—] â‹… 2ğ‘— mod ğ‘š\n 4:    end for           ğ‘—â†0\n 5:    return ğ¹\n\n4.2.2       Sampling Algorithms\nThe algorithms of ML-KEM require two sampling subroutines that are specified in Algorithms 7\nand 8. Both of these algorithms can be used to convert a stream of uniformly random bytes into\na sample from some desired distribution. In this standard, these algorithms will be invoked with\na stream of pseudorandom bytes as the input. It follows that the output will then be a sample\nfrom a distribution that is computationally indistinguishable from the desired distribution.\n\nUniform sampling of NTT representations. The algorithm SampleNTT (Algorithm 7) converts\na seed together with two indexing bytes into a polynomial in the NTT domain. If the seed is\nuniformly random, the resulting polynomial will be drawn from a distribution that is computa-\ntionally indistinguishable from the uniform distribution on ğ‘‡ğ‘ . The output of SampleNTT is an\narray in â„¤Â²âµâ¶ that contains the coefficients of the sampled element of ğ‘‡ (see Section 2.4.4). See\nAppendixğ‘                                                            ğ‘\n            B for a note on (optionally) safely bounding the algorithmâ€™s while-loop iterations.\n\n                                                         22"
  },
  {
    "doc_id": "NIST.FIPS.203",
    "source_path": "data/raw_pdfs/NIST.FIPS.203.pdf",
    "page_number": 32,
    "text": "FIPS 203                                      MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\n\nAlgorithm 7 SampleNTT(ğµ)\nTakes a 32-byte seed and two indices as input and outputs a pseudorandom element of ğ‘‡ğ‘ .\nInput: byte array ğµ âˆˆ ğ”¹Â³â´.                  â–· a 32-byte seed along with two indices\nOutput: array ğ‘ âˆˆ â„¤Â²âµâ¶.                        â–· the coefficients of the NTT of a polynomial\n                 ğ‘\n 1:    ctx â† XOF.Init()\n 2:    ctx â† XOF.Absorb(ctx, ğµ)                        â–· input the given byte array into XOF\n 3:    ğ‘— â† 0\n 4:    while ğ‘— < 256 do\n 5:     (ctx, ğ¶) â† XOF.Squeeze(ctx, 3)                 â–· get a fresh 3-byte array ğ¶ from XOF\n 6:     ğ‘‘â‚ â† ğ¶[0] + 256 â‹… (ğ¶[1] mod 16)                                     â–· 0 â‰¤ ğ‘‘â‚ < 2Â¹Â²\n 7:     ğ‘‘â‚‚ â† âŒŠğ¶[1]/16âŒ‹ + 16 â‹… ğ¶[2]                                          â–· 0 â‰¤ ğ‘‘â‚‚ < 2Â¹Â²\n 8:     if ğ‘‘â‚ < ğ‘ then                                                                  256\n 9:          ğ‘[ğ‘—] â† ğ‘‘â‚                     â–· ğ‘ âˆˆ â„¤ğ‘\n10:          ğ‘— â† ğ‘— + 1\n11:     end if\n12:     if ğ‘‘â‚‚ < ğ‘ and ğ‘— < 256 then\n13:          ğ‘[ğ‘—] â† ğ‘‘â‚‚\n14:          ğ‘— â† ğ‘— + 1\n15:     end if\n16:    end while\n17:    return ğ‘Ì‚\n\nSampling from the centered binomial distribution. ML-KEM makes use of a special distribution\nDğœ‚(ğ‘…ğ‘ ) of polynomials in ğ‘…ğ‘ with small coefficients. Such polynomials are sometimes referred\nto as â€œerrorsâ€ or â€œnoise.â€ The distribution is parameterized by an integer ğœ‚ âˆˆ {2, 3}. To sample a\npolynomial from Dğœ‚(ğ‘…ğ‘ ), each of its coefficients is independently sampled from a certain cen-\ntered binomial distribution (CBD) on â„¤ğ‘ . The algorithm SamplePolyCBD (Algorithm 8) samples\nthe coefficient array of a polynomial ğ‘“ âˆˆ ğ‘…ğ‘ according to the distribution Dğœ‚(ğ‘…ğ‘ ), provided that\n\nAlgorithm 8 SamplePolyCBDğœ‚(ğµ)\nTakes a seed as input and outputs a pseudorandom sample from the distribution Dğœ‚(ğ‘…ğ‘ ).\nInput: byte array ğµ âˆˆ ğ”¹64ğœ‚ .\nOutput: array ğ‘“ âˆˆ â„¤Â²âµâ¶.                  â–· the coefficients of the sampled polynomial\n                ğ‘\n 1:    ğ‘ â† BytesToBits(ğµ)\n 2:    for (ğ‘– â† 0; ğ‘– < 256; ğ‘– ++)\n 3:     ğ‘¥ â† âˆ‘ğœ‚âˆ’1 ğ‘[2ğ‘–ğœ‚ + ğ‘—]         â–· 0 â‰¤ ğ‘¥ â‰¤ ğœ‚\n                ğ‘—â†0\n 4:     ğ‘¦ â† âˆ‘ğœ‚âˆ’1 ğ‘[2ğ‘–ğœ‚ + ğœ‚ + ğ‘—]    â–· 0 â‰¤ ğ‘¦ â‰¤ ğœ‚\n                ğ‘—â†0\n 5:     ğ‘“[ğ‘–] â† ğ‘¥ âˆ’ ğ‘¦ mod ğ‘           â–· 0 â‰¤ ğ‘“[ğ‘–] â‰¤ ğœ‚ or ğ‘ âˆ’ ğœ‚ â‰¤ ğ‘“[ğ‘–] â‰¤ ğ‘ âˆ’ 1\n 6:    end for\n 7:    return ğ‘“\n\n                                          23"
  },
  {
    "doc_id": "NIST.FIPS.203",
    "source_path": "data/raw_pdfs/NIST.FIPS.203.pdf",
    "page_number": 33,
    "text": "FIPS 203                          MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\n\nits input is a stream of uniformly random bytes.\n\n4.3  The Number-Theoretic Transform\n   The Number-Theoretic Transform (NTT) can be viewed as a specialized, exact version of the\ndiscrete Fourier transform. In the case of ML-KEM, the NTT is used to improve the efficiency of\nmultiplication in the ring ğ‘…ğ‘ . Recall that ğ‘…ğ‘ is the ring â„¤ğ‘ [ğ‘‹]/(ğ‘‹ğ‘› + 1) of polynomials of the\nform ğ‘“ = ğ‘“â‚€ + ğ‘“â‚ğ‘‹ + â‹¯ + ğ‘“â‚‚â‚…â‚…ğ‘‹Â²âµâµ (where ğ‘“ğ‘— âˆˆ â„¤ğ‘ for all ğ‘—), with the ring operations defined\nby arithmetic modulo ğ‘‹ğ‘› + 1.\nThe ring ğ‘…ğ‘ is isomorphic to another ring ğ‘‡ğ‘ , which is a direct sum of 128 quadratic extensions\nof â„¤ğ‘ . The NTT is a computationally efficient isomorphism between these two rings. When a\npolynomial ğ‘“ âˆˆ ğ‘…ğ‘ is input, the NTT outputs an element ğ‘“ âˆ¶= NTT(ğ‘“) of the ring ğ‘‡ğ‘ , where ğ‘“ is\ncalled the â€œNTT representationâ€ of ğ‘“. The isomorphism property implies that\n\n                                   ğ‘“ Ã—ğ‘…ğ‘ ğ‘” = NTTâˆ’1(ğ‘“ Ã—ğ‘‡ğ‘ ğ‘”),                           (4.9)\n\n  where Ã—ğ‘…ğ‘ and Ã—ğ‘‡ğ‘ denote multiplication in ğ‘…ğ‘ and ğ‘‡ğ‘ , respectively. Moreover, since ğ‘‡ğ‘ is a\nproduct of 128 rings that each consist of polynomials of degree at most one, the operation Ã—ğ‘‡ğ‘\nis much more efficient than the operation Ã—ğ‘…ğ‘ . For these reasons, the NTT is considered to be\nan integral part of ML-KEM and not merely an optimization.\n As the rings ğ‘…ğ‘ and ğ‘‡ğ‘ have a vector space structure over â„¤ğ‘ , the most natural abstract data\ntype to represent elements from either of these rings is â„¤ğ‘›. For this reason, the choice of data\n                                                   ğ‘\nstructure for the inputs and outputs of NTT and NTTâˆ’1 are length-ğ‘› arrays of integers modulo\nğ‘. These arrays are understood to represent elements of ğ‘‡ğ‘ or ğ‘…ğ‘ , respectively (see Section\n2.4.4). Algorithms 9 and 10 describe an efficient means of computing NTT and NTTâˆ’1 in place.\nHowever, to clarify the distinction between the algebraic objects before and after the conversion,\nthe algorithms are written with explicit inputs and outputs. This is consistent with this standardâ€™s\nconvention that all inputs are passed by copy.\n\n    The mathematical structure of the NTT. In ML-KEM, ğ‘ is the prime 3329 = 2â¸ â‹… 13 + 1, and\nğ‘› = 256. There are 128 primitive 256-th roots of unity and no primitive 512-th roots of unity in\nâ„¤ğ‘ . Note that ğœ = 17 âˆˆ â„¤ğ‘ is a primitive 256-th root of unity modulo ğ‘. Thus, ğœ 128 â‰¡ âˆ’1.\nDefine BitRevâ‚‡ (ğ‘–) to be the integer represented by bit-reversing the unsigned 7-bit value that\ncorresponds to the input integer ğ‘– âˆˆ {0, â€¦ , 127}.\nThe polynomial ğ‘‹Â²âµâ¶ + 1 factors into 128 polynomials of degree 2 modulo ğ‘ as follows:\n\n                              127\n                             ğ‘‹Â²âµâ¶ + 1 = âˆ (ğ‘‹Â² âˆ’ ğœ 2BitRevâ‚‡(ğ‘–)+1) .                         (4.10)\n                              ğ‘–=0\n\n  Therefore, ğ‘…ğ‘ âˆ¶= â„¤ğ‘ [ğ‘‹]/(ğ‘‹Â²âµâ¶ + 1) is isomorphic to a direct sum of 128 quadratic extension\n\n24"
  },
  {
    "doc_id": "NIST.FIPS.203",
    "source_path": "data/raw_pdfs/NIST.FIPS.203.pdf",
    "page_number": 34,
    "text": "FIPS 203                             MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\n\nfields of â„¤ğ‘ , denoted ğ‘‡ğ‘ . Specifically, this ring has the structure\n\n                                 127\n                               ğ‘‡ğ‘ âˆ¶= â¨ â„¤ğ‘ [ğ‘‹]/ (ğ‘‹Â² âˆ’ ğœ 2BitRevâ‚‡(ğ‘–)+1) .                    (4.11)\n                                 ğ‘–=0\n\n    Thus, the NTT representation ğ‘“ âˆˆ ğ‘‡ğ‘ of a polynomial ğ‘“ âˆˆ ğ‘…ğ‘ is the vector that consists of the\ncorresponding residues of degree at most one:\n\n              ğ‘“ âˆ¶= (ğ‘“ mod (ğ‘‹Â² âˆ’ ğœ 2BitRevâ‚‡(0)+1), â€¦ , ğ‘“ mod (ğ‘‹Â² âˆ’ ğœ 2BitRevâ‚‡(127)+1)) .    (4.12)\n\n    As discussed in Section 2.4.4, the algorithms in this standard represent ğ‘“ as an array of 256\nintegers modulo ğ‘. Specifically,\n\n                     ğ‘“ mod (ğ‘‹Â² âˆ’ ğœ 2BitRevâ‚‡(ğ‘–)+1) = ğ‘“[2ğ‘–] + ğ‘“[2ğ‘– + 1]ğ‘‹,                  (4.13)\n\nfor ğ‘– from 0 to 127.\n\n      The ML-KEM NTT algorithms. An algorithm for the ML-KEM NTT is described in Algorithm 9. An\n    algorithm for the inverse operation (NTTâˆ’1) is described in Algorithm 10. These two algorithms\n     will be used to transform elements of ğ‘…ğ‘ to elements of ğ‘‡ğ‘ (using NTT) and vice versa (using\nNTTâˆ’1). In addition, as discussed in Section 2.4.8, these algorithms represent the coordinate-\n   wise transformation of structures over those rings. Specifically, they map matrices/vectors with\n    entries in ğ‘…ğ‘ to matrices/vectors with entries in ğ‘‡ğ‘ (using NTT) and vice versa (using NTTâˆ’1).\nThe values ğœ BitRevâ‚‡(ğ‘–) mod ğ‘ for ğ‘– = 1, â€¦ , 127 used in line 5 of Algorithm 9 and line 5 of Algorithm\n10 may be precomputed into an array. This array is given in Appendix A.\n\n25"
  },
  {
    "doc_id": "NIST.FIPS.203",
    "source_path": "data/raw_pdfs/NIST.FIPS.203.pdf",
    "page_number": 35,
    "text": "FIPS 203                                       MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\n\nAlgorithm 9 NTT(ğ‘“)\nComputes the NTT representation ğ‘“ of the given polynomial ğ‘“ âˆˆ ğ‘…ğ‘ .\nInput: array ğ‘“ âˆˆ â„¤Â²âµâ¶.                                    â–· the coefficients of the input polynomial\n                   ğ‘\nOutput: array ğ‘“ âˆˆ â„¤Â²âµâ¶.                       â–· the coefficients of the NTT of the input polynomial\n                         ğ‘\n 1:    ğ‘“ â† ğ‘“                                 â–· will compute in place on a copy of input array\n 2:    ğ‘– â† 1\n 3:    for (len â† 128; len â‰¥ 2; len â† len/2)\n 4:     for (start â† 0; start < 256; start â† start + 2 â‹… len)\n 5:               zeta â† ğœ BitRevâ‚‡(ğ‘–) mod ğ‘\n 6:               ğ‘– â† ğ‘– + 1\n 7:               for (ğ‘— â† start; ğ‘— < start + len; ğ‘— ++)\n 8:                ğ‘¡ â† zeta â‹… ğ‘“[ğ‘— + len]                  â–· steps 8-10 done modulo ğ‘\n 9:                ğ‘“[ğ‘— + len] â† ğ‘“[ğ‘—] âˆ’ ğ‘¡\n10:                ğ‘“[ğ‘—] â† ğ‘“[ğ‘—] + ğ‘¡\n11:               end for\n12:     end for\n13:    end for\n14:    return ğ‘“\n\nAlgorithm 10 NTTâˆ’1(ğ‘“)\nComputes the polynomial ğ‘“ âˆˆ ğ‘…ğ‘ that corresponds to the given NTT representation ğ‘“ âˆˆ ğ‘‡ğ‘ .\nInput: array ğ‘“ âˆˆ â„¤Â²âµâ¶.                                   â–· the coefficients of input NTT representation\n                   ğ‘\nOutput: array ğ‘“ âˆˆ â„¤Â²âµâ¶.                              â–· the coefficients of the inverse NTT of the input\n                         ğ‘\n 1:    ğ‘“ â† ğ‘“                                   â–· will compute in place on a copy of input array\n 2:    ğ‘– â† 127\n 3:    for (len â† 2; len â‰¤ 128; len â† 2 â‹… len)\n 4:     for (start â† 0; start < 256; start â† start + 2 â‹… len)\n 5:               zeta â† ğœ BitRevâ‚‡(ğ‘–) mod ğ‘\n 6:               ğ‘– â† ğ‘– âˆ’ 1\n 7:               for (ğ‘— â† start; ğ‘— < start + len; ğ‘— ++)\n 8:                ğ‘¡ â† ğ‘“[ğ‘—]\n 9:                ğ‘“[ğ‘—] â† ğ‘¡ + ğ‘“[ğ‘— + len]                â–· steps 9-10 done modulo ğ‘\n10:                ğ‘“[ğ‘— + len] â† zeta â‹… (ğ‘“[ğ‘— + len] âˆ’ ğ‘¡)\n11:               end for\n12:     end for\n13:    end for\n14:    ğ‘“ â† ğ‘“ â‹… 3303 mod ğ‘                               â–· multiply every entry by 3303 â‰¡ 128âˆ’1 mod ğ‘\n15:    return ğ‘“\n\n26"
  },
  {
    "doc_id": "NIST.FIPS.203",
    "source_path": "data/raw_pdfs/NIST.FIPS.203.pdf",
    "page_number": 36,
    "text": "FIPS 203                                    MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\n\n4.3.1       Multiplication in the NTT Domain\nThe addition and scalar multiplication of elements of ğ‘‡ğ‘ can be done using the corresponding\ncoordinate-wise arithmetic operations on the coefficient arrays (see Section 2.4.5). This section\ndescribes how to do the remaining ring operation (i.e., multiplication in ğ‘‡ğ‘ ).\n\nRecall from (4.12) that ğ‘“ âˆˆ ğ‘‡ğ‘ is a vector of 128 degree-one residues modulo quadratic polyno-\nmials. Algebraically, multiplication in the ring ğ‘‡ğ‘ consists of independent multiplication in each\nof the 128 coordinates with respect to the quadratic modulus of that coordinate. Specifically,\nthe ğ‘–-th coordinate in ğ‘‡ğ‘ of the product â„ = ğ‘“ Ã—ğ‘‡ğ‘ ğ‘”Ì‚ is determined by the calculation\n\n â„[2ğ‘–] + â„[2ğ‘– + 1]ğ‘‹ = (ğ‘“[2ğ‘–] + ğ‘“[2ğ‘– + 1]ğ‘‹)(ğ‘”[2ğ‘–] + ğ‘”[2ğ‘– + 1]ğ‘‹) mod (ğ‘‹Â² âˆ’ ğœ 2BitRevâ‚‡(ğ‘–)+1).\n                                                                                             (4.14)\n\nAlgorithm 11 MultiplyNTTs(ğ‘“, ğ‘”)\nComputes the product (in the ring ğ‘‡ğ‘ ) of two NTT representations.\nInput: Two arrays ğ‘“ âˆˆ â„¤Â²âµâ¶ and ğ‘” âˆˆ â„¤Â²âµâ¶.           â–· the coefficients of two NTT representations\n                            ğ‘           ğ‘\nOutput: An array â„ âˆˆ â„¤Â²âµâ¶.                           â–· the coefficients of the product of the inputs\n                            ğ‘\n 1:  for (ğ‘– â† 0; ğ‘– < 128; ğ‘– ++)\n 2:         (â„[2ğ‘–], â„[2ğ‘– + 1]) â† BaseCaseMultiply(ğ‘“[2ğ‘–], ğ‘“[2ğ‘– + 1], ğ‘”[2ğ‘–], ğ‘”[2ğ‘– + 1], ğœ 2BitRevâ‚‡(ğ‘–)+1)\n 3:  end for\n 4:  return â„\n\nThus, one can compute the product of two elements of ğ‘‡ğ‘ using the algorithm MultiplyNTTs (Al-\ngorithm 11), which uses BaseCaseMultiply (Algorithm 12) as a subroutine. The values ğœ 2BitRevâ‚‡(ğ‘–)+1\nused in Algorithm 11 may be precomputed and stored in an array (see Appendix A). MultiplyNTTs\nalso enables linear-algebraic arithmetic with matrices and vectors whose entries are in ğ‘‡ğ‘ (see\nSection 2.4.7).\n\nAlgorithm 12 BaseCaseMultiply(ğ‘â‚€, ğ‘â‚, ğ‘â‚€, ğ‘â‚, ğ›¾)\nComputes the product of two degree-one polynomials with respect to a quadratic modulus.\nInput: ğ‘â‚€, ğ‘â‚, ğ‘â‚€, ğ‘â‚ âˆˆ â„¤ğ‘ .                    â–· the coefficients of ğ‘â‚€ + ğ‘â‚ğ‘‹ and ğ‘â‚€ + ğ‘â‚ğ‘‹\nInput: ğ›¾ âˆˆ â„¤ğ‘ .                                                   â–· the modulus is ğ‘‹Â² âˆ’ ğ›¾\nOutput: ğ‘â‚€, ğ‘â‚ âˆˆ â„¤ğ‘ .                 â–· the coefficients of the product of the two polynomials\n 1:  ğ‘â‚€ â† ğ‘â‚€ â‹… ğ‘â‚€ + ğ‘â‚ â‹… ğ‘â‚ â‹… ğ›¾                               â–· steps 1-2 done modulo ğ‘\n 2:  ğ‘â‚ â† ğ‘â‚€ â‹… ğ‘â‚ + ğ‘â‚ â‹… ğ‘â‚€\n 3:  return (ğ‘â‚€, ğ‘â‚)\n\n27"
  },
  {
    "doc_id": "NIST.FIPS.203",
    "source_path": "data/raw_pdfs/NIST.FIPS.203.pdf",
    "page_number": 37,
    "text": "FIPS 203                              MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\n\n5.   The K-PKE Component Scheme\n\n        This section describes the component scheme K-PKE. As discussed in Section 3.3, K-PKE is not\napproved for use in a stand-alone fashion. It serves only as a collection of subroutines for use in\nthe algorithms of the approved scheme ML-KEM, as described in Section 7.\nK-PKE consists of three algorithms:\n 1.  Key generation (K-PKE.KeyGen)\n 2.  Encryption (K-PKE.Encrypt)\n 3.  Decryption (K-PKE.Decrypt)\n        When K-PKE is instantiated as part of ML-KEM, K-PKE inherits the parameter set selected for\nML-KEM. Each parameter set specifies numerical values for each parameter. While ğ‘› is always\n256 and ğ‘ is always 3329, the values of the remaining parameters ğ‘˜, ğœ‚â‚, ğœ‚â‚‚, ğ‘‘ğ‘¢, and ğ‘‘ğ‘£ vary\namong the three parameter sets. Parameters and parameter sets are described in Section 8.\n     The algorithms in this section do not perform any input checking because they are only invoked as\nsubroutines of the main ML-KEM algorithms. The algorithms of ML-KEM themselves do perform\ninput checking as needed.\nEach of the algorithms of K-PKE is accompanied by a brief, informal description in text. For\nsimplicity, this description is written in terms of vectors and matrices whose entries are elements\nof ğ‘…ğ‘ . In the actual algorithm, most of the computations occur in the NTT domain in order to\nimprove the efficiency of multiplication. The relevant vectors and matrices will then have entries\nin ğ‘‡ğ‘ . Linear-algebraic arithmetic with such vectors and matrices (e.g., line 18 of K-PKE.KeyGen)\nis performed as described in Sections 2.4.7 and 4.3.1. The encryption and decryption keys of\nK-PKE are also stored in the NTT form.\n\n5.1  K-PKE Key Generation\n       The key generation algorithm K-PKE.KeyGen of K-PKE (Algorithm 13) receives a seed as input and\noutputs an encryption key ekPKE and a decryption key dkPKE. As is typically the case for public-key\nencryption, the encryption key can be made public, while the decryption key and the randomness\nmust remain private. Indeed, the encryption key of K-PKE will serve as the encapsulation key of\nML-KEM (see ML-KEM.KeyGen below) and can thus be made public. Meanwhile, the decryption\nkey and seed of K-PKE.KeyGen must remain private as they can be used to perform decapsulation\nin ML-KEM.\n      The matrix ğ€ generated in steps 3-7 of K-PKE.KeyGen can be stored, as specified in Section 3.3.\n     This allows later operations to use ğ€ directly rather than re-expanding it from the public seed ğœŒ.\n\nInformal description. The decryption key of K-PKE.KeyGen is a length-ğ‘˜ vector ğ¬ of elements\nof ğ‘…ğ‘ (i.e., ğ¬ âˆˆ ğ‘…ğ‘˜). Roughly speaking, ğ¬ is a set of secret variables, while the encryption key is\na collection of  ğ‘\n                 â€œnoisyâ€ linear equations (ğ€, ğ€ğ¬ + ğ) in the secret variables ğ¬. The rows of the\nmatrix ğ€ form the equation coefficients. This matrix is generated pseudorandomly using XOF\n       with only a seed stored in the encryption key. The secret ğ¬ and the â€œnoiseâ€ ğ are sampled from\n\n                                                     28"
  },
  {
    "doc_id": "NIST.FIPS.203",
    "source_path": "data/raw_pdfs/NIST.FIPS.203.pdf",
    "page_number": 38,
    "text": "FIPS 203                                   MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\n\nAlgorithm 13 K-PKE.KeyGen(ğ‘‘)\nUses randomness to generate an encryption key and a corresponding decryption key.\nInput: randomness ğ‘‘ âˆˆ ğ”¹Â³Â².\nOutput: encryption key ekPKE âˆˆ ğ”¹384ğ‘˜+32 .\nOutput: decryption key dkPKE âˆˆ ğ”¹384ğ‘˜ .\n 1:    (ğœŒ, ğœ) â† G(ğ‘‘â€–ğ‘˜)              â–· expand 32+1 bytes to two pseudorandom 32-byte seedsÂ¹\n 2:    ğ‘ â† 0\n 3:    for (ğ‘– â† 0; ğ‘– < ğ‘˜; ğ‘– ++)        â–· generate matrix ğ€âˆˆ (â„¤Â²âµâ¶)ğ‘˜Ã—ğ‘˜\n 4:     for (ğ‘— â† 0; ğ‘— < ğ‘˜; ğ‘— ++)                                             ğ‘\n 5:           ğ€[ğ‘–, ğ‘—] â† SampleNTT(ğœŒâ€–ğ‘—â€–ğ‘–)    â–· ğ‘— and ğ‘– are bytes 33 and 34 of the input\n 6:     end for\n 7:    end for\n 8:    for (ğ‘– â† 0; ğ‘– < ğ‘˜; ğ‘– ++)               â–· generate ğ¬ âˆˆ (â„¤Â²âµâ¶)ğ‘˜\n                                                                                   ğ‘\n 9:     ğ¬[ğ‘–] â† SamplePolyCBD          (PRFğœ‚ (ğœ, ğ‘ ))    â–· ğ¬[ğ‘–] âˆˆ â„¤Â²âµâ¶ sampled from CBD\n10:     ğ‘ â† ğ‘ + 1                     ğœ‚1  1               ğ‘\n11:    end for\n12:    for (ğ‘– â† 0; ğ‘– < ğ‘˜; ğ‘– ++)                          â–· generate ğ âˆˆ (â„¤Â²âµâ¶)ğ‘˜\n                                                                                   ğ‘\n13:     ğ[ğ‘–] â† SamplePolyCBD               (PRFğœ‚ (ğœ, ğ‘ ))    â–· ğ[ğ‘–] âˆˆ â„¤Â²âµâ¶ sampled from CBD\n14:     ğ‘ â† ğ‘ + 1                     ğœ‚1  1                    ğ‘\n15:    end for\n16:    ğ¬ â† NTT(ğ¬)                               â–· run NTT ğ‘˜ times (once for each coordinate of ğ¬)\n17:    ğ â† NTT(ğ)                                                           â–· run NTT ğ‘˜ times\n18:    ğ­ â† ğ€ âˆ˜ ğ¬ +Ì‚ ğÌ‚                                  â–· noisy linear system in NTT domain\n19:    ekPKE â† ByteEncodeâ‚â‚‚(ğ­)â€–ğœŒ                â–· run ByteEncodeâ‚â‚‚ ğ‘˜ times, then append ğ€-seed\n20:    dkPKE â† ByteEncodeâ‚â‚‚(ğ¬)Ì‚                                     â–· run ByteEncodeâ‚â‚‚ ğ‘˜ times\n21:    return (ekPKE, dkPKE)\n\ncentered binomial distributions using randomness expanded from another seed ğœ via PRF. Once\nğ€, ğ¬, and ğ are generated, the computation of the final part ğ­ = ğ€ğ¬ + ğ of the encryption key\ntakes place. The results are appropriately encoded into byte arrays and output.\nIn K-PKE.KeyGen, the choice of parameter set affects the length of the secret ğ¬ (via the parameter\nğ‘˜) and, as a consequence, the sizes of the noise vector ğ and the pseudorandom matrix ğ€. The\nchoice of parameter set also affects the noise distribution (via the parameter ğœ‚â‚) used to sample\nthe entries of ğ¬ and ğ.\n\n5.2    K-PKE Encryption\nThe encryption algorithm K-PKE.Encrypt of K-PKE (Algorithm 14) takes an encryption key ekPKE,\na 32-byte plaintext ğ‘š, and randomness ğ‘Ÿ as input and produces a single output: a ciphertext ğ‘.\n1Byte 33 of the input to G is the module dimension ğ‘˜ âˆˆ {2, 3, 4} âŠ‚ ğ”¹. This is included to establish domain separation\n between the three parameter sets. For implementations that use the seed in place of the private key, this ensures\n that the expansion will produce an unrelated key if the seed is mistakenly expanded using a parameter set other\n than the originally intended one.\n                                                  29"
  },
  {
    "doc_id": "NIST.FIPS.203",
    "source_path": "data/raw_pdfs/NIST.FIPS.203.pdf",
    "page_number": 39,
    "text": "FIPS 203                                         MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\n\nThe matrix ğ€ generated in steps 4-8 of K-PKE.Encrypt can be stored, as specified in Section 3.3.\nThis allows later operations to use ğ€ directly rather than re-expanding it from the public seed ğœŒ.\n\nAlgorithm 14 K-PKE.Encrypt(ekPKE, ğ‘š, ğ‘Ÿ)\nUses the encryption key to encrypt a plaintext message using the randomness ğ‘Ÿ.\nInput: encryption key ekPKE âˆˆ ğ”¹384ğ‘˜+32 .\nInput: message ğ‘š âˆˆ ğ”¹Â³Â².\nInput: randomness ğ‘Ÿ âˆˆ ğ”¹Â³Â².\nOutput: ciphertext ğ‘ âˆˆ ğ”¹32(ğ‘‘ğ‘¢ğ‘˜+ğ‘‘ğ‘£).\n 1:    ğ‘ â† 0\n 2:    ğ­ â† ByteDecode (ekPKE[0 âˆ¶ 384ğ‘˜])      â–· run ByteDecode  ğ‘˜ times to decode ğ­ âˆˆ (â„¤Â²âµâ¶)ğ‘˜\n       ğœŒ â† ek  [384ğ‘˜ âˆ¶Â¹Â²                                       12            ğ‘\n 3:          PKE       384ğ‘˜ + 32]               â–· extract 32-byte seed from ekPKE\n 4:    for (ğ‘– â† 0; ğ‘– < ğ‘˜; ğ‘– ++)       â–· re-generate matrix ğ€ âˆˆ (â„¤Â²âµâ¶)ğ‘˜Ã—ğ‘˜ sampled in Alg. 13\n 5:     for (ğ‘— â† 0; ğ‘— < ğ‘˜; ğ‘— ++)                                   ğ‘\n 6:             ğ€[ğ‘–, ğ‘—] â† SampleNTT(ğœŒâ€–ğ‘—â€–ğ‘–)    â–· ğ‘— and ğ‘– are bytes 33 and 34 of the input\n 7:     end for\n 8:    end for\n 9:    for (ğ‘– â† 0; ğ‘– < ğ‘˜; ğ‘– ++)                                      â–· generate ğ² âˆˆ (â„¤Â²âµâ¶)ğ‘˜\n                                                                               ğ‘\n10:     ğ²[ğ‘–] â† SamplePolyCBD            (PRFğœ‚ (ğ‘Ÿ, ğ‘ ))      â–· ğ²[ğ‘–] âˆˆ â„¤Â²âµâ¶ sampled from CBD\n11:     ğ‘ â† ğ‘ + 1                     ğœ‚1  1                           ğ‘\n12:    end for\n13:    for (ğ‘– â† 0; ğ‘– < ğ‘˜; ğ‘– ++)                                      â–· generate ğ âˆˆ (â„¤Â²âµâ¶)ğ‘˜\n                                                                                       ğŸ  ğ‘\n14:     ğğŸ [ğ‘–] â† SamplePolyCBD            (PRFğœ‚ (ğ‘Ÿ, ğ‘ ))    â–· ğğŸ [ğ‘–] âˆˆ â„¤Â²âµâ¶ sampled from CBD\n15:     ğ‘ â† ğ‘ + 1                     ğœ‚2         2                    ğ‘\n16:    end for\n17:    ğ‘’â‚‚ â† SamplePolyCBD             (PRFğœ‚ (ğ‘Ÿ, ğ‘ ))               â–· sample ğ‘’â‚‚ âˆˆ â„¤Â²âµâ¶ from CBD\n       ğ² â† NTT(ğ²)                    ğœ‚2   2                             â–· run ğ‘\n18:                                                                            NTT ğ‘˜ times\n19:    ğ® â† NTTâˆ’1(ğ€âŠº âˆ˜ ğ²) + ğğŸ                                       â–· run NTTâˆ’1 ğ‘˜ times\n20:    ğœ‡ â† Decompressâ‚(ByteDecodeâ‚(ğ‘š))\n21:    ğ‘£ â† NTTâˆ’1(ğ­âŠº âˆ˜ ğ²) + ğ‘’â‚‚ + ğœ‡                            â–· encode plaintext ğ‘š into polynomial ğ‘£\n22:    ğ‘â‚ â† ByteEncodeğ‘‘ğ‘¢ (Compressğ‘‘ğ‘¢ (ğ®))             â–· run ByteEncodeğ‘‘ğ‘¢ and Compressğ‘‘ğ‘¢ ğ‘˜ times\n23:    ğ‘â‚‚ â† ByteEncodeğ‘‘ğ‘£ (Compressğ‘‘ğ‘£ (ğ‘£))\n24:    return ğ‘ â† (ğ‘â‚â€–ğ‘â‚‚)\n\nInformal description. The algorithm K-PKE.Encrypt begins by extracting the vector ğ­ and the\nseed from the encryption key. The seed is then expanded to re-generate the matrix ğ€ in the same\nmanner as was done in K-PKE.KeyGen. If ğ­ and ğ€ are derived correctly from an encryption key\nproduced by K-PKE.KeyGen, then they are equal to their corresponding values in K-PKE.KeyGen.\nRecall from the description of key generation that the pair (ğ€, ğ­ = ğ€ğ¬ + ğ) can be thought of as\na system of noisy linear equations in the secret variables ğ¬. One can generate an additional noisy\nlinear equation in the same secret variables â€” without knowing ğ¬ â€” by picking a random linear\n\n30"
  },
  {
    "doc_id": "NIST.FIPS.203",
    "source_path": "data/raw_pdfs/NIST.FIPS.203.pdf",
    "page_number": 40,
    "text": " FIPS 203                                        MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\n\n combination of the noisy equations in the system (ğ€, ğ­). One can then encode information in the\nâ€œconstant termâ€ (i.e., the entry that is a linear combination of entries of ğ­) of such a combined\n equation. This information can then be deciphered by a party in possession of ğ¬. For example,\n one could encode a single bit by deciding whether or not to significantly alter the constant term,\n thus making either a nearly correct equation that corresponds to the decrypted bit value of 0 or a\n far-from-correct equation that corresponds to the decrypted bit value of 1. In the case of K-PKE,\n the constant term is a polynomial with 256 coefficients, so one can encode more information:\n one bit in each coefficient.\n To this end, K-PKE.Encrypt proceeds by generating a vector ğ² âˆˆ ğ‘…ğ‘˜ and noise terms ğ  âˆˆ ğ‘…ğ‘˜\n and         , all of which are sampled from the centered binomial ğ‘                     ğŸ  ğ‘\n      ğ‘’â‚‚ âˆˆ ğ‘…ğ‘            PRF                           ğ‘Ÿ       distribution using pseudoran-\n domness expanded via              from the input randomness  . One then computes the â€œnew noisy\n equation,â€ which is (up to some details) (ğ€âŠºğ² + ğâ‚, ğ­âŠºğ² + ğ‘’â‚‚). An appropriate encoding ğœ‡ of\n the input message ğ‘š is then added to the latter term in the pair. Finally, the resulting pair (ğ®, ğ‘£)\n is compressed, serialized into a byte array, and output as the ciphertext.\n\n 5.3  K-PKE Decryption\n The decryption algorithm K-PKE.Decrypt of K-PKE (Algorithm 15) takes a decryption key dkPKE\n and a ciphertext ğ‘ as input, requires no randomness, and outputs a plaintext ğ‘š.\n\n Informal description. The algorithm K-PKE.Decrypt begins by recovering a pair (ğ®â€² , ğ‘£â€² ) from the\n ciphertext ğ‘ (see the description of K-PKE.Encrypt). Here, one can think of ğ®â€² as the coefficients\n of the equation and ğ‘£â€² as the constant term. The decryption key dkPKE contains the vector of\n secret variables ğ¬. The decryption algorithm can thus use the decryption key to compute the\n true constant term ğ‘£ = ğ¬âŠºğ®â€² and calculate ğ‘£â€² âˆ’ ğ‘£. The decryption algorithm ends by decoding\n the plaintext message ğ‘š from ğ‘£â€² âˆ’ ğ‘£ and outputting ğ‘š.\n\n Algorithm 15 K-PKE.Decrypt(dkPKE, ğ‘)\n Uses the decryption key to decrypt a ciphertext.\n Input: decryption key dkPKE âˆˆ ğ”¹384ğ‘˜ .\n Input: ciphertext ğ‘ âˆˆ ğ”¹32(ğ‘‘ğ‘¢ğ‘˜+ğ‘‘ğ‘£).\n Output: message ğ‘š âˆˆ ğ”¹Â³Â².\n  1:  ğ‘â‚ â† ğ‘[0 âˆ¶ 32ğ‘‘ğ‘¢ğ‘˜]\n  2:  ğ‘â‚‚ â† ğ‘[32ğ‘‘ğ‘¢ğ‘˜ âˆ¶ 32(ğ‘‘ğ‘¢ğ‘˜ + ğ‘‘ğ‘£)]\n  3:  ğ®â€² â† Decompressğ‘‘ğ‘¢ (ByteDecodeğ‘‘ğ‘¢ (ğ‘â‚)) â–· run Decompressğ‘‘ğ‘¢ and ByteDecodeğ‘‘ğ‘¢ ğ‘˜ times\n  4:  ğ‘£â€² â† Decompressğ‘‘ğ‘£ (ByteDecodeğ‘‘ğ‘£ (ğ‘â‚‚))\n  5:  ğ¬ â† ByteDecodeâ‚â‚‚(dkPKE)                                         â–· run ByteDecodeâ‚â‚‚ ğ‘˜ times\n  6:  ğ‘¤ â† ğ‘£â€² âˆ’ NTTâˆ’1(ğ¬âŠº âˆ˜ NTT(ğ®â€² ))                      â–· run NTT ğ‘˜ times; run NTTâˆ’1 once\n  7:  ğ‘š â† ByteEncodeâ‚(Compressâ‚(ğ‘¤))                      â–· decode plaintext ğ‘š from polynomial ğ‘£\n  8:  return ğ‘š\n\n 31"
  },
  {
    "doc_id": "NIST.FIPS.203",
    "source_path": "data/raw_pdfs/NIST.FIPS.203.pdf",
    "page_number": 41,
    "text": "FIPS 203                                   MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\n\n6.   Main Internal Algorithms\n\nThis section specifies three algorithms:  ML-KEM.KeyGen_internal, ML-KEM.Encaps_internal,\nand ML-KEM.Decaps_internal. These three algorithms are all deterministic, meaning that their\noutput is completely determined by their input. No randomness is sampled inside of these\nalgorithms. These three algorithms will be used to construct ML-KEM in Section 7. The algorithms\nin this section make use of the parameters ğ‘›, ğ‘, ğ‘˜, ğ‘‘ğ‘¢, and ğ‘‘ğ‘£. The subroutines they invoke\nadditionally make use of the parameters ğœ‚â‚ and ğœ‚â‚‚. While ğ‘› is always 256 and ğ‘ is always 3329,\nthe remaining parameters vary among the possible parameter sets (see Section 8).\nThe interfaces specified in this section will be used to test ML-KEM implementations through\nthe Cryptographic Algorithm Validation Program (CAVP). The key generation function in this\nsection may also be used to re-expand a key from a seed (see Section 3.3), including when\nobtaining assurance of private key possession via regeneration. As prescribed in Section 3.3, the\ninterfaces specified in this section should not be made available to applications other than for\ntesting purposes, and the random seeds (as specified in ML-KEM.KeyGen and ML-KEM.Encaps\nin Section 7) shall be generated by the cryptographic module.\n\n6.1  Internal Key Generation\nThe algorithm ML-KEM.KeyGen_internal (Algorithm 16) accepts two random seeds as input, and\nproduces an encapsulation key and a decapsulation key.\n\nInformal description. The core subroutine of ML-KEM.KeyGen_internal is the key generation\nalgorithm of K-PKE (Algorithm 13). The encapsulation key is simply the encryption key of K-PKE.\nThe decapsulation key consists of the decryption key of K-PKE, the encapsulation key, a hash\nof the encapsulation key, and a random 32-byte value. This random value will be used in the\nâ€implicit rejectionâ€ mechanism of the internal decapsulation algorithm (Algorithm 18).\n\nAlgorithm 16 ML-KEM.KeyGen_internal(ğ‘‘, ğ‘§)\nUses randomness to generate an encapsulation key and a corresponding decapsulation key.\nInput: randomness ğ‘‘ âˆˆ ğ”¹Â³Â².\nInput: randomness ğ‘§ âˆˆ ğ”¹Â³Â².\nOutput: encapsulation key ek âˆˆ ğ”¹384ğ‘˜+32 .\nOutput: decapsulation key dk âˆˆ ğ”¹768ğ‘˜+96 .\n 1:  (ekPKE, dkPKE) â† K-PKE.KeyGen(ğ‘‘)                       â–· run key generation for K-PKE\n 2:  ek â† ekPKE                            â–· KEM encaps key is just the PKE encryption key\n 3:  dk â† (dkPKEâ€–ekâ€–H(ek)â€–ğ‘§)              â–· KEM decaps key includes PKE decryption key\n 4:  return (ek, dk)\n\n6.2  Internal Encapsulation\nThe algorithm ML-KEM.Encaps_internal (Algorithm 17) accepts an encapsulation key and a ran-\ndom byte array as input and outputs a ciphertext and a shared key.\n\n                           32"
  },
  {
    "doc_id": "NIST.FIPS.203",
    "source_path": "data/raw_pdfs/NIST.FIPS.203.pdf",
    "page_number": 42,
    "text": "FIPS 203                                  MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\n\nAlgorithm 17 ML-KEM.Encaps_internal(ek, ğ‘š)\nUses the encapsulation key and randomness to generate a key and an associated ciphertext.\nInput: encapsulation key ek âˆˆ ğ”¹384ğ‘˜+32 .\nInput: randomness ğ‘š âˆˆ ğ”¹Â³Â².\nOutput: shared secret key ğ¾ âˆˆ ğ”¹Â³Â².\nOutput: ciphertext ğ‘ âˆˆ ğ”¹32(ğ‘‘ğ‘¢ğ‘˜+ğ‘‘ğ‘£).\n 1:  (ğ¾, ğ‘Ÿ) â† G(ğ‘šâ€–H(ek))               â–· derive shared secret key ğ¾ and randomness ğ‘Ÿ\n 2:  ğ‘ â† K-PKE.Encrypt(ek, ğ‘š, ğ‘Ÿ)        â–· encrypt ğ‘š using K-PKE with randomness ğ‘Ÿ\n 3:  return (ğ¾, ğ‘)\n\nInformal description. The core subroutine of ML-KEM.Encaps_internal is the encryption algo-\nrithm of K-PKE, which is used to encrypt a random value ğ‘š into a ciphertext ğ‘. A copy of the\nshared secret key ğ¾ and the randomness used during encryption are derived from ğ‘š and the\nencapsulation key ek via hashing. Specifically, H is applied to ek, and the result is concatenated\nwith ğ‘š and then hashed using G. Finally, the algorithm outputs the shared secret key ğ¾ and the\nciphertext ğ‘.\n\n6.3  Internal Decapsulation\nThe algorithm ML-KEM.Decaps_internal (Algorithm 18) accepts a decapsulation key and a cipher-\ntext as input, does not use any randomness, and outputs a shared secret key.\n\nInformal description. The algorithm ML-KEM.Decaps_internal begins by parsing out the com-\nponents of the decapsulation key dk of ML-KEM. These components are an (encryption key,\ndecryption key) pair for K-PKE, a hash value â„, and a random value ğ‘§. The decryption key of\nK-PKE is then used to decrypt the input ciphertext ğ‘ to get a plaintext ğ‘šâ€² . The decapsulation\nalgorithm then re-encrypts ğ‘šâ€² and computes a candidate shared secret key ğ¾â€² in the same\nmanner as should have been done in encapsulation. Specifically, ğ¾â€² and the encryption ran-\ndomness ğ‘Ÿâ€² are computed by hashing ğ‘šâ€² and the encryption key of K-PKE, and a ciphertext ğ‘â€² is\ngenerated by encrypting ğ‘šâ€² using randomness ğ‘Ÿâ€² . Finally, decapsulation checks whether the\nresulting ciphertext ğ‘â€² matches the provided ciphertext ğ‘. If it does not, the algorithm performs\nan â€œimplicit rejectionâ€: the value of ğ¾â€² is changed to a hash of ğ‘ together with the random value\nğ‘§ stored in the ML-KEM secret key (see the discussion of decapsulation failures in Section    3.2).\nIn either case, decapsulation outputs the resulting shared secret key ğ¾â€² .\nThe â€œimplicit rejectâ€ flag computed in step 9 (by comparing ğ‘ and ğ‘â€² ) is a secret piece of interme-\ndiate data. As specified in the requirements in Section 3.3, this flag shall be destroyed prior to\nML-KEM.Decaps_internal terminating. In particular, returning the value of the flag as an output\nin any form is not permitted.\n\n33"
  },
  {
    "doc_id": "NIST.FIPS.203",
    "source_path": "data/raw_pdfs/NIST.FIPS.203.pdf",
    "page_number": 43,
    "text": "FIPS 203                                         MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\n\nAlgorithm 18 ML-KEM.Decaps_internal(dk, ğ‘)\nUses the decapsulation key to produce a shared secret key from a ciphertext.\nInput: decapsulation key dk âˆˆ ğ”¹768ğ‘˜+96 .\nInput: ciphertext ğ‘ âˆˆ ğ”¹32(ğ‘‘ğ‘¢ğ‘˜+ğ‘‘ğ‘£).\nOutput: shared secret key ğ¾ âˆˆ ğ”¹Â³Â².\n 1:    dkPKE â† dk[0 âˆ¶ 384ğ‘˜]               â–· extract (from KEM decaps key) the PKE decryption key\n 2:    ekPKE â† dk[384ğ‘˜ âˆ¶ 768ğ‘˜ + 32]            â–· extract PKE encryption key\n 3:    â„ â† dk[768ğ‘˜ + 32 âˆ¶ 768ğ‘˜ + 64]           â–· extract hash of PKE encryption key\n 4:    ğ‘§ â† dk[768ğ‘˜ + 64 âˆ¶ 768ğ‘˜ + 96]          â–· extract implicit rejection value\n 5:    ğ‘šâ€² â€²â†â€²K-PKE.Decrypt(dkPKE, ğ‘)           â–· decrypt ciphertext\n 6:    (ğ¾ , ğ‘Ÿ ) â† G(ğ‘šâ€² â€–â„)Ì„\n 7:    ğ¾ â† J(ğ‘§â€–ğ‘)\n 8:    ğ‘â€² â† K-PKE.Encrypt(ekPKE, ğ‘šâ€² , ğ‘Ÿâ€² )    â–· re-encrypt using the derived randomness ğ‘Ÿâ€²\n 9:    if ğ‘ â‰  ğ‘â€² then\n10:         ğ¾â€² â† ğ¾                             â–· if ciphertexts do not match, â€œimplicitly rejectâ€\n11:    end if\n12:    return ğ¾â€²\n\n34"
  },
  {
    "doc_id": "NIST.FIPS.203",
    "source_path": "data/raw_pdfs/NIST.FIPS.203.pdf",
    "page_number": 44,
    "text": "FIPS 203                                   MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\n\n7.         The ML-KEM Key-Encapsulation Mechanism\n\nThis section describes the three main algorithms of the ML-KEM scheme:\n  1.       Key generation (ML-KEM.KeyGen)\n  2.       Encapsulation (ML-KEM.Encaps)\n  3.       Decapsulation (ML-KEM.Decaps)\nTo instantiate ML-KEM, one must select a parameter set. Each parameter set is associated with\na particular trade-off between security and performance. The three possible parameter sets are\ncalled ML-KEM-512, ML-KEM-768, and ML-KEM-1024 and are described in detail in Table 2 of\nSection 8. Each parameter set assigns specific numerical values to the individual parameters ğ‘›,\nğ‘, ğ‘˜, ğœ‚â‚, ğœ‚â‚‚, ğ‘‘ğ‘¢, and ğ‘‘ğ‘£. While ğ‘› is always 256 and ğ‘ is always 3329, the remaining parameters\nvary among the three parameter sets. Implementers shall ensure that the three algorithms of\nML-KEM listed above are only invoked with a valid parameter set, and that this parameter set is\nselected appropriately for the desired application. Moreover, implementers shall ensure that the\nparameter set used in any particular invocation of ML-KEM.Encaps or ML-KEM.Decaps matches\nthe parameter set associated to the provided inputs.\n\n7.1        ML-KEM Key Generation\nThe key generation algorithm ML-KEM.KeyGen for ML-KEM (Algorithm 19) accepts no input,\ngenerates randomness internally, and produces an encapsulation key and a decapsulation key.\nWhile the encapsulation key can be made public, the decapsulation key shall remain private.\nThe seed (ğ‘‘, ğ‘§) generated in steps 1 and 2 of ML-KEM.KeyGen can be stored for later expan-\nsion using ML-KEM.KeyGen_internal (see Section 3.3). As the seed can be used to compute\nthe decapsulation key, it is sensitive data and shall be treated with the same safeguards as a\ndecapsulation key (see SP 800-227 [1]).\n\nAlgorithm 19 ML-KEM.KeyGen()\nGenerates an encapsulation key and a corresponding decapsulation key.\nOutput: encapsulation key ek âˆˆ ğ”¹384ğ‘˜+32 .\nOutput: decapsulation key dk âˆˆ ğ”¹768ğ‘˜+96 .\n       ğ‘‘   $ ğ”¹Â³Â²                                              â–· ğ‘‘ is 32 random bytes (see Section 3.3)\n           â†\n 1:         âˆ’\n       ğ‘§   $ ğ”¹Â³Â²                                              â–· ğ‘§ is 32 random bytes (see Section 3.3)\n           â†\n 2:        âˆ’\n 3:    if ğ‘‘ == NULL or ğ‘§ == NULL then\n 4:         return âŠ¥        â–· return an error indication if random bit generation failed\n 5:    end if\n 6:    (ek, dk) â† ML-KEM.KeyGen_internal(ğ‘‘, ğ‘§)    â–· run internal key generation algorithm\n 7:    return (ek, dk)\n\nSecure key establishment depends on the use of key pairs that have been properly generated\nvia ML-KEM.KeyGen. If the owner of a KEM key pair did not generate the key pair but instead\nreceived it from a trusted third party or other source, the owner may optionally perform certain\n                                           35"
  },
  {
    "doc_id": "NIST.FIPS.203",
    "source_path": "data/raw_pdfs/NIST.FIPS.203.pdf",
    "page_number": 45,
    "text": "FIPS 203                                  MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\n\nchecks on the key pair. While these checks can detect certain corruptions, they do not guarantee\nthat the key pair was properly generated.\n\nKey pair check. To check a candidate key pairÂ¹ (ek, dk), perform the following checks:\n 1.  (Seed consistency) If a seed (ğ‘‘, ğ‘§) is available, run ML-KEM.KeyGen_internal(ğ‘‘, ğ‘§), and\n     verify that the output is equal to (ek, dk).\n 2.  (Encapsulation key check) Check ek as specified in Section 7.2.\n 3.  (Decapsulation key check) Check dk as specified in Section 7.3.\n 4.  (Pair-wise consistency) Perform the following steps:\n            i.   Generate an array of 32 random bytes by performing ğ‘š     $ ğ”¹Â³Â².\n                                                                           â†\n                                                                           âˆ’\n            ii.  Perform (ğ¾, ğ‘) â† ML-KEM.Encaps_internal(ek, ğ‘š).\n     iii.        Perform ğ¾â€² â† ML-KEM.Decaps_internal(dk, ğ‘).\n     iv.         Reject unless ğ¾ == ğ¾â€² .\nIt is important to note that this checking process does not guarantee that the key pair is a properly\nproduced output of ML-KEM.KeyGen.\n\n7.2  ML-KEM Encapsulation\nThe encapsulation algorithm ML-KEM.Encaps of ML-KEM (Algorithm 20) accepts an encapsula-\ntion key as input, generates randomness internally, and outputs a ciphertext and a shared key.\nThis algorithm requires input checking, as specified below.\n\nEncapsulation key check. To check a candidate encapsulation key ek, perform the following:\n 1.  (Type check) If ek is not an array of bytes of length 384ğ‘˜ + 32 for the value of ğ‘˜ specified\n     by the relevant parameter set, then input checking failed.\n 2.  (Modulus check) Perform the computation\n\n                 test â† ByteEncodeâ‚â‚‚(ByteDecodeâ‚â‚‚(ek[0 âˆ¶ 384ğ‘˜]))                     (7.1)\n\n     (see Section 4.2.1). If test â‰  ek[0 âˆ¶ 384ğ‘˜], then input checking failed. This check ensures\n     that the integers encoded in the public key are in the valid range [0, ğ‘ âˆ’ 1].\nIf both checks pass, then ML-KEM.Encaps can be run with input ek âˆ¶= ek.           It is important to\nnote that this checking process does not guarantee that ek is a properly produced output of\nML-KEM.KeyGen.\nML-KEM.Encaps shall not be run with an encapsulation key that has not been checked as above.\nHowever, checking of the encapsulation key need not be performed by the encapsulating party,\n\n1In discussions of input checking, the â€œlow overlineâ€ in the notation indicates that the input has not yet been\nchecked (e.g., ek has not yet been checked, while ek has passed the check).\n                                          36"
  },
  {
    "doc_id": "NIST.FIPS.203",
    "source_path": "data/raw_pdfs/NIST.FIPS.203.pdf",
    "page_number": 46,
    "text": "FIPS 203                                  MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\n\nnor with every execution of ML-KEM.Encaps. Instead, assurance that these checks have been\nperformed can be acquired through other means (see SP 800-227 [1]).\n\nAlgorithm 20 ML-KEM.Encaps(ek)\nUses the encapsulation key to generate a shared secret key and an associated ciphertext.\nChecked input: encapsulation key ek âˆˆ ğ”¹384ğ‘˜+32 .\nOutput: shared secret key ğ¾ âˆˆ ğ”¹Â³Â².\nOutput: ciphertext ğ‘ âˆˆ ğ”¹32(ğ‘‘ğ‘¢ğ‘˜+ğ‘‘ğ‘£).\n     ğ‘š $   ğ”¹Â³Â²                                  â–· ğ‘š is 32 random bytes (see Section 3.3)\n     â†\n 1:         âˆ’\n 2:  if ğ‘š == NULL then\n 3:         return âŠ¥          â–· return an error indication if random bit generation failed\n 4:  end if\n 5:  (ğ¾, ğ‘) â† ML-KEM.Encaps_internal(ek, ğ‘š)    â–· run internal encapsulation algorithm\n 6:  return (ğ¾, ğ‘)\n\n7.3  ML-KEM Decapsulation\nThe decapsulation algorithm ML-KEM.Decaps of ML-KEM (Algorithm 21) accepts a decapsulation\nkey and an ML-KEM ciphertext as input, does not use any randomness, and outputs a shared\nsecret. This algorithm requires input checking, as specified below.\n\nDecapsulation input check. To check a candidate decapsulation key dk and ciphertext ğ‘, perform\nthe following checks:\n 1.  (Ciphertext type check) If ğ‘ is not a byte array of length 32(ğ‘‘ğ‘¢ğ‘˜ + ğ‘‘ğ‘£) for the values of ğ‘‘ğ‘¢,\n     ğ‘‘ğ‘£, and ğ‘˜ specified by the relevant parameter set, then input checking has failed.\n 2.  (Decapsulation key type check) If dk is not a byte array of length 768ğ‘˜ + 96 for the value of\n     ğ‘˜ specified by the relevant parameter set, then input checking has failed.\n 3.  (Hash check) Perform the computation\n\n                     test â† H(dk[384ğ‘˜ âˆ¶ 768ğ‘˜ + 32])) .                                  (7.2)\n\n     If test â‰  dk[768ğ‘˜ + 32 âˆ¶ 768ğ‘˜ + 64], then input checking has failed.\nIf all of the above checks pass, then ML-KEM.Decaps can be run with inputs dk âˆ¶= dk and ğ‘ âˆ¶= ğ‘. It\nis important to note that this checking process does not guarantee that dk is a properly produced\noutput of ML-KEM.KeyGen, nor that ğ‘ is a properly produced output of ML-KEM.Encaps.\nML-KEM.Decaps shall not be run with a decapsulation key or a ciphertext unless both have\nbeen checked. However, checking of the decapsulation key need not be performed by the\ndecapsulating party, nor with every execution of ML-KEM.Decaps. Instead, assurance that this\ncheck has been performed can be acquired through other means (see SP 800-227 [1]). Ciphertext\nchecking shall be performed with every execution of ML-KEM.Decaps.\n\n37"
  },
  {
    "doc_id": "NIST.FIPS.203",
    "source_path": "data/raw_pdfs/NIST.FIPS.203.pdf",
    "page_number": 47,
    "text": "FIPS 203                                         MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\n\nAlgorithm 21 ML-KEM.Decaps(dk, ğ‘)\nUses the decapsulation key to produce a shared secret key from a ciphertext.\nChecked input: decapsulation key dk âˆˆ ğ”¹768ğ‘˜+96 .\nChecked input: ciphertext ğ‘ âˆˆ ğ”¹32(ğ‘‘ğ‘¢ğ‘˜+ğ‘‘ğ‘£).\nOutput: shared secret key ğ¾ âˆˆ ğ”¹Â³Â².\n 1:  ğ¾â€² â† ML-KEM.Decaps_internal(dk, ğ‘)         â–· run internal decapsulation algorithm\n 2:  return ğ¾â€²\n\n38"
  },
  {
    "doc_id": "NIST.FIPS.203",
    "source_path": "data/raw_pdfs/NIST.FIPS.203.pdf",
    "page_number": 48,
    "text": "FIPS 203                                MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\n\n8.   Parameter Sets\n\nML-KEM is equipped with three parameter sets, each of the which comprises five individual\nparameters: ğ‘˜, ğœ‚â‚, ğœ‚â‚‚, ğ‘‘ğ‘¢, and ğ‘‘ğ‘£. There are also two constants: ğ‘› = 256 and ğ‘ = 3329. The\nfollowing is a brief and informal description of the roles played by the variable parameters in the\nalgorithms of K-PKE and ML-KEM. See Section 5 for details.\n    â€¢ The parameter ğ‘˜ determines the dimensions of the matrix ğ€ that appears in K-PKE.KeyGen\n     and K-PKE.Encrypt. It also determines the dimensions of vectors ğ¬ and ğ in K-PKE.KeyGen\n     and the dimensions of vectors ğ² and ğâ‚ in K-PKE.Encrypt.\n    â€¢ The parameter ğœ‚â‚ is required to specify the distribution for generating the vectors ğ¬ and ğ\n     in K-PKE.KeyGen and the vector ğ² in K-PKE.Encrypt.\n    â€¢ The parameter ğœ‚â‚‚ is required to specify the distribution for generating the vectors ğâ‚ and\n     ğ‘’â‚‚ in K-PKE.Encrypt.\n    â€¢ The parameters ğ‘‘ğ‘¢ and ğ‘‘ğ‘£ serve as parameters and inputs for the functions Compress,\n     Decompress, ByteEncode, and ByteDecode in K-PKE.Encrypt and K-PKE.Decrypt.\n       This standard approves the parameter sets given in Table 2. Each parameter set is associated\n     with a required security strength for randomness generation (see Section 3.3). The sizes of the\nML-KEM keys and ciphertexts for each parameter set are summarized in Table 3.\n\n                               Table 2. Approved parameter sets for ML-KEM\n\n                     ğ‘›     ğ‘     ğ‘˜    ğœ‚â‚    ğœ‚â‚‚     ğ‘‘ğ‘¢    ğ‘‘ğ‘£    required RBG strength (bits)\n      ML-KEM-512    256    3329    2     3      2       10      4                   128\n      ML-KEM-768    256    3329    3     2      2       10      4                   192\n     ML-KEM-1024    256    3329    4     2      2       11      5                   256\n\n            Table 3. Sizes (in bytes) of keys and ciphertexts of ML-KEM\n\n             encapsulation key    decapsulation key     ciphertext    shared secret key\n      ML-KEM-512    800                  1632              768                32\n      ML-KEM-768    1184                 2400              1088               32\n     ML-KEM-1024    1568                 3168              1568               32\n\n      A parameter set name can also be said to denote a (parameter-free) KEM. Specifically, ML-KEM-ğ‘¥\ncan be used to denote the parameter-free KEM that results from instantiating the scheme\nML-KEM with the parameter set ML-KEM-ğ‘¥.\n       The three parameter sets included in Table 2 were designed to meet certain security strength\ncategories defined by NIST in its original Call for Proposals [4, 22]. These security strength\ncategories are explained further in SP 800-57, Part 1 [7].\nUsing this approach, security strength is not described by a single number, such as â€œ128 bits of\nsecurity.â€ Instead, each ML-KEM parameter set is claimed to be at least as secure as a generic\n                                                    39"
  },
  {
    "doc_id": "NIST.FIPS.203",
    "source_path": "data/raw_pdfs/NIST.FIPS.203.pdf",
    "page_number": 49,
    "text": "FIPS 203                                 MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\n\nblock cipher with a prescribed key size or a generic hash function with a prescribed output\nlength. More precisely, it is claimed that the computational resources needed to break ML-KEM\nare greater than or equal to the computational resources needed to break the block cipher or\nhash function when those computational resources are estimated using any realistic model of\ncomputation. Different models of computation can be more or less realistic and, accordingly,\nlead to more or less accurate estimates of security strength. Some commonly studied models\nare discussed in [23].\nConcretely, ML-KEM-512 is claimed to be in security category 1, ML-KEM-768 is claimed to be\nin security category 3, and ML-KEM-1024 is claimed to be in security category 5. For additional\ndiscussion of the security strength of MLWE-based cryptosystems, see [4].\n\nSelecting an appropriate parameter set. When initially establishing cryptographic protections\nfor data, the strongest possible parameter set should be used. This has a number of advantages,\nincluding reducing the likelihood of costly transitions to higher-security parameter sets in the\nfuture.     At the same time, it should be noted that some parameter sets might have adverse\nperformance effects for the relevant application (e.g., the algorithm may be unacceptably slow,\nor objects such as keys or ciphertexts may be unacceptably large).\nNIST recommends using ML-KEM-768 as the default parameter set, as it provides a large security\nmargin at a reasonable performance cost. In cases where this is impractical or even higher\nsecurity is required, other parameter sets may be used.\n\n40"
  },
  {
    "doc_id": "NIST.FIPS.203",
    "source_path": "data/raw_pdfs/NIST.FIPS.203.pdf",
    "page_number": 50,
    "text": "FIPS 203                                  MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\n\nReferences\n\n [1]  National Institute of Standards     and Technology (2024) Recommendations for key-\n      encapsulation mechanisms, (National Institute of Standards and Technology, Gaithers-\n      burg, MD), NIST Special Publication (SP) 800-227. [Forthcoming;   will be available at\n      https://csrc.nist.gov/publications].\n [2]  Barker EB, Chen L, Roginsky AL, Vassilev A, Davis R (2018) Recommendation for pair-wise\n      key-establishment schemes using discrete logarithm cryptography (National Institute of\n      Standards and Technology, Gaithersburg, MD), NIST Special Publication (SP) 800-56A Revi-\n      sion 3. https://doi.org/10.6028/NIST.SP.800-56Ar3.\n [3]  Barker EB, Chen L, Roginsky AL, Vassilev A, Davis R, Simon S (2019) Recommendation for\n      pair-wise key-establishment using integer factorization cryptography (National Institute\n      of Standards and Technology, Gaithersburg, MD), NIST Special Publication (SP) 800-56B\n      Revision 2. https://doi.org/10.6028/NIST.SP.800-56Br2.\n [4]  Avanzi R, Bos J, Ducas L, Kiltz E, Lepoint T, Lyubashevsky V, Schanck JM, Schwabe P, Seiler G,\n      StehlÃ© D (2020) CRYSTALS-Kyber algorithm specifications and supporting documentation,\n      Third-round submission to the NISTâ€™s post-quantum cryptography standardization process.\n      Available at https://csrc.nist.gov/Projects/post-quantum-cryptography/post-quantum-cry\n      ptography-standardization/round-3-submissions.\n [5]  National Institute of Standards and Technology (2015) Secure hash standard (SHS), (U.S.\n      Department of Commerce, Washington, DC), Federal Information Processing Standards\n      Publication (FIPS) 180-4. https://doi.org/10.6028/NIST.FIPS.180-4.\n [6]  National Institute of Standards and Technology (2015) SHA-3 standard: Permutation-based\n      hash and extendable-output functions, (U.S. Department of Commerce, Washington, DC),\n      Federal Information Processing Standards Publication (FIPS) 202. https://doi.org/10.6028/\n      NIST.FIPS.202.\n [7]  Barker EB (2020) Recommendation for key management: Part 1 - General, (National Institute\n      of Standards and Technology, Gaithersburg, MD), NIST Special Publication (SP) 800-57 Part\n      1, Rev. 5 [or as amended]. https://doi.org/10.6028/NIST.SP.800-57pt1r5.\n [8]  Bos J, Ducas L, Kiltz E, Lepoint T, Lyubashevsky V, Schanck JM, Schwabe P, Seiler G, StehlÃ©\n      D (2018) CRYSTALS-Kyber: A CCA-secure module-lattice-based KEM. 2018 IEEE European\n      Symposium on Security and Privacy (EuroS&P), pp 353â€“367. https://doi.org/10.1109/Euro\n      SP.2018.00032.\n [9]  Langlois A, StehlÃ© D (2015) Worst-case to average-case reductions for module lattices.\n      Designs, Codes and Cryptography 75(3):565â€“599. https://doi.org/10.1007/s10623-014-9\n      938-4.\n[10]  Regev O (2005) On lattices, learning with errors, random linear codes, and cryptography.\n      Proceedings of the Thirty-Seventh Annual ACM Symposium on Theory of Computing STOC\n     â€™05 (Association for Computing Machinery, New York, NY, USA), pp 84â€“â€“93. https://doi.org/\n      10.1145/1060590.1060603.\n\n41"
  },
  {
    "doc_id": "NIST.FIPS.203",
    "source_path": "data/raw_pdfs/NIST.FIPS.203.pdf",
    "page_number": 51,
    "text": "FIPS 203                              MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\n\n[11]  Fujisaki E, Okamoto T (2013) Secure integration of asymmetric and symmetric encryption\n      schemes. Journal of Cryptology 26:80â€“101. https://doi.org/10.1007/s00145-011-9114-1.\n[12]  Hofheinz D, HÃ¶velmanns K, Kiltz E (2017) A modular analysis of the Fujisaki-Okamoto trans-\n      formation. Theory of Cryptography, eds Kalai Y, Reyzin L (Springer International Publishing,\n      Cham), pp 341â€“371. https://doi.org/10.1007/978-3-319-70500-2_12.\n[13]  Katz J, Lindell Y (2020) Introduction to Modern Cryptography (Chapman & Hall/CRC), 3rd Ed.\n[14]  Almeida JB, Olmos SA, Barbosa M, Barthe G, Dupressoir F, GrÃ©goire B, Laporte V, LÃ©chenet JC,\n      Low C, Oliveira T, Pacheco H, Quaresma M, Schwabe P, Strub PY (2024) Formally verifying Ky-\n      ber episode V: Machine-checked IND-CCA security and correctness of ML-KEM in EasyCrypt,\n      Cryptology ePrint Archive, Paper 2024/843. Available at https://eprint.iacr.org/2024/843.\n[15]  Ducas L, Schanck J (2021) Security estimation scripts for Kyber and Dilithium, Github reposi-\n      tory. Available at https://github.com/pq-crystals/security-estimates.\n[16]  Chen L (2022) Recommendation for key derivation using pseudorandom functions, (National\n      Institute of Standards and Technology, Gaithersburg, MD), NIST Special Publication (SP)\n      800-108r1-upd1, Includes updates as of February 2, 2024. https://doi.org/10.6028/NIST.SP.\n      800-108r1-upd1.\n[17]  Barker EB, Chen L, Davis R (2020) Recommendation for key-derivation methods in key-\n      establishment schemes (National Institute of Standards and Technology, Gaithersburg, MD),\n      NIST Special Publication (SP) 800-56C Revision 2. https://doi.org/10.6028/NIST.SP.800-56C\n      r2.\n[18]  Barker EB, Kelsey JM (2015) Recommendation for random number generation using deter-\n      ministic random bit generators, (National Institute of Standards and Technology, Gaithers-\n      burg, MD), NIST Special Publication (SP) 800-90A, Rev. 1. https://doi.org/10.6028/NIST.SP.\n      800-90Ar1.\n[19]  SÃ¶nmez Turan M, Barker EB, Kelsey JM, McKay KA, Baish ML, Boyle M (2018) Recom-\n      mendation for the entropy sources used for random bit generation, (National Institute\n      of Standards and Technology, Gaithersburg, MD), NIST Special Publication (SP) 800-90B.\n      https://doi.org/10.6028/NIST.SP.800-90B.\n[20]  Barker E, Kelsey J, McKay K, Roginsky A, Turan MS (2024) Recommendation for random bit\n      generator (RBG) constructions, (National Institute of Standards and Technology, Gaithers-\n      burg, MD), NIST Special Publication (SP) 800-90C 4pd. https://doi.org/10.6028/NIST.SP.80\n      0-90C.4pd.\n[21]  Kelsey J, Chang S, Perlner R (2016) SHA-3 Derived Functions: cSHAKE, KMAC, TupleHash\n      and ParallelHash, (National Institute of Standards and Technology, Gaithersburg, MD), NIST\n      Special Publication (SP) 800-185 [or as amended]. https://doi.org/10.6028/NIST.SP.800-1\n      85.\n[22]  National Institute of Standards and Technology (2016) Submission requirements and eval-\n      uation criteria for the post-quantum cryptography standardization process. Available at\n      https://csrc.nist.gov/CSRC/media/Projects/Post-Quantum-Cryptography/documents/call-f\n      or-proposals-final-dec-2016.pdf.\n\n                                      42"
  },
  {
    "doc_id": "NIST.FIPS.203",
    "source_path": "data/raw_pdfs/NIST.FIPS.203.pdf",
    "page_number": 52,
    "text": "FIPS 203                    MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\n\n[23]  Alagic G, Apon D, Cooper D, Dang Q, Dang T, Kelsey J, Lichtinger J, Liu YK, Miller C, Moody\n      D, Peralta R, Perlner R, Robinson A, Smith-Tone D (2022) Status report on the third round\n      of the NIST post-quantum cryptography standardization process (National Institute of\n      Standards and Technology, Gaithersburg, MD), NIST Interagency or Internal Report (IR)\n      8413. https://doi.org/10.6028/NIST.IR.8413-upd1.\n[24]  CRYSTALS-Kyber submission team (2023) â€œDiscussion about Kyberâ€™s tweaked FO transformâ€,\n      PQC-Forum Post. Available at https://groups.google.com/a/list.nist.gov/g/pqc-forum/c/W\n      FRDl8DqYQ4.\n[25]  CRYSTALS-Kyber submission team (2023) â€œKyber decisions, part 2: FO transformâ€, PQC-\n      Forum Post. Available at https://groups.google.com/a/list.nist.gov/g/pqc-forum/c/C0D3W\n      1KoINY/m/99kIvydoAwAJ.\n\n43"
  },
  {
    "doc_id": "NIST.FIPS.203",
    "source_path": "data/raw_pdfs/NIST.FIPS.203.pdf",
    "page_number": 53,
    "text": "FIPS 203                                          MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\n\nAppendix A â€” Precomputed Values for the NTT\n\nThe following 128 numbers are the values of ğœ BitRevâ‚‡(ğ‘–) mod ğ‘ for ğ‘– âˆˆ {0, â€¦ , 127}. These numbers\nare used in Algorithms 9 and 10.\n{ 1     1729    2580    3289    2642    630     1897    848\n\n1062    1919    193     797     2786    3260    569     1746\n\n296     2447    1339    1476    3046     56     2240    1333\n\n1426    2094    535     2882    2393    2879    1974    821\n\n289     331     3253    1756    1197    2304    2277    2055\n\n650     1977    2513    632     2865     33     1320    1915\n\n2319    1435    807     452     1438    2868    1534    2402\n\n2647    2617    1481    648     2474    3110    1227    910\n\n 17     2761    583     2649    1637    723     2288    1100\n\n1409    2662    3281    233     756     2156    3015    3050\n\n1703    1651    2789    1789    1847    952     1461    2687\n\n939     2308    2437    2388    733     2337    268     641\n\n1584    2298    2037    3220    375     2549    2090    1645\n\n1063    319     2773    757     2099    561     2466    2594\n\n2804    1092    403     1026    1143    2150    2775    886\n\n1722    1212    1874    1029    2110    2935    885    2154 }\n\n44"
  },
  {
    "doc_id": "NIST.FIPS.203",
    "source_path": "data/raw_pdfs/NIST.FIPS.203.pdf",
    "page_number": 54,
    "text": "FIPS 203                                        MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\n\nWhen implementing Algorithm 11, the values ğœ 2BitRevâ‚‡(ğ‘–)+1 mod ğ‘ need to be computed. The\nfollowing array contains these values for ğ‘– âˆˆ {0, â€¦ , 127}:\n            { 17     -17       2761     -2761     583      -583      2649     -2649\n\n            1637     -1637     723      -723      2288     -2288     1100     -1100\n\n            1409     -1409     2662     -2662     3281     -3281     233      -233\n\n            756      -756      2156     -2156     3015     -3015     3050     -3050\n\n            1703     -1703     1651     -1651     2789     -2789     1789     -1789\n\n            1847     -1847     952      -952      1461     -1461     2687     -2687\n\n            939      -939      2308     -2308     2437     -2437     2388     -2388\n\n            733      -733      2337     -2337     268      -268      641      -641\n\n            1584     -1584     2298     -2298     2037     -2037     3220     -3220\n\n            375      -375      2549     -2549     2090     -2090     1645     -1645\n\n            1063     -1063     319      -319      2773     -2773     757      -757\n\n            2099     -2099     561      -561      2466     -2466     2594     -2594\n\n            2804     -2804     1092     -1092     403      -403      1026     -1026\n\n            1143     -1143     2150     -2150     2775     -2775     886      -886\n\n            1722     -1722     1212     -1212     1874     -1874     1029     -1029\n\n            2110     -2110     2935     -2935     885      -885      2154     -2154 }\n\n45"
  },
  {
    "doc_id": "NIST.FIPS.203",
    "source_path": "data/raw_pdfs/NIST.FIPS.203.pdf",
    "page_number": 55,
    "text": "FIPS 203                   MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\n\nAppendix B â€” SampleNTT Loop Bounds\n\nIn SampleNTT (Algorithm 7), the algorithm repeatedly generates byte arrays from the XOF to\ncreate an element of ğ‘‡ğ‘ . If a generated byte array value is out of bounds for a coefficient of ğ‘‡ğ‘ ,\nthe algorithm tries again until all 256 coefficients are created. On average, this while loop will\nresolve within a reasonable number of iterations. However, there may be cases in which the\ngenerated byte arrays are consistently out of bounds and the algorithm may run for a higher\nnumber of iterations.\nImplementations should not bound this loop, if at all possible. An incorrect limit will cause\ninteroperability errors, and the chances for SampleNTT to iterate longer become exponentially\nrare. If an implementation does bound the number of iterations of SampleNTT, it shall not use a\nlimit lower than those presented in Table 4. The calculated probability of SampleNTT exceeding\nthe limit is included and calculated under standard assumptions about the output distributions\nof XOFs and hash functions.\n\n            Table 4. While-loop limits and probabilities of occurrence for SampleNTT\n\nNumber of iterations       Probability of reaching limit\n        280                2âˆ’261\n\nIf a limit is used and the number of iterations exceeds the limit, then the algorithm shall destroy\nall intermediate results. If a return value or exception is produced, it shall be the same value for\nany execution in which the maximum number of iterations is exceeded.\n\n46"
  },
  {
    "doc_id": "NIST.FIPS.203",
    "source_path": "data/raw_pdfs/NIST.FIPS.203.pdf",
    "page_number": 56,
    "text": "FIPS 203                                        MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\n\nAppendix C â€” Differences From the CRYSTALS-Kyber Submission\n\n This appendix lists the differences between CRYSTALS-KYBER (as described in [4]) and the ML-KEM\nscheme (specified in this document) that result in differing input-output behavior of the main\nalgorithms (i.e., KeyGen, Encaps, Decaps). Since a conforming implementation need only match\nthe input-output behavior of these three algorithms (see â€œImplementationsâ€ and Section 3.3\nbelow), the list does not include any of the numerous differences in how the main algorithms actu-\nally produce outputs from inputs (e.g., via different computational steps or different subroutines),\nnor any differences in presentation between this standard and [4].\n\nC.1   Differences Between CRYSTALS-Kyber and FIPS 203 Initial Pub-\nlic  Draft\n     â€¢ In the third-round specification [4], the shared secret key was treated as a variable-length\n      value whose length depended on how it would be used in the relevant application. In this\n      specification, the length of the shared secret key is fixed to 256 bits. It can be used directly\n      in applications as a symmetric key, or symmetric keys can be derived from it, as specified\n      in Section 3.3.\n     â€¢ The ML-KEM.Encaps and ML-KEM.Decaps algorithms in this specification use a different\n      variant of the Fujisaki-Okamoto transform (see [24, 25]) than the third-round specifica-\n      tion [4]. Specifically, ML-KEM.Encaps no longer includes a hash of the ciphertext in the\n      derivation of the shared secret, and ML-KEM.Decaps has been adjusted to match this\n      change.\n     â€¢ In the third-round specification [4], the initial randomness ğ‘š in the ML-KEM.Encaps algo-\n      rithm was first hashed before being used. Specifically, between lines 1 and 2 in Algorithm\n      20, there was an additional step that performed the operation ğ‘š â† ğ»(ğ‘š). The purpose\n      of this step was to safeguard against the use of flawed randomness generation processes.\n       As this standard requires the use of NIST-approved randomness generation, this step is\n      unnecessary and is not performed in ML-KEM.\n     â€¢ This specification includes explicit input checking steps that were not part of the third-round\n      specification [4]. For example, ML-KEM.Encaps requires that the byte array containing the\n      encapsulation key correctly decodes to an array of integers modulo ğ‘ without any modular\n      reductions.\n\nC.2   Changes From FIPS 203 Initial Public Draft\n      The differences between CRYSTALS-KYBER and ML-KEM as described in Appendix C were included\nin the initial public draft (ipd) of FIPS 203, which was posted on August 24, 2023.     Based on\ncomments submitted on the draft ML-KEM, domain separation was added to K-PKE.KeyGen to\nprevent the misuse of keys generated to target one security level from being used for a different\nsecurity level when saving a key as a seed.\nAdditionally, FIPS 203 ipd had inadvertently swapped the indices of matrix ğ€ in K-PKE.KeyGen and\nK-PKE.Encrypt. This was changed back in the final version of ML-KEM to match CRYSTALS-KYBER.\n\n                                           47"
  }
]