[
  {
    "doc_id": "NIST.FIPS.204",
    "source_path": "data/raw_pdfs/NIST.FIPS.204.pdf",
    "page_number": 1,
    "text": "  FIPS 204\n\n  Federal Information Processing Standards Publication\n\n  Module-Lattice-Based Digital\n  Signature Standard\n\n  Category: Computer Security                         Subcategory: Cryptography\n\n  Information Technology Laboratory\n  National Institute of Standards and Technology\n  Gaithersburg, MD 20899-8900\n\n  This publication is available free of charge from:\n  https://doi.org/10.6028/NIST.FIPS.204\n\n  Published August 13, 2024\n\n  U.S. Department of Commerce\n  Gina M. Raimondo, Secretary\n\n 0 National Institute of Standards and Technology\n  Laurie E. Locascio, NIST Director and Under Secretary of Commerce for Standards and Technology\n\nCheck\n   for\nupdates"
  },
  {
    "doc_id": "NIST.FIPS.204",
    "source_path": "data/raw_pdfs/NIST.FIPS.204.pdf",
    "page_number": 2,
    "text": "                                                 Foreword\n\n  The Federal Information Processing Standards Publication Series of the National Institute of Standards\nand Technology is the official series of publications relating to standards and guidelines developed under\n    15 U.S.C. 278g-3, and issued by the Secretary of Commerce under 40 U.S.C. 11331.\n   Comments concerning this Federal Information Processing Standard publication are welcomed and should\n  be submitted using the contact information in the â€œInquiries and commentsâ€ clause of the announcement\n    section.\n\n            Kevin M. Stine, Director\n            Information Technology Laboratory"
  },
  {
    "doc_id": "NIST.FIPS.204",
    "source_path": "data/raw_pdfs/NIST.FIPS.204.pdf",
    "page_number": 3,
    "text": "FIPS 204                         MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n\n                                 Abstract\nDigital signatures are used to detect unauthorized modifications to data and to authenticate the identity\nof the signatory. In addition, the recipient of signed data can use a digital signature as evidence in\ndemonstrating to a third party that the signature was, in fact, generated by the claimed signatory. This is\nknown as non-repudiation since the signatory cannot easily repudiate the signature at a later time. This\nstandard specifies ML-DSA, a set of algorithms that can be used to generate and verify digital signatures.\nML-DSA is believed to be secure, even against adversaries in possession of a large-scale quantum computer.\n\nKeywords: cryptography; digital signatures; Federal Information Processing Standards; lattice; post-\nquantum; public-key cryptography."
  },
  {
    "doc_id": "NIST.FIPS.204",
    "source_path": "data/raw_pdfs/NIST.FIPS.204.pdf",
    "page_number": 4,
    "text": "FIPS 204                                           MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n\n            Federal Information Processing Standards Publication 204\n\n       Published:                                  August 13, 2024\n       Effective:                                  August 13, 2024\n\n                            Announcing the\n       Module-Lattice-Based Digital Signature Standard\n\nFederal Information Processing Standards (FIPS) publications are developed by the National Institute of\nStandards and Technology (NIST) under 15 U.S.C. 278g-3 and issued by the Secretary of Commerce under\n40 U.S.C. 11331.\n\n1.     Name of Standard. Module-Lattice-Based Digital Signature Standard (FIPS 204).\n\n2.     Category of Standard. Computer Security. Subcategory. Cryptography.\n\n3.     Explanation. This standard specifies ML-DSA, a lattice-based digital signature algorithm for applications\n       that require a digital signature rather than a written signature. Additional digital signature schemes are\n       specified and approved in other NIST Special Publications and FIPS publications (e.g., FIPS 186-5 [1]).\n       A digital signature is represented in a computer as a string of bits and computed using a set of rules\n       and parameters that allow the identity of the signatory and the integrity of the data to be verified.\n       Digital signatures may be generated on both stored and transmitted data.\n       Signature generation uses a private key to generate a digital signature. Signature verification uses\n       a public key that corresponds to but is not the same as the private key. Each signatory possesses a\n       key-pair composed of a private key and a corresponding public key. Public keys may be known by\n       the public, but private keys must be kept secret. Anyone can verify the signature by employing the\n       signatoryâ€™s public key. Only the user who possesses the private key can generate a signature that can\n       be verified by the corresponding public key.\n       The digital signature is provided to the intended verifier along with the signed data. The verifying\n       entity verifies the signature by using the claimed signatoryâ€™s public key. Similar procedures may be\n       used to generate and verify signatures for both stored and transmitted data.\n       This standard specifies several parameter sets for ML-DSA that are approved for use. Additional\n       parameter sets may be specified and approved in future NIST Special Publications.\n\n4.     Approving Authority. Secretary of Commerce.\n\n5.     Maintenance Agency. Department of Commerce, National Institute of Standards and Technology,\n       Information Technology Laboratory (ITL).\n\n6.     Applicability. This standard is applicable to all federal departments and agencies for the protection of\n       sensitive unclassified information that is not subject to section 2315 of Title 10, United States Code,\n       or section 3502 (2) of Title 44, United States Code. Either this standard, FIPS 205, FIPS 186-5, or NIST\n       Special Publication 800-208 shall be used in designing and implementing public-key-based signature\n       systems that federal departments and agencies operate or that are operated for them under contract.\n       In the future, additional digital signature schemes may be specified and approved in FIPS or NIST\n       Special Publications.\n       The adoption and use of this standard are available to private and commercial organizations.\n                                                   i"
  },
  {
    "doc_id": "NIST.FIPS.204",
    "source_path": "data/raw_pdfs/NIST.FIPS.204.pdf",
    "page_number": 5,
    "text": "FIPS 204    MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n\n7.     Applications. A digital signature algorithm allows an entity to authenticate the integrity of signed\n       data and the identity of the signatory. The recipient of a signed message can use a digital signature as\n       evidence in demonstrating to a third party that the signature was, in fact, generated by the claimed\n       signatory. This is known as non-repudiation since the signatory cannot easily repudiate the signature\n       at a later time. A digital signature algorithm is intended for use in electronic mail, electronic funds\n       transfer, electronic data interchange, software distribution, data storage, and other applications that\n       require data integrity assurance and data origin authentication.\n8.     Implementations. A digital signature algorithm may be implemented in software, firmware, hardware,\n       or any combination thereof.           NIST will develop a validation program to test implementations for\n       conformance to the algorithm in this standard. For every computational procedure that is specified in\n       this standard, a conforming implementation may replace the given set of steps with any mathematically\n       equivalent set of steps. In other words, different procedures that produce the correct output for every\n       input are permitted.\n       Information about validation programs is available at https://csrc.nist.gov/projects/cmvp. Examples\n       for digital signature algorithms are available at https://csrc.nist.gov/projects/cryptographic-standards\n       -and-guidelines/example-values.\n       Agencies are advised that digital signature key pairs shall not be used for other purposes.\n9.     Other Approved Security Functions. Digital signature implementations that comply with this standard\n       shall employ cryptographic algorithms that have been approved for protecting Federal Government-\n       sensitive information. Approved cryptographic algorithms and techniques include those that are\n       either:\n       a.  Specified in a Federal Information Processing Standards (FIPS) publication,\n       b.  Adopted in a FIPS or NIST recommendation, or\n       c.  Specified in the list of approved security functions in SP 800-140C.\n10. Export Control. Certain cryptographic devices and technical data regarding them are subject to federal\n       export controls. Exports of cryptographic modules that implement this standard and technical data\n       regarding them must comply with these federal regulations and be licensed by the Bureau of Industry\n       and Security of the U.S. Department of Commerce. Information about export regulations is available\n       at https://www.bis.doc.gov.\n11. Patents. The algorithm in this standard may be covered by U.S. or foreign patents.\n12. Implementation Schedule. This standard becomes effective immediately upon final publication.\n13. Specifications. Federal Information Processing Standards (FIPS) 204, Module-Lattice-Based Digital\n       Signature Standard (affixed).\n14. Qualifications. The security of a digital signature system depends on maintaining the secrecy of the\n       signatoryâ€™s private keys.    Signatories shall, therefore, guard against the disclosure of their private\n       keys. While it is the intent of this standard to specify general security requirements for generating\n       digital signatures, conformance to this standard does not ensure that a particular implementation is\n       secure. It is the responsibility of an implementer to ensure that any module that implements a digital\n       signature capability is designed and built in a secure manner.\n       Similarly, the use of a product containing an implementation that conforms to this standard does not\n       guarantee the security of the overall system in which the product is used. The responsible authority in\n       each agency or department shall ensure that an overall implementation provides an acceptable level\n       of security.\n                                      ii"
  },
  {
    "doc_id": "NIST.FIPS.204",
    "source_path": "data/raw_pdfs/NIST.FIPS.204.pdf",
    "page_number": 6,
    "text": "FIPS 204    MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n\n Since a standard of this nature must be flexible enough to adapt to advancements and innovations in\n science and technology, this standard will be reviewed every five years in order to assess its adequacy.\n\n15. Waiver Procedure. The Federal Information Security Management Act (FISMA) does not allow for\n waivers to Federal Information Processing Standards (FIPS) that are made mandatory by the Secretary\n of Commerce.\n\n16. Where to Obtain Copies of the Standard. This publication is available by accessing https://csrc.nist.\n gov/publications. Other computer security publications are available at the same website.\n\n17. How to Cite This Publication. NIST has assigned NIST FIPS 204 as the publication identifier for this\n FIPS, per the NIST Technical Series Publication Identifier Syntax. NIST recommends that it be cited as\n follows:\n  National Institute of Standards and Technology (2024) Module-Lattice-Based Digital Signa-\n  ture Standard. (Department of Commerce, Washington, D.C.), Federal Information Pro-\n  cessing Standards Publication (FIPS) NIST FIPS 204. https://doi.org/10.6028/NIST.FIPS.204\n\n18. Inquiries and Comments. Inquiries and comments about this FIPS may be submitted to fips-204-\n comments@nist.gov.\n\niii"
  },
  {
    "doc_id": "NIST.FIPS.204",
    "source_path": "data/raw_pdfs/NIST.FIPS.204.pdf",
    "page_number": 7,
    "text": "    FIPS 204    MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n\nFederal Information Processing Standards Publication 204\n\n                 Specification for the\n    Module-Lattice-Based Digital Signature Standard\n\n                                                Table of Contents\n\n    1  Introduction                                                                                               1\n       1.1     Purpose and Scope      . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     1\n       1.2      Context . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     1\n\n    2  Glossary of Terms, Acronyms, and Symbols                                                                   2\n       2.1     Terms and Definitions    . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     2\n       2.2       Acronyms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     5\n       2.3     Mathematical Symbols       . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     5\n       2.4     Notation   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     7\n               2.4.1     Rings  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     7\n               2.4.2     Vectors and Matrices   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     7\n       2.5     NTT Representation     . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     8\n\n    3  Overview of the ML-DSA Signature Scheme                                                                    9\n       3.1     Security Properties    . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     9\n       3.2     Computational Assumptions        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     9\n       3.3     ML-DSA Construction      . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     9\n       3.4     Hedged and Deterministic Signing       . . . . . . . . . . . . . . . . . . . . . . . . . . . .    11\n       3.5      Use of Digital Signatures . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .    11\n       3.6     Additional Requirements      . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .    12\n               3.6.1     Randomness Generation      . . . . . . . . . . . . . . . . . . . . . . . . . . . . .    12\n               3.6.2     Public-Key and Signature Length Checks . . . . . . . . . . . . . . . . . . . .     .    12\n               3.6.3     Intermediate Values    . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .    12\n               3.6.4     No Floating-Point Arithmetic   . . . . . . . . . . . . . . . . . . . . . . . . . . .    13\n       3.7          Use of Symmetric Cryptography . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .    13\n\n    4  Parameter Sets                                                                                            15\n\n    5  External Functions                                                                                        17\n       5.1          ML-DSA Key Generation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .    17\n       5.2     ML-DSA Signing     . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .    17\n       5.3     ML-DSA Verifying     . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .    18\n                                                      iv"
  },
  {
    "doc_id": "NIST.FIPS.204",
    "source_path": "data/raw_pdfs/NIST.FIPS.204.pdf",
    "page_number": 8,
    "text": "FIPS 204    MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n\n   5.4     Pre-Hash ML-DSA    . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .    18\n           5.4.1  HashML-DSA Signing and Verifying      . . . . . . . . . . . . . . . . . . . . . . . .    19\n6  Internal Functions                                                                                      22\n   6.1     ML-DSA Key Generation (Internal)     . . . . . . . . . . . . . . . . . . . . . . . . . . . .    22\n   6.2     ML-DSA Signing (Internal)  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .    23\n   6.3     ML-DSA Verifying (Internal)  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .    25\n\n7  Auxiliary Functions                                                                                     28\n   7.1     Conversion Between Data Types      . . . . . . . . . . . . . . . . . . . . . . . . . . . . .    28\n   7.2     Encodings of ML-DSA Keys and Signatures      . . . . . . . . . . . . . . . . . . . . . . . .    33\n   7.3     Pseudorandom Sampling      . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .    36\n   7.4     High-Order and Low-Order Bits and Hints      . . . . . . . . . . . . . . . . . . . . . . . .    39\n   7.5     NTT and NTTâˆ’1    . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .    42\n   7.6     Arithmetic Under NTT   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .    45\n\nReferences                                                                                                 47\n\nAppendix A â€” Montgomery Multiplication                                                                     50\n\nAppendix B â€” Zetas Array                                                                                   51\n\nAppendix C â€” Loop Bounds                                                                                   52\n\nAppendix D â€” Differences from the CRYSTALS-DILITHIUM Submission                                            54\n   D.1     Differences Between Version 3.1 and the Round 3 Version of CRYSTALS-DILITHIUM            . .    54\n   D.2     Differences Between Version 3.1 of CRYSTALS-DILITHIUM and FIPS 204 Initial Public Draft         54\n   D.3     Changes From FIPS 204 Initial Public Draft   . . . . . . . . . . . . . . . . . . . . . . . .    54\n\nv"
  },
  {
    "doc_id": "NIST.FIPS.204",
    "source_path": "data/raw_pdfs/NIST.FIPS.204.pdf",
    "page_number": 9,
    "text": "FIPS 204                                               MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n\n                                          List of Tables\n\n Table 1       ML-DSA parameter sets         . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .           15\n Table 2       Sizes (in bytes) of keys and signatures of ML-DSA . . . . . . . . . . . . . .  .  .  .    .           16\n Table 3       While loop and XOF output limits for a 2âˆ’256 or less probability of failure .  .  .  .    .           52\n\n                                       List of Algorithms\nAlgorithm 1      ML-DSA.KeyGen()             . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .           17\nAlgorithm 2      ML-DSA.Sign(ğ‘ ğ‘˜, ğ‘€, ğ‘ğ‘¡ğ‘¥)       . . . . . . . . . . . . . . . . . . . . . . . . . . .           18\nAlgorithm 3      ML-DSA.Verify(ğ‘ğ‘˜, ğ‘€, ğœ, ğ‘ğ‘¡ğ‘¥)     . . . . . . . . . . . . . . . . . . . . . . . . .           18\nAlgorithm 4      HashML-DSA.Sign(ğ‘ ğ‘˜, ğ‘€, ğ‘ğ‘¡ğ‘¥, PH)         . . . . . . . . . . . . . . . . . . . . . .           20\nAlgorithm 5      HashML-DSA.Verify(ğ‘ğ‘˜, ğ‘€, ğœ, ğ‘ğ‘¡ğ‘¥, PH)       . . . . . . . . . . . . . . . . . . . .           21\nAlgorithm 6                  ML-DSA.KeyGen_internal(ğœ‰) . . . . . . . . . . . . . . . . . . . . . . . . . .          23\nAlgorithm 7                  ML-DSA.Sign_internal(ğ‘ ğ‘˜, ğ‘€â€², ğ‘Ÿğ‘›ğ‘‘) . . . . . . . . . . . . . . . . . . . . . .     25\nAlgorithm 8      ML-DSA.Verify_internal(ğ‘ğ‘˜, ğ‘€â€², ğœ)         . . . . . . . . . . . . . . . . . . . . . .           27\nAlgorithm 9      IntegerToBits(ğ‘¥, ğ›¼)       . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .           28\nAlgorithm 10     BitsToInteger(ğ‘¦, ğ›¼)       . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .           28\nAlgorithm 11     IntegerToBytes(ğ‘¥, ğ›¼)        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .           28\nAlgorithm 12     BitsToBytes(ğ‘¦)         . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .           29\nAlgorithm 13     BytesToBits(ğ‘§)         . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .           29\nAlgorithm 14     CoeffFromThreeBytes(ğ‘0, ğ‘1, ğ‘2)        . . . . . . . . . . . . . . . . . . . . . . . .           29\nAlgorithm 15     CoeffFromHalfByte(ğ‘)           . . . . . . . . . . . . . . . . . . . . . . . . . . . . .           30\nAlgorithm 16     SimpleBitPack(ğ‘¤, ğ‘)         . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .           30\nAlgorithm 17     BitPack(ğ‘¤, ğ‘, ğ‘)     . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .           30\nAlgorithm 18     SimpleBitUnpack(ğ‘£, ğ‘)         . . . . . . . . . . . . . . . . . . . . . . . . . . . . .           31\nAlgorithm 19     BitUnpack(ğ‘£, ğ‘, ğ‘)     . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .           31\nAlgorithm 20     HintBitPack(ğ¡)         . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .           32\nAlgorithm 21     HintBitUnpack(ğ‘¦)         . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .           32\nAlgorithm 22     pkEncode(ğœŒ, ğ­1)       . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .           33\nAlgorithm 23     pkDecode(ğ‘ğ‘˜)        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .           33\nAlgorithm 24     skEncode(ğœŒ, ğ¾, ğ‘¡ğ‘Ÿ, ğ¬1, ğ¬2, ğ­0) . . . . . . . . . . . . . . . . . . . . . . . . . .           34\nAlgorithm 25     skDecode(ğ‘ ğ‘˜)        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .           34\nAlgorithm 26     sigEncode(ğ‘, ğ³, ğ¡)     . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .           35\nAlgorithm 27     sigDecode(ğœ)         . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .           35\nAlgorithm 28     w1Encode(ğ°1)           . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .           35\nAlgorithm 29     SampleInBall(ğœŒ)        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .           36\nAlgorithm 30     RejNTTPoly(ğœŒ)          . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .           37\nAlgorithm 31     RejBoundedPoly(ğœŒ)          . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .           37\nAlgorithm 32     ExpandA(ğœŒ)         . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .           38\nAlgorithm 33     ExpandS(ğœŒ)         . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .           38\nAlgorithm 34              ExpandMask(ğœŒ, ğœ‡) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .         38\nAlgorithm 35     Power2Round(ğ‘Ÿ)           . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .           40\nAlgorithm 36              Decompose(ğ‘Ÿ) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .          40\nAlgorithm 37     HighBits(ğ‘Ÿ)        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .           40\nAlgorithm 38            LowBits(ğ‘Ÿ) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .          41\n\n                                                       vi"
  },
  {
    "doc_id": "NIST.FIPS.204",
    "source_path": "data/raw_pdfs/NIST.FIPS.204.pdf",
    "page_number": 10,
    "text": "FIPS 204    MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n\nAlgorithm 39     MakeHint(ğ‘§, ğ‘Ÿ)    . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .       41\nAlgorithm 40     UseHint(â„, ğ‘Ÿ)    . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .       41\nAlgorithm 41     NTT(ğ‘¤)     . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .       43\nAlgorithm 42         NTTâˆ’1(ğ‘¤)Ì‚ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .      44\nAlgorithm 43        BitRev8(ğ‘š) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .      44\nAlgorithm 44     AddNTT(ğ‘,Ì‚ ğ‘)   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .       45\nAlgorithm 45        MultiplyNTT(ğ‘,Ì‚ ğ‘) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     45\nAlgorithm 46          AddVectorNTT(ğ¯,Ì‚ ğ°)Ì‚ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     45\nAlgorithm 47     ScalarVectorNTT(ğ‘,Ì‚ ğ¯)Ì‚   . . . . . . . . . . . . . . . . . . . . . . . . . . . . .       46\nAlgorithm 48            MatrixVectorNTT(ğŒ, ğ¯)Ì‚ . . . . . . . . . . . . . . . . . . . . . . . . . . . .     46\nAlgorithm 49     MontgomeryReduce(ğ‘)        . . . . . . . . . . . . . . . . . . . . . . . . . . . . .       50\n\nvii"
  },
  {
    "doc_id": "NIST.FIPS.204",
    "source_path": "data/raw_pdfs/NIST.FIPS.204.pdf",
    "page_number": 11,
    "text": "FIPS 204                                      MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n\n1.   Introduction\n\n1.1  Purpose and Scope\n  This standard defines a digital signature scheme, which includes a method for digital signature generation\nthat can be used for the protection of binary data (commonly called a â€œmessageâ€) and a method for the\nverification and validation of those digital signatures. NIST Special Publication (SP) 800-175B [2], Guideline\nfor Using Cryptographic Standards in the Federal Government: Cryptographic Mechanisms, includes a\ngeneral discussion of digital signatures.\n    This standard specifies the mathematical steps that need to be performed for key generation, signature\ngeneration, and signature verification. In order for digital signatures to be valid, additional assurances\nare required, such as assurance of identity and of private key possession. SP 800-89, Recommendation\nfor Obtaining Assurances for Digital Signature Applications [3], specifies the required assurances and the\nmethods for obtaining them.\n     The digital signature scheme approved in this standard is the Module-Lattice-Based Digital Signature\n    Algorithm (ML-DSA), which is based on the Module Learning With Errors problem [4]. ML-DSA is believed\nto be secure, even against adversaries in possession of a large-scale fault-tolerant quantum computer. In\nparticular, ML-DSA is believed to be strongly unforgeable, which implies that the scheme can be used to\ndetect unauthorized modifications to data and to authenticate the identity of the signatory (one bound\nto the possession of the private-key).   In addition, a signature generated by this scheme can be used\nas evidence in demonstrating to a third party that the signature was, in fact, generated by the claimed\nsignatory. The latter property is known as non-repudiation since the signatory cannot easily repudiate the\nsignature at a later time.\n  This standard gives algorithms for ML-DSA key generation, signature generation, and signature verification\n    (Section 5), and for supporting algorithms used by them (Section 7). ML-DSA is standardized with three\npossible parameter sets, each of which corresponds to a different security strength. Section 4 describes\nthe global parameters used by these algorithms and enumerates the parameter sets for ML-DSA that are\napproved by this standard. ML-DSA can be used in place of other digital signature schemes specified in\nNIST FIPS and Special Publications (e.g., FIPS 186-5, Digital Signature Standard (DSS) [1]).\n\n1.2  Context\nOver the past several years, there has been steady progress toward building quantum computers. The\nsecurity of many commonly used public-key cryptosystems will be at risk if large-scale quantum computers\nare ever realized. This would include key-establishment schemes and digital signatures that are based on\ninteger factorization and discrete logarithms (both over finite fields and elliptic curves). As a result, in 2016,\nNIST initiated a public Post-Quantum Cryptography (PQC) Standardization process to select quantum-\nresistant public-key cryptographic algorithms for standardization. A total of 82 candidate algorithms were\nsubmitted to NIST for consideration.\nAfter three rounds of evaluation and analysis, NIST selected the first four algorithms for standardization.\nML-DSA is derived from one of the selected schemes, CRYSTALS-DILITHIUM [5, 6], and is intended to protect\nsensitive U.S. Government information well into the foreseeable future, including after the advent of\ncryptographically relevant quantum computers. For the differences between ML-DSA and CRYSTALS-\nDILITHIUM, see Appendix D.\n\n1"
  },
  {
    "doc_id": "NIST.FIPS.204",
    "source_path": "data/raw_pdfs/NIST.FIPS.204.pdf",
    "page_number": 12,
    "text": "FIPS 204                                             MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n\n2.   Glossary of Terms, Acronyms, and Symbols\n\n2.1  Terms and Definitions\n\n approved                    FIPS-approved and/or NIST-recommended. An algorithm or technique that\n                             is either 1) specified in a FIPS or NIST recommendation, 2) adopted in a FIPS\n                             or NIST recommendation, or 3) specified in a list of NIST-approved security\n                             functions.\n\n assurance of                Confidence that an entity possesses a private key and any associated keying\n possession                  material.\n\n asymmetric                  Cryptography that uses two separate keys to exchange data â€” one to encrypt\n cryptography                or digitally sign the data and one to decrypt the data or verify the digital\n                             signature. Also known as public-key cryptography.\n\n bit string                  An ordered sequence of zeros and ones.\n\n byte                        An integer from the set {0, 1, 2, â€¦, 255}.\n\n byte string                 An ordered sequence of bytes.\n\n certificate                 A set of data that uniquely identifies a public key that has a corresponding\n                             private key and an owner that is authorized to use the key pair. The certificate\n                             contains the ownerâ€™s public key and possibly other information and is digitally\n                             signed by a certification authority (i.e., a trusted party), thereby binding the\n                             public key to the owner.\n\n certification authority     The entity in a public-key infrastructure (PKI) that is responsible for issuing\n (CA)                        certificates and exacting compliance with a PKI policy.\n\n claimed signatory           From the verifierâ€™s perspective, the claimed signatory is the entity that pur-\n                             portedly generated a digital signature.\n\n destroy                     An action applied to a key or a piece of secret data. After a key or a piece of\n                             secret data is destroyed, no information about its value can be recovered.\n\n digital signature           The result of a cryptographic transformation of data that, when properly\n                             implemented, provides a mechanism to verify origin authenticity and data\n                             integrity and to enforce signatory non-repudiation.\n\n entity                      An individual person, organization, device, or process. Used interchangeably\n                            with party.\n\n equivalent process          Two processes are equivalent if the same output is produced when the same\n                             values are input to each process (either as input parameters, as values made\n                             available during the process, or both).\n\n eXtendable-Output           A function on bit strings in which the output can be extended to any desired\n Function (XOF)              length. Approved XOFs (e.g., those specified in FIPS 202 [7]) are designed\n                             to satisfy the following properties as long as the specified output length is\n                             sufficiently long to prevent trivial attacks:\n\n                                       2"
  },
  {
    "doc_id": "NIST.FIPS.204",
    "source_path": "data/raw_pdfs/NIST.FIPS.204.pdf",
    "page_number": 13,
    "text": "FIPS 204    MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n\n                          1.  (One-way) It is computationally infeasible to find any input that maps to\n                              any new pre-specified output.\n                          2.  (Collision-resistant) It is computationally infeasible to find any two dis-\n                              tinct inputs that map to the same output.\n\nfresh random value      A previously unused output of a random bit generator.\n\nhash function           A function on bit strings in which the length of the output is fixed. Approved\n                         hash functions (such as those specified in FIPS 180 [8] and FIPS 202 [7]) are\n                         designed to satisfy the following properties:\n                          1.  (One-way) It is computationally infeasible to find any input that maps to\n                              any new pre-specified output.\n                          2.  (Collision-resistant) It is computationally infeasible to find any two dis-\n                              tinct inputs that map to the same output.\n\nhash value               See message digest.\n\nkey                     A parameter used in conjunction with a cryptographic algorithm that deter-\n                         mines its operation. Examples of cryptographic algorithms applicable to this\n                         standard include:\n                          1.  The computation of a digital signature from data\n                          2.  The verification of a digital signature\n\nkey pair                A public key and its corresponding private key.\n\nlittle-endian           The property of a byte string having its bytes positioned in order of increasing\n                         significance. In particular, the leftmost (first) byte is the least significant,\n                         and the rightmost (last) byte is the most significant. The term â€œlittle-endianâ€\n                         may also be applied in the same manner to bit strings (e.g., the 8-bit string\n                        11010001 corresponds to the byte 20 + 21 + 23 + 27 = 139).\n\nmessage                 The data that is signed. Also known as signed data during the signature\n                        verification and validation process.\n\nmessage digest          The result of applying a hash function to a message. Also known as a hash\n                        value.\n\nnon-repudiation         A service that is used to provide assurance of the integrity and origin of data\n                         in such a way that the integrity and origin can be verified and validated by\n                         a third party as having originated from a specific entity in possession of the\n                         private key (i.e., the signatory).\n\nowner                   A key pair owner is the entity authorized to use the private key of a key pair.\n\nparty                   An individual person, organization, device, or process. Used interchangeably\n                        with entity.\n\npublic-key              A framework that is established to issue, maintain, and revoke public key\ninfrastructure (PKI)     certificates.\n\n3"
  },
  {
    "doc_id": "NIST.FIPS.204",
    "source_path": "data/raw_pdfs/NIST.FIPS.204.pdf",
    "page_number": 14,
    "text": "FIPS 204    MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n\nprivate key                A cryptographic key that is used with an asymmetric (public-key) cryptographic\n                           algorithm. The private key is uniquely associated with the owner and is not\n                           made public. The private key is used to compute a digital signature that may\n                           be verified using the corresponding public key.\n\npseudorandom               A process or data produced by a process is said to be pseudorandom when the\n                           outcome is deterministic yet also effectively random as long as the internal\n                           action of the process is hidden from observation. For cryptographic purposes,\n                          â€œeffectively randomâ€ means â€œcomputationally indistinguishable from random\n                           within the limits of the intended security strength.â€\n\npublic key                 A cryptographic key that is used with an asymmetric (public-key) cryptographic\n                           algorithm and is associated with a private key. The public key is associated\n                           with an owner and may be made public. In the case of digital signatures, the\n                           public key is used to verify a digital signature that was generated using the\n                           corresponding private key.\n\nsecurity category          A number associated with the security strength of a post-quantum crypto-\n                           graphic algorithm, as specified by NIST (see [9, Sect. 5.6]).\n\nsecurity strength          A number associated with the amount of work (i.e., the number of operations)\n                           that is required to break a cryptographic algorithm or system.\n\nseed                       A bit string used as input to a pseudorandom process.\n\nshall                      Used to indicate a requirement of this standard.\n\nshould                     Used to indicate a strong recommendation but not a requirement of this\n                           standard. Ignoring the recommendation could lead to undesirable results.\n\nsignatory                  The entity that generates a digital signature on data using a private key.\n\nsignature generation       The process of using a digital signature algorithm and a private key to generate\n                           a digital signature on data.\n\nsignature validation       The mathematical verification of the digital signature along with obtaining the\n                           appropriate assurances (e.g., public-key validity, private-key possession, etc.).\n\nsignature verification     The process of using a digital signature algorithm and a public key to verify a\n                           digital signature on data.\n\nsigned data                The data or message upon which a digital signature has been computed. Also\n                           see message.\n\ntrusted third party        An entity other than the key pair owner and the verifier that is trusted by the\n(TTP)                      owner, the verifier, or both. Sometimes shortened to â€œtrusted party.â€\n\nverifier                   The entity that verifies the authenticity of a digital signature using the public\n                           key of the signatory.\n\n4"
  },
  {
    "doc_id": "NIST.FIPS.204",
    "source_path": "data/raw_pdfs/NIST.FIPS.204.pdf",
    "page_number": 15,
    "text": "FIPS 204                                     MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n\n2.2      Acronyms\n AES             Advanced Encryption Standard\n API             Application Programming Interface\n DER             Distinguished Encoding Rules\n FIPS            Federal Information Processing Standard\n ML-DSA          Module-Lattice-Based Digital Signature Algorithm\n MLWE            Module Learning With Errors\n NIST            National Institute of Standards and Technology\n NIST IR         NIST Interagency or Internal Report\n NTT             Number Theoretic Transform\n OID             Object Identifier\n PQC             Post-Quantum Cryptography\n RBG             Random Bit Generator\n SHA             Secure Hash Algorithm\n SHAKE           Secure Hash Algorithm KECCAK\n SP              Special Publication\n SUF-CMA         Strongly existentially UnForgeable under Chosen Message Attack\n XOF             eXtendable-Output Function\n\n2.3      Mathematical Symbols\nThe following symbols and mathematical expressions are used in this standard.\n\n ğ‘              The prime number ğ‘ = 223 âˆ’ 213 + 1 = 8380417.\n ğ”¹              The set {0, 1, â€¦ , 255} of integers represented by a byte.\n â„•               The set of natural numbers {1, 2, 3, â€¦}.\n â„¤               The ring of integers.\n â„¤ğ‘š             The ring of integers modulo ğ‘š whose set of elements is {0, 1, â€¦ , ğ‘š âˆ’ 1}.\n â„¤ğ‘›             The set of ğ‘›-tuples over â„¤ğ‘š equipped with the â„¤-module structure.\n       ğ‘š\n ğ‘…              The ring of single-variable polynomials over â„¤ modulo ğ‘‹256 + 1, also denoted by\n                 â„¤[ğ‘‹]/(ğ‘‹256 + 1).\n ğ‘…ğ‘š            The ring of single-variable polynomials over â„¤ğ‘š modulo ğ‘‹256 + 1, also denoted by\n                 â„¤ğ‘š[ğ‘‹]/(ğ‘‹256 + 1).\n                                             5"
  },
  {
    "doc_id": "NIST.FIPS.204",
    "source_path": "data/raw_pdfs/NIST.FIPS.204.pdf",
    "page_number": 16,
    "text": "FIPS 204    MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n\nğµğœ            The set of all polynomials ğ‘ = âˆ‘255 ğ‘ğ‘–ğ‘‹ğ‘– in ğ‘…ğ‘ that are such that exactly ğœ of the\n                coefficients of ğ‘ are from the setğ‘–=0       , and all other coefficients are zero. (See\n                Section 7.3.)      ğ‘–           {âˆ’1, 1}\nÎ                Used to denote a direct product of two or more rings, where addition and multipli-\n                cation are performed componentwise.\nğ‘‡ğ‘            The ring Î 255 â„¤ğ‘.\n                          ğ‘—=0\nğ´ Ã— ğµ         Cartesian product of two sets ğ´, ğµ.\n[ğ‘, ğ‘]        For two integers ğ‘ â‰¤ ğ‘, [ğ‘, ğ‘] denotes the set of integers {ğ‘, ğ‘ + 1, â€¦ , ğ‘}.\nbitlen ğ‘       The bit length of a positive integer ğ‘. The bit length of ğ‘ is the number of digits that\n                would appear in a base-2 representation of ğ‘, where the most significant digit in\n                the representation is assumed to be a 1 (e.g., bitlen 32 = 6 and bitlen 31 = 5).1\nBitRev8(ğ‘Ÿ)     Bit reversal of an 8-bit integer ğ‘Ÿ. If ğ‘Ÿ = ğ‘Ÿ0 + 2ğ‘Ÿ1 + 4ğ‘Ÿ2 + â€¦ + 128ğ‘Ÿ7 with ğ‘Ÿğ‘– âˆˆ {0, 1},\n                then BitRev8(ğ‘Ÿ) = ğ‘Ÿ7 + 2ğ‘Ÿ6 + 4ğ‘Ÿ5 + â€¦ + 128ğ‘Ÿ0.\n0x              Prefix to an integer written in hexadecimal representation.\nlog2 ğ‘¥         The base 2 logarithm of ğ‘¥. For example, log2(16) = 4.\n mod            If ğ›¼ is a positive integer and ğ‘š âˆˆ â„¤ or ğ‘š âˆˆ â„¤ğ›¼, then ğ‘š mod ğ›¼ denotes the unique\n                element ğ‘šâ€²    âˆˆ â„¤ in the range 0 â‰¤ ğ‘šâ€² < ğ›¼ such that ğ‘š and ğ‘šâ€² are congruent\n                modulo ğ›¼.\n modÂ±           If ğ›¼ is a positive integer and ğ‘š âˆˆ â„¤ or ğ‘š âˆˆ â„¤ğ›¼, then ğ‘š modÂ±ğ›¼ denotes the unique\n                element ğ‘šâ€² âˆˆ â„¤ in the range âˆ’âŒˆğ›¼/2âŒ‰ < ğ‘šâ€² â‰¤ âŒŠğ›¼/2âŒ‹ such that ğ‘š and ğ‘šâ€² are\n                congruent modulo ğ›¼.\nâŒŠğ‘¥âŒ‹            The largest integer less than or equal to the real number ğ‘¥, called the floor of ğ‘¥. For\n                example, âŒŠ2.1âŒ‹ = 2, and âŒŠ4âŒ‹ = 4.\nâŒˆğ‘¥âŒ‰            The least integer greater than or equal to the real number ğ‘¥, called the ceiling of ğ‘¥.\n                For example, âŒˆ5âŒ‰ = 5 and âŒˆ5.3âŒ‰ = 6.\nâ€–â‹…â€–âˆ            The infinity norm.       For an element ğ‘¤ âˆˆ  â„¤, â€–ğ‘¤â€–âˆ = |ğ‘¤|, the absolute value of\n                ğ‘¤. For an element ğ‘¤ âˆˆ â„¤ğ‘,â€–ğ‘¤â€–âˆ = âˆ£ğ‘¤ modÂ±ğ‘âˆ£ . For an element ğ‘¤ of ğ‘… or ğ‘…ğ‘,\n                â€–ğ‘¤â€–âˆ = max0â‰¤ğ‘–<256 â€–ğ‘¤ğ‘–â€–âˆ . For a length-ğ‘š vector ğ° with entries from ğ‘… or ğ‘…ğ‘,\n                â€–ğ°â€–âˆ = max0â‰¤ğ‘–<ğ‘š â€–ğ‘¤[ğ‘–]â€–âˆ .\nğ‘!             The factorial quantity 1 â‹… 2 â‹… 3 â‹… â€¦ â‹… ğ‘. The value 0! is defined as 1.\n(ğ‘)            For ğ‘ â‰¥ ğ‘, the quantity ğ‘!/(ğ‘!(ğ‘ âˆ’ ğ‘)!).\n ğ‘\nğ‘  â† ğ‘¥         In pseudocode, this notation means that the variable ğ‘  is assigned the value of the\n                expression ğ‘¥.\nğ‘  â† ğ”¹â„“        In pseudocode, this notation means that the variable ğ‘  is assigned the value of an\n                array of â„“ random bytes. The bytes must be generated using randomness from an\n                approved RBG. See Section 3.6.1.\n1In this specification, bitlen ğ‘ is only ever called with a small finite number of values for ğ‘, so it may be helpful to\nprecompute bitlen ğ‘ for these values and hard code the results, rather than computing them on the fly.\n                                         6"
  },
  {
    "doc_id": "NIST.FIPS.204",
    "source_path": "data/raw_pdfs/NIST.FIPS.204.pdf",
    "page_number": 17,
    "text": "FIPS 204    MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n\n   ğ‘¥ âˆˆ ğ‘† â† ğ‘¦        Type casting. The variable ğ‘¥ is assigned a value in a set ğ‘† that is constructed from\n                       the value of an expression ğ‘¦ in a possibly different set ğ‘‡. The set ğ‘‡ and the mapping\n                       from ğ‘‡ to ğ‘† are not explicitly specified, but they should be obvious from the context\n                       in which this statement appears.\n\n   [[ğ‘ < ğ‘]]         A Boolean predicate. A comparison operator inside double square brackets [[ğ‘ < ğ‘]]\n                       denotes that the expression should be evaluated as a Boolean. Booleans can also\n                       be interpreted as elements of â„¤2 with 1 denoting true and 0 denoting false.\n\n   âŸ¨âŸ¨ğ‘“(ğ‘¥)âŸ©âŸ©          A temporary variable that stores the output of a computation ğ‘“(ğ‘¥) so that it can be\n                       used many times without needing to be recomputed. This is equivalent to defining a\n                       temporary variable ğ‘¦ â† ğ‘“(ğ‘¥). Naming the variable âŸ¨âŸ¨ğ‘“(ğ‘¥)âŸ©âŸ© makes the pseudocode\n                       less cluttered.\n\n   ğ‘||ğ‘              Concatenation of two bit or byte strings ğ‘ and ğ‘.\n\n   ğ‘ âˆ˜ ğ‘             Multiplication of ğ‘ and ğ‘ in the ring ğ‘‡ğ‘.\n\n   ğ‘ â‹… ğ‘ or ğ‘ğ‘     Multiplication in any of the rings â„¤, â„¤ğ‘š, ğ‘…, or ğ‘…ğ‘š.\n\n   ğ‘ + ğ‘             Addition of ğ‘ and ğ‘.\n\n   ğ‘/ğ‘               Division of integers. When this notation is used, ğ‘ and ğ‘ are always integers. If ğ‘\n                       cannot be assumed to divide ğ‘, then either âŒŠğ‘/ğ‘âŒ‹ or âŒˆğ‘/ğ‘âŒ‰ is used.\n\n   âŠ¥                   Blank symbol that indicates failure or the lack of an output from an algorithm.\n\n2.4          Notation\n2.4.1         Rings\nElements of the rings â„¤, â„¤ğ‘, â„¤2, ğ‘…, and ğ‘…ğ‘ are denoted by italicized lowercase letters (e.g., ğ‘¤). Elements\nof the ring ğ‘‡ğ‘ are length-256 arrays of elements of â„¤ğ‘, and they are denoted by italicized letters with a\nhat symbol (e.g., ğ‘¤Ì‚). The addition and multiplication of elements of ğ‘‡ğ‘ are performed entry-wise. Thus,\nthe ğ‘–th entry of the product of two elements ğ‘¢Ì‚ and ğ‘£Ì‚ of ğ‘‡ğ‘ is ğ‘¢[ğ‘–] â‹… ğ‘£[ğ‘–] âˆˆ â„¤ğ‘. The multiplication operation\nin ğ‘‡ğ‘ is denoted by the symbol âˆ˜ (see Section 2.3).\nWhen a product ğ‘ â‹… ğ‘ or a sum ğ‘ + ğ‘ is written and either ğ‘ or ğ‘ is a congruence class modulo ğ‘š (i.e., if\neither ğ‘ or ğ‘ is an element of â„¤ğ‘š or ğ‘…ğ‘š), then the product or sum is also understood to be a congruence\nclass modulo ğ‘š (i.e., an element of â„¤ğ‘š or ğ‘…ğ‘š). Likewise, an element of ğ‘… or â„¤ may be â€œtypecastâ€ to an\nelement of ğ‘…ğ‘š or â„¤ğ‘š, respectively, and may be used as the input of a function specified to act on an\nelement of ğ‘…ğ‘š or â„¤ğ‘š, respectively. In both cases, the element itself or its coefficients are mapped from\nâ„¤ to â„¤ğ‘š by taking the unique congruence class modulo ğ‘š that contains the integer.\nThe coefficients of an element ğ‘¤ of ğ‘… or ğ‘…ğ‘š are denoted by ğ‘¤ğ‘– so that ğ‘¤ = ğ‘¤0 + ğ‘¤1ğ‘‹ + â€¦ + ğ‘¤255ğ‘‹255.\nIf ğ‘¤ is in ğ‘… (respectively, ğ‘…ğ‘š) and ğ‘¡ is in â„¤ (respectively, â„¤ğ‘‘), then ğ‘¤(ğ‘¡) denotes the polynomial ğ‘¤ =\nğ‘¤0 + ğ‘¤1ğ‘‹ + â€¦ + ğ‘¤255ğ‘‹255 evaluated at ğ‘‹ = ğ‘¡.\n\n2.4.2         Vectors and Matrices\nVectors with elements in ğ‘… or ğ‘…ğ‘š are denoted by bold lowercase letters (e.g., ğ¯). Matrices with elements\nin ğ‘… or ğ‘…ğ‘š are denoted by bold uppercase letters (e.g., ğ€).\n\n                                                     7"
  },
  {
    "doc_id": "NIST.FIPS.204",
    "source_path": "data/raw_pdfs/NIST.FIPS.204.pdf",
    "page_number": 18,
    "text": "FIPS 204    MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n\nIf ğ‘† is a ring and ğ¯ is a length-ğ¿ vector over ğ‘†, then the entries in the vector ğ¯ are expressed as\n\n                                     ğ‘£[0], ğ‘£[1], â€¦ , ğ‘£[ğ¿ âˆ’ 1].\n\nThe entries of a ğ¾ Ã— ğ¿ matrix ğ€ over ğ‘† are denoted as ğ€[ğ‘–, ğ‘—], where 0 â‰¤ ğ‘– < ğ¾ and 0 â‰¤ ğ‘— < ğ¿.\nThe set of all length-ğ¿ vectors over ğ‘† is denoted by ğ‘†ğ¿. The set of all ğ¾ Ã— ğ¿ matrices over ğ‘† is denoted\nby ğ‘†ğ¾Ã—ğ¿ . A length-ğ¿ vector can also be treated as an ğ¿ Ã— 1 matrix.\n\n2.5  NTT Representation\nThe Number Theoretic Transform (NTT) is a specific isomorphism between the rings ğ‘…ğ‘ and ğ‘‡ğ‘.         Let\nğœ = 1753 âˆˆ â„¤ğ‘, which is a 512th root of unity. If ğ‘¤ âˆˆ ğ‘…ğ‘, then\n\n                     NTT(ğ‘¤) = (ğ‘¤(ğœ0), ğ‘¤(ğœ1), â€¦ , ğ‘¤(ğœ255)) âˆˆ ğ‘‡ğ‘,                                (2.1)\n\nwhere ğœğ‘– = ğ‘¤(ğœ2BitRevâ‚ˆ(ğ‘–)+1) mod ğ‘. See Section 7.5 for an implementation discussion for NTT and NTTâˆ’1.\nThe motivation for using NTT is that multiplication is considerably faster in the ring ğ‘‡ğ‘. Since NTT is an\nisomorphism, for any ğ‘, ğ‘ âˆˆ ğ‘…ğ‘,  NTT(ğ‘ğ‘) = NTT(ğ‘) âˆ˜ NTT(ğ‘).                                     (2.2)\n\nIf ğ€ is a matrix with entries from ğ‘…ğ‘, then NTT(ğ€) denotes the matrix computed via the entry-wise\napplication of NTT to ğ€. The symbol âˆ˜ is also used to denote the matrix multiplication of matrices with\nentries in ğ‘‡ğ‘. Thus, NTT(ğ€ğ) = NTT(ğ€) âˆ˜ NTT(ğ). Explicit algorithms for linear algebra over ğ‘‡ğ‘ are\ngiven in Section 7.6.\n\n8"
  },
  {
    "doc_id": "NIST.FIPS.204",
    "source_path": "data/raw_pdfs/NIST.FIPS.204.pdf",
    "page_number": 19,
    "text": "FIPS 204                                  MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n\n3.           Overview of the ML-DSA Signature Scheme\n\nML-DSA is a digital signature scheme based on CRYSTALS-DILITHIUM [6]. It consists of three main algorithms:\nML-DSA.KeyGen (Algorithm 1), ML-DSA.Sign (Algorithm 2), and ML-DSA.Verify (Algorithm 3). The\nML-DSA scheme uses the Fiat-Shamir With Aborts construction [10, 11] and bears the most resemblance\nto the schemes proposed in [12, 13].\n          This document also defines a closely related but domain-separated signature scheme, HashML-DSA, which\ndiffers from ML-DSA in that it includes an additional pre-hashing step before signing. It consists of three\nmain algorithms: ML-DSA.KeyGen (Algorithm 1), which is the same key generation algorithm used for\nML-DSA; HashML-DSA.Sign (Algorithm 4); and HashML-DSA.Verify (Algorithm 5).\n\n3.1          Security Properties\nML-DSA is designed to be strongly existentially unforgeable under chosen message attack (SUF-CMA).\n        That is, it is expected that even if an adversary can get the honest party to sign arbitrary messages, the\nadversary cannot create any additional valid signatures based on the signerâ€™s public key, including on\nmessages for which the signer has already provided a signature.\nBeyond unforgeability, ML-DSA is designed to satisfy additional security properties described in [14].\n\n3.2          Computational Assumptions\nSecurity for lattice-based digital signature schemes is typically related to the Learning With Errors (LWE)\nproblem and the short integer solution (SIS) problem. The LWE problem [15] is to recover a vector ğ¬ âˆˆ â„¤ğ‘›\ngiven a set of random â€œnoisyâ€ linear equations2 satisfied by . The SIS problem is to find a non-zero  ğ‘\n                                                             ğ¬                                    solution\nğ­ âˆˆ â„¤ğ‘› for a given linear system over â„¤ğ‘ of the form ğ€ğ­ = ğŸ such that â€–ğ­â€–  is small. For appropriate\n       ğ‘                                                          âˆ\nchoices of parameters, these problems are intractable for the best known techniques, including Gaussian\nelimination.\n           When the module â„¤ğ‘› in LWE and SIS is replaced by a module over a ring larger than â„¤ğ‘ (e.g., ğ‘…ğ‘), the\nresulting problems  ğ‘\n                    are called Module Learning With Errors (MLWE) [4] and Module Short Integer Solution\n             (MSIS). The security of ML-DSA is based on the MLWE problem over ğ‘…ğ‘ and a nonstandard variant of\nMSIS called SelfTargetMSIS [16].\n\n3.3          ML-DSA Construction\nML-DSA is a Schnorr-like signature with several optimizations. The Schnorr signature scheme applies the\nFiat-Shamir heuristic to an interactive protocol between a verifier who knows ğ‘” (the generator of a group in\n        which discrete logs are believed to be difficult) and the value ğ‘¦ = ğ‘”ğ‘¥ and a prover who knows ğ‘” and ğ‘¥. The\ninteractive protocol, where the prover demonstrates knowledge of ğ‘¥ to the verifier, consists of three steps:\n\n    1.  Commitment: The prover generates a random positive integer ğ‘Ÿ that is less than the order of ğ‘” and\n        commits to its value by sending ğ‘”ğ‘Ÿ to the verifier.\n\n    2.    Challenge: The verifier sends a random positive integer ğ‘ that is less than the order of ğ‘” to the\n        prover.\n\n2Specifically, the LWE problem is to solve a system of equations of the form ğ€ğ¬ + ğ = ğ‘, where ğ€ and ğ‘ are given\nand ğ is not given but known to be small.\n                                                            9"
  },
  {
    "doc_id": "NIST.FIPS.204",
    "source_path": "data/raw_pdfs/NIST.FIPS.204.pdf",
    "page_number": 20,
    "text": "FIPS 204    MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n\n3.  Response: The prover returns ğ‘  = ğ‘Ÿ âˆ’ ğ‘ğ‘¥ reduced modulo the order of ğ‘”, and the verifier checks\n   whether ğ‘”ğ‘  â‹… ğ‘¦ğ‘ = ğ‘”ğ‘Ÿ.\n\n                                      This protocol is made noninteractive and turned into a signature scheme by replacing the verifierâ€™s random\nchoice of ğ‘ in step 2 with a deterministic process that pseudorandomly derives ğ‘ from a hash of the\ncommitment ğ‘”ğ‘Ÿ concatenated with the message to be signed. For this signature scheme, ğ‘¦ is the public\nkey, and ğ‘¥ is the private key.\n                                          The basic idea of ML-DSA and similar lattice signature schemes is to build a signature scheme from\nan analogous interactive protocol, where a prover who knows matrices ğ€ âˆˆ â„¤ğ¾Ã—ğ¿ , ğ’1 âˆˆ â„¤ğ¿Ã—ğ‘›, and\n    ğ¾Ã—ğ‘› with small coefficients (for          and            ) demonstrates knowledge of  ğ‘    ğ‘\nğ’2 âˆˆ â„¤ğ‘       ğ¾Ã—ğ‘›                       ğ’1      ğ’2                               these matrices to a verifier\nwho knows ğ€ and ğ“ âˆˆ â„¤ğ‘          = ğ€ğ’1 + ğ’2. Such an interactive protocol would proceed as follows:\n\n1.  Commitment: The prover generates ğ² âˆˆ â„¤ğ¿ with small coefficients and commits to its value by\n    sending ğ°  = ğ€ğ² + ğ²                 to the verifier, ğ‘    ğ¾\n             Approx                   2                        where ğ²2 âˆˆ â„¤ğ‘ is a vector with small coefficients.\n2.  Challenge: The verifier sends a vector ğœ âˆˆ â„¤ğ‘› with small coefficients to the prover.\n                                                            ğ‘\n3.  Response: The prover returns ğ³ = ğ² + ğ’1ğœ, and the verifier checks that ğ³ has small coefficients\n    and that ğ€ğ³ âˆ’ ğ“ğœ â‰ˆ ğ°Approx.\n\n                                       As written, the above protocol has a security flaw: the response ğ³ will be biased in a direction related\nto the private value ğ’1. Likewise ğ« = ğ°Approx âˆ’ ğ€ğ³ + ğ“ğœ = ğ²2 + ğ’2ğœ is biased in a direction related\nto the private value ğ’2. However, this flaw can be corrected when converting the interactive protocol\ninto a signature scheme. As with Schnorr signatures, the signer derives the challenge by a pseudorandom\nprocess from a hash of the commitment concatenated with the message. To correct the bias, the signer\napplies rejection sampling to ğ³; if coefficients of ğ³ fall outside of a specified range, the signing process is\naborted, and the signer starts over from a new value of ğ². Likewise, similar rejection sampling must also\nbe applied to ğ«. These checks are analogous to those done at Line 23 of Algorithm 7. In the simplified\nFiat-Shamir With Aborts signature, the public key is (ğ€, ğ“), and the private key is (ğ’1, ğ’2).\nIn the ML-DSA standard, a number of tweaks and modifications are added to this basic framework for\nsecurity or efficiency reasons:\n\n â€¢  To reduce key and signature size and to use fast NTT-based polynomial multiplication, ML-DSA\n    uses module-structured matrices.                      Relative to the basic scheme described above, it replaces\n    dimension-ğ‘› Ã— ğ‘› blocks of matrices and dimension-ğ‘› blocks of vectors with polynomials in the ring\n    ğ‘…ğ‘. Thus, instead of ğ€ âˆˆ â„¤ğ¾Ã—ğ¿ , ğ“ âˆˆ â„¤ğ¾Ã—ğ‘›, ğ’           âˆˆ â„¤ğ¿Ã—ğ‘›, ğ’ âˆˆ â„¤ğ¾Ã—ğ‘›, ğ² âˆˆ â„¤ğ¿, ğœ âˆˆ â„¤ğ‘›, ML-DSA\n                                      ğ‘             ğ‘            1  ğ‘        ğŸ  ğ‘            ğ‘    ğ‘\n    has ğ€ âˆˆ ğ‘…ğ‘˜Ã—â„“, ğ­ âˆˆ ğ‘…ğ‘˜, ğ¬    âˆˆ ğ‘…â„“, ğ¬     âˆˆ ğ‘…ğ‘˜, ğ² âˆˆ ğ‘…â„“, ğ‘ âˆˆ ğ‘…  , where â„“ = ğ¿/ğ‘› and ğ‘˜ = ğ¾/ğ‘›.\n                ğ‘             ğ‘  1        ğ‘   2       ğ‘           ğ‘      ğ‘\n â€¢  To further reduce the size of the public key, the matrix ğ€ is pseudorandomly derived from a 256-bit\n    public seed ğœŒ, which is included in the ML-DSA public key in place of ğ€.\n\n â€¢  For a still further reduction in public key size, the ML-DSA public key substitutes a compressed\n    value ğ­1 for ğ­, which drops the ğ‘‘ low-order bits of each coefficient.\n\n â€¢  To obtain beyond unforgeability (BUFF) properties noted in [14], ML-DSA does not directly sign\n    the message ğ‘€ but rather signs a message representative ğœ‡ that is obtained by hashing the\n    concatenation of a hash of the public key and ğ‘€.\n\n                                                               10"
  },
  {
    "doc_id": "NIST.FIPS.204",
    "source_path": "data/raw_pdfs/NIST.FIPS.204.pdf",
    "page_number": 21,
    "text": "FIPS 204    MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n\n     â€¢  To reduce signature size, rather than including the commitment ğ°Approx = ğ€ğ²+ğ²2 in the signature,\n        the ML-DSA signature uses a rounded version of ğ° = ğ€ğ² as a commitment ğ°1 and includes only\n        the hash ğ‘ of ğ°1||ğœ‡.\n\n     â€¢  To ensure that ğ°1 can be reconstructed by the verifier from ğ³ and the compressed value ğ­1, the\n        signature must also include a hint ğ¡ âˆˆ ğ‘…ğ‘˜ computed by the signer using the signerâ€™s private key.\n                               2\n     â€¢  Additionally, to ensure correctness, a second stage of rejection sampling must be included (Line 28\n        of Algorithm 7)\n\nIn this document, the abbreviations ML-DSA-44, ML-DSA-65, and ML-DSA-87 are used to refer to ML-DSA\n        with the parameter choices given in Table 1. In these abbreviations, the numerical suffix refers to the\ndimension of the matrix ğ€. For example, in ML-DSA-65, the matrix ğ€ is a 6 Ã— 5 matrix over ğ‘…ğ‘.\n\n3.4     Hedged and Deterministic Signing\nFor ML-DSA to be secure, the signerâ€™s commitment value ğ² must not be used to sign more than one\nmessage, and it must not be easily guessed by an attacker. This requires randomness. In principle, the\nrandomness leading to ğ² can be produced either with the use of fresh randomness at signing time or\npseudorandomly from the message being signed and a precomputed random value included in the signerâ€™s\nprivate key.\nBy default, this standard specifies the signing algorithm to use both types of randomness. This is referred\nto as the â€œhedgedâ€ variant of the signing procedure. The use of fresh randomness during signing helps\nmitigate side-channel attacks, while the use of precomputed randomness protects against the possibility\nthat there may be flaws in the random number generator used by the signer at signing time.\n        This document also permits a fully deterministic variant of the signing procedure in case the signer has\nno access to a fresh source of randomness at signing time. However, the lack of randomness in the\ndeterministic variant makes the risk of side-channel attacks (particularly fault attacks) more difficult to\nmitigate. Therefore, this variant should not be used on platforms where side-channel attacks are a concern\nand where they cannot be otherwise mitigated.\nOnly implementing the hedged variant (i.e., without the deterministic variant) is sufficient to guarantee\ninteroperability. The same verification algorithm will work to verify signatures produced by either variant,\nso implementing the deterministic variant in addition to the hedged variant does not enhance interoper-\nability. The hedged and deterministic signing procedure differ only at line 5 of Algorithm 2 and line 5 of\nAlgorithm 4.\n\n3.5     Use of Digital Signatures\nSecure key management is an essential requirement for the use of digital signatures. This is context-\ndependent and involves more than the key generation, signing, and signature verification algorithms in\nthis document. Guidance for key management is provided in the SP 800-57 series [9, 17, 18].\nDigital signatures are most useful when bound to an identity. Binding a public key to an identity requires\nproof of possession of the private key. In the PKI context, issuing certificates involves assurances of identity\nand proof of possession. When a public-key certificate is not available, users of digital signatures should\ndetermine whether a public key needs to be bound to an identity. Methods for obtaining assurances of\nidentity and proof of possession are provided in [3].\n\n                                             11"
  },
  {
    "doc_id": "NIST.FIPS.204",
    "source_path": "data/raw_pdfs/NIST.FIPS.204.pdf",
    "page_number": 22,
    "text": "FIPS 204                                            MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n\n3.6    Additional Requirements\nThis section describes several required assurances when implementing ML-DSA. These are in addition to\nthe considerations in Section 3.5.\n\n3.6.1  Randomness Generation\n     Algorithm 1, implementing key generation for ML-DSA, uses an RBG to generate the 256-bit random seed\nğœ‰. The seed ğœ‰ shall be a fresh (i.e., not previously used) random value generated using an approved RBG,\nas prescribed in SP 800-90A, SP 800-90B, and SP 800-90C [19, 20, 21]. Moreover, the RBG used shall have\na security strength of at least 192 bits for ML-DSA-65 and 256 bits for ML-DSA-87. For ML-DSA-44, the\nRBG should have a security strength of at least 192 bits and shall have a security strength of at least 128\nbits. If an approved RBG with at least 128 bits of security but less than 192 bits of security is used, then\nthe claimed security strength of ML-DSA-44 is reduced from category 2 to category 1.\n    Additionally, the value ğ‘Ÿğ‘›ğ‘‘ is generated using an RBG in the default â€œhedgedâ€ variants of Algorithms 2\nand 4 for ML-DSA and HashML-DSA signing, respectively. While this value should ideally be generated by\nan approved RBG, other methods for generating fresh random values may be used. The primary purpose\nof ğ‘Ÿğ‘›ğ‘‘ is to facilitate countermeasures to side-channel attacks and fault attacks on deterministic signatures,\nsuch as [22, 23, 24].3 For this purpose, even a weak RBG may be preferable to the fully deterministic\nvariants of Algorithms 2 and 4.\n\n3.6.2  Public-Key and Signature Length Checks\n  Algorithm 3, implementing verification for ML-DSA, and Algorithm 5, implementing verification for HashML-\nDSA, specify the length of the signature ğœ and the public key ğ‘ğ‘˜ in terms of the parameters described in\n  Table 1. If an implementation of ML-DSA can accept inputs for ğœ or ğ‘ğ‘˜ of any other length, it shall return\nfalse whenever the lengths of either of these inputs differ from their lengths specified in this standard.\nFailing to check the length of ğ‘ğ‘˜ or ğœ may interfere with the security properties that ML-DSA is designed\nto have, like strong unforgeability.\n\n3.6.3  Intermediate Values\n   The data used internally by the key generation and signing algorithms in intermediate computation steps\ncould be used by an adversary to gain information about the private key and thereby compromise security.\n The data used internally by verification algorithms is similarly sensitive for some applications, including\nthe verification of signatures that are used as bearer tokens (i.e., authentication secrets) or the verification\nof signatures on plaintext messages that are intended to be confidential. Intermediate values of the\n   verification algorithm may reveal information about its inputs (i.e., the message, signature, and public\nkey), and in some applications, security or privacy requires one or more of these inputs to be confidential.\n    Therefore, implementations of ML-DSA shall ensure that any potentially sensitive intermediate data is\ndestroyed as soon as it is no longer needed.\nTwo particular cases in which implementations may refrain from destroying intermediate data are:\n\n 1.    The seed ğœ‰ generated in step 1 of ML-DSA.KeyGen can be stored for the purpose of later expansion\n\n3In addition, when signing is deterministic, there is leakage through timing side channels of information about\n the message but not the private key). If the signer does not want to reveal the message being signed, hedged\n signatures should be used (see Section 3.2 in [6]).\n                                                    12"
  },
  {
    "doc_id": "NIST.FIPS.204",
    "source_path": "data/raw_pdfs/NIST.FIPS.204.pdf",
    "page_number": 23,
    "text": "FIPS 204    MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n\n        using ML-DSA.KeyGen_internal. As the seed can be used to compute the private key, it is sensitive\n        data and shall be treated with the same safeguards as a private key.\n\n2.            The matrix ğ€ generated in step 3 of ML-DSA.KeyGen_internal can be stored so that it need not\n        be recomputed in later operations. Likewise, the matrix ğ€ generated in step 5 of the verification\n        algorithm ML-DSA.Verify_internal can also be stored. In either case, the matrix ğ€ is data that is\n        easily computed from the public key and does not require any special protections.\n\nIn certain situations (e.g., deterministic signing and the verification of confidential messages and signa-\ntures), additional care must be taken to protect implementations against side-channel attacks or fault\nattacks. A cryptographic device may leak critical information through side channels, which allows internal\ndata or keying material to be extracted without breaking the cryptographic primitives.\n\n3.6.4   No Floating-Point Arithmetic\nImplementations of ML-DSA shall not use floating-point arithmetic, as rounding errors in floating point\noperations may lead to incorrect results in some cases. Either âŒŠğ‘¥/ğ‘¦âŒ‹ or âŒˆğ‘¥/ğ‘¦âŒ‰ is used in all pseudocode\nin this standard in which division is performed (e.g., ğ‘¥/ğ‘¦), and ğ‘¦ may not divide ğ‘¥. Both of these can\nbe computed without floating-point arithmetic, as ordinary integer division ğ‘¥/ğ‘¦ computes âŒŠğ‘¥/ğ‘¦âŒ‹, and\nâŒˆğ‘¥/ğ‘¦âŒ‰ = âŒŠ(ğ‘¥ + ğ‘¦ âˆ’ 1)/ğ‘¦âŒ‹ for non-negative integers ğ‘¥ and positive integers ğ‘¦. If ğ‘¦ is a power of two, it\nmay be more efficient to use bit shift operations than integer division.\n\n3.7     Use of Symmetric Cryptography\n            This standard makes use of the functions SHAKE256 and SHAKE128, as defined in FIPS 202 [7]. While FIPS\n202 specifies these functions as inputting and outputting bit strings, most implementations treat inputs\nand outputs as byte strings.\n        This standard will always call these functions with an output length of a multiple of eight bits and treat the\noutput of these functions as a byte string, which will be the same byte string that would result from taking\nthe bit string expected from a literal reading of FIPS 202 and processing it with BitsToBytes. However,\nto allow the signing of messages that are not a whole number of bytes, this document will overload\nSHAKE256 so that its input may be a bit string but will usually be a byte string. The following equivalence\nwill hold for any byte string str and integer â„“ â‰¥ 1:\n\n                                     SHAKE256(str, 8â„“) = SHAKE256(BytesToBits(str), 8â„“).\n\nIn addition to using a mostly byte-oriented variant of the API defined in FIPS 202 for SHAKE256 and\nSHAKE128, this standard sometimes makes use of the incremental API defined in SP 800-185 [25]. This API\nconsists of three functions for each variant of SHAKE. These functions can be used to absorb a sequence\nof arbitrary-length strings and squeeze a sequence of arbitrary-length strings. These functions perform\nbuffering to handle any incomplete data blocks while absorbing or squeezing. For example, for SHAKE256:\n\n     â€¢  ctx â† SHAKE256.Init()\n        Initializes a hash function context.\n\n     â€¢  ctx â† SHAKE256.Absorb(ctx, str)\n        Injects data to be used in the absorbing phase of SHAKE256 and updates context ctx.\n\n13"
  },
  {
    "doc_id": "NIST.FIPS.204",
    "source_path": "data/raw_pdfs/NIST.FIPS.204.pdf",
    "page_number": 24,
    "text": "FIPS 204    MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n\n â€¢   (ctx, out) â† SHAKE256.Squeeze(ctx, 8â„“)\n     Extracts â„“ output bytes produced during the squeezing phase of SHAKE256 and updates context\n     ctx.\n\nWhile the above functions are specified in terms of the Keccak-ğ‘“ permutation rather than the eXtendable-\nOutput Function (XOF), SHAKE256, they are defined so that any series of commands of the following\nform:\n\n 1.  ctx â† SHAKE256.Init()\n\n 2.  For ğ‘– = 1 to ğ‘š: ctx â† SHAKE256.Absorb(ctx, strğ‘–)\n\n 3.  For ğ‘— = 1 to ğ‘˜: (ctx, outğ‘—) â† SHAKE256.Squeeze(ctx, 8ğ‘ğ‘—)\n\n 4.  output â† out1|| â€¦ ||outğ‘˜\n\nwill yield the same output as a single SHAKE256 call:\n\n         output â† SHAKE256(str1|| â€¦ ||strğ‘š, 8ğ‘1 + â€¦ + 8ğ‘ğ‘˜).\n\nThis equivalence holds whether or not |strğ‘–| and ğ‘ğ‘— are multiples of the SHAKE256 block length.\n\nSince all outputs of SHAKE128 and SHAKE256 in this document give a whole number of bytes, the wrapper\nfunctions H and G are defined as follows:\n\n 1.  H(str, â„“) = SHAKE256(str, 8â„“)\n\n 2.  G(str, â„“) = SHAKE128(str, 8â„“)\n\n 3.  H.Init() = SHAKE256.Init()\n\n 4.  G.Init() = SHAKE128.Init()\n\n 5.  H.Absorb(ctx, str) = SHAKE256.Absorb(ctx, str)\n\n 6.  G.Absorb(ctx, str) = SHAKE128.Absorb(ctx, str)\n\n 7.  H.Squeeze(ctx, â„“) = SHAKE256.Squeeze(ctx, 8â„“)\n\n 8.  G.Squeeze(ctx, â„“) = SHAKE128.Squeeze(ctx, 8â„“)\n\nIn addition to SHAKE128 and SHAKE256, HashML-DSA.Sign and HashML-DSA.Verify may call other\napproved hash functions for pre-hashing. The pseudocode in this standard also treats these functions\nas returning a byte string as output while supporting either a bit string or a byte string as input. Here, it\nshould be noted that the hash functions defined in [8] use different rules (i.e., big-endian ordering) to\nrelate bits, bytes, and words.\n\n14"
  },
  {
    "doc_id": "NIST.FIPS.204",
    "source_path": "data/raw_pdfs/NIST.FIPS.204.pdf",
    "page_number": 25,
    "text": "FIPS 204                                            MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n\n4.  Parameter Sets\n\n                              Table 1. ML-DSA parameter sets\n\n                 Parameters                          Values assigned by each parameter set\n(see Sections 6.1 and 6.2 of this document)      ML-DSA-44     ML-DSA-65     ML-DSA-87\n           ğ‘ - modulus [see Â§6.1]                8380417       8380417       8380417\n ğœ - a 512th root of unity in â„¤ğ‘ [see Â§7.5]       1753          1753          1753\n  ğ‘‘ - # of dropped bits from ğ­ [see Â§6.1]          13            13            13\n  ğœ - # of Â±1â€™s in polynomial ğ‘ [see Â§6.2]         39            49            60\n   ğœ† - collision strength of ğ‘ [see Â§6.2]         128           192           256\n\n    ğ›¾ ğ›¾Â¹ - coefficient range of ğ² [see Â§6.2]     2Â¹â·           2Â¹â¹           2Â¹â¹\n    2 - low-order rounding range [see Â§6.2]      (ğ‘ âˆ’ 1)/88  (ğ‘ âˆ’ 1)/32    (ğ‘ âˆ’ 1)/32\n    (ğ‘˜, â„“) - dimensions of ğ€ [see Â§6.1]          (4,4)         (6,5)         (8,7)\n      ğœ‚ - private key range [see Â§6.1]              2             4             2\n            ğ›½ = ğœ â‹… ğœ‚ [see Â§6.2]                  78           196           120\n ğœ” - max # of 1â€™s in the hint ğ¡ [see Â§6.2]         80            55            75\n    Challenge entropy log     (Â²âµâ¶) + ğœ [see Â§6.2]  192          225           257\n            Repetitions (see  2  ğœ\n                              explanation below)    4.25          5.1           3.85\n            Claimed security strength            Category 2    Category 3    Category 5\n\nThree ML-DSA parameter sets are included in Table 1. Each parameter set assigns values for all of the\nparameters used in the ML-DSA algorithms for key generation, signing, and verification. For informational\npurposes, some parameters used in the analysis of these algorithms are also included in the table. In\nparticular, â€œrepetitionsâ€ refers to the expected number of repetitions of the main loop in the signing\nalgorithm from eq. 5 in [5]. The names of the parameter sets are of the form â€œML-DSA-ğ‘˜â„“,â€ where (ğ‘˜, â„“)\nare the dimensions of the matrix ğ€.\nThese parameter sets were designed to meet certain security strength categories defined by NIST in its\noriginal Call for Proposals [26]. These security strength categories are explained further in SP 800-57, Part\n1 [9].\nUsing this approach, security strength is not described by a single number, such as â€œ128 bits of security.â€\nInstead, each ML-DSA parameter set is claimed to be at least as secure as a generic block cipher with a\nprescribed key size or a generic hash function with a prescribed output length. More precisely, it is claimed\nthat the computational resources needed to break ML-DSA are greater than or equal to the computational\nresources needed to break the block cipher or hash function when these computational resources are\nestimated using any realistic model of computation. Different models of computation can be more or less\nrealistic and, accordingly, lead to more or less accurate estimates of security strength. Some commonly\nstudied models are discussed in [27].\nConcretely, the parameter set ML-DSA-44 is claimed to be in security strength category 2, ML-DSA-65 is\nclaimed to be in category 3, and ML-DSA-87 is claimed to be in category 5 [6]. For additional discussion of\nthe security strength of MLWE-based cryptosystems, see [28].\nThe sizes of keys and signatures that correspond to each parameter set are given in Table 2. Certain\noptimizations are possible when storing ML-DSA public and private keys. If additional space is available,\none can precompute and store ğ€ to speed up signing and verifying. Alternatively, if one wants to reduce\n                                     15"
  },
  {
    "doc_id": "NIST.FIPS.204",
    "source_path": "data/raw_pdfs/NIST.FIPS.204.pdf",
    "page_number": 26,
    "text": "FIPS 204    MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n\nthe space needed for the private key, one can store only the 32-byte seed ğœ‰, which is sufficient to generate\nthe other parts of the private key. For additional details, see Section 3.1 in [6].\n\nTable 2. Sizes (in bytes) of keys and signatures of ML-DSA\n\n          Private Key    Public Key  Signature Size\n ML-DSA-44    2560          1312     2420\n ML-DSA-65    4032          1952     3309\n ML-DSA-87    4896          2592     4627\n\n16"
  },
  {
    "doc_id": "NIST.FIPS.204",
    "source_path": "data/raw_pdfs/NIST.FIPS.204.pdf",
    "page_number": 27,
    "text": "    FIPS 204                                             MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n\n    5.   External Functions\n\n    The signing, verifying, and key generation functions can be split into â€œexternalâ€ and â€œinternalâ€ components\n    to simplify APIs and Cryptographic Algorithm Validation Program (CAVP) testing. The external components\n    generate randomness and perform various checks before calling their internal counterparts. The internal\n    components are deterministic and can assume that the external components did not encounter error\n    conditions.\n    The distinction between external and internal functions also simplifies the presentation of algorithms\n    for signing and verification by grouping the operations that are shared between ML-DSA.Sign and\n    HashML-DSA.Sign in ML-DSA.Sign_internal and grouping the operations that are shared between\n    ML-DSA.Verify and HashML-DSA.Verify in ML-DSA.Verify_internal.\n\n    5.1  ML-DSA Key Generation\n    The key generation algorithm ML-DSA.KeyGen takes no input and outputs a public key and a private key,\n    which are both encoded as byte strings.\n    The algorithm uses an approved RBG to generate a 256-bit (32-byte) random seed ğœ‰ that is given as input\n    to ML-DSA.KeyGen_internal (Algorithm 6), which produces the public and private keys.\n\n    Algorithm 1 ML-DSA.KeyGen()\n    Generates a public-private key pair.\n    Output: Public key ğ‘ğ‘˜ âˆˆ ğ”¹32+32ğ‘˜(bitlen (ğ‘âˆ’1)âˆ’ğ‘‘)\n                and private key ğ‘ ğ‘˜ âˆˆ ğ”¹32+32+64+32â‹…((â„“+ğ‘˜)â‹…bitlen (2ğœ‚)+ğ‘‘ğ‘˜).\n     1:  ğœ‰ â† ğ”¹Â³Â²                                                              â–· choose random seed\n     2:  if ğœ‰  = NULL then\n     3:         return âŠ¥                â–· return an error indication if random bit generation failed\n     4:  end if\n     5:  return ML-DSA.KeyGen_internal (ğœ‰)\n\n    5.2  ML-DSA Signing\n    The signing algorithm ML-DSA.Sign (Algorithm 2) takes a private key, a message, and a context string as\n    input4. It outputs a signature that is encoded as a byte string.\n    For the default â€œhedgedâ€ version of ML-DSA signing, the algorithm (at line 5) uses an approved RBG to\n    generate a 256-bit (32-byte) random seed ğ‘Ÿğ‘›ğ‘‘. If the deterministic variant is desired, then ğ‘Ÿğ‘›ğ‘‘ is set\n    to the fixed zero string {0}32.    The value ğ‘Ÿğ‘›ğ‘‘, the private key, and the encoded message are input to\n    ML-DSA.Sign_internal (Algorithm 7), which produces the signature.\n\n4By default, the context is the empty string, though applications may specify the use of a non-empty context string.\n                                                         17"
  },
  {
    "doc_id": "NIST.FIPS.204",
    "source_path": "data/raw_pdfs/NIST.FIPS.204.pdf",
    "page_number": 28,
    "text": "FIPS 204                                            MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n\nAlgorithm 2 ML-DSA.Sign(ğ‘ ğ‘˜, ğ‘€, ğ‘ğ‘¡ğ‘¥)\nGenerates an ML-DSA signature.\nInput: Private key ğ‘ ğ‘˜ âˆˆ ğ”¹32+32+64+32â‹…((â„“+ğ‘˜)â‹…bitlen (2ğœ‚)+ğ‘‘ğ‘˜), message ğ‘€ âˆˆ {0, 1}âˆ—,\ncontext string ğ‘ğ‘¡ğ‘¥ (a byte string of 255 or fewer bytes).\nOutput: Signature ğœ âˆˆ ğ”¹ğœ†/4+â„“â‹…32â‹…(1+bitlen (ğ›¾â‚âˆ’1))+ğœ”+ğ‘˜.\n 1:    if |ğ‘ğ‘¡ğ‘¥| > 255 then\n 2:         return âŠ¥          â–· return an error indication if the context string is too long\n 3:    end if\n 4:\n 5:    ğ‘Ÿğ‘›ğ‘‘ â† ğ”¹Â³Â²         â–· for the optional deterministic variant, substitute ğ‘Ÿğ‘›ğ‘‘ â† {0}Â³Â²\n 6:    if ğ‘Ÿğ‘›ğ‘‘ = NULL then\n 7:         return âŠ¥          â–· return an error indication if random bit generation failed\n 8:    end if\n 9:\n10:    ğ‘€â€² â† BytesToBits(IntegerToBytes(0, 1) âˆ¥ IntegerToBytes(|ğ‘ğ‘¡ğ‘¥|, 1) âˆ¥ ğ‘ğ‘¡ğ‘¥) âˆ¥ ğ‘€\n11:    ğœ â† ML-DSA.Sign_internal(ğ‘ ğ‘˜, ğ‘€â€² , ğ‘Ÿğ‘›ğ‘‘)\n12:    return ğœ\n\n5.3    ML-DSA Verifying\n       The verification algorithm ML-DSA.Verify (Algorithm 3) takes a public key, a message, a signature, and a\ncontext string as input. The public key, signature, and context string are all encoded as byte strings, while\nthe message is a bit string. ML-DSA.Verify outputs a Boolean value that is true if the signature is valid\nwith respect to the message and the public key and false if the signature is invalid. The verification is\naccomplished by calling ML-DSA.Verify_internal (Algorithm 8) with the public key, the encoded message,\nand the signature.\n\nAlgorithm 3 ML-DSA.Verify(ğ‘ğ‘˜, ğ‘€, ğœ, ğ‘ğ‘¡ğ‘¥)\nVerifies a signature ğœ for a message ğ‘€.\nInput: Public key ğ‘ğ‘˜ âˆˆ ğ”¹32+32ğ‘˜(bitlen (ğ‘âˆ’1)âˆ’ğ‘‘), message ğ‘€ âˆˆ {0, 1}âˆ—,\nsignature ğœ âˆˆ ğ”¹ğœ†/4+â„“â‹…32â‹…(1+bitlen (ğ›¾â‚âˆ’1))+ğœ”+ğ‘˜,\ncontext string ğ‘ğ‘¡ğ‘¥ (a byte string of 255 or fewer bytes).\nOutput: Boolean.\n 1:    if |ğ‘ğ‘¡ğ‘¥| > 255 then\n 2:         return âŠ¥          â–· return an error indication if the context string is too long\n 3:    end if\n 4:\n 5:    ğ‘€â€² â† BytesToBits(IntegerToBytes(0, 1) âˆ¥ IntegerToBytes(|ğ‘ğ‘¡ğ‘¥|, 1) âˆ¥ ğ‘ğ‘¡ğ‘¥) âˆ¥ ğ‘€\n 6:    return ML-DSA.Verify_internal(ğ‘ğ‘˜, ğ‘€â€² , ğœ)\n\n5.4    Pre-Hash ML-DSA\nFor some cryptographic modules that generate ML-DSA signatures, hashing the message in step 6 of\nML-DSA.Sign_internal may result in unacceptable performance if the message ğ‘€ is large. For example,\n                                                          18"
  },
  {
    "doc_id": "NIST.FIPS.204",
    "source_path": "data/raw_pdfs/NIST.FIPS.204.pdf",
    "page_number": 29,
    "text": "FIPS 204    MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n\nthe platform may require hardware support for hashing to achieve acceptable performance but lack\nhardware support for SHAKE256 specifically. For some use cases, this may be addressed by signing a\ndigest of the message along with some domain separation information rather than signing the message\ndirectly. This version of ML-DSA is known as â€œpre-hashâ€ ML-DSA or HashML-DSA . In general, the â€œpureâ€\nML-DSA version is preferred.\n While key generation for HashML-DSA is the same as for ML-DSA, it is not the same for the signing algorithm\nHashML-DSA.Sign or the verification algorithm HashML-DSA.Verify. Like ML-DSA, the signing algorithm\nof HashML-DSA takes the content to be signed, the private key, and a context as input, as well as a hash\nfunction or XOF that is to be used to pre-hash the content to be signed. The context string has a maximum\nlength of 255 bytes. By default, the context is the empty string, though applications may specify the use\nof a non-empty context string.\nThe identifier for a signature (e.g., the object identifier [OID]) should indicate whether the signature is a\nML-DSA signature or a pre-hash HashML-DSA signature. In the case of pre-hash signatures, the identifier\nshould also indicate the hash function or XOF used to compute the pre-hash. 5 While a single key pair\nmay be used for both ML-DSA and HashML-DSA signatures, it is recommended that each key pair only\nbe used for one version or the other. If a non-empty context string is to be used, this should either be\nindicated by the signatureâ€™s identifier or by the application with which the signature is being used.\nIf the default â€œhedgedâ€ variant of is used, the 32-byte random value ğ‘Ÿğ‘›ğ‘‘ shall be generated by the\ncryptographic module that generates the signature (i.e., that runs ML-DSA.Sign_internal). However, all\nother steps of signing may be performed outside of the cryptographic module that generates the signature.\nIn the case of pre-hashing, the hash or XOF of the content to be signed must be computed within a FIPS\n     140-validated cryptographic module, but it may be a different cryptographic module than the one that\ngenerates the signature.\nIf the content to be signed is large, hashing of the content is often performed at the application level.\nFor example, in the Cryptographic Message Syntax [29], a digest of the content may be computed, and\nthat digest is signed along with other attributes. If the content is not hashed at the application level, the\npre-hash version of ML-DSA signing may be used.\nIn order to maintain the same level of security strength when the content is hashed at the application level\nor using HashML-DSA , the digest that is signed needs to be generated using an approved hash function\nor XOF (e.g., from FIPS 180 [8] or FIPS 202 [7]) that provides at least ğœ† bits of classical security strength\nagainst both collision and second preimage attacks [7, Table 4].6 The verification of a signature that is\ncreated in this way will require the verify function to generate a digest from the message in the same way\nto be used as input for the verification function.\n\n5.4.1  HashML-DSA Signing and Verifying\nIn the HashML-DSA version, the message input to ML-DSA.Sign_internal is the result of applying either a\nhash function or a XOF to the content to be signed. The output of the hash function or XOF is prepended\nby a one-byte domain separator, one byte that indicates the length of the context string, the context\nstring, and the distinguished encoding rules (DER) encoding of the hash function or XOFâ€™s OID. The domain\nseparator has a value of one for â€œpre-hashâ€ signing. The DER encoding of the OID includes the tag and\nlength.\n\n5In the case of a XOF this would also include the length of the output from the XOF.\n6Obtaining at least ğœ† bits of classical security strength against collision attacks requires that the digest to be signed\nbe at least 2ğœ† bits in length.\n                                                      19"
  },
  {
    "doc_id": "NIST.FIPS.204",
    "source_path": "data/raw_pdfs/NIST.FIPS.204.pdf",
    "page_number": 30,
    "text": "FIPS 204                                  MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n\nAlgorithm 4 shows the DER encodings of the OIDs for SHA-256, SHA-512, and SHAKE128. However, it may\nbe used with other hash functions or XOFs.\n\nAlgorithm 4 HashML-DSA.Sign(ğ‘ ğ‘˜, ğ‘€ , ğ‘ğ‘¡ğ‘¥, PH)\nGenerate a â€œpre-hashâ€ ML-DSA signature.\nInput: Private key ğ‘ ğ‘˜ âˆˆ ğ”¹32+32+64+32â‹…((â„“+ğ‘˜)â‹…bitlen (2ğœ‚)+ğ‘‘ğ‘˜), message ğ‘€ âˆˆ {0, 1}âˆ—,\ncontext string ğ‘ğ‘¡ğ‘¥ (a byte string of 255 or fewer bytes), pre-hash function PH.\nOutput: ML-DSA signature ğœ âˆˆ ğ”¹ğœ†/4+â„“â‹…32â‹…(1+bitlen (ğ›¾â‚âˆ’1))+ğœ”+ğ‘˜.\n 1:    if |ğ‘ğ‘¡ğ‘¥| > 255 then\n 2:     return âŠ¥                  â–· return an error indication if the context string is too long\n 3:    end if\n 4:\n 5:    ğ‘Ÿğ‘›ğ‘‘ â† ğ”¹Â³Â²         â–· for the optional deterministic variant, substitute ğ‘Ÿğ‘›ğ‘‘ â† {0}Â³Â²\n 6:    if ğ‘Ÿğ‘›ğ‘‘ = NULL then\n 7:     return âŠ¥                  â–· return an error indication if random bit generation failed\n 8:    end if\n 9:\n10:    switch PH do\n11:     case SHA-256:\n12:          OID â† 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x01\n                                                                       â–· 2.16.840.1.101.3.4.2.1\n13:          PHğ‘€ â† SHA256(ğ‘€)\n14:     case SHA-512:\n15:          OID â† 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x03\n                                                                       â–· 2.16.840.1.101.3.4.2.3\n16:          PHğ‘€ â† SHA512(ğ‘€)\n17:     case SHAKE128:\n18:          OID â† 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x0B\n                                                                       â–· 2.16.840.1.101.3.4.2.11\n19:          PHğ‘€ â† SHAKE128(ğ‘€, 256)\n20:     case â€¦\n21:          â€¦\n22:    end switch\n23:    ğ‘€â€² â† BytesToBits(IntegerToBytes(1, 1) âˆ¥ IntegerToBytes(|ğ‘ğ‘¡ğ‘¥|, 1) âˆ¥ ğ‘ğ‘¡ğ‘¥ âˆ¥ OID âˆ¥ PHğ‘€)\n       ğœ â† ML-DSA Sign internal          â€²\n24:                     .    _  (ğ‘ ğ‘˜, ğ‘€ , ğ‘Ÿğ‘›ğ‘‘)\n25:    return ğœ\n\nAlgorithm 5 presents the signature verification for HashML-DSA . This function constructs ğ‘€â€² in the same\nway as Algorithm 4 and passes the resulting ğ‘€â€² to Algorithm ML-DSA.Verify_internal for verification. As\nwith the pre-hash signature generation, ğ‘€â€² may be constructed outside of the cryptographic module\nthat performs ML-DSA.Verify_internal. However, in the case of HashML-DSA , the hash or XOF of the\ncontent must be computed within a FIPS 140-validated cryptographic module, which may be a different\ncryptographic module than the one that performs ML-DSA.Verify_internal.\nAs noted in Section 5.4, the identifier associated with the signature should indicate whether ML-DSA or\n                                           20"
  },
  {
    "doc_id": "NIST.FIPS.204",
    "source_path": "data/raw_pdfs/NIST.FIPS.204.pdf",
    "page_number": 31,
    "text": "FIPS 204                                            MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n\nthe pre-hash version HashML-DSA of signature verification should be used, as well as the hash function or\nXOF to be used to compute the pre-hash. A non-empty context string should be used in verification if one\nis specified either in the signatureâ€™s identifier or by the application with which the signature is being used.\n\nAlgorithm 5 HashML-DSA.Verify(ğ‘ğ‘˜, ğ‘€ , ğœ, ğ‘ğ‘¡ğ‘¥, PH)\nVerifies a pre-hash HashML-DSA signature.\nInput: Public key ğ‘ğ‘˜ âˆˆ ğ”¹32+32ğ‘˜(bitlen (ğ‘âˆ’1)âˆ’ğ‘‘), message ğ‘€ âˆˆ {0, 1}âˆ—,\nsignature ğœ âˆˆ ğ”¹ğœ†/4+â„“â‹…32â‹…(1+bitlen (ğ›¾â‚âˆ’1))+ğœ”+ğ‘˜,\ncontext string ğ‘ğ‘¡ğ‘¥ (a byte string of 255 or fewer bytes), pre-hash function PH.\nOutput: Boolean.\n 1:    if |ğ‘ğ‘¡ğ‘¥| > 255 then\n 2:     return false\n 3:    end if\n 4:\n 5:    switch PH do\n 6:     case SHA-256:\n 7:          OID â† 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x01\n                                                                           â–· 2.16.840.1.101.3.4.2.1\n 8:          PHğ‘€ â† SHA256(ğ‘€)\n 9:     case SHA-512:\n10:          OID â† 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x03\n                                                                           â–· 2.16.840.1.101.3.4.2.3\n11:          PHğ‘€ â† SHA512(ğ‘€)\n12:     case SHAKE128:\n13:          OID â† 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x0B\n                                                                           â–· 2.16.840.1.101.3.4.2.11\n14:          PHğ‘€ â† SHAKE128(ğ‘€, 256)\n15:     case â€¦\n16:          â€¦\n17:    end switch\n18:    ğ‘€â€² â† BytesToBits(IntegerToBytes(1, 1) âˆ¥ IntegerToBytes(|ğ‘ğ‘¡ğ‘¥|, 1) âˆ¥ ğ‘ğ‘¡ğ‘¥ âˆ¥ OID âˆ¥ PHğ‘€)\n19:    return ML-DSA.Verify_internal(ğ‘ğ‘˜, ğ‘€â€² , ğœ)\n\n21"
  },
  {
    "doc_id": "NIST.FIPS.204",
    "source_path": "data/raw_pdfs/NIST.FIPS.204.pdf",
    "page_number": 32,
    "text": "FIPS 204                                              MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n\n6.      Internal Functions\n\nThis section describes the functions for ML-DSA key generation, signature generation, and signature\nverification. Where randomness is required, the random values are provided as inputs to the functions.\nThe interfaces specified in this section will be used when testing of ML-DSA implementations is performed\nthrough the CAVP.\nOther than for testing purposes, the interfaces for key generation and signature generation specified\nin this section should not be made available to applications, as any random values required for key\ngeneration and signature generation shall be generated by the cryptographic module. Section 5 provides\nguidance on the interfaces to be made available to applications.7\n\n6.1     ML-DSA Key Generation (Internal)\nThe internal key generation algorithm ML-DSA.KeyGen_internal takes a 32-byte random seed as input\nand outputs a public key and a private key that are both encoded as byte strings.\nThe seed ğœ‰ is expanded as needed using an XOF (i.e., a byte-variant of SHAKE256) denoted by H to produce\nother random values.8 In particular:\n\n     â€¢ A 32-byte public random seed ğœŒ. Using this seed, a polynomial matrix ğ€ âˆˆ ğ‘…ğ‘˜Ã—â„“ is pseudorandomly\n                                                                                  ğ‘\n        sampled9 from ğ‘…ğ‘˜Ã—â„“.\n                       ğ‘\n     â€¢  A 64-byte private random seed ğœŒâ€². Using this seed, the polynomial vectors ğ¬1 âˆˆ ğ‘…â„“ and ğ¬ âˆˆ ğ‘…ğ‘˜\n        are pseudorandomly sampled from the subset of polynomial vectors whose      ğ‘  2                      ğ‘\n                                                                                  coordinate polynomials\n        have short coefficients (i.e., in the range [âˆ’ğœ‚, ğœ‚]).\n     â€¢ A 32-byte private random seed ğ¾ for use during signing.\n\nThe core cryptographic operation computes the public value\n\n                                                      ğ­ = ğ€ğ¬1 + ğ¬2.\n\nThe vector ğ­ together with the matrix ğ€ may be considered an expanded form of the public key. The vector\nğ­ is compressed in the actual public key by dropping the ğ‘‘ least significant bits from each coefficient, thus\nproducing the polynomial vector ğ­1. This compression is an optimization for performance, not security.\nThe low-order bits of ğ­ can be reconstructed from a small number of signatures and, therefore, need not\nbe regarded as secret.\nThe ML-DSA public key ğ‘ğ‘˜ is a byte encoding of the public random seed ğœŒ and the compressed polynomial\nvector ğ­1.\nThe ML-DSA private key ğ‘ ğ‘˜ is a byte encoding of the public random seed ğœŒ, a private random seed ğ¾\nfor use during signing, a 64-byte hash ğ‘¡ğ‘Ÿ of the public key for use during signing, the secret polynomial\n7In some cases, it is permissible to modify the format of the private key in these interfaces (see Sections 4 and 3.6.3.)\n8Single-byte encodings of the parameters ğ‘˜ and â„“ are included in the XOF input for domain separation. For\n implementations that use the seed in place of the private key, this ensures that the expansion will produce an\n unrelated key if the seed is mistakenly expanded using a parameter set other than the one originally intended.\n9More precisely, since only the NTT form of ğ€, ğ€ âˆˆ ğ‘‡ ğ‘˜Ã—â„“ = NTT(ğ€) is needed in subsequent calculations, the\n                                                      ğ‘\n code actually computes ğ€Ì‚ as a pseudorandom sample over ğ‘‡ ğ‘˜Ã—â„“, and the sampling of ğ€ = NTTâˆ’1(ğ€)Ì‚ is only\n implicit (i.e., it could be computed but is not).             ğ‘\n                                                      22"
  },
  {
    "doc_id": "NIST.FIPS.204",
    "source_path": "data/raw_pdfs/NIST.FIPS.204.pdf",
    "page_number": 33,
    "text": "FIPS 204    MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n\nvectors ğ¬1 and ğ¬2, and a polynomial vector ğ­0 encoding the ğ‘‘ least significant bits of each coefficient of\nthe uncompressed public-key polynomial ğ­.\n\nAlgorithm 6 ML-DSA.KeyGen_internal(ğœ‰)\nGenerates a public-private key pair from a seed.\nInput: Seed ğœ‰ âˆˆ ğ”¹Â³Â²\nOutput: Public key ğ‘ğ‘˜ âˆˆ ğ”¹32+32ğ‘˜(bitlen (ğ‘âˆ’1)âˆ’ğ‘‘)\n       and private key ğ‘ ğ‘˜ âˆˆ ğ”¹32+32+64+32â‹…((â„“+ğ‘˜)â‹…bitlen (2ğœ‚)+ğ‘‘ğ‘˜).\n 1:    (ğœŒ, ğœŒâ€² , ğ¾) âˆˆ ğ”¹Â³Â² Ã— ğ”¹â¶â´ Ã— ğ”¹Â³Â² â† H(ğœ‰||IntegerToBytes(ğ‘˜, 1)||IntegerToBytes(â„“, 1), 128)\n 2:                                                                    â–· expand seed\n 3:    ğ€ â† ExpandA(ğœŒ)                    â–· ğ€ is generated and stored in NTT representation as ğ€\n 4:    (ğ¬â‚, ğ¬â‚‚) â† ExpandS(ğœŒâ€² )\n 5:    ğ­ â† NTTâˆ’1 (ğ€ âˆ˜ NTT(ğ¬â‚)) + ğ¬â‚‚                                â–· compute ğ­ = ğ€ğ¬â‚ + ğ¬â‚‚\n 6:    (ğ­â‚, ğ­â‚€) â† Power2Round(ğ­)                                    â–· compress ğ­\n 7:    â–· PowerTwoRound is applied componentwise (see explanatory text in Section 7.4)\n 8:    ğ‘ğ‘˜ â† pkEncode(ğœŒ, ğ­â‚)\n 9:    ğ‘¡ğ‘Ÿ â† H(ğ‘ğ‘˜, 64)\n10:    ğ‘ ğ‘˜ â† skEncode(ğœŒ, ğ¾, ğ‘¡ğ‘Ÿ, ğ¬â‚, ğ¬â‚‚, ğ­â‚€)    â–· ğ¾ and ğ‘¡ğ‘Ÿ are for use in signing\n11:    return (ğ‘ğ‘˜, ğ‘ ğ‘˜)\n\n6.2  ML-DSA Signing (Internal)\nML-DSA.Sign_internal (Algorithm 7) outputs a signature encoded as a byte string. It takes a private\nkey ğ‘ ğ‘˜ encoded as a byte string, a formatted message ğ‘€â€² encoded as a bit string, and a 32-byte string\nğ‘Ÿğ‘›ğ‘‘ as input. There are two ways that a signing algorithm can use ML-DSA.Sign_internal: â€œhedgedâ€\nand â€œdeterministic.â€ The default â€œhedgedâ€ variants of ML-DSA.Sign and HashML-DSA.Sign use a fresh\nrandom value for ğ‘Ÿğ‘›ğ‘‘, while the optional deterministic variants use the constant byte string {0}32 (see\nSection 3).\nIn both variants, the signer first extracts the following from the private key: the public random seed ğœŒ,\nthe 32-byte private random seed ğ¾, the 64-byte hash of the public key ğ‘¡ğ‘Ÿ, the secret polynomial vectors\nğ¬1 and ğ¬2, and the polynomial vector ğ­0 encoding the ğ‘‘ least significant bits of each coefficient of the\nuncompressed public-key polynomial ğ­. ğœŒ is then expanded to the same matrix ğ€ as in key generation.\nBefore the message ğ‘€ is signed, it is concatenated with the public-key hash ğ‘¡ğ‘Ÿ and hashed down to a\n64-byte message representative ğœ‡ using H.\n   The signer produces an additional 64-byte seed ğœŒâ€³ for private randomness during each signing operation.\nğœŒâ€³ is computed as ğœŒâ€³ â† H(ğ¾||ğ‘Ÿğ‘›ğ‘‘||ğœ‡, 64). In the default hedged variant, ğ‘Ÿğ‘›ğ‘‘ is the output of an RBG,\nwhile in the deterministic variant, ğ‘Ÿğ‘›ğ‘‘ is a 32-byte string that consists entirely of zeros. This is the only\ndifference between the deterministic and hedged variant of ML-DSA.Sign.\n The main part of the signing algorithm consists of a rejection sampling loop in which each iteration of the\nloop either produces a valid signature or an invalid signature whose release would leak information about\nthe private key. The loop is repeated until a valid signature is produced, which can then be encoded as a\nbyte string and output.10 The rejection sampling loop follows the Fiat-Shamir With Aborts paradigm [10]\n\n10Implementations may limit the number of iterations in this loop to not exceed a finite maximum value. If this\n                                                      23"
  },
  {
    "doc_id": "NIST.FIPS.204",
    "source_path": "data/raw_pdfs/NIST.FIPS.204.pdf",
    "page_number": 34,
    "text": "FIPS 204    MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n\nand (aside from the rejection step) is similar in structure to Schnorr signatures [30] (e.g., EdDSA [31]). The\nsigner first produces a â€œcommitmentâ€ ğ°1 and then pseudorandomly derives a â€œchallengeâ€ ğ‘ from ğ°1 and\nthe message representative ğœ‡. Finally, the signer computes a response ğ³.\nIn more detail, the main computations involved in the rejection sampling loop are as follows:\n\n â€¢  Using the ExpandMask function (Algorithm 34), the seed ğœŒâ€³, and a counter ğœ…, a polynomial vector\n    ğ² âˆˆ ğ‘…â„“ is pseudorandomly sampled from the subset of polynomial vectors whose coefficients are\n       ğ‘\n    moderately short (i.e., in the range [âˆ’ğ›¾1 + 1, ğ›¾1]).\n\n â€¢  From ğ², the signer computes the commitment ğ°1 by computing ğ° = ğ€ğ² and then rounding to a\n    nearby multiple of 2ğ›¾2 using HighBits (Algorithm 37).\n\nâ€¢   ğ°1 and ğœ‡ are concatenated and hashed to produce the commitment hash ğ‘. This uses the function\n    w1Encode (Algorithm 28). The byte string ğ‘ is used to pseudorandomly sample a polynomial ğ‘ âˆˆ ğ‘…ğ‘\n    that has coefficients in {âˆ’1, 0, 1} and Hamming weight ğœ. The sampling is done with the function\n    SampleInBall (Algorithm 29).11\n\n â€¢  The signer computes the response ğ³ = ğ² + ğ‘ğ¬1 and performs various validity checks. If any of the\n    checks fails, the signer will continue the rejection sampling loop.\n\n â€¢  If the checks pass, the signer can compute a hint polynomial ğ¡, which will allow the verifier to\n    reconstruct ğ°1 using the compressed public key along with the other components of the signature.\n    This uses the function MakeHint (Algorithm 39). The signer will then output the final signature,\n    which is a byte encoding of the commitment hash ğ‘, the response ğ³, and the hint ğ¡.\n\nIn addition, there is an alternative way of implementing the validity checks on ğ³ and the computation of\nğ¡, which is described in Section 5.1 of [6]. This method may also be used in implementations of ML-DSA.\nIn Algorithm 7, variables are sometimes used to store products to avoid recomputing them later in the\nsigning algorithm. These precomputed products are denoted in the pseudocode by a pair of double angle\nbrackets enclosing the variables being multiplied (e.g., âŸ¨âŸ¨ğ‘ğ¬1âŸ©âŸ©).\n\noption is used and the maximum number of iterations is exceeded without producing a valid signature, the signing\nalgorithm shall return a constant that represents an error and no other output, destroying the results of the\nunsuccessful signing attempts. See Appendix C.\n11The length of ğ‘ is determined by the desired security with respect to the â€œmessage-bound signaturesâ€ property\ndescribed in [14]. Here, a length of ğœ†/4 bytes or equivalently 2ğœ† bits is required for ğœ† bits of classical security.\n                                              24"
  },
  {
    "doc_id": "NIST.FIPS.204",
    "source_path": "data/raw_pdfs/NIST.FIPS.204.pdf",
    "page_number": 35,
    "text": "FIPS 204                                             MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n\nAlgorithm 7 ML-DSA.Sign_internal(ğ‘ ğ‘˜, ğ‘€â€² , ğ‘Ÿğ‘›ğ‘‘)\nDeterministic algorithm to generate a signature for a formatted message ğ‘€â€² .\nInput: Private key ğ‘ ğ‘˜ âˆˆ ğ”¹32+32+64+32â‹…((â„“+ğ‘˜)â‹…bitlen (2ğœ‚)+ğ‘‘ğ‘˜), formatted message ğ‘€â€² âˆˆ {0, 1}âˆ—, and\nper message randomness or dummy variable ğ‘Ÿğ‘›ğ‘‘ âˆˆ ğ”¹Â³Â².\nOutput: Signature ğœ âˆˆ ğ”¹ğœ†/4+â„“â‹…32â‹…(1+bitlen (ğ›¾â‚âˆ’1))+ğœ”+ğ‘˜.\n 1:    (ğœŒ, ğ¾, ğ‘¡ğ‘Ÿ, ğ¬â‚, ğ¬â‚‚, ğ­â‚€) â† skDecode(ğ‘ ğ‘˜)\n 2:    ğ¬â‚ â† NTT(ğ¬â‚)\n 3:    ğ¬â‚‚ â† NTT(ğ¬â‚‚)\n 4:    ğ­â‚€ â† NTT(ğ­â‚€)\n 5:    ğ€ â† ExpandA(ğœŒ)                       â–· ğ€ is generated and stored in NTT representation as ğ€\n 6:    ğœ‡ â† H(BytesToBits(ğ‘¡ğ‘Ÿ)||ğ‘€ â€² , 64)          â–· message representative that may optionally be\n       computed in a different cryptographic module\n 7:    ğœŒâ€³ â† H(ğ¾||ğ‘Ÿğ‘›ğ‘‘||ğœ‡, 64)                                        â–· compute private random seed\n 8:    ğœ… â† 0                                                             â–· initialize counter ğœ…\n 9:    (ğ³, ğ¡) â† âŠ¥\n10:    while     (ğ³, ğ¡) = âŠ¥ do                                          â–· rejection sampling loop\n11:     ğ² âˆˆ ğ‘…â„“ â† ExpandMask(ğœŒâ€³ , ğœ…)\n                    ğ‘\n12:     ğ° â† NTTâˆ’1 (ğ€ âˆ˜ NTT(ğ²))\n13:     ğ°â‚ â† HighBits(ğ°)                                                â–· signerâ€™s commitment\n14:                    â–· HighBits is applied componentwise (see explanatory text in Section 7.4)\n15:     ğ‘ â† H(ğœ‡||w1Encode(ğ°â‚), ğœ†/4)                                   â–· commitment hash\n16:     ğ‘ âˆˆ ğ‘…ğ‘ â† SampleInBall(ğ‘)Ìƒ                                     â–· verifierâ€™s challenge\n17:     ğ‘ â† NTT(ğ‘)\n18:     âŸ¨âŸ¨ğ‘ğ¬â‚âŸ©âŸ© â† NTTâˆ’1 (ğ‘ âˆ˜Ì‚ ğ¬â‚)\n19:     âŸ¨âŸ¨ğ‘ğ¬â‚‚âŸ©âŸ© â† NTTâˆ’1 (ğ‘ âˆ˜Ì‚ ğ¬â‚‚)\n20:     ğ³ â† ğ² + âŸ¨âŸ¨ğ‘ğ¬â‚âŸ©âŸ©                                               â–· signerâ€™s response\n21:     ğ«â‚€ â† LowBits(ğ° âˆ’ âŸ¨âŸ¨ğ‘ğ¬â‚‚âŸ©âŸ©)\n22:                    â–· LowBits is applied componentwise (see explanatory text in Section 7.4)\n23:     if   ||ğ³||âˆ â‰¥ ğ›¾â‚ âˆ’ ğ›½ or ||ğ«â‚€||âˆ â‰¥ ğ›¾â‚‚ âˆ’ ğ›½ then (z, h) â† âŠ¥    â–· validity checks\n24:     else\n25:              âŸ¨âŸ¨ğ‘ğ­â‚€âŸ©âŸ© â† NTTâˆ’1 (ğ‘ âˆ˜Ì‚ ğ­â‚€)\n26:              ğ¡ â† MakeHint(âˆ’âŸ¨âŸ¨ğ‘ğ­â‚€âŸ©âŸ©, ğ° âˆ’ âŸ¨âŸ¨ğ‘ğ¬â‚‚âŸ©âŸ© + âŸ¨âŸ¨ğ‘ğ­â‚€âŸ©âŸ©)       â–· Signerâ€™s hint\n27:                    â–· MakeHint is applied componentwise (see explanatory text in Section 7.4)\n28:              if ||âŸ¨âŸ¨ğ‘ğ­â‚€âŸ©âŸ©||âˆ â‰¥ ğ›¾â‚‚ or the number of 1â€™s in ğ¡ is greater than ğœ”, then (z, h) â† âŠ¥\n29:              end if\n30:     end if\n31:     ğœ… â† ğœ… + â„“                                                       â–· increment counter\n32:    end while\n33:    ğœ â† sigEncode(ğ‘, ğ³Ìƒ modÂ±ğ‘, ğ¡)\n34:    return ğœ\n\n6.3    ML-DSA Verifying (Internal)\n                 The algorithm ML-DSA.Verify_internal (Algorithm 8) takes a public key ğ‘ğ‘˜ encoded as a byte string, a\nmessage ğ‘€ encoded as a bit string, and a signature ğœ encoded as a byte string as input. No randomness is\n                                                                  25"
  },
  {
    "doc_id": "NIST.FIPS.204",
    "source_path": "data/raw_pdfs/NIST.FIPS.204.pdf",
    "page_number": 36,
    "text": "FIPS 204    MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n\nrequired for ML-DSA.Verify_internal. It produces a Boolean value (i.e., a value that is true if the signature\nis valid with respect to the message and public key and false if the signature is invalid) as output. Algorithm 8\nspecifies the lengths of the signature ğœ and the public key ğ‘ğ‘˜ in terms of the parameters described in\nTable 1. If an implementation of ML-DSA.Verify_internal can accept inputs for ğœ or ğ‘ğ‘˜ of any other\nlength, it shall return false whenever the length of either of these inputs differs from its specified length.\n    The verifier first extracts the public random seed ğœŒ and the compressed polynomial vector ğ­1 from the\npublic key ğ‘ğ‘˜ and then extracts the signerâ€™s commitment hash ğ‘, response ğ³, and hint ğ¡ from the signature\nğœ. The verifier may find that the hint was not properly byte-encoded, denoted by the symbol â€œâŠ¥,â€ in\nwhich case the verification algorithm will immediately return false to indicate that the signature is invalid.\nAssuming that the signature is successfully extracted from its byte encoding, the verifier pseudorandomly\nderives ğ€ from ğœŒ, as is done in key generation and signing, and creates a message representative ğœ‡ by\nhashing the concatenation of ğ‘¡ğ‘Ÿ (i.e., the hash of the public key ğ‘ğ‘˜) and the message ğ‘€. The verifier\nthen attempts to reconstruct the signerâ€™s commitment (i.e., the polynomial vector ğ°1) from the public\nkey ğ‘ğ‘˜ and the signature ğœ. In ML-DSA.Sign_internal, ğ°1 is computed by rounding ğ° = ğ€ğ². In\nML-DSA.Verify_internal, the reconstructed value of ğ°1 is called ğ°â€²   since it may have been computed in\na different way if the signature is invalid. This ğ°â€² is computed      1\n                                              1                    through the following process:\n\n â€¢     Derive the challenge polynomial ğ‘ from the signerâ€™s commitment hash ğ‘, just as similarly is done in\n       ML-DSA.Sign_internal.\n\n â€¢     Use the signerâ€™s response ğ³ to compute\n\n                                              ğ°â€²     = ğ€ğ³ âˆ’ ğ‘ğ­1 â‹… 2ğ‘‘.\n                                              Approx\n       Assuming the signature was computed correctly, as in ML-DSA.Sign_internal, it follows that\n\n                 ğ° = ğ€ğ² = ğ€ğ³ âˆ’ ğ‘ğ­ + ğ‘ğ¬2 â‰ˆ ğ°â€²                 = ğ€ğ³ âˆ’ ğ‘ğ­1 â‹… 2ğ‘‘\n                                                              Approx\n\n       because ğ‘ and ğ¬2 have small coefficients, and ğ­1 â‹… 2ğ‘‘ â‰ˆ ğ­ .\n\n â€¢     Use the signerâ€™s hint ğ¡ to obtain ğ°â€² from ğ°â€²  .\n                                   1                  Approx\n\nFinally, the verifier checks that the signerâ€™s response ğ³ and the signerâ€™s hint ğ¡ are valid and that the\nreconstructed ğ°â€² is consistent with the signerâ€™s commitment hash ğ‘. More precisely, the verifier checks\nthat all of the  1\n                 coefficients of ğ³ are sufficiently small (i.e., inâ€²the range (âˆ’(ğ›¾1 âˆ’ ğ›½), ğ›¾1 âˆ’ ğ›½)), ğ¡ contains no\nmore than ğœ” nonzero coefficients, and ğ‘ matches the hash ğ‘ of the message representative ğœ‡ concatenated\nwith ğ°â€² (represented as a byte string). If all of these checks succeed, then ML-DSA.Verify_internal returns\ntrue.  1\n       Otherwise, it returns false.\n\n26"
  },
  {
    "doc_id": "NIST.FIPS.204",
    "source_path": "data/raw_pdfs/NIST.FIPS.204.pdf",
    "page_number": 37,
    "text": "FIPS 204                                       MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n\nAlgorithm 8 ML-DSA.Verify_internal(ğ‘ğ‘˜, ğ‘€â€² , ğœ)\nInternal function to verify a signature ğœ for a formatted message ğ‘€â€² .\nInput: Public key ğ‘ğ‘˜ âˆˆ ğ”¹32+32ğ‘˜(bitlen (ğ‘âˆ’1)âˆ’ğ‘‘) and message ğ‘€â€² âˆˆ {0, 1}âˆ—.\nInput: Signature ğœ âˆˆ ğ”¹ğœ†/4+â„“â‹…32â‹…(1+bitlen (ğ›¾â‚âˆ’1))+ğœ”+ğ‘˜.\nOutput: Boolean\n 1:    (ğœŒ, ğ­â‚) â† pkDecode(ğ‘ğ‘˜)\n 2:    (ğ‘, ğ³, ğ¡) â† sigDecode(ğœ)            â–· signerâ€™s commitment hash ğ‘, response ğ³, and hint ğ¡\n 3:    if ğ¡ = âŠ¥ then return false                         â–· hint was not properly encoded\n 4:    end if\n 5:    ğ€ â† ExpandA(ğœŒ)                 â–· ğ€ is generated and stored in NTT representation as ğ€\n 6:    ğ‘¡ğ‘Ÿ â† H(ğ‘ğ‘˜, 64)\n 7:    ğœ‡ â† (H(BytesToBits(ğ‘¡ğ‘Ÿ)||ğ‘€ â€² , 64))  â–· message representative that may optionally be\n       computed in a different cryptographic module\n 8:    ğ‘ âˆˆ ğ‘…ğ‘ â† SampleInBall(ğ‘)Ìƒ                       â–· compute verifierâ€™s challenge from ğ‘\n 9:    ğ°â€²   â† NTTâˆ’1 (ğ€ âˆ˜ NTT(ğ³) âˆ’ NTT(ğ‘) âˆ˜ NTT(ğ­      â‹… 2ğ‘‘))  â–· ğ°â€²      = ğ€ğ³ âˆ’ ğ‘ğ­ â‹… 2ğ‘‘\n           Approx                                          1            Approx    1\n10:    ğ°â€² â† UseHint(ğ¡, ğ°â€²           )                   â–· reconstruction of signerâ€™s commitment\n           1             â–· Approx\n11:                        UseHint is applied componentwise (see explanatory text in Section 7.4)\n12:    ğ‘â€²  â† H(ğœ‡||w1Encode(ğ°â€² ), ğœ†/4)                           â–· hash it; this should match ğ‘\n       return [[ ||ğ³||  < ğ›¾ âˆ’ 1              â€²\n13:                  âˆ        1  ğ›½]] and [[ğ‘ = ğ‘ ]]\n\n27"
  },
  {
    "doc_id": "NIST.FIPS.204",
    "source_path": "data/raw_pdfs/NIST.FIPS.204.pdf",
    "page_number": 38,
    "text": "FIPS 204                              MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n\n7.     Auxiliary Functions\n\nThis section provides pseudocode for subroutines utilized by ML-DSA, including functions for data-type\nconversions, arithmetic, and sampling.\n\n7.1    Conversion Between Data Types\nWhile the primary data type in ML-DSA is a byte string, other data types are used as well. The goal in\nthis section is to construct procedures for translating between the various algebraic objects defined in\nSection 2.3. Algorithms 9â€“13 are intermediate procedures for converting between bit strings, byte strings,\nand integers.\n\nAlgorithm 9 IntegerToBits(ğ‘¥, ğ›¼)\nComputes a base-2 representation of ğ‘¥ mod 2ğ›¼ using little-endian order.\nInput: A nonnegative integer ğ‘¥ and a positive integer ğ›¼.\nOutput: A bit string ğ‘¦ of length ğ›¼.\n 1:    ğ‘¥â€² â† ğ‘¥\n 2:    for ğ‘– from 0 to ğ›¼ âˆ’ 1 do\n 3:     ğ‘¦[ğ‘–] â† ğ‘¥â€² mod 2\n 4:     ğ‘¥â€² â† âŒŠğ‘¥â€² /2âŒ‹\n 5:    end for\n 6:    return ğ‘¦\n\nAlgorithm 10 BitsToInteger(ğ‘¦, ğ›¼)\nComputes the integer value expressed by a bit string using little-endian order.\nInput: A positive integer ğ›¼ and a bit string ğ‘¦ of length ğ›¼.\nOutput: A nonnegative integer ğ‘¥.\n 1:    ğ‘¥ â† 0\n 2:    for ğ‘– from 1 to ğ›¼ do\n 3:     ğ‘¥ â† 2ğ‘¥ + ğ‘¦[ğ›¼ âˆ’ ğ‘–]\n 4:    end for\n 5:    return ğ‘¥\n\nAlgorithm 11 IntegerToBytes(ğ‘¥, ğ›¼)\nComputes a base-256 representation of ğ‘¥ mod 256ğ›¼ using little-endian order.\nInput: A nonnegative integer ğ‘¥ and a positive integer ğ›¼.\nOutput: A byte string ğ‘¦ of length ğ›¼.\n 1:    ğ‘¥â€² â† ğ‘¥\n 2:    for ğ‘– from 0 to ğ›¼ âˆ’ 1 do\n 3:     ğ‘¦[ğ‘–] â† ğ‘¥â€² mod 256\n 4:     ğ‘¥â€² â† âŒŠğ‘¥â€² /256âŒ‹\n 5:    end for\n 6:    return ğ‘¦\n\n                                      28"
  },
  {
    "doc_id": "NIST.FIPS.204",
    "source_path": "data/raw_pdfs/NIST.FIPS.204.pdf",
    "page_number": 39,
    "text": "FIPS 204                                                  MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n\nAlgorithm 12 BitsToBytes(ğ‘¦)\nConverts a bit string into a byte string using little-endian order.\nInput: A bit string ğ‘¦ of length ğ›¼.\nOutput: A byte string ğ‘§ of length âŒˆğ›¼/8âŒ‰.\n 1:    ğ‘§ âˆˆ ğ”¹âŒˆğ›¼/8âŒ‰ â† 0âŒˆğ›¼/8âŒ‰\n 2:    for ğ‘– from 0 to ğ›¼ âˆ’ 1 do\n 3:         ğ‘§ [âŒŠğ‘–/8âŒ‹] â† ğ‘§ [âŒŠğ‘–/8âŒ‹] + ğ‘¦[ğ‘–] â‹… 2ğ‘– mod 8\n 4:    end for\n 5:    return ğ‘§\n\nAlgorithm 13 BytesToBits(ğ‘§)\nConverts a byte string into a bit string using little-endian order.\nInput: A byte string ğ‘§ of length ğ›¼.\nOutput: A bit string ğ‘¦ of length 8ğ›¼.\n 1:    ğ‘§â€² â† ğ‘§\n 2:    for ğ‘– from 0 to ğ›¼ âˆ’ 1 do\n 3:        for ğ‘— from 0 to 7 do                          â–· convert the byte ğ‘§[ğ‘–] into 8 bits\n 4:             ğ‘¦[8ğ‘– + ğ‘—] â† ğ‘§â€² [ğ‘–] mod 2\n 5:             ğ‘§â€² [ğ‘–] â† âŒŠğ‘§â€² [ğ‘–]/2âŒ‹\n 6:        end for\n 7:    end for\n 8:    return ğ‘¦\n\nAlgorithms 14 and 15 translate byte strings into coefficients of polynomials in ğ‘…. CoeffFromThreeBytes\nuses a 3-byte string to either generate an element of {0, 1, â€¦ , ğ‘ âˆ’ 1} or return the blank symbol âŠ¥.\nCoeffFromHalfByte uses an element of {0, 1, â€¦ , 15} to either generate an element of {âˆ’ğœ‚, âˆ’ğœ‚+1, â€¦ , ğœ‚}\nor return âŠ¥. These two procedures will be used in the uniform sampling algorithms RejNTTPoly and\nRejBoundedPoly, which are discussed in Section 7.3.\n\nAlgorithm 14 CoeffFromThreeBytes(ğ‘â‚€, ğ‘â‚, ğ‘â‚‚)\nGenerates an element of {0, 1, 2, â€¦ , ğ‘ âˆ’ 1} âˆª {âŠ¥}.\nInput: Bytes ğ‘â‚€, ğ‘â‚, ğ‘â‚‚.\nOutput: An integer modulo ğ‘ or âŠ¥.\n 1:    ğ‘â€² â† ğ‘â‚‚\n       2 â€²\n 2:    if ğ‘â‚‚ > 127 then\n 3:         ğ‘â€² â† ğ‘â€² âˆ’ 128                                        â–· set the top bit of ğ‘â€²       to zero\n       end 2       2                                               2\n 4:         if\n 5:    ğ‘§ â† 2Â¹â¶ â‹… ğ‘â€²   + 2â¸ â‹… ğ‘â‚ + ğ‘â‚€                                                â–· 0 â‰¤ ğ‘§ â‰¤ 2Â²Â³ âˆ’ 1\n       if ğ‘§ < ğ‘  2\n 6:                then return ğ‘§                                                    â–· rejection sampling\n 7:    else return âŠ¥\n 8:    end if\n\n                                                          29"
  },
  {
    "doc_id": "NIST.FIPS.204",
    "source_path": "data/raw_pdfs/NIST.FIPS.204.pdf",
    "page_number": 40,
    "text": "FIPS 204                                           MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n\nAlgorithm 15 CoeffFromHalfByte(ğ‘)\nLet ğœ‚ âˆˆ {2, 4}. Generates an element of {âˆ’ğœ‚, âˆ’ğœ‚ + 1, â€¦ , ğœ‚} âˆª {âŠ¥}.\nInput: Integer ğ‘ âˆˆ {0, 1, â€¦ , 15}.\nOutput: An integer between âˆ’ğœ‚ and ğœ‚, or âŠ¥.\n 1:    if ğœ‚ = 2  and ğ‘ < 15 then return 2 âˆ’ (ğ‘ mod 5)      â–· rejection sampling from {âˆ’2, â€¦ , 2}\n 2:    else\n 3:     if ğœ‚ = 4 and ğ‘ < 9 then return 4 âˆ’ ğ‘               â–· rejection sampling from {âˆ’4, â€¦ , 4}\n 4:     else      return âŠ¥\n 5:     end if\n 6:    end if\n\nAlgorithms 16â€“19 efficiently translate an element ğ‘¤ âˆˆ    ğ‘… into a byte string and vice versa under the\nassumption that the coefficients of ğ‘¤ are in a restricted range. SimpleBitPack assumes that ğ‘¤ğ‘– âˆˆ [0, ğ‘]\nfor some positive integer ğ‘ and packs ğ‘¤ into a byte string of length 32 â‹… bitlen ğ‘. BitPack allows for the\nmore general restriction ğ‘¤ğ‘– âˆˆ [âˆ’ğ‘, ğ‘]. The BitPack algorithm works by merely subtracting ğ‘¤ from the\npolynomial âˆ‘255 ğ‘ğ‘‹ğ‘–.\n                  ğ‘–=0\n\nAlgorithm 16 SimpleBitPack(ğ‘¤, ğ‘)\nEncodes a polynomial ğ‘¤ into a byte string.\nInput: ğ‘ âˆˆ â„• and ğ‘¤ âˆˆ ğ‘… such that the coefficients of ğ‘¤ are all in [0, ğ‘].\nOutput: A byte string of length 32 â‹… bitlen ğ‘.\n 1:    ğ‘§ â† ()                                                â–· set ğ‘§ to the empty bit string\n 2:    for ğ‘– from 0 to 255 do\n 3:    endğ‘§ â† ğ‘§||IntegerToBits(ğ‘¤ğ‘– , bitlen ğ‘)\n 4:         for\n 5:    return BitsToBytes(ğ‘§)\n\nAlgorithm 17 BitPack(ğ‘¤, ğ‘, ğ‘)\nEncodes a polynomial ğ‘¤ into a byte string.\nInput: ğ‘, ğ‘ âˆˆ â„• and ğ‘¤ âˆˆ ğ‘… such that the coefficients of ğ‘¤ are all in [âˆ’ğ‘, ğ‘].\nOutput: A byte string of length 32 â‹… bitlen (ğ‘ + ğ‘).\n 1:    ğ‘§ â† ()                                                â–· set ğ‘§ to the empty bit string\n 2:    for ğ‘– from 0 to 255 do\n 3:    endğ‘§ â† ğ‘§||IntegerToBits(ğ‘ âˆ’ ğ‘¤ğ‘– , bitlen (ğ‘ + ğ‘))\n 4:         for\n 5:    return BitsToBytes(ğ‘§)\n\nSimpleBitUnpack and BitUnpack are used to decode the byte strings produced by the above functions.\nFor some choices of ğ‘ and ğ‘, there exist malformed byte strings that will cause SimpleBitUnpack and\nBitUnpack to output polynomials whose coefficients are not in the ranges [0, ğ‘] and [âˆ’ğ‘, ğ‘], respectively.\n        This can be a concern when running SimpleBitUnpack and BitUnpack on inputs that may come from an\nuntrusted source.\n                                                       30"
  },
  {
    "doc_id": "NIST.FIPS.204",
    "source_path": "data/raw_pdfs/NIST.FIPS.204.pdf",
    "page_number": 41,
    "text": "FIPS 204                             MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n\nAlgorithm 18 SimpleBitUnpack(ğ‘£, ğ‘)\nReverses the procedure SimpleBitPack.\nInput: ğ‘ âˆˆ â„• and a byte string ğ‘£ of length 32 â‹… bitlen ğ‘.\nOutput: A polynomial ğ‘¤ âˆˆ ğ‘… with coefficients in [0, 2ğ‘ âˆ’ 1], where ğ‘ = bitlen ğ‘.\nWhen ğ‘ + 1 is a power of 2, the coefficients are in [0, ğ‘].\n 1:  ğ‘ â† bitlen ğ‘\n 2:  ğ‘§ â† BytesToBits(ğ‘£)\n 3:  for ğ‘– from 0 to 255 do\n 4:  endğ‘¤ğ‘– â† BitsToInteger((ğ‘§[ğ‘–ğ‘], ğ‘§[ğ‘–ğ‘ + 1], â€¦ ğ‘§[ğ‘–ğ‘ + ğ‘ âˆ’ 1]), ğ‘)\n 5:         for\n 6:  return ğ‘¤\n\nAlgorithm 19 BitUnpack(ğ‘£, ğ‘, ğ‘)\nReverses the procedure BitPack.\nInput: ğ‘, ğ‘ âˆˆ â„• and a byte string ğ‘£ of length 32 â‹… bitlen (ğ‘ + ğ‘).\nOutput: A polynomial ğ‘¤ âˆˆ ğ‘… with coefficients in [ğ‘ âˆ’ 2ğ‘ + 1, ğ‘], where ğ‘ = bitlen (ğ‘ + ğ‘).\nWhen ğ‘ + ğ‘ + 1 is a power of 2, the coefficients are in [âˆ’ğ‘, ğ‘].\n 1:  ğ‘ â† bitlen (ğ‘ + ğ‘)\n 2:  ğ‘§ â† BytesToBits(ğ‘£)\n 3:  for ğ‘– from 0 to 255 do\n 4:  endğ‘¤ğ‘– â† ğ‘ âˆ’ BitsToInteger((ğ‘§[ğ‘–ğ‘], ğ‘§[ğ‘–ğ‘ + 1], â€¦ ğ‘§[ğ‘–ğ‘ + ğ‘ âˆ’ 1]), ğ‘)\n 5:         for\n 6:  return ğ‘¤\n\nAlgorithms 20 and 21 carry out byte-string-to-polynomial conversions for polynomials with sparse binary\ncoefficients. In particular, the signing and verification algorithms (Sections 6.2 and 6.3) make use of a â€œhint,â€\nwhich is a vector of polynomials ğ¡ âˆˆ ğ‘…ğ‘˜ such that the total number of coefficients in ğ¡[0], ğ¡[1], â€¦ , ğ¡[ğ‘˜âˆ’1]\nthat are equal to  is no more than  . 2\n                   1                ğœ” This constraint enables encoding and decoding procedures that are\nmore efficient (although more complex) than BitPack and BitUnpack.\nHintBitPack (ğ¡) outputs a byte string ğ‘¦ of length ğœ” + ğ‘˜. The last ğ‘˜ bytes of ğ‘¦ contain information about\nhow many nonzero coefficients are present in each of the polynomials ğ¡[0], ğ¡[1], â€¦ , ğ¡[ğ‘˜ âˆ’ 1], and the\nfirst ğœ” bytes of ğ‘¦ contain information about exactly where those nonzero terms occur. HintBitUnpack\nreverses the procedure performed by HintBitPack and recovers the vector ğ¡.\n\n31"
  },
  {
    "doc_id": "NIST.FIPS.204",
    "source_path": "data/raw_pdfs/NIST.FIPS.204.pdf",
    "page_number": 42,
    "text": "FIPS 204    MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n\nAlgorithm 20 HintBitPack(ğ¡)\nEncodes a polynomial vector ğ¡ with binary coefficients into a byte string.\nInput: A polynomial vector ğ¡         âˆˆ ğ‘…ğ‘˜ such that the polynomials ğ¡[0], ğ¡[1],...,ğ¡[ğ‘˜ âˆ’ 1] have\ncollectively at most ğœ” nonzero          2\n                                      coefficients.\nOutput: A byte string ğ‘¦ of length ğœ” + ğ‘˜ that encodes ğ¡ as described above.\n 1:    ğ‘¦ âˆˆ ğ”¹ğœ”+ğ‘˜ â† 0ğœ”+ğ‘˜\n 2:    Index â† 0                                   â–· Index for writing the first ğœ” bytes of ğ‘¦\n 3:    for ğ‘– from 0 to ğ‘˜ âˆ’ 1 do                                             â–· look at ğ¡[ğ‘–]\n 4:     for ğ‘— from 0 to 255 do\n 5:      if ğ¡[ğ‘–]ğ‘— â‰  0    then\n 6:                 ğ‘¦[Index] â† ğ‘—        â–· store the locations of the nonzero coefficients in ğ¡[ğ‘–]\n 7:                 Index â† Index + 1\n 8:      end if\n 9:     end for\n10:     ğ‘¦[ğœ” + ğ‘–] â† Index                        â–· after processing ğ¡[ğ‘–], store the value of Index\n11:    end for\n12:    return ğ‘¦\n\nAlgorithm 21 HintBitUnpack(ğ‘¦)\nReverses the procedure HintBitPack.\nInput: A byte string ğ‘¦ of length ğœ” + ğ‘˜ that encodes ğ¡ as described above.\nOutput: A polynomial vector ğ¡ âˆˆ ğ‘…ğ‘˜ or âŠ¥.\n                                         2\n 1:    ğ¡ âˆˆ ğ‘…ğ‘˜ â† 0ğ‘˜\n       Index 2\n 2:     â† 0                                        â–· Index for reading the first ğœ” bytes of ğ‘¦\n 3:    for ğ‘– from 0 to ğ‘˜ âˆ’ 1 do                                             â–· reconstruct ğ¡[ğ‘–]\n 4:     if ğ‘¦[ğœ” + ğ‘–] < Index or ğ‘¦[ğœ” + ğ‘–] > ğœ” then return âŠ¥             â–· malformed input\n 5:     end if\n 6:     First â† Index\n 7:     while Index < ğ‘¦[ğœ” + ğ‘–] do               â–· ğ‘¦[ğœ” + ğ‘–] says how far one can advance Index\n 8:      if Index > First      then\n 9:                 if ğ‘¦[Index âˆ’ 1] â‰¥ ğ‘¦[Index] then return âŠ¥               â–· malformed input\n10:                 end if\n11:      end if\n12:      ğ¡[ğ‘–]ğ‘¦[Index]  â† 1             â–· ğ‘¦[Index] says which coefficient in ğ¡[ğ‘–] should be 1\n13:      Index â† Index + 1\n14:     end while\n15:    end for\n16:    for ğ‘– from Index to ğœ” âˆ’ 1 do              â–· read any leftover bytes in the first ğœ” bytes of ğ‘¦\n17:     if ğ‘¦[ğ‘–] â‰  0 then return âŠ¥                                          â–· malformed input\n18:     end if\n19:    end for\n20:    return ğ¡\n\n                                                   32"
  },
  {
    "doc_id": "NIST.FIPS.204",
    "source_path": "data/raw_pdfs/NIST.FIPS.204.pdf",
    "page_number": 43,
    "text": "FIPS 204                                              MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n\n7.2    Encodings of ML-DSA Keys and Signatures\nAlgorithms 22â€“27 translate keys and signatures for ML-DSA into byte strings. These procedures take\ncertain sequences of algebraic objects, encode them consecutively into byte strings, and perform the\nrespective decoding procedures.\nFirst, pkEncode and pkDecode translate ML-DSA public keys into byte strings and vice versa.   When\nverifying a signature, pkDecode might be run on an input that comes from an untrusted source. Thus,\ncare is required when using SimpleBitUnpack. As used here, SimpleBitUnpack always returns values in\nthe correct range.\n\nAlgorithm 22 pkEncode(ğœŒ, ğ­â‚)\nEncodes a public key for ML-DSA into a byte string.\nInput:ğœŒ âˆˆ ğ”¹Â³Â², ğ­â‚ âˆˆ ğ‘…ğ‘˜ with coefficients in [0, 2áµ‡â±áµ—Ë¡áµ‰â¿ (ğ‘âˆ’1)âˆ’ğ‘‘ âˆ’ 1].\nOutput: Public key ğ‘ğ‘˜ âˆˆ ğ”¹32+32ğ‘˜(bitlen (ğ‘âˆ’1)âˆ’ğ‘‘).\n 1:  ğ‘ğ‘˜ â† ğœŒ\n 2:  for ğ‘– from 0 to ğ‘˜ âˆ’ 1 do\n 3:  endğ‘ğ‘˜ â† ğ‘ğ‘˜ || SimpleBitPack (ğ­Â¹[ğ‘–], 2áµ‡â±áµ—Ë¡áµ‰â¿ (ğ‘âˆ’1)âˆ’ğ‘‘ âˆ’ 1)\n 4:         for\n 5:  return ğ‘ğ‘˜\n\nAlgorithm 23 pkDecode(ğ‘ğ‘˜)\nReverses the procedure pkEncode.\nInput: Public key ğ‘ğ‘˜ âˆˆ ğ”¹32+32ğ‘˜(bitlen (ğ‘âˆ’1)âˆ’ğ‘‘).\nOutput: ğœŒ âˆˆ ğ”¹Â³Â², ğ­â‚ âˆˆ ğ‘…ğ‘˜ with coefficients in [0, 2áµ‡â±áµ—Ë¡áµ‰â¿ (ğ‘âˆ’1)âˆ’ğ‘‘ âˆ’ 1].\n 1:  (ğœŒ, ğ‘§â‚€, â€¦ , ğ‘§ğ‘˜âˆ’1 ) âˆˆ ğ”¹Â³Â² Ã— (ğ”¹32(bitlen (ğ‘âˆ’1)âˆ’ğ‘‘))ğ‘˜ â† ğ‘ğ‘˜\n 2:  for ğ‘– from 0 to ğ‘˜ âˆ’ 1 do\n 3:  endğ­Â¹[ğ‘–] â† SimpleBitUnpack(ğ‘§ğ‘– , 2áµ‡â±áµ—Ë¡áµ‰â¿ (ğ‘âˆ’1)âˆ’ğ‘‘ âˆ’ 1)       â–· This is always in the correct range\n 4:  for\n 5:  return (ğœŒ, ğ­â‚)\n\nNext, skEncode and skDecode translate ML-DSA secret keys into byte strings and vice versa. Note that\nthere exist malformed inputs that can cause skDecode to return values that are not in the correct range.\nHence, skDecode should only be run on inputs that come from trusted sources.\n\n33"
  },
  {
    "doc_id": "NIST.FIPS.204",
    "source_path": "data/raw_pdfs/NIST.FIPS.204.pdf",
    "page_number": 44,
    "text": "FIPS 204                                                  MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n\nAlgorithm 24 skEncode(ğœŒ, ğ¾, ğ‘¡ğ‘Ÿ, ğ¬â‚, ğ¬â‚‚, ğ­â‚€)\nEncodes a secret key for ML-DSA into a byte string.\nInput: ğœŒ   âˆˆ ğ”¹Â³Â², ğ¾    âˆˆ ğ”¹Â³Â², ğ‘¡ğ‘Ÿ     âˆˆ ğ”¹â¶â´, ğ¬â‚ âˆˆ ğ‘…â„“ with coefficients in [âˆ’ğœ‚, ğœ‚], ğ¬â‚‚ âˆˆ ğ‘…ğ‘˜ with\ncoefficients in [âˆ’ğœ‚, ğœ‚], ğ­â‚€ âˆˆ ğ‘…ğ‘˜ with coefficients in [âˆ’2ğ‘‘âˆ’1 + 1, 2ğ‘‘âˆ’1].\nOutput: Private key ğ‘ ğ‘˜ âˆˆ ğ”¹32+32+64+32â‹…((ğ‘˜+â„“)â‹…bitlen (2ğœ‚)+ğ‘‘ğ‘˜).\n 1:    ğ‘ ğ‘˜ â† ğœŒ||ğ¾||ğ‘¡ğ‘Ÿ\n 2:    for ğ‘– from 0 to â„“ âˆ’ 1 do\n 3:    endğ‘ ğ‘˜ â† ğ‘ ğ‘˜ || BitPack (ğ¬Â¹[ğ‘–], ğœ‚, ğœ‚)\n 4:         for\n 5:    for ğ‘– from 0 to ğ‘˜ âˆ’ 1 do\n 6:    endğ‘ ğ‘˜ â† ğ‘ ğ‘˜ || BitPack (ğ¬Â²[ğ‘–], ğœ‚, ğœ‚)\n 7:         for\n 8:    for ğ‘– from 0 to ğ‘˜ âˆ’ 1 do\n 9:    endğ‘ ğ‘˜ â† ğ‘ ğ‘˜ || BitPack (ğ­â°[ğ‘–], 2ğ‘‘âˆ’1 âˆ’ 1, 2ğ‘‘âˆ’1)\n10:         for\n11:    return ğ‘ ğ‘˜\n\nAlgorithm 25 skDecode(ğ‘ ğ‘˜)\nReverses the procedure skEncode.\nInput: Private key ğ‘ ğ‘˜ âˆˆ ğ”¹32+32+64+32â‹…((â„“+ğ‘˜)â‹…bitlen (2ğœ‚)+ğ‘‘ğ‘˜).\nOutput: ğœŒ âˆˆ ğ”¹Â³Â², ğ¾ âˆˆ ğ”¹Â³Â², ğ‘¡ğ‘Ÿ âˆˆ ğ”¹â¶â´,\nğ¬â‚ âˆˆ ğ‘…â„“, ğ¬â‚‚ âˆˆ ğ‘…ğ‘˜, ğ­â‚€ âˆˆ ğ‘…ğ‘˜ with coefficients in [âˆ’2ğ‘‘âˆ’1 + 1, 2ğ‘‘âˆ’1].\n 1:    (ğœŒ, ğ¾, ğ‘¡ğ‘Ÿ, ğ‘¦â‚€, â€¦ , ğ‘¦â„“âˆ’1, ğ‘§â‚€, â€¦ , ğ‘§ğ‘˜âˆ’1 , ğ‘¤â‚€, â€¦ , ğ‘¤ğ‘˜âˆ’1 ) âˆˆ ğ”¹Â³Â² Ã— ğ”¹Â³Â² Ã— ğ”¹â¶â´ Ã— (ğ”¹32â‹…bitlen (2ğœ‚))â„“ Ã—\n       (ğ”¹32â‹…bitlen (2ğœ‚))ğ‘˜ Ã— (ğ”¹32ğ‘‘)ğ‘˜ â† ğ‘ ğ‘˜\n 2:    for ğ‘– from 0 to â„“ âˆ’ 1 do\n 3:    endğ¬Â¹[ğ‘–] â† BitUnpack(ğ‘¦ğ‘– , ğœ‚, ğœ‚)           â–· this may lie outside [âˆ’ğœ‚, ğœ‚] if input is malformed\n 4:         for\n 5:    for ğ‘– from 0 to ğ‘˜ âˆ’ 1 do\n 6:    endğ¬Â²[ğ‘–] â† BitUnpack(ğ‘§ğ‘– , ğœ‚, ğœ‚)           â–· this may lie outside [âˆ’ğœ‚, ğœ‚] if input is malformed\n 7:         for\n 8:    for ğ‘– from 0 to ğ‘˜ âˆ’ 1 do\n 9:    endğ­â°[ğ‘–] â† BitUnpack(ğ‘¤ğ‘– , 2ğ‘‘âˆ’1 âˆ’ 1, 2ğ‘‘âˆ’1)              â–· this is always in the correct range\n10:         for\n11:    return (ğœŒ, ğ¾, ğ‘¡ğ‘Ÿ, ğ¬â‚, ğ¬â‚‚, ğ­â‚€)\n\nNext, sigEncode and sigDecode translate ML-DSA signatures into byte strings and vice versa.      When\nverifying a signature, sigDecode might take input that comes from an untrusted source. Thus, care is\nrequired when using BitUnpack. As used here, BitUnpack always returns values in the correct range.\n\n34"
  },
  {
    "doc_id": "NIST.FIPS.204",
    "source_path": "data/raw_pdfs/NIST.FIPS.204.pdf",
    "page_number": 45,
    "text": "FIPS 204                                         MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n\nAlgorithm 26 sigEncode(ğ‘, ğ³, ğ¡)\nEncodes a signature into a byte string.\nInput: ğ‘ âˆˆ ğ”¹ğœ†/4, ğ³ âˆˆ ğ‘…â„“ with coefficients in [âˆ’ğ›¾â‚ + 1, ğ›¾â‚], ğ¡ âˆˆ ğ‘…ğ‘˜.\nOutput: Signature ğœ âˆˆ ğ”¹ğœ†/4+â„“â‹…32â‹…(1+bitlen (ğ›¾â‚âˆ’1))+ğœ”+ğ‘˜.       2\n 1:  ğœ â† ğ‘Ìƒ\n 2:  for ğ‘– from 0 to â„“ âˆ’ 1 do\n 3:  endğœ â† ğœ || BitPack (ğ³[ğ‘–], ğ›¾Â¹ âˆ’ 1, ğ›¾Â¹)\n 4:         for\n 5:  ğœ â† ğœ || HintBitPack (ğ¡)\n 6:  return ğœ\n\nAlgorithm 27 sigDecode(ğœ)\nReverses the procedure sigEncode.\nInput: Signature ğœ âˆˆ ğ”¹ğœ†/4+â„“â‹…32â‹…(1+bitlen (ğ›¾â‚âˆ’1))+ğœ”+ğ‘˜.\nOutput: ğ‘ âˆˆ ğ”¹ğœ†/4, ğ³ âˆˆ ğ‘…â„“ with coefficients in [âˆ’ğ›¾â‚ + 1, ğ›¾â‚], ğ¡ âˆˆ ğ‘…ğ‘˜, or âŠ¥.\n                                                                             2\n 1:  (ğ‘, ğ‘¥Ìƒâ‚€, â€¦ , ğ‘¥â„“âˆ’1, ğ‘¦) âˆˆ ğ”¹ğœ†/4 Ã— (ğ”¹32â‹…(1+áµ‡â±áµ—Ë¡áµ‰â¿ (ğ›¾â‚âˆ’1)))â„“ Ã— ğ”¹ğœ”+ğ‘˜ â† ğœ\n 2:  for ğ‘– from 0 to â„“ âˆ’ 1 do\n 3:  endğ³[ğ‘–] â† BitUnpack(ğ‘¥ğ‘– , ğ›¾Â¹ âˆ’ 1, ğ›¾Â¹)  â–· this is in the correct range, as ğ›¾â‚ is a power of 2\n 4:         for\n 5:  ğ¡ â† HintBitUnpack(ğ‘¦)\n 6:  return (ğ‘, ğ³, ğ¡)\n\nw1Encode is a specific subroutine used in ML-DSA.Sign. The procedure w1Encode encodes a polynomial\nvector ğ°1 into a string of bytes so that it can be processed by the function H.\n\nAlgorithm 28 w1Encode(ğ°â‚)\nEncodes a polynomial vector ğ°â‚ into a byte string.\nInput: ğ°â‚ âˆˆ ğ‘…ğ‘˜ whose polynomial coordinates have coefficients in [0, (ğ‘ âˆ’ 1)/(2ğ›¾â‚‚) âˆ’ 1].\nOutput: A byte string representation ğ°â‚ âˆˆ ğ”¹32ğ‘˜â‹…bitlen ((ğ‘âˆ’1)/(2ğ›¾â‚‚)âˆ’1).\n 1:  ğ°Ìƒâ‚ â† ()\n 2:  for ğ‘– from 0 to ğ‘˜ âˆ’ 1 do\n 3:  endğ°ÌƒÂ¹ â† ğ°ÌƒÂ¹ || SimpleBitPack (ğ°Â¹[ğ‘–], (ğ‘ âˆ’ 1)/(2ğ›¾Â²) âˆ’ 1)\n 4:         for\n 5:  return ğ°Ìƒâ‚\n\n35"
  },
  {
    "doc_id": "NIST.FIPS.204",
    "source_path": "data/raw_pdfs/NIST.FIPS.204.pdf",
    "page_number": 46,
    "text": "    FIPS 204                                                   MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n\n    7.3       Pseudorandom Sampling\n               This section specifies various algorithms for generating algebraic objects pseudorandomly from a seed\n    ğœŒ, where ğœŒ is a byte string whose length varies depending on the algorithm. The first procedure to be\n    defined is SampleInBall. As in Section 2.3, ğµğœ denotes the set of all polynomials ğ‘ âˆˆ ğ‘… such that\n\n           â€¢  Each coefficient of ğ‘ is either âˆ’1, 0, or 1, and\n\n           â€¢  Exactly ğœ of the coefficients of ğ‘ are nonzero.\n\n    SampleInBall pseudorandomly generates an element of ğµğœ using the XOF of a seed ğœŒ. The procedure\n    is based on the Fisher-Yates shuffle. H is applied to ğœŒ, and the first 8 bytes of the output are used to\n    choose the signs of the nonzero entries of ğ‘.12 Subsequent bytes are used to choose the positions of\n    those nonzero entries.\n\n    Algorithm 29 SampleInBall(ğœŒ)\n    Samples a polynomial ğ‘ âˆˆ ğ‘… with coefficients from {âˆ’1, 0, 1} and Hamming weight ğœ â‰¤ 64.\n    Input: A seed ğœŒ âˆˆ ğ”¹ğœ†/4\n    Output: A polynomial ğ‘ in ğ‘….\n     1:     ğ‘ â† 0\n     2:     ctx â† H.Init()\n     3:     ctx â† H.Absorb(ctx, ğœŒ)\n     4:     (ctx, ğ‘ ) â† H.Squeeze(ctx, 8)\n     5:     â„ â† BytesToBits(ğ‘ )                                â–· â„ is a bit string of length 64\n     6:     for ğ‘– from 256 âˆ’ ğœ to 255 do\n     7:        (ctx, ğ‘—) â† H.Squeeze(ctx, 1)\n     8:        while ğ‘— > ğ‘– do                                â–· rejection sampling in {0, â€¦ , ğ‘–}\n     9:             (ctx, ğ‘—) â† H.Squeeze(ctx, 1)\n    10:        end while                                       â–· ğ‘— is a pseudorandom byte that is â‰¤ ğ‘–\n    11:        ğ‘ğ‘– â† ğ‘ğ‘—\n    12:     endğ‘ğ‘— â† (âˆ’1)â„[ğ‘–+ğœâˆ’256]\n    13:         for\n    14:     return ğ‘\n\n    Algorithms 30â€“34 are the pseudorandom procedures RejNTTPoly, RejBoundedPoly, ExpandA, ExpandS,\n    and ExpandMask.       Each generates elements of ğ‘… or ğ‘‡ğ‘ under different input and output conditions.\n    RejNTTPoly and ExpandA make use of the more efficient XOF G, whereas the other three procedures\n    use the XOF H.\n                  The procedure ExpandMask (Algorithm 34) generates a polynomial vector ğ² in ğ‘…ğ‘˜ that disguises the\n    secret key in the ML-DSA.Sign_internal procedure (Algorithm 7). In addition to the seed ğœŒ, ExpandMask\n    also accepts an integer input ğœ‡ that is incorporated into the pseudorandom procedure that generates ğ¬.\n\n12The parameter ğœ is always less than or equal to 64, and thus 8 bytes are sufficient to choose the signs for all ğœ\n    nonzero entries of ğœ.\n                                                         36"
  },
  {
    "doc_id": "NIST.FIPS.204",
    "source_path": "data/raw_pdfs/NIST.FIPS.204.pdf",
    "page_number": 47,
    "text": "FIPS 204    MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n\nAlgorithm 30 RejNTTPoly(ğœŒ)\nSamples a polynomial âˆˆ ğ‘‡ğ‘ .\nInput: A seed ğœŒ âˆˆ ğ”¹Â³â´.\nOutput: An element ğ‘ âˆˆ ğ‘‡ğ‘ .\n 1:    ğ‘— â† 0\n 2:    ctx â† G.Init()\n 3:    ctx â† G.Absorb(ctx, ğœŒ)\n 4:    while ğ‘— < 256 do\n 5:     (ctx, ğ‘ ) â† G.Squeeze(ctx, 3)\n 6:     ğ‘[ğ‘—] â† CoeffFromThreeBytes(ğ‘ [0], ğ‘ [1], ğ‘ [2])\n 7:     if ğ‘[ğ‘—] â‰  âŠ¥ then\n 8:          ğ‘— â† ğ‘— + 1\n 9:     end if\n10:    end while\n11:    return ğ‘Ì‚\n\nAlgorithm 31 RejBoundedPoly(ğœŒ)\nSamples an element ğ‘ âˆˆ ğ‘… with coefficients in [âˆ’ğœ‚, ğœ‚] computed via rejection sampling from ğœŒ.\nInput: A seed ğœŒ âˆˆ ğ”¹â¶â¶.\nOutput: A polynomial ğ‘ âˆˆ ğ‘….\n 1:    ğ‘— â† 0\n 2:    ctx â† H.Init()\n 3:    ctx â† H.Absorb(ctx, ğœŒ)\n 4:    while ğ‘— < 256 do\n 5:     ğ‘§ â† H.Squeeze(ctx, 1)\n 6:     ğ‘§â‚€ â† CoeffFromHalfByte(ğ‘§ mod 16)\n 7:     ğ‘§â‚ â† CoeffFromHalfByte(âŒŠğ‘§/16âŒ‹)\n 8:     if ğ‘§â‚€ â‰  âŠ¥ then\n 9:          ğ‘ğ‘— â† ğ‘§â‚€\n10:          ğ‘— â† ğ‘— + 1\n11:     end if\n12:     if   ğ‘§â‚ â‰  âŠ¥ and ğ‘— < 256 then\n13:          ğ‘ğ‘— â† ğ‘§â‚\n14:          ğ‘— â† ğ‘— + 1\n15:     end if\n16:    end while\n17:    return ğ‘\n\n37"
  },
  {
    "doc_id": "NIST.FIPS.204",
    "source_path": "data/raw_pdfs/NIST.FIPS.204.pdf",
    "page_number": 48,
    "text": "FIPS 204    MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n\nAlgorithm 32 ExpandA(ğœŒ)\nSamples a ğ‘˜ Ã— â„“ matrix ğ€ of elements of ğ‘‡ğ‘ .\nInput: A seed ğœŒ âˆˆ ğ”¹Â³Â².\nOutput: Matrix ğ€ âˆˆ (ğ‘‡ğ‘ )ğ‘˜Ã—â„“.\n 1:    for ğ‘Ÿ from 0 to ğ‘˜ âˆ’ 1 do\n 2:     for ğ‘  from 0 to â„“ âˆ’ 1 do\n 3:      ğœŒâ€² â† ğœŒ||IntegerToBytes(ğ‘ , 1)||IntegerToBytes(ğ‘Ÿ, 1)\n 4:      ğ€[ğ‘Ÿ, ğ‘ ] â† RejNTTPoly(ğœŒâ€² )                         â–· seed ğœŒâ€² depends on ğ‘  and ğ‘Ÿ\n 5:     end for\n 6:    end for\n 7:    return ğ€\n\nAlgorithm 33 ExpandS(ğœŒ)\nSamples vectors ğ¬â‚ âˆˆ ğ‘…â„“ and ğ¬â‚‚ âˆˆ ğ‘…ğ‘˜, each with polynomial coordinates whose coefficients are\nin the interval [âˆ’ğœ‚, ğœ‚].\nInput: A seed ğœŒ âˆˆ ğ”¹â¶â´.\nOutput: Vectors ğ¬â‚, ğ¬â‚‚ of polynomials in ğ‘….\n 1:  for ğ‘Ÿ from 0 to â„“ âˆ’ 1 do\n 2:  endğ¬ğŸ [ğ‘Ÿ] â† RejBoundedPoly(ğœŒ||IntegerToBytes(ğ‘Ÿ, 2))      â–· seed depends on ğ‘Ÿ\n 3:  for\n 4:  for ğ‘Ÿ from 0 to ğ‘˜ âˆ’ 1 do\n 5:  endğ¬ğŸ [ğ‘Ÿ] â† RejBoundedPoly(ğœŒ||IntegerToBytes(ğ‘Ÿ + â„“, 2))  â–· seed depends on ğ‘Ÿ + â„“\n 6:  for\n 7:  return (ğ¬ğŸ , ğ¬ğŸ )\n\nAlgorithm 34 ExpandMask(ğœŒ, ğœ‡)\nSamples a vector ğ² âˆˆ ğ‘…â„“ such that each polynomial ğ²[ğ‘Ÿ] has coefficients between âˆ’ğ›¾â‚ + 1 and\nğ›¾â‚.\nInput: A seed ğœŒ âˆˆ ğ”¹â¶â´ and a nonnegative integer ğœ‡.\nOutput: Vector ğ² âˆˆ ğ‘…â„“.\n 1:    ğ‘ â† 1 + bitlen (ğ›¾â‚ âˆ’ 1)                     â–· ğ›¾â‚ is always a power of 2\n 2:    for ğ‘Ÿ from 0 to â„“ âˆ’ 1 do\n 3:     ğœŒâ€² â† ğœŒ||IntegerToBytes(ğœ‡ + ğ‘Ÿ, 2)\n 4:     ğ‘£ â† H(ğœŒâ€² , 32ğ‘)                           â–· seed depends on ğœ‡ + ğ‘Ÿ\n 5:    endğ²[ğ‘Ÿ] â† BitUnpack(ğ‘£, ğ›¾Â¹ âˆ’ 1, ğ›¾Â¹)\n 6:     for\n 7:    return ğ²\n\n                                              38"
  },
  {
    "doc_id": "NIST.FIPS.204",
    "source_path": "data/raw_pdfs/NIST.FIPS.204.pdf",
    "page_number": 49,
    "text": "FIPS 204                                                    MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n\n7.4      High-Order and Low-Order Bits and Hints\nThis specification uses the auxiliary functions Power2Round, Decompose, HighBits, LowBits, MakeHint,\nand UseHint and explicitly defines these functions, where ğ‘Ÿ âˆˆ â„¤ğ‘, ğ‘Ÿ1, ğ‘Ÿ0 âˆˆ â„¤, and â„ is a Boolean (or\nequivalently an element of â„¤2). However, this specification also uses these functions where ğ«, ğ³ âˆˆ ğ‘…ğ‘˜,\n                                                                                         ğ‘\nğ«1, ğ«0 âˆˆ ğ‘…ğ‘˜, and ğ¡ âˆˆ ğ‘…ğ‘˜. In this case, the functions are applied coefficientwise to the polynomials in the\nvectors. In particular:  2\n\n      â€¢  For ğ« âˆˆ ğ‘…ğ‘˜, define (ğ«     , ğ«   ) âˆˆ (ğ‘…ğ‘˜)2 = Power2Round(ğ«) so that:\n                   ğ‘             1          0\n                                              ((ğ«1[ğ‘–])ğ‘—, (ğ«0[ğ‘–])ğ‘—) = Power2Round((ğ«[ğ‘–])ğ‘—).\n\n      â€¢  For ğ« âˆˆ ğ‘…ğ‘˜, define (ğ«     , ğ«   ) âˆˆ (ğ‘…ğ‘˜)2 = Decompose(ğ«) so that:\n                   ğ‘             1          0\n                                              ((ğ«1[ğ‘–])ğ‘—, (ğ«0[ğ‘–])ğ‘—) = Decompose((ğ«[ğ‘–])ğ‘—).\n\n      â€¢  For ğ« âˆˆ ğ‘…ğ‘˜, define ğ«   = HighBits (ğ«) so that:\n                   ğ‘             1\n                                                (ğ«1[ğ‘–])ğ‘— = HighBits((ğ«[ğ‘–])ğ‘—).\n\n      â€¢  For ğ« âˆˆ ğ‘…ğ‘˜, define ğ«   = LowBits(ğ«) so that:\n                   ğ‘             0\n                                                (ğ«0[ğ‘–])ğ‘— = LowBits((ğ«[ğ‘–])ğ‘—).\n\n      â€¢  For ğ³, ğ« âˆˆ ğ‘…ğ‘˜, define ğ¡ âˆˆ ğ‘…ğ‘˜ = MakeHint(ğ³, ğ«) so that:\n                         ğ‘                   2\n                                               (ğ¡[ğ‘–])ğ‘— = MakeHint((ğ³[ğ‘–])ğ‘—, (ğ«[ğ‘–])ğ‘—).\n\n      â€¢  For ğ¡ âˆˆ ğ‘…ğ‘˜ and ğ« âˆˆ ğ‘…ğ‘˜, define ğ« âˆˆ ğ‘…ğ‘˜ = UseHint(ğ¡, ğ«) so that:\n                   2                   ğ‘      1\n                                               ğ«1[ğ‘–]ğ‘— = UseHint((ğ¡[ğ‘–])ğ‘—, (ğ«[ğ‘–])ğ‘—).\n\nThese algorithms are used to support the key compression optimization of ML-DSA. They involve dropping\nthe ğ‘‘ low-order bits of each coefficient of the polynomial vector ğ­ from the public key using the function\nPower2Round. However, in order to make this optimization work, additional information called a â€œhintâ€\nneeds to be provided in the signature to allow the verifier to reconstruct enough of the information in\nthe dropped public-key bits to verify the signature.        Hints are created during signing and used during\nverification by the functions MakeHint and UseHint, respectively. In the verification of a valid signature,\nthe hint allows the verifier to recover ğ°1 âˆˆ ğ‘…ğ‘˜, which represents ğ° âˆˆ ğ‘…ğ‘˜ rounded to a nearby multiple\nof          . The signer directly obtains       using the function                 ,       ğ‘\nis    ğ›¼ = 2ğ›¾2                                ğ°1                    HighBits        and the part rounded off (i.e., ğ«0)\n      obtained by LowBits. ğ«0 is used by the signer in the rejection sampling procedure.\nPower2Round decomposes an input ğ‘Ÿ âˆˆ â„¤ğ‘ into integers that represent the high- and low-order bits of\nğ‘Ÿ mod ğ‘ in the straightforward bitwise way, ğ‘Ÿ mod ğ‘ = ğ‘Ÿ1 â‹… 2ğ‘‘ + ğ‘Ÿ0, where ğ‘Ÿ0 = (ğ‘Ÿ mod ğ‘) modÂ±2ğ‘‘ and\nğ‘Ÿ1 = (ğ‘Ÿ mod ğ‘ âˆ’ ğ‘Ÿ0)/2ğ‘‘.\nHowever, for the purpose of computations related to hints, this method of decomposing ğ‘Ÿ has the\nundesirable property that when ğ‘Ÿ is close to ğ‘ âˆ’ 1 or 0, a small rounding error in ğ‘Ÿ can cause ğ‘Ÿ1 to change\nby more than 1, even accounting for wrap-around. In contrast to other unequal pairs of values of ğ‘Ÿ1 â‹… 2ğ‘‘\nand ğ‘Ÿâ€² â‹… 2ğ‘‘, the distance (modğ‘) between âŒŠğ‘/2ğ‘‘âŒ‹ â‹… 2ğ‘‘ and 0 may be very small.\n        1\n                                                          39"
  },
  {
    "doc_id": "NIST.FIPS.204",
    "source_path": "data/raw_pdfs/NIST.FIPS.204.pdf",
    "page_number": 50,
    "text": "FIPS 204    MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n\nTo avoid this problem, this specification defines Decompose, which is similar to Power2Round except:\n\n    â€¢  ğ‘Ÿ is generally decomposed as ğ‘Ÿ mod ğ‘ = ğ‘Ÿ1 â‹… ğ›¼ + ğ‘Ÿ0, where ğ›¼ = 2ğ›¾2 is a divisor of ğ‘ âˆ’ 1.\n\n    â€¢  If the straightforward rounding procedure would return (ğ‘Ÿ1 = (ğ‘ âˆ’ 1)/ğ›¼, ğ‘Ÿ0 âˆˆ [âˆ’(ğ›¼/2) + 1, ğ›¼/2]),\n       Decompose instead returns (ğ‘Ÿ1 = 0, ğ‘Ÿ0 âˆ’ 1).\n\nThe functions HighBits and LowBits â€” which only return ğ‘Ÿ1 and ğ‘Ÿ0, respectively â€” and MakeHint and\nUseHint use Decompose. For additional discussion of the mathematical properties of these functions\nthat are relevant to the correctness and security of ML-DSA, see Section 2.4 in [6].\n\nAlgorithm 35 Power2Round(ğ‘Ÿ)\nDecomposes ğ‘Ÿ into (ğ‘Ÿâ‚, ğ‘Ÿâ‚€) such that ğ‘Ÿ â‰¡ ğ‘Ÿâ‚2ğ‘‘ + ğ‘Ÿâ‚€ mod ğ‘.\nInput: ğ‘Ÿ âˆˆ â„¤ğ‘ .\nOutput: Integers (ğ‘Ÿâ‚, ğ‘Ÿâ‚€).\n 1:  ğ‘Ÿâº â† ğ‘Ÿ mod ğ‘\n 2:  ğ‘Ÿâ‚€ â† ğ‘Ÿâº modÂ±2ğ‘‘\n 3:  return ((ğ‘Ÿâº âˆ’ ğ‘Ÿâ‚€)/2ğ‘‘, ğ‘Ÿâ‚€)\n\nAlgorithm 36 Decompose(ğ‘Ÿ)\nDecomposes ğ‘Ÿ into (ğ‘Ÿâ‚, ğ‘Ÿâ‚€) such that ğ‘Ÿ â‰¡ ğ‘Ÿâ‚(2ğ›¾â‚‚) + ğ‘Ÿâ‚€ mod ğ‘.\nInput: ğ‘Ÿ âˆˆ â„¤ğ‘ .\nOutput: Integers (ğ‘Ÿâ‚, ğ‘Ÿâ‚€).\n 1:    ğ‘Ÿâº â† ğ‘Ÿ mod ğ‘\n 2:    ğ‘Ÿâ‚€ â† ğ‘Ÿâº modÂ±(2ğ›¾â‚‚)\n 3:    if ğ‘Ÿâº âˆ’ ğ‘Ÿâ‚€ = ğ‘ âˆ’ 1 then\n 4:     ğ‘Ÿâ‚ â† 0\n 5:     ğ‘Ÿâ‚€ â† ğ‘Ÿâ‚€ âˆ’ 1\n 6:    else ğ‘Ÿâ‚ â† (ğ‘Ÿâº âˆ’ ğ‘Ÿâ‚€)/(2ğ›¾â‚‚)\n 7:    end if\n 8:    return (ğ‘Ÿâ‚, ğ‘Ÿâ‚€)\n\nAlgorithm 37 HighBits(ğ‘Ÿ)\nReturns ğ‘Ÿâ‚ from the output of Decompose (ğ‘Ÿ).\nInput: ğ‘Ÿ âˆˆ â„¤ğ‘ .\nOutput: Integer ğ‘Ÿâ‚.\n 1:  (ğ‘Ÿâ‚, ğ‘Ÿâ‚€) â† Decompose(ğ‘Ÿ)\n 2:  return ğ‘Ÿâ‚\n\n40"
  },
  {
    "doc_id": "NIST.FIPS.204",
    "source_path": "data/raw_pdfs/NIST.FIPS.204.pdf",
    "page_number": 51,
    "text": "FIPS 204    MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n\nAlgorithm 38 LowBits(ğ‘Ÿ)\nReturns ğ‘Ÿâ‚€ from the output of Decompose (ğ‘Ÿ).\nInput: ğ‘Ÿ âˆˆ â„¤ğ‘ .\nOutput: Integer ğ‘Ÿâ‚€.\n 1:  (ğ‘Ÿâ‚, ğ‘Ÿâ‚€) â† Decompose(ğ‘Ÿ)\n 2:  return ğ‘Ÿâ‚€\n\nAlgorithm 39 MakeHint(ğ‘§, ğ‘Ÿ)\nComputes hint bit indicating whether adding ğ‘§ to ğ‘Ÿ alters the high bits of ğ‘Ÿ.\nInput: ğ‘§, ğ‘Ÿ âˆˆ â„¤ğ‘ .\nOutput: Boolean.\n 1:  ğ‘Ÿâ‚ â† HighBits(ğ‘Ÿ)\n 2:  ğ‘£â‚ â† HighBits(ğ‘Ÿ + ğ‘§)\n 3:  return [[ğ‘Ÿâ‚ â‰  ğ‘£â‚]]\n\nAlgorithm 40 UseHint(â„, ğ‘Ÿ)\nReturns the high bits of ğ‘Ÿ adjusted according to hint â„.\nInput: Boolean â„, ğ‘Ÿ âˆˆ â„¤ğ‘ .\nOutput: ğ‘Ÿâ‚ âˆˆ â„¤ with 0 â‰¤ ğ‘Ÿâ‚ â‰¤ ğ‘âˆ’1.\n                               2ğ›¾2\n 1:  ğ‘š â† (ğ‘ âˆ’ 1)/(2ğ›¾â‚‚)\n 2:  (ğ‘Ÿâ‚, ğ‘Ÿâ‚€) â† Decompose(ğ‘Ÿ)\n 3:  if â„ = 1 and ğ‘Ÿâ‚€ > 0 return (ğ‘Ÿâ‚ + 1) mod ğ‘š\n 4:  if â„ = 1 and ğ‘Ÿâ‚€ â‰¤ 0 return (ğ‘Ÿâ‚ âˆ’ 1) mod ğ‘š\n 5:  return ğ‘Ÿâ‚\n\n41"
  },
  {
    "doc_id": "NIST.FIPS.204",
    "source_path": "data/raw_pdfs/NIST.FIPS.204.pdf",
    "page_number": 52,
    "text": "FIPS 204                                      MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n\n7.5  NTT and NTTâˆ’1\n\nThe following algorithms implement the NTT and its inverse (NTTâˆ’1), which is important for efficiency.\nThere are other optimizations that are not included in this standard. In particular, mod ğ‘ and modÂ±ğ‘ are\nexpensive operations whose use can be minimized by using Montgomery Multiplication (see Appendix A).\nAn element of ğ‘…ğ‘ is a polynomial in â„¤ğ‘[ğ‘‹]/(ğ‘‹256 + 1), and an element of ğ‘‡ğ‘ is a tuple in Î 255 â„¤ğ‘. The\n                                                                                                ğ‘—=0\nNTT algorithm takes a polynomial ğ‘¤ âˆˆ ğ‘…ğ‘ as input and returns ğ‘¤ âˆˆ ğ‘‡ğ‘. NTTâˆ’1 takes ğ‘¤ âˆˆ ğ‘‡ğ‘ as input\nand returns ğ‘¤ such that ğ‘¤Ì‚ = NTT(ğ‘¤).\nThis document always distinguishes between elements of ğ‘…ğ‘ and elements of ğ‘‡ğ‘. However, the natural\ndata structure for both of these sets is as an integer array of size 256. This would allow the NTT and\nNTTâˆ’1 algorithms to perform computation in place on an integer array passed by reference.           That\noptimization is not included in this document.\nIn Section 2.5, ğœ = 1753 âˆˆ â„¤ğ‘, which is a 512th root of unity modulo ğ‘. On input ğ‘¤ âˆˆ ğ‘…ğ‘, the algorithm\noutputs\n                  NTT(ğ‘¤) = (ğ‘¤(ğœ0), ğ‘¤(ğœ1), â€¦ , ğ‘¤(ğœ255)) âˆˆ ğ‘‡ğ‘,                               (7.1)\nwhere ğœğ‘– = ğ‘¤(ğœ2BitRevâ‚ˆ(ğ‘–)+1) mod ğ‘.\nThe values ğœBitRevâ‚ˆ(ğ‘˜) mod ğ‘ for ğ‘˜ = 1, â€¦ , 255 used in line 10 of Algorithms 41 and 42 are pre-computed\ninto an array zetas[1..255]. The table of zetas is given in Appendix B. If Montgomery Multiplication is used\n(see Appendix A), then the zetas array would typically be stored in Montgomery form.\nNTT and NTTâˆ’1 use BitRev8, which reverses the order of bits in an 8-bit integer.\n\n42"
  },
  {
    "doc_id": "NIST.FIPS.204",
    "source_path": "data/raw_pdfs/NIST.FIPS.204.pdf",
    "page_number": 53,
    "text": "FIPS 204    MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n\nAlgorithm 41 NTT(ğ‘¤)\nComputes the NTT.\nInput: Polynomial ğ‘¤(ğ‘‹) = âˆ‘Â²âµâµ ğ‘¤ğ‘—ğ‘‹ğ‘— âˆˆ ğ‘…ğ‘ .\n                                 ğ‘—=0\nOutput: ğ‘¤ = (ğ‘¤[0], â€¦ , ğ‘¤[255]) âˆˆ ğ‘‡ğ‘ .\n 1:    for ğ‘— from 0 to 255 do\n 2:    endğ‘¤[ğ‘—] â† ğ‘¤ğ‘—\n 3:     for\n 4:    ğ‘š â† 0\n 5:    ğ‘™ğ‘’ğ‘› â† 128\n 6:    while ğ‘™ğ‘’ğ‘› â‰¥ 1 do\n 7:     ğ‘ ğ‘¡ğ‘ğ‘Ÿğ‘¡ â† 0\n 8:     while ğ‘ ğ‘¡ğ‘ğ‘Ÿğ‘¡ < 256 do\n 9:          ğ‘š â† ğ‘š + 1\n10:          ğ‘§ â† zetas[ğ‘š]                                      â–· ğ‘§ â† ğœá´®â±áµ—á´¿áµ‰áµ›â‚ˆ(ğ‘š) mod ğ‘\n11:          for ğ‘— from ğ‘ ğ‘¡ğ‘ğ‘Ÿğ‘¡ to ğ‘ ğ‘¡ğ‘ğ‘Ÿğ‘¡ + ğ‘™ğ‘’ğ‘› âˆ’ 1 do\n12:                ğ‘¡ â† (ğ‘§ â‹… ğ‘¤[ğ‘— + ğ‘™ğ‘’ğ‘›]) mod ğ‘\n13:                ğ‘¤[ğ‘— + ğ‘™ğ‘’ğ‘›] â† (ğ‘¤[ğ‘—] âˆ’ ğ‘¡) mod ğ‘\n14:                ğ‘¤[ğ‘—] â† (ğ‘¤[ğ‘—] + ğ‘¡) mod ğ‘\n15:          end for\n16:          ğ‘ ğ‘¡ğ‘ğ‘Ÿğ‘¡ â† ğ‘ ğ‘¡ğ‘ğ‘Ÿğ‘¡ + 2 â‹… ğ‘™ğ‘’ğ‘›\n17:     end while\n18:     ğ‘™ğ‘’ğ‘› â† âŒŠğ‘™ğ‘’ğ‘›/2âŒ‹\n19:    end while\n20:    return ğ‘¤Ì‚\n\n43"
  },
  {
    "doc_id": "NIST.FIPS.204",
    "source_path": "data/raw_pdfs/NIST.FIPS.204.pdf",
    "page_number": 54,
    "text": "FIPS 204    MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n\nAlgorithm 42 NTTâˆ’1 (ğ‘¤)Ì‚\nComputes the inverse of the NTT.\nInput: ğ‘¤ = (ğ‘¤[0], â€¦ , ğ‘¤[255]) âˆˆ ğ‘‡ğ‘ .\nOutput: Polynomial ğ‘¤(ğ‘‹) = âˆ‘Â²âµâµ ğ‘¤ğ‘—ğ‘‹ğ‘— âˆˆ ğ‘…ğ‘ .\n                                     ğ‘—=0\n 1:    for ğ‘— from 0 to 255 do\n 2:    endğ‘¤ğ‘— â† ğ‘¤[ğ‘—]\n 3:     for\n 4:    ğ‘š â† 256\n 5:    ğ‘™ğ‘’ğ‘› â† 1\n 6:    while ğ‘™ğ‘’ğ‘› < 256 do\n 7:     ğ‘ ğ‘¡ğ‘ğ‘Ÿğ‘¡ â† 0\n 8:     while ğ‘ ğ‘¡ğ‘ğ‘Ÿğ‘¡ < 256 do\n 9:          ğ‘š â† ğ‘š âˆ’ 1\n10:          ğ‘§ â† âˆ’ğ‘§ğ‘’ğ‘¡ğ‘ğ‘ [ğ‘š]                                â–· ğ‘§ â† âˆ’ğœá´®â±áµ—á´¿áµ‰áµ›â‚ˆ(ğ‘š) mod ğ‘\n11:          for ğ‘— from ğ‘ ğ‘¡ğ‘ğ‘Ÿğ‘¡ to ğ‘ ğ‘¡ğ‘ğ‘Ÿğ‘¡ + ğ‘™ğ‘’ğ‘› âˆ’ 1 do\n12:              ğ‘¡ â† ğ‘¤ğ‘—\n13:              ğ‘¤ğ‘— â† (ğ‘¡ + ğ‘¤ğ‘—+ğ‘™ğ‘’ğ‘›) mod ğ‘\n14:              ğ‘¤ğ‘—+ğ‘™ğ‘’ğ‘› â† (ğ‘¡ âˆ’ ğ‘¤ğ‘—+ğ‘™ğ‘’ğ‘›) mod ğ‘\n15:          endğ‘¤ğ‘—+ğ‘™ğ‘’ğ‘› â† (ğ‘§ â‹… ğ‘¤ğ‘—+ğ‘™ğ‘’ğ‘›) mod ğ‘\n16:              for\n17:          ğ‘ ğ‘¡ğ‘ğ‘Ÿğ‘¡ â† ğ‘ ğ‘¡ğ‘ğ‘Ÿğ‘¡ + 2 â‹… ğ‘™ğ‘’ğ‘›\n18:     end while\n19:     ğ‘™ğ‘’ğ‘› â† 2 â‹… ğ‘™ğ‘’ğ‘›\n20:    end while\n21:    ğ‘“ â† 8347681                                              â–· ğ‘“ = 256âˆ’1 mod ğ‘\n22:    for ğ‘— from 0 to 255 do\n23:    endğ‘¤ğ‘— â† (ğ‘“ â‹… ğ‘¤ğ‘—) mod ğ‘\n24:     for\n25:    return ğ‘¤\n\nAlgorithm 43 BitRevâ‚ˆ (ğ‘š)\nTransforms a byte by reversing the order of bits in its 8-bit binary expansion.\nInput: A byte ğ‘š âˆˆ [0, 255].\nOutput: A byte ğ‘Ÿ âˆˆ [0, 255].\n 1:    ğ‘ â† IntegerToBits(ğ‘š, 8)\n 2:    ğ‘rev âˆˆ {0, 1}â¸ â† (0, â€¦ , 0)\n 3:    for ğ‘– from 0 to 7 do\n 4:    endğ‘Ê³áµ‰áµ› [ğ‘–] â† ğ‘ [7 âˆ’ ğ‘–]\n 5:     for\n 6:    ğ‘Ÿ â† BitsToInteger(ğ‘rev, 8)\n 7:    return r\n\n                                                        44"
  },
  {
    "doc_id": "NIST.FIPS.204",
    "source_path": "data/raw_pdfs/NIST.FIPS.204.pdf",
    "page_number": 55,
    "text": "FIPS 204                           MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n\n7.6  Arithmetic Under NTT\nThe NTT converts elements of the ring ğ‘…ğ‘ (where addition and multiplication are denoted by + and â‹…,\nrespectively) into elements of the ring ğ‘‡ğ‘ (where addition and multiplication are denoted by + and âˆ˜,\nrespectively). This section gives explicit algorithms for linear algebra over the ring ğ‘‡ğ‘.\nThe ring ğ‘‡ğ‘ is defined to be the direct product ring Î 255â„¤ğ‘. Thus, an element ğ‘ âˆˆ ğ‘‡ğ‘ is an array of length\n256, and its elements are denoted by ğ‘[0], ğ‘[1], â€¦ , ğ‘–=0\n                                   ğ‘[255] âˆˆ â„¤ğ‘.\n\nAlgorithm 44 AddNTT(ğ‘,Ì‚ ğ‘)\nComputes the sum ğ‘ + ğ‘ of two elements ğ‘, ğ‘ âˆˆ ğ‘‡ğ‘ .\nInput: ğ‘,Ì‚ ğ‘ âˆˆ ğ‘‡ğ‘ .\nOutput: ğ‘ âˆˆ ğ‘‡ğ‘ .\n 1:  for ğ‘– from 0 to 255 do\n 2:         ğ‘[ğ‘–] â† ğ‘[ğ‘–] + ğ‘[ğ‘–]\n 3:  end for\n 4:  return ğ‘\n\nAlgorithm 45 MultiplyNTT(ğ‘,Ì‚ ğ‘)\nComputes the product ğ‘ âˆ˜Ì‚ ğ‘ of two elements ğ‘,Ì‚ ğ‘ âˆˆ ğ‘‡ğ‘ .\nInput: ğ‘,Ì‚ ğ‘ âˆˆ ğ‘‡ğ‘ .\nOutput: ğ‘ âˆˆ ğ‘‡ğ‘ .\n 1:  for ğ‘– from 0 to 255 do\n 2:         ğ‘[ğ‘–] â† ğ‘[ğ‘–] â‹… ğ‘[ğ‘–]\n 3:  end for\n 4:  return ğ‘\n\nAlgorithm 46 AddVectorNTT(ğ¯,Ì‚ ğ°)Ì‚\nComputes the sum ğ¯ + ğ° of two vectors ğ¯, ğ° over ğ‘‡ğ‘ .\nInput: â„“ âˆˆ â„•, ğ¯ âˆˆ ğ‘‡ â„“, ğ° âˆˆ ğ‘‡ â„“.\n                       ğ‘           ğ‘\nOutput: ğ® âˆˆ ğ‘‡ â„“.\n               ğ‘\n 1:  for ğ‘– from 0 to â„“ âˆ’ 1 do\n 2:         ğ®[ğ‘–] â† AddNTT(ğ¯[ğ‘–], ğ°[ğ‘–])\n 3:  end for\n 4:  return ğ®Ì‚\n\n45"
  },
  {
    "doc_id": "NIST.FIPS.204",
    "source_path": "data/raw_pdfs/NIST.FIPS.204.pdf",
    "page_number": 56,
    "text": "FIPS 204    MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n\nAlgorithm 47 ScalarVectorNTT(ğ‘,Ì‚ ğ¯)Ì‚\nComputes the product ğ‘ âˆ˜Ì‚ ğ¯Ì‚ of a scalar ğ‘ and a vector ğ¯Ì‚ over ğ‘‡ğ‘ .\nInput: ğ‘ âˆˆ ğ‘‡ğ‘ , â„“ âˆˆ â„•, ğ¯ âˆˆ ğ‘‡ â„“.\n                  ğ‘\nOutput: ğ° âˆˆ ğ‘‡ â„“.\n               ğ‘\n 1:  for ğ‘– from 0 to â„“ âˆ’ 1 do\n 2:  ğ°[ğ‘–] â† MultiplyNTT(ğ‘, ğ¯[ğ‘–])\n 3:  end for\n 4:  return ğ°Ì‚\n\nAlgorithm 48 MatrixVectorNTT(ğŒ, ğ¯)Ì‚\nComputes the product ğŒ âˆ˜ ğ¯Ì‚ of a matrix ğŒ and a vector ğ¯Ì‚ over ğ‘‡ğ‘ .\nInput: ğ‘˜, â„“ âˆˆ â„•, ğŒ âˆˆ ğ‘‡ ğ‘˜Ã—â„“, ğ¯ âˆˆ ğ‘‡ â„“.\n                   ğ‘            ğ‘\nOutput: ğ° âˆˆ ğ‘‡ ğ‘˜.\n                 ğ‘\n 1:    ğ° â† 0ğ‘˜\n 2:    for ğ‘– from 0 to ğ‘˜ âˆ’ 1 do\n 3:     for ğ‘— from 0 to â„“ âˆ’ 1 do\n 4:           ğ°[ğ‘–] â† AddNTT(ğ°[ğ‘–], MultiplyNTT(ğŒ[ğ‘–, ğ‘—], ğ¯[ğ‘—]))\n 5:     end for\n 6:    end for\n 7:    return ğ°Ì‚\n\n46"
  },
  {
    "doc_id": "NIST.FIPS.204",
    "source_path": "data/raw_pdfs/NIST.FIPS.204.pdf",
    "page_number": 57,
    "text": "FIPS 204                                      MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n\nReferences\n\n [1]  National Institute of Standards and Technology (2023) Digital signature standard (DSS), (U.S. Depart-\n      ment of Commerce, Washington, DC), Federal Information Processing Standards Publication (FIPS)\n      186-5. https://doi.org/10.6028/NIST.FIPS.186-5.\n\n [2]  Barker E (2020) Guideline for using cryptographic standards in the federal government: Cryptographic\n      mechanisms, (National Institute of Standards and Technology, Gaithersburg, MD), NIST Special\n      Publication (SP) 800-175B, Rev. 1 [or as amended]. https://doi.org/10.6028/NIST.SP.800-175Br1.\n\n [3]  Barker E (2006) Recommendation for obtaining assurances for digital signature applications, National\n      Institute of Standards and Technology, Gaithersburg, MD. NIST Special Publication (SP) 800-89 [or as\n      amended]. https://doi.org/10.6028/NIST.SP.800-89.\n\n [4]  Langlois A, StehlÃ© D (2015) Worst-case to average-case reductions for module lattices. Designs, Codes\n      and Cryptography 75(3):565â€“599. https://doi.org/10.1007/s10623-014-9938-4.\n\n [5]  Bai S, Ducas L, Kiltz E, Lepoint T, Lyubashevsky V, Schwabe P, Seiler G, StehlÃ© D (2020) CRYSTALS-\n      Dilithium: Algorithm specifications and supporting documentation, Submission to the NISTâ€™s post-\n      quantum cryptography standardization process. Available at https://csrc.nist.gov/Projects/post-qua\n      ntum-cryptography/post-quantum-cryptography-standardization/round-3-submissions.\n\n [6]  Bai S, Ducas L, Kiltz E, Lepoint T, Lyubashevsky V, Schwabe P, Seiler G, StehlÃ© D (2021) CRYSTALS-\n      Dilithium: Algorithm specifications and supporting documentation (Version 3.1). Available at https:\n      //pq-crystals.org/dilithium/data/dilithium-specification-round3-20210208.pdf.\n\n [7]  National Institute of Standards and Technology (2015) SHA-3 standard: Permutation-based hash and\n      extendable-output functions, (U.S. Department of Commerce, Washington, DC), Federal Information\n      Processing Standards Publication (FIPS) 202. https://doi.org/10.6028/NIST.FIPS.202.\n\n [8]  National Institute of Standards and Technology (2015) Secure hash standard (SHS), (U.S. Department\n      of Commerce, Washington, DC), Federal Information Processing Standards Publication (FIPS) 180-4.\n      https://doi.org/10.6028/NIST.FIPS.180-4.\n\n [9]  Barker E (2020) Recommendation for key management: Part 1 - general, (National Institute of\n      Standards and Technology, Gaithersburg, MD), NIST Special Publication (SP) 800-57 Part 1, Rev. 5 [or\n      as amended]. https://doi.org/10.6028/NIST.SP.800-57pt1r5.\n\n[10]  Lyubashevsky V (2009) Fiat-Shamir with aborts: Applications to lattice and factoring-based signa-\n      tures. Advances in Cryptology â€“ ASIACRYPT 2009, ed Matsui M (Springer Berlin Heidelberg, Berlin,\n      Heidelberg), pp 598â€“616. https://doi.org/10.1007/978-3-642-10366-7_35.\n\n[11]  Lyubashevsky V (2012) Lattice signatures without trapdoors. EUROCRYPT (Springer), Lecture Notes\n      in Computer Science, Vol. 7237, pp 738â€“755. https://doi.org/10.1007/978-3-642-29011-4_43.\n\n[12]  GÃ¼neysu T, Lyubashevsky V, PÃ¶ppelmann T (2012) Practical lattice-based cryptography: A signature\n      scheme for embedded systems. CHES (Springer), Vol. 7428, pp 530â€“547. https://doi.org/10.1007/97\n      8-3-642-33027-8_31.\n\n[13]  Bai S, Galbraith SD (2014) An improved compression technique for signatures based on learning with\n      errors. Topics in Cryptology â€“ CT-RSA 2014, ed Benaloh J (Springer International Publishing, Cham),\n      pp 28â€“47. https://doi.org/10.1007/978-3-319-04852-9_2.\n\n                                              47"
  },
  {
    "doc_id": "NIST.FIPS.204",
    "source_path": "data/raw_pdfs/NIST.FIPS.204.pdf",
    "page_number": 58,
    "text": "FIPS 204    MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n\n[14]  Cremers C, DÃ¼zlÃ¼ S, Fiedler R, Janson C, Fischlin M (2021) BUFFing signature schemes beyond\n      unforgeability and the case of post-quantum signatures. 2021 IEEE Symposium on Security and\n      Privacy (SP) (IEEE Computer Society, Los Alamitos, CA, USA), pp 1696â€“1714. https://doi.org/10.110\n      9/SP40001.2021.00093.\n\n[15]  Regev O (2005) On lattices, learning with errors, random linear codes, and cryptography. Proceedings\n      of the Thirty-Seventh Annual ACM Symposium on Theory of Computing STOC â€™05 (Association for\n      Computing Machinery, New York, NY, USA), p 84â€“93. https://doi.org/10.1145/1060590.1060603.\n\n[16]  Kiltz E, Lyubashevsky V, Schaffner C (2018) A concrete treatment of Fiat-Shamir signatures in the\n      quantum random-oracle model. Advances in Cryptology â€“ EUROCRYPT 2018, eds Nielsen JB, Rijmen\n     V (Springer International Publishing, Cham), pp 552â€“586. https://doi.org/10.1007/978-3-319-78372\n     -7_18.\n\n[17]  Barker E, Barker W (2019) Recommendation for key management: Part 2 - best practices for key\n      management organizations, National Institute of Standards and Technology, Gaithersburg, MD. NIST\n      Special Publication (SP) 800-57 Part 2, Rev. 1. https://doi.org/10.6028/NIST.SP.800-57pt2r1.\n\n[18]  Barker E, Dang Q (2019) Recommendation for key management: Part 3 - application-specific key\n      management guidance, National Institute of Standards and Technology, Gaithersburg, MD. NIST\n      Special Publication (SP) 800-57 Part 3, Rev. 1. http://doi.org/10.6028/NIST.SP.800-57pt3r1.\n\n[19]  Barker E, Kelsey J (2015) Recommendation for random number generation using deterministic\n      random bit generators, (National Institute of Standards and Technology, Gaithersburg, MD), NIST\n      Special Publication (SP) 800-90A, Rev. 1. https://doi.org/10.6028/NIST.SP.800-90Ar1.\n\n[20]  SÃ¶nmez Turan M, Barker E, Kelsey J, McKay K, Baish M, Boyle M (2018) Recommendation for the\n      entropy sources used for random bit generation, (National Institute of Standards and Technology,\n      Gaithersburg, MD), NIST Special Publication (SP) 800-90B. https://doi.org/10.6028/NIST.SP.800-90B.\n\n[21]  Barker E, Kelsey J, McKay K, Roginsky A, Turan MS (2024) Recommendation for random bit generator\n     (RBG) constructions, (National Institute of Standards and Technology, Gaithersburg, MD), NIST Special\n      Publication (SP) 800-90C 4pd. https://doi.org/10.6028/NIST.SP.800-90C.4pd.\n\n[22]  Bruinderink LG, Pessl P (2018) Differential fault attacks on deterministic lattice signatures. IACR\n     Transactions on Cryptographic Hardware and Embedded Systems (3):21â€“43. https://doi.org/10.131\n      54/tches.v2018.i3.21-43.\n\n[23]  Poddebniak D, Somorovsky J, Schinzel S, Lochter M, RÃ¶sler P (2018) Attacking deterministic signature\n      schemes using fault attacks. 2018 IEEE European Symposium on Security and Privacy (EuroS&P)\n     (IEEE), pp 338â€“352. https://doi.org/10.1109/EuroSP.2018.00031.\n\n[24]  Samwel N, Batina L, Bertoni G, Daemen J, Susella R (2018) Breaking ed25519 in wolfssl. Topics in\n      Cryptologyâ€“CT-RSA 2018: The Cryptographersâ€™ Track at the RSA Conference 2018, San Francisco, CA,\n      USA, April 16-20, 2018, Proceedings (Springer), pp 1â€“20. https://doi.org/10.1007/978-3-319-76953\n      -0_1.\n\n[25]  Kelsey J, Chang S, Perlner R (2016) SHA-3 Derived Functions: cSHAKE, KMAC, TupleHash and Parallel-\n      Hash, (National Institute of Standards and Technology, Gaithersburg, MD), NIST Special Publication\n     (SP) 800-185 [or as amended]. https://doi.org/10.6028/NIST.SP.800-185.\n\n[26]  National Institute of Standards and Technology (2016) Submission requirements and evaluation\n      criteria for the post-quantum cryptography standardization process. Available at https://csrc.nist.go\n                              48"
  },
  {
    "doc_id": "NIST.FIPS.204",
    "source_path": "data/raw_pdfs/NIST.FIPS.204.pdf",
    "page_number": 59,
    "text": "FIPS 204    MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n\n     v/CSRC/media/Projects/Post-Quantum-Cryptography/documents/call-for-proposals-final-dec-201\n      6.pdf.\n\n[27]  Alagic G, Apon D, Cooper D, Dang Q, Dang T, Kelsey J, Lichtinger J, Liu YK, Miller C, Moody D, Peralta R,\n      Perlner R, Robinson A, Smith-Tone D (2022) Status report on the third round of the NIST post-quantum\n      cryptography standardization process (National Institute of Standards and Technology, Gaithersburg,\n      MD), NIST Interagency or Internal Report (IR) 8413. https://doi.org/10.6028/NIST.IR.8413-upd1.\n\n[28]  Avanzi R, Bos J, Ducas L, Kiltz E, Lepoint T, Lyubashevsky V, Schanck JM, Schwabe P, Seiler G,\n      StehlÃ© D (2020) CRYSTALS-Kyber algorithm specifications and supporting documentation, 3rd\n      Round submission to the NISTâ€™s post-quantum cryptography standardization process. Available\n      at https://csrc.nist.gov/Projects/post-quantum-cryptography/post-quantum-cryptography-standar\n      dization/round-3-submissions.\n\n[29]  Housley R (2009) Cryptographic Message Syntax (CMS), Internet Engineering Task Force (IETF) request\n      for comments (RFC) 5652, https://doi.org/10.17487/RFC5652.\n\n[30]  Schnorr C (1990) Efficient identification and signatures for smart cards. Advances in Cryptology â€”\n      CRYPTOâ€™ 89 Proceedings, ed Brassard G (Springer New York, New York, NY), pp 239â€“252. https:\n     //doi.org/10.1007/0-387-34805-0_22.\n\n[31]  Josefsson S, Liusvaara I (2017) Edwards-Curve Digital Signature Algorithm (EdDSA), RFC 8032. https:\n     //doi.org/10.17487/RFC8032.\n\n[32]  Lyubashevsky V (2021) Round 3 Official Comment: CRYSTALS-DILITHIUM. Available at https://groups\n      .google.com/a/list.nist.gov/g/pqc-forum/c/BjfjRMIdnhM/m/W7kkVOFDBAAJ.\n\n[33]  Hamburg M (2024) Dilithium hint unpacking. Available at https://groups.google.com/a/list.nist.gov/\n      g/pqc-forum/c/TQo-qFbBO1A/m/YcYKjMblAAAJ.\n\n[34]  Mattsson (on behalf of SÃ¶nke Jendral) JP (2024) Dilithium hint unpacking. Available at https://grou\n      ps.google.com/a/list.nist.gov/g/pqc-forum/c/TQo-qFbBO1A/m/sLjseYlSAwAJ.\n\n[35]  Lee S (2024) Updates for FIPS 203. Available at https://groups.google.com/a/list.nist.gov/g/pqc-for\n      um/c/Rb0nFvfFTEQ/m/lw-k7tVdBQAJ.\n\n49"
  },
  {
    "doc_id": "NIST.FIPS.204",
    "source_path": "data/raw_pdfs/NIST.FIPS.204.pdf",
    "page_number": 60,
    "text": "FIPS 204                                                MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n\nAppendix A â€” Montgomery Multiplication\n\n  This document uses modular multiplications of the form ğ‘ â‹… ğ‘ modulo ğ‘. This is an expensive operation\nthat is often sped up in practice through the use of Montgomery Multiplication.\nIf ğ‘ is an integer modulo ğ‘, then its Montgomery form with multiplier 232 is ğ‘Ÿ â‰¡ ğ‘ â‹… 232 mod ğ‘. 13\nSuppose that two integers ğ‘¢ and ğ‘£ modulo ğ‘ are in Montgomery form.         Their product modulo ğ‘ is\nğ‘ = ğ‘¢ â‹… ğ‘£ â‹… 2âˆ’32, which is also in Montgomery form. If the integer product of ğ‘¢ and ğ‘£ does not overflow a\n64-bit signed integer, then one can compute ğ‘ by first performing the integer multiplication ğ‘¢ â‹… ğ‘£ and then\nâ€œreducingâ€ the product by multiplying by 2âˆ’32 modulo ğ‘. This last operation can be done efficiently as\nfollows.\n The MontgomeryReduce function takes an integer ğ‘ with absolute value at most 231ğ‘ as input. It returns\nan integer ğ‘Ÿ such that ğ‘Ÿ = ğ‘ â‹… 2âˆ’32 mod ğ‘. The output is in Montgomery form with multiplier 232 mod ğ‘.\nAn implementation would typically input a 64-bit input and return a 32-bit output. The â€œmodulo 232â€\noperation simply extracts the 32 least significant bits of a 64-bit value. The value (ğ‘ âˆ’ ğ‘¡ â‹… ğ‘) on line 3 is an\ninteger divisible by 232. Therefore, the division consists of simply taking the most significant 32 bits of a\n64-bit value. Extracting the four low- or high-order bytes is often done using typecasting.\n\nAlgorithm 49 MontgomeryReduce(ğ‘)\nComputes ğ‘ â‹… 2âˆ’32 mod ğ‘.\nInput: Integer ğ‘ with âˆ’2Â³Â¹ğ‘ â‰¤ ğ‘ â‰¤ 2Â³Â¹ğ‘.\nOutput: ğ‘Ÿ â‰¡ ğ‘ â‹… 2âˆ’32 mod ğ‘.\n 1:  QINV â† 58728449                       â–· the inverse of ğ‘ modulo 2Â³Â²\n 2:  ğ‘¡ â† ((ğ‘ mod 2Â³Â²) â‹… QINV) mod 2Â³Â²\n 3:  ğ‘Ÿ â† (ğ‘ âˆ’ ğ‘¡ â‹… ğ‘)/2Â³Â²\n 4:  return ğ‘Ÿ\n\n  With this algorithm, the modular product of ğ‘ and ğ‘ is ğ‘ = MontgomeryReduce(ğ‘ â‹… ğ‘), where ğ‘, ğ‘, and ğ‘\nare in Montgomery form. The return value of the algorithm is not necessarily less than ğ‘ in absolute value,\nbut it is less than 2ğ‘ in absolute value. This is not a concern in practice since the objective of Montgomery\nMultiplication is to efficiently work with modular values that fit in a 32-bit register. If necessary, the result\ncan be normalized to an integer in (âˆ’ğ‘, ğ‘) using a comparison and an integer addition.\nConverting an integer modulo ğ‘ to Montgomery form by multiplying by 232 modulo ğ‘ is an expensive\noperation. When a sequence of modular operations is to be performed, the operands are converted once\nto Montgomery form. The operations are then performed, and the factor 232 is extracted from the final\nresult.\n\n13This section does not distinguish between different versions of the â€œ mod â€ operator. There are three such versions\nof â€œğ‘¥ = ğ‘ modulo ğ‘â€: i) ğ‘¥ âˆˆ [0, ğ‘ âˆ’ 1]; ii) ğ‘¥ âˆˆ [âˆ’âŒˆğ‘/2âŒ‰, âŒŠğ‘/2âŒ‹] ; iii) ğ‘¥ âˆˆ [âˆ’ğ‘ + 1, ğ‘ âˆ’ 1]. The last version\ncorresponds to the â€¶%â€³ operator in most programming languages.\n                                                    50"
  },
  {
    "doc_id": "NIST.FIPS.204",
    "source_path": "data/raw_pdfs/NIST.FIPS.204.pdf",
    "page_number": 61,
    "text": "FIPS 204                MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n\nAppendix B â€” Zetas Array\n\nThe values ğœBitRevâ‚ˆ(ğ‘˜) mod ğ‘ for ğ‘˜ = 1, â€¦ , 255 used in the NTT Algorithms 41 and 42 may be pre-computed\nand stored in an array zetas[1..255]. This table of zetas is given below.\nzetas[0..255] = {\n   0,       4808194,    3765607,    3761513,    5178923,     5496691,    5234739,     5178987,\n7778734,    3542485,    2682288,    2129892,    3764867,     7375178,    557458,      7159240,\n5010068,    4317364,    2663378,    6705802,    4855975,     7946292,    676590,      7044481,\n5152541,    1714295,    2453983,    1460718,    7737789,     4795319,    2815639,     2283733,\n3602218,    3182878,    2740543,    4793971,    5269599,     2101410,    3704823,     1159875,\n394148,     928749,     1095468,    4874037,    2071829,     4361428,    3241972,     2156050,\n3415069,    1759347,    7562881,    4805951,    3756790,     6444618,    6663429,     4430364,\n5483103,    3192354,    556856,     3870317,    2917338,     1853806,    3345963,     1858416,\n3073009,    1277625,    5744944,    3852015,    4183372,     5157610,    5258977,     8106357,\n2508980,    2028118,    1937570,    4564692,    2811291,     5396636,    7270901,     4158088,\n1528066,    482649,     1148858,    5418153,    7814814,     169688,     2462444,     5046034,\n4213992,    4892034,    1987814,    5183169,    1736313,     235407,     5130263,     3258457,\n5801164,    1787943,    5989328,    6125690,    3482206,     4197502,    7080401,     6018354,\n7062739,    2461387,    3035980,    621164,     3901472,     7153756,    2925816,     3374250,\n1356448,    5604662,    2683270,    5601629,    4912752,     2312838,    7727142,     7921254,\n348812,     8052569,    1011223,    6026202,    4561790,     6458164,    6143691,     1744507,\n 1753,      6444997,    5720892,    6924527,    2660408,     6600190,    8321269,     2772600,\n1182243,     87208,     636927,     4415111,    4423672,     6084020,    5095502,     4663471,\n8352605,    822541,     1009365,    5926272,    6400920,     1596822,    4423473,     4620952,\n6695264,    4969849,    2678278,    4611469,    4829411,     635956,     8129971,     5925040,\n4234153,    6607829,    2192938,    6653329,    2387513,     4768667,    8111961,     5199961,\n3747250,    2296099,    1239911,    4541938,    3195676,     2642980,    1254190,     8368000,\n2998219,    141835,     8291116,    2513018,    7025525,     613238,     7070156,     6161950,\n7921677,    6458423,    4040196,    4908348,    2039144,     6500539,    7561656,     6201452,\n6757063,    2105286,    6006015,    6346610,    586241,      7200804,    527981,      5637006,\n6903432,    1994046,    2491325,    6987258,    507927,      7192532,    7655613,     6545891,\n5346675,    8041997,    2647994,    3009748,    5767564,     4148469,    749577,      4357667,\n3980599,    2569011,    6764887,    1723229,    1665318,     2028038,    1163598,     5011144,\n3994671,    8368538,    7009900,    3020393,    3363542,     214880,     545376,      7609976,\n3105558,    7277073,    508145,     7826699,    860144,      3430436,    140244,      6866265,\n6195333,    3123762,    2358373,    6187330,    5365997,     6663603,    2926054,     7987710,\n8077412,    3531229,    4405932,    4606686,    1900052,     7598542,    1054478,    7648983 }\n\n51"
  },
  {
    "doc_id": "NIST.FIPS.204",
    "source_path": "data/raw_pdfs/NIST.FIPS.204.pdf",
    "page_number": 62,
    "text": "FIPS 204                                                   MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n\nAppendix C â€” Loop Bounds\n\nThere are four algorithms in this standard with loops that iterate an indeterminate number of times,\nthough the expected number of iterations is a small constant in each case. Three of the four algorithms\ninvolve sampling from the output of an XOF, where the amount of output required from the XOF is\nproportional to the number of iterations that are performed.\nImplementations should not bound the number of iterations in these loops or the amount of output that\nis extracted from the XOFs when executing these functions.14 If an implementation bounds the number of\niterations or the number of bytes that may be extracted from the XOF, it shall not use a limit lower than\nthose presented in Table 3. The limits yield a probability of approximately 2âˆ’256 (or less) of being reached\nin a correct implementation of this standard. The probability is calculated under standard assumptions\nabout the output distributions of XOFs and hash functions.\n\nTable 3. While loop and XOF output limits for a 2âˆ’256 or less probability of failure\n\n     Algorithm    Minimum allowable limit                               Minimum allowable limit\n                     (Loop iterations)                                     (XOF output bytes)\nML-DSA.Sign_internal        814                                                   N/A\n   RejBoundedPoly           481                                         481\n     RejNTTPoly             298                                         894\n    SampleInBall            121                                         221\n\nImplementations may limit the number of iterations of a while loop or the number of bytes drawn from\nthe XOF to not exceed the maximum values in Table 3. If this option is used and the maximum number of\niterations or XOF output bytes is exceeded, the algorithm shall destroy all intermediate results. If a return\nvalue or exception is produced, it shall be the same for any execution in which the maximum number of\niterations or output bytes is exceeded.\nThere is essentially no performance penalty for using a larger than necessary limit, as the limit will only\nbe reached on a faulty execution of the loop. Because of this, limits were chosen that lower-bound the\nprobability of reaching them to 2âˆ’256.\nML-DSA.Sign_internal\nTable 1 contains the expected repetitions in the rejection sampling loop of ML-DSA.Sign_internal. These\nare 4.25, 5.1, and 3.85 for Categories 2, 3, and 5, respectively. Therefore, the probability that the number\nof repetitions exceeds ğ‘› is less than or equal to ( 5.1âˆ’1)ğ‘› for all categories. Solving ( 5.1âˆ’1)ğ‘› â‰¤ 2âˆ’256\nyields ğ‘› = 814.                                           5.1             5.1\nRejBoundedPoly\nLet ğ‘‹ be the number of coefficients generated in ğ‘› iterations of the while loop of RejBoundedPoly15.\nThen ğ‘‹ is ğµğ‘–ğ‘›ğ‘œğ‘šğ‘–ğ‘ğ‘™(2ğ‘›, ğœƒ), where ğœƒ is either 9 or 15 , depending on the parameter ğœ‚. For ğœƒ = 9 ,\n                                   256 coefficient16              16                                       16\nthe probability that fewer than                          s are generated in 481 iterations of the main loop in\nRejBoundedPoly is less than 2âˆ’256. Each iteration consumes one byte of output from H.\n\n14RejBoundedPoly, RejNTTPoly, and SampleInBall use the incremental APIs described in Section 3.7 in order to\nextract the amount of output needed from the XOFs, given that the amount needed is not known in advance.\n15Note that 0, 1, or 2 coefficients are generated in each iteration.\n                                                           52"
  },
  {
    "doc_id": "NIST.FIPS.204",
    "source_path": "data/raw_pdfs/NIST.FIPS.204.pdf",
    "page_number": 63,
    "text": "FIPS 204                                   MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n\nRejNTTPoly\nThe number of valid coefficients generated in ğ‘› calls to G.Squeeze in RejNTTPoly is ğµğ‘–ğ‘›ğ‘œğ‘šğ‘–ğ‘ğ‘™(ğ‘›, 2âˆ’23ğ‘).\nIt follows that after 298 calls, the probability of failure is less than 2âˆ’256. Each iteration consumes three\nbytes of output from G.\nSampleInBall\nStep 9 in SampleInBall is executed every time a pseudorandom byte is greater than a value ğ‘– in the range\n[256 âˆ’ ğœ , 255]. The parameter ğœ is 39, 49, and 60 for categories 2, 3, and 5, respectively. Therefore, the\nprobability that this step is executed more than ğ‘› times in a single iteration of the for loop is less than or\nequal to ( 59 )ğ‘› â‰¤ ( ğœ       )ğ‘›. Solving ( 59 )ğ‘› â‰¤ 2âˆ’256 yields a bound of ğ‘› = 121 for the while loop on step\n8 of        256       256      256\n      SampleInBall. Each iteration consumes one byte of output from H.\nEach call to SampleInBall extracts eight bytes from H and then performs ğœ iterations of the for loop, each\nof which extracts an indeterminate amount of data from H. The probability that more than ğ‘› bytes of\noutput will be required from H during an execution of SampleInBall for a given value of ğœ is\n\n                      â§               1                                              if ğ‘› â‰¤ 8\n            ğ‘ƒ (ğ‘›, ğœ) = {           0                                              if ğœ  = 1 and ğ‘› > 8 .\n                      â¨\n                      { ( 257âˆ’ğœ ) ğ‘ƒ (ğ‘› âˆ’ 1, ğœ âˆ’ 1) + ( ğœâˆ’1) ğ‘ƒ (ğ‘› âˆ’ 1, ğœ)     if ğœ  > 1 and ğ‘› > 8\n                      â©        256                        256\n\nğ‘ƒ (ğ‘›, 60) is less than 2âˆ’256 when ğ‘› is 221 or greater. Implementations may limit the number of bytes\nextracted from H to ğ‘› â‰¥ 221. Such implementations must stop the execution of SampleInBall, return a\nconstant that represents an error and no other output, and destroy all intermediate results after ğ‘› bytes\nof output have been consumed.\n\n53"
  },
  {
    "doc_id": "NIST.FIPS.204",
    "source_path": "data/raw_pdfs/NIST.FIPS.204.pdf",
    "page_number": 64,
    "text": "FIPS 204                                   MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n\nAppendix D â€” Differences from the CRYSTALS-DILITHIUM Submission\n\nML-DSA is derived from Version 3.1 of CRYSTALS-DILITHIUM [6]. Version 3.1 differs slightly from the most\nrecent version that appears on the NIST website (i.e., Version 3 CRYSTALS-DILITHIUM [5]). Appendices D.1,\nD.2, and D.3 document the differences between Versions 3 and 3.1, the differences between Version 3.1\nand the initial public draft of the ML-DSA, and the differences between the initial public draft and the\nML-DSA standard as published in this document, respectively.\n\nD.1  Differences Between Version 3.1 and the Round 3 Version of CRYSTALS-\nDILITHIUM\n  The lengths of the variables ğœŒâ€² (private random seed) and ğœ‡ (message representative) in the signing\nalgorithm were increased from 384 to 512 bits. The increase in the length of ğœ‡ corrects a security flaw\nthat appeared in the third-round submission, where a collision attack against SHAKE256 with a 384-bit\noutput would make it so that parameters targeting NIST security strength category 5 could only meet\ncategory 4 [32].\nAdditionally, the length of the variable ğ‘¡ğ‘Ÿ (the hash of the public key) was reduced from 384 to 256 bits.\nIn key generation, the variable ğœ was relabeled as ğœŒâ€² and increased in size from 256 bits to 512 bits.\n\nD.2  Differences Between Version 3.1 of CRYSTALS-DILITHIUM and FIPS 204\nInitial Public Draft\nIn order to ensure the properties noted in [14], ML-DSA increases the length of ğ‘¡ğ‘Ÿ to 512 bits and increases\nthe length of ğ‘ to 384 and 512 bits for the parameter sets ML-DSA-65 and ML-DSA-87, respectively. In\ndraft ML-DSA, only the first 256 bits of ğ‘ are used in the generation of ğ‘.\nIn Version 3.1 of the CRYSTALS-DILITHIUM submission, the default version of the signing algorithm is\ndeterministic with ğœŒâ€² being generated pseudorandomly from the signerâ€™s private key and the message,\nand an optional version of the signing algorithm has ğœŒâ€² sampled instead as a 512-bit random string. In\nML-DSA, ğœŒâ€² is generated by a â€œhedgedâ€ procedure in which ğœŒâ€² is pseudorandomly derived from the signerâ€™s\nprivate key, the message, and a 256-bit string ğ‘Ÿğ‘›ğ‘‘, which should be generated by an Approved RBG by\ndefault. The ML-DSA standard also allows for an optional deterministic version in which ğ‘Ÿğ‘›ğ‘‘ is a 256-bit\nconstant string.\n The draft ML-DSA standard also included pseudocode that unintentionally omitted a check for malformed\ninput while unpacking the hint [33]. Failure to perform this check results in a signature scheme that is not\nstrongly existentially unforgeable [34].\n\nD.3  Changes From FIPS 204 Initial Public Draft\nIn the final version of the ML-DSA standard, the omitted malformed input check was restored to the hint\nunpacking algorithm (Algorithm 21). Additionally, in the final version of ML-DSA, all of the bits of ğ‘ are\nused in the generation of ğ‘ (Algorithm 29), and ExpandMask (Algorithm 34) is modified to take output\nbits from the beginning of the output of H.\nBased on comments that were submitted on the draft version, more details were provided for the pre-hash\nversion HashML-DSA in Section 5.4. These modifications include domain separation for the cases in which\nthe message is signed directly and cases in which a digest of the message is signed. The changes were\nmade by explicitly defining external functions for both versions of the signing and verification functions\n\n                                                   54"
  },
  {
    "doc_id": "NIST.FIPS.204",
    "source_path": "data/raw_pdfs/NIST.FIPS.204.pdf",
    "page_number": 65,
    "text": "FIPS 204    MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n\nthat call an internal function corresponding to the signing or verification functions from the draft FIPS.\nDomain separation is included in the input to the internal function (see Algorithms 2, 3, 4, 5, 7, and 8).\nTo simplify APIs and for testing purposes, this document also introduced a similar external/internal split\nfor key generation (see Algorithms 1 and 6), but this is a purely editorial change, as the external key\ngeneration algorithm is functionally equivalent to the key-generation algorithm from the draft FIPS.\nFinally, to offer misuse resistance against the possibility that keys for different parameter sets might be\nexpanded from the same seed [35], domain separation was added to line 1 of Algorithm 6.\n\n55"
  }
]