[
  {
    "doc_id": "NIST.FIPS.205",
    "source_path": "data/raw_pdfs/NIST.FIPS.205.pdf",
    "page_number": 1,
    "text": "  FIPS 205\n\n  Federal Information Processing Standards Publication\n\n  Stateless Hash-Based Digital Signature\n  Standard\n\n  Category: Computer Security    Subcategory: Cryptography\n\n  Information Technology Laboratory\n  National Institute of Standards and Technology\n  Gaithersburg, MD 20899-8900\n\n  This publication is available free of charge from:\n  https://doi.org/10.6028/NIST.FIPS.205\n\n  Published: August 13, 2024\n\n  U.S. Department of Commerce\n  Gina M. Raimondo, Secretary\n\n 0 National Institute of Standards and Technology\n  Laurie E. Locascio, NIST Director and Under Secretary of Commerce for Standards and Technology\n\nCheck\n   for\nupdates"
  },
  {
    "doc_id": "NIST.FIPS.205",
    "source_path": "data/raw_pdfs/NIST.FIPS.205.pdf",
    "page_number": 2,
    "text": "                                                   Foreword\n\nThe Federal Information Processing Standards Publication (FIPS) series of the National Institute of Standards\nand Technology (NIST) is the official series of publications relating to standards and guidelines developed\nunder 15 U.S.C. 278g-3, and issued by the Secretary of Commerce under 40 U.S.C. 11331.\nComments concerning this Federal Information Processing Standard publication are welcomed and should\nbe submitted using the contact information in the â€œInquiries and commentsâ€ clause of the announcement\nsection.\n\n        Kevin M. Stine, Director\n        Information Technology Laboratory"
  },
  {
    "doc_id": "NIST.FIPS.205",
    "source_path": "data/raw_pdfs/NIST.FIPS.205.pdf",
    "page_number": 3,
    "text": "FIPS 205    STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n\n                                            Abstract\nThis standard specifies the stateless hash-based digital signature algorithm (SLH-DSA). Digital\nsignatures are used to detect unauthorized modifications to data and to authenticate the identity\nof the signatory. In addition, the recipient of signed data can use a digital signature as evidence in\ndemonstrating to a third party that the signature was, in fact, generated by the claimed signatory.\nThis is known as non-repudiation since the signatory cannot easily repudiate the signature at a\nlater time. SLH-DSA is based on SPHINCSâº, which was selected for standardization as part of the\nNIST Post-Quantum Cryptography Standardization process.\n\nKeywords: computer security; cryptography; digital signatures; Federal Information Processing\nStandards; hash-based signatures; post-quantum; public-key cryptography."
  },
  {
    "doc_id": "NIST.FIPS.205",
    "source_path": "data/raw_pdfs/NIST.FIPS.205.pdf",
    "page_number": 4,
    "text": "FIPS 205                              STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n\n    Federal Information Processing Standards Publication 205\n\n    Published:                       August 13, 2024\n    Effective:                       August 13, 2024\n\n                     Announcing the\n    Stateless Hash-Based Digital Signature Standard\n\nFederal Information Processing Standards (FIPS) publications are developed by the National\nInstitute of Standards and Technology (NIST) under 15 U.S.C. 278g-3 and issued by the Secretary\nof Commerce under 40 U.S.C. 11331.\n1.  Name of Standard. Stateless Hash-Based Digital Signature Standard (FIPS 205).\n2.  Category of Standard. Computer Security. Subcategory. Cryptography.\n3.  Explanation. This standard specifies a stateless hash-based digital signature scheme (SLH-\n    DSA) for applications that require a digital signature rather than a written signature. Additional\n    digital signature schemes are specified and approved in other NIST Special Publications and\n    FIPS publications (e.g., FIPS 186-5 [1]). A digital signature is represented in a computer as a\n    string of bits and computed using a set of rules and parameters that allow the identity of the\n    signatory and the integrity of the data to be verified. Digital signatures may be generated on\n    both stored and transmitted data.\n    Signature generation uses a private key to generate a digital signature. Signature verification\n    uses a public key that corresponds to but is not the same as the private key. Each signatory\n    possesses a private and public key pair. Public keys may be known by the public, but private\n    keys must be kept secret. Anyone can verify the signature by employing the signatoryâ€™s public\n    key. Only the user who possesses the private key can perform signature generation.\n    The digital signature is provided to the intended verifier along with the signed data. The\n    verifying entity verifies the signature by using the claimed signatoryâ€™s public key. Similar\n    procedures may be used to generate and verify signatures for both stored and transmitted\n    data.\n    This standard specifies several parameter sets for SLH-DSA that are approved for use. Addi-\n    tional parameter sets may be specified and approved in future NIST Special Publications.\n4.  Approving Authority. Secretary of Commerce.\n5.  Maintenance Agency. Department of Commerce, National Institute of Standards and Tech-\n    nology, Information Technology Laboratory (ITL).\n6.  Applicability. This standard is applicable to all federal departments and agencies for the\n    protection of sensitive unclassified information that is not subject to section 2315 of Title 10,\n    United States Code, or section 3502 (2) of Title 44, United States Code. Either this standard,\n    FIPS 204, FIPS 186-5, or NIST Special Publication 800-208 shall be used in designing and\n    implementing public-key-based signature systems that federal departments and agencies op-\n    erate or that are operated for them under contract. In the future, additional digital signature\n\n                                     i"
  },
  {
    "doc_id": "NIST.FIPS.205",
    "source_path": "data/raw_pdfs/NIST.FIPS.205.pdf",
    "page_number": 5,
    "text": "FIPS 205                                 STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n\n    schemes may be specified and approved in FIPS publications or NIST Special Publications.\n    The adoption and use of this standard are available to private and commercial organizations.\n7.  Applications. A digital signature algorithm allows an entity to authenticate the integrity of\n    signed data and the identity of the signatory. The recipient of a signed message can use a\n    digital signature as evidence in demonstrating to a third party that the signature was, in fact,\n    generated by the claimed signatory. This is known as non-repudiation since the signatory\n    cannot easily repudiate the signature at a later time. A digital signature algorithm is intended\n    for use in electronic mail, electronic funds transfer, electronic data interchange, software\n    distribution, data storage, and other applications that require data integrity assurance and\n    data origin authentication.\n8.  Implementations. A digital signature algorithm may be implemented in software, firmware,\n    hardware, or any combination thereof. NIST will develop a validation program to test imple-\n    mentations for conformance to the algorithms in this standard. For every computational\n    procedure that is specified in this standard, a conforming implementation may replace the\n    given set of steps with any mathematically equivalent process. In other words, different\n    procedures that produce the correct output for every input are permitted. Information about\n    validation programs is available at https://csrc.nist.gov/projects/cmvp. Examples for digital\n    signature algorithms are available at https://csrc.nist.gov/projects/cryptographic-standards-\n    and-guidelines/example-values.\n    Agencies are advised that digital signature key pairs shall not be used for other purposes.\n9.  Other Approved Security Functions. Digital signature implementations that comply with this\n    standard shall employ cryptographic algorithms that have been approved for protecting Fed-\n    eral Government-sensitive information. Approved cryptographic algorithms and techniques\n    include those that are either:\n    a.     Specified in a Federal Information Processing Standard (FIPS) publication,\n    b.     Adopted in a FIPS or NIST recommendation, or\n    c.     Specified in the list of approved security functions in SP 800-140C.\n10. Export Control. Certain cryptographic devices and technical data regarding them are subject\n    to federal export controls. Exports of cryptographic modules that implement this standard\n    and technical data regarding them must comply with these federal regulations and be licensed\n    by the Bureau of Industry and Security of the U.S. Department of Commerce. Information\n    about export regulations is available at https://www.bis.doc.gov.\n11. Patents. The algorithm in this standard may be covered by U.S. or foreign patents.\n12. Implementation Schedule. This standard becomes effective immediately upon final publica-\n    tion.\n13. Specifications. Federal Information Processing Standard (FIPS) 205, Stateless Hash-Based\n    Digital Signature Standard (affixed).\n\nii"
  },
  {
    "doc_id": "NIST.FIPS.205",
    "source_path": "data/raw_pdfs/NIST.FIPS.205.pdf",
    "page_number": 6,
    "text": "FIPS 205                                   STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n\n14. Qualifications. The security of a digital signature system depends on the secrecy of the\n signatoryâ€™s private keys. Signatories shall, therefore, guard against the disclosure of their\n private keys. While it is the intent of this standard to specify general security requirements for\n generating digital signatures, conformance to this standard does not ensure that a particular\n implementation is secure. It is the responsibility of an implementer to ensure that any module\n that implements a digital signature capability is designed and built in a secure manner.\n Similarly, the use of a product containing an implementation that conforms to this standard\n does not guarantee the security of the overall system in which the product is used. The re-\n sponsible authority in each agency or department shall ensure that an overall implementation\n provides an acceptable level of security.\n Since a standard of this nature must be flexible enough to adapt to advancements and\n innovations in science and technology, this standard will be reviewed every five years in order\n to assess its adequacy.\n15. Waiver Procedure. The Federal Information Security Management Act (FISMA) does not\n allow for waivers to Federal Information Processing Standards (FIPS) that are made mandatory\n by the Secretary of Commerce.\n16. Where to Obtain Copies of the Standard. This publication is available by accessing https:\n//csrc.nist.gov/publications. Other computer security publications are available at the same\nwebsite.\n17. How to Cite This Publication. NIST has assigned NIST FIPS 205 as the publication identifier\n for this FIPS, per the NIST Technical Series Publication Identifier Syntax. NIST recommends\n that it be cited as follows:\n            National Institute of Standards and Technology (2024) Stateless Hash-Based Dig-\n            ital Signature Standard. (Department of Commerce, Washington, D.C.), Fed-\n            eral Information Processing Standards Publication (FIPS) NIST FIPS 205. https:\n            //doi.org/10.6028/NIST.FIPS.205\n18. Inquiries and Comments. Inquiries and comments about this FIPS may be submitted to\n fips-205-comments@nist.gov.\n\niii"
  },
  {
    "doc_id": "NIST.FIPS.205",
    "source_path": "data/raw_pdfs/NIST.FIPS.205.pdf",
    "page_number": 7,
    "text": "FIPS 205    STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n\nFederal Information Processing Standards Publication 205\n\nStateless  Specification for the\n           Hash-Based Digital Signature Standard\n\n                                    Table of Contents\n\n1  Introduction                                                                                      1\n   1.1     Purpose and Scope     . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     1\n   1.2     Context   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     1\n\n2  Glossary of Terms, Acronyms, and Symbols                                                          2\n   2.1     Terms and Definitions     . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     2\n   2.2     Acronyms    . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     4\n   2.3     Mathematical Symbols      . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     5\n\n3  Overview of the SLH-DSA Signature Scheme                                                          7\n   3.1     Additional Requirements     . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     9\n   3.2     Implementation Considerations       . . . . . . . . . . . . . . . . . . . . . . . . .    10\n\n4  Functions and Addressing                                                                         11\n   4.1     Hash Functions and Pseudorandom Functions           . . . . . . . . . . . . . . . . .    11\n   4.2     Addresses   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .    11\n   4.3     Member Functions      . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .    14\n   4.4     Arrays, Byte Strings, and Integers    . . . . . . . . . . . . . . . . . . . . . . . .    15\n\n5  Winternitz One-Time Signature Plus Scheme                                                        17\n   5.1     WOTSâº Public-Key Generation       . . . . . . . . . . . . . . . . . . . . . . . . . .    18\n   5.2     WOTSâº Signature Generation        . . . . . . . . . . . . . . . . . . . . . . . . . .    19\n   5.3     Computing a WOTSâº Public Key From a Signature           . . . . . . . . . . . . . . .    21\n\n6  eXtended Merkle Signature Scheme (XMSS)                                                          22\n   6.1     Generating a Merkle Hash Tree       . . . . . . . . . . . . . . . . . . . . . . . . .    22\n   6.2          Generating an XMSS Signature . . . . . . . . . . . . . . . . . . . . . . . . . .    23\n   6.3             Computing an XMSS Public Key From a Signature . . . . . . . . . . . . . . . .    25\n\n7 The SLH-DSA Hypertree                                                                             26\n                                                 iv"
  },
  {
    "doc_id": "NIST.FIPS.205",
    "source_path": "data/raw_pdfs/NIST.FIPS.205.pdf",
    "page_number": 8,
    "text": "FIPS 205                                     STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n\n   7.1      Hypertree Signature Generation             . . . . . . . . . . . . . . . . . . . . . . . . .    26\n   7.2      Hypertree Signature Verification . . . . . . . . . . . . . . . . . . . . . . . . .              28\n\n8  Forest of Random Subsets (FORS)                                                                          29\n   8.1      Generating FORS Secret Values . . . . . . . . . . . . . . . . . . . . . . . . . .               29\n   8.2      Generating a Merkle Hash Tree              . . . . . . . . . . . . . . . . . . . . . . . . .    30\n   8.3      Generating a FORS Signature . . . . . . . . . . . . . . . . . . . . . . . . . . .               30\n   8.4      Computing a FORS Public Key From a Signature . . . . . . . . . . . . . . . . .                  31\n\n9  SLH-DSA Internal Functions                                                                               33\n   9.1      SLH-DSA Key Generation             . . . . . . . . . . . . . . . . . . . . . . . . . . . . .    33\n   9.2      SLH-DSA Signature Generation . . . . . . . . . . . . . . . . . . . . . . . . . .                34\n   9.3      SLH-DSA Signature Verification . . . . . . . . . . . . . . . . . . . . . . . . . .              36\n\n10 SLH-DSA External Functions                                                                               37\n   10.1     SLH-DSA Key Generation             . . . . . . . . . . . . . . . . . . . . . . . . . . . . .    37\n   10.2     SLH-DSA Signature Generation . . . . . . . . . . . . . . . . . . . . . . . . . .                37\n            10.2.1  Pure SLH-DSA Signature Generation  .  .  .  . .  .  .  .  .  .  .  .  .  . . . . . .    38\n            10.2.2  HashSLH-DSA Signature Generation   .  .  .  . .  .  .  .  .  .  .  .  .  . . . . . .    39\n   10.3     SLH-DSA Signature Verification . . . . . . . . . . . . . . . . . . . . . . . . . .              41\n\n11 Parameter Sets                                                                                           43\n   11.1     SLH-DSA Using SHAKE              . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .    44\n   11.2     SLH-DSA Using SHA2             . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .    44\n            11.2.1  SLH-DSA Using SHA2 for Security Category 1 .     .  .  .  .  .  .  .  .  . . . . . .    45\n            11.2.2  SLH-DSA Using SHA2 for Security Categories 3 and 5           .  .  .  .  . . . . . .    46\n\nReferences                                                                                                  47\n\nAppendix A â€” Differences From the SPHINCS+ Submission                                                       51\n   A.1      Changes From FIPS 205 Initial Public Draft . . . . . . . . . . . . . . . . . . . .              51\n\nv"
  },
  {
    "doc_id": "NIST.FIPS.205",
    "source_path": "data/raw_pdfs/NIST.FIPS.205.pdf",
    "page_number": 9,
    "text": "FIPS 205                                                                     STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n\n                                       List of Tables\n\nTable 1      Member functions for addresses                 . . . . . . . . . . . . . . . . . . . . . .                   14\nTable 2      SLH-DSA parameter sets                 . . . . . . . . . . . . . . . . . . . . . . . . . .                     43\nTable 3      Member functions for compressed addresses .    . . .                  . . . . . . . . . . .                    45\n\n                                       List of Figures\n\nFigure 1       An SLH-DSA signature               . . . . . . . . . . . . . . . . . . . . . . . . . . .                     8\nFigure 2       Address (ADRS)                 . . . . . . . . . . . . . . . . . . . . . . . . . . . . .                     12\nFigure 3       WOTSâº hash address                 . . . . . . . . . . . . . . . . . . . . . . . . . . .                     12\nFigure 4       WOTSâº public-key compression address   . .   . . . .                . . . . . . . . . . .                    12\nFigure 5       Hash tree address              . . . . . . . . . . . . . . . . . . . . . . . . . . . . .                     13\nFigure 6       FORS tree address              . . . . . . . . . . . . . . . . . . . . . . . . . . . . .                     13\nFigure 7       FORS tree roots compression address .  . . . . . . .                . . . . . . . . . . .                    13\nFigure 8       WOTSâº key generation address                 . . . . . . . . . . . . . . . . . . . . . .                     14\nFigure 9       FORS key generation address                . . . . . . . . . . . . . . . . . . . . . . .                     14\nFigure 10                     WOTSâº signature data format . . . . . . . . . . . . . . . . . . . . . . .                     19\nFigure 11      XMSS signature data format               . . . . . . . . . . . . . . . . . . . . . . . .                     22\nFigure 12                  Merkle hash tree . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .                   24\nFigure 13      HT signature data format               . . . . . . . . . . . . . . . . . . . . . . . . .                     26\nFigure 14      FORS signature data format               . . . . . . . . . . . . . . . . . . . . . . . .                     29\nFigure 15      SLH-DSA private key              . . . . . . . . . . . . . . . . . . . . . . . . . . . .                     33\nFigure 16                  SLH-DSA public key . . . . . . . . . . . . . . . . . . . . . . . . . . . . .                     33\nFigure 17      SLH-DSA signature data format                . . . . . . . . . . . . . . . . . . . . . .                   34\nFigure 18                        Compressed address (ADRSğ‘) . . . . . . . . . . . . . . . . . . . . . .                    45\n\n                                       List of Algorithms\nAlgorithm 1      gen_lenâ‚‚ (ğ‘›, ğ‘™ğ‘”ğ‘¤)          . . . . . . . . . . . . . . . . . . . . . . . . . . . .                     10\nAlgorithm 2      toInt(ğ‘‹, ğ‘›)            . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .                     15\nAlgorithm 3      toByte(ğ‘¥, ğ‘›)             . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .                     15\nAlgorithm 4      base_2áµ‡(ğ‘‹, ğ‘, ğ‘œğ‘¢ğ‘¡_ğ‘™ğ‘’ğ‘›)         . . . . . . . . . . . . . . . . . . . . . . . .                     16\nAlgorithm 5      chain(ğ‘‹, ğ‘–, ğ‘ , PK.seed, ADRS)                 . . . . . . . . . . . . . . . . . . .                     18\nAlgorithm 6      wots_pkGen(SK.seed, PK.seed, ADRS)                         . . . . . . . . . . . . . .                     18\nAlgorithm 7      wots_sign(ğ‘€, SK.seed, PK.seed, ADRS)                        . . . . . . . . . . . . .                     20\nAlgorithm 8                             wots_pkFromSig(ğ‘ ğ‘–ğ‘”, ğ‘€, PK.seed, ADRS) . . . . . . . . . . . . .                 21\nAlgorithm 9      xmss_node(SK.seed, ğ‘–, ğ‘§, PK.seed, ADRS)                      . . . . . . . . . . . .                     23\nAlgorithm 10                            xmss_sign(ğ‘€, SK.seed, ğ‘–ğ‘‘ğ‘¥, PK.seed, ADRS) . . . . . . . . . . .                 24\nAlgorithm 11                               xmss_pkFromSig(ğ‘–ğ‘‘ğ‘¥, SIGğ‘‹ğ‘€ğ‘†ğ‘†, ğ‘€, PK.seed, ADRS) . . . . . . .             25\nAlgorithm 12     ht_sign(ğ‘€, SK.seed, PK.seed, ğ‘–ğ‘‘ğ‘¥ğ‘¡ğ‘Ÿğ‘’ğ‘’, ğ‘–ğ‘‘ğ‘¥ğ‘™ğ‘’ğ‘ğ‘“ )     . . . . . . . . . .                     27\nAlgorithm 13                       ht_verify(ğ‘€, SIGğ»ğ‘‡, PK.seed, ğ‘–ğ‘‘ğ‘¥ğ‘¡ğ‘Ÿğ‘’ğ‘’, ğ‘–ğ‘‘ğ‘¥ğ‘™ğ‘’ğ‘ğ‘“ , PK.root) . . . . . .    28\nAlgorithm 14     fors_skGen(SK.seed, PK.seed, ADRS, ğ‘–ğ‘‘ğ‘¥)                     . . . . . . . . . . . .                     29\n\n                                                   vi"
  },
  {
    "doc_id": "NIST.FIPS.205",
    "source_path": "data/raw_pdfs/NIST.FIPS.205.pdf",
    "page_number": 10,
    "text": "FIPS 205                                         STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n\nAlgorithm 15     fors_node(SK.seed, ğ‘–, ğ‘§, PK.seed, ADRS)           . . . . . . . . . . . . .     30\nAlgorithm 16     fors_sign(ğ‘šğ‘‘, SK.seed, PK.seed, ADRS)             . . . . . . . . . . . . .     31\nAlgorithm 17     fors_pkFromSig(SIGğ¹ ğ‘‚ğ‘…ğ‘† , ğ‘šğ‘‘, PK.seed, ADRS) . . . . . . . . . .            32\nAlgorithm 18     slh_keygen_internal(SK.seed, SK.prf, PK.seed)             . . . . . . . . . .     34\nAlgorithm 19     slh_sign_internal(ğ‘€, SK, ğ‘ğ‘‘ğ‘‘ğ‘Ÿğ‘›ğ‘‘) . . . . . . . . . . . . . . . . . . .     35\nAlgorithm 20     slh_verify_internal(ğ‘€, SIG, PK)      . . . . . . . . . . . . . . . . . . . .     36\nAlgorithm 21     slh_keygen()      . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     37\nAlgorithm 22     slh_sign(ğ‘€, ğ‘ğ‘¡ğ‘¥, SK)  . . . . . . . . . . . . . . . . . . . . . . . . . .     39\nAlgorithm 23     hash_slh_sign(ğ‘€, ğ‘ğ‘¡ğ‘¥, PH, SK)   . . . . . . . . . . . . . . . . . . . . .     40\nAlgorithm 24     slh_verify(ğ‘€, SIG, ğ‘ğ‘¡ğ‘¥, PK) . . . . . . . . . . . . . . . . . . . . . . .     41\nAlgorithm 25     hash_slh_verify(ğ‘€, SIG, ğ‘ğ‘¡ğ‘¥, PH, PK)    . . . . . . . . . . . . . . . . .     42\n\nvii"
  },
  {
    "doc_id": "NIST.FIPS.205",
    "source_path": "data/raw_pdfs/NIST.FIPS.205.pdf",
    "page_number": 11,
    "text": "FIPS 205              STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n\n1.   Introduction\n\n1.1  Purpose and Scope\nThis standard defines a method for digital signature generation that can be used for the protection\nof binary data (commonly called a message) and for the verification and validation of those digital\nsignatures.Â¹ The security of the stateless hash-based digital signature algorithm (SLH-DSA) relies\non the presumed difficulty of finding preimages for hash functions as well as several related\nproperties of the same hash functions. Unlike the algorithms specified in FIPS 186-5 [1], SLH-DSA\nis designed to provide resistance against attacks from a large-scale quantum computer.\nThis standard specifies the mathematical steps that need to be performed for key generation,\nsignature generation, and signature verification. Additional assurances are required for digital\nsignatures to be valid (e.g., the assurance of identity and private key possession). SP 800-89,\nRecommendation for Obtaining Assurances for Digital Signature Applications [3], specifies the\nrequired assurances and the methods for obtaining these assurances.\n\n1.2  Context\nOver the past several years, there has been steady progress toward building quantum computers.\nThe security of many commonly used public-key cryptosystems will be at risk if large-scale\nquantum computers are ever realized. This would include key-establishment schemes and digital\nsignatures that are based on integer factorization and discrete logarithms (both over finite fields\nand elliptic curves). As a result, in 2016, NIST initiated a public Post-Quantum Cryptography\n(PQC) Standardization process to select quantum-resistant public-key cryptographic algorithms\nfor standardization. A total of 82 candidate algorithms were submitted to NIST for consideration.\nAfter three rounds of evaluation and analysis, NIST selected the first four algorithms for stan-\ndardization. These algorithms are intended to protect sensitive U.S. Government information\nwell into the foreseeable future, including after the advent of cryptographically relevant quan-\ntum computers. This standard includes the specification for one of the algorithms selected:\nSPHINCSâº, a stateless hash-based digital signature scheme. This standard contains several minor\nmodifications compared to Version 3 [4], which was submitted at the beginning of round three\nof the NIST PQC Standardization process. The changes are described in Appendix A. Throughout\nthis standard, SPHINCSâº will be referred to as SLH-DSA for stateless hash-based digital signature\nalgorithm.\n\n1NIST Special Publication (SP) 800-175B [2], Guideline for Using Cryptographic Standards in the Federal Government:\nCryptographic Mechanisms, includes a general discussion of digital signatures.\n1"
  },
  {
    "doc_id": "NIST.FIPS.205",
    "source_path": "data/raw_pdfs/NIST.FIPS.205.pdf",
    "page_number": 12,
    "text": "FIPS 205                                     STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n\n2.   Glossary of Terms, Acronyms, and Symbols\n\n2.1  Terms and Definitions\n approved               FIPS-approved and/or NIST-recommended.        An algorithm or tech-\n                        nique that is either 1) specified in a FIPS or NIST recommendation, 2)\n                        adopted in a FIPS or NIST recommendation, or 3) specified in a list of\n                        NIST-approved security functions. [1]\n big-endian             The property of a byte string having its bytes positioned in order of\n                        decreasing significance. In particular, the leftmost (first) byte is the\n                        most significant, and the rightmost (last) byte is the least significant.\n                        The term â€œbig-endianâ€ may also be applied in the same manner to bit\n                        strings. [5, adapted]\n byte string            An array of integers in which each integer is in the set {0, â€¦ , 255}.\n claimed signatory      From the verifierâ€™s perspective, the claimed signatory is the entity that\n                        purportedly generated a digital signature. [1]\n destroy                An action applied to a key or a piece of secret data. After a key or a\n                        piece of secret data is destroyed, no information about its value can\n                        be recovered. [1]\n digital signature      The result of a cryptographic transformation of data that, when prop-\n                        erly implemented, provides a mechanism for verifying origin authenti-\n                        cation, data integrity, and signatory non-repudiation. [1]\n entity                 An individual (person), organization, device, or process. Used inter-\n                        changeably with party. [1]\n equivalent process     Two processes are equivalent if the same output is produced when\n                        the same values are input to each process (either as input parameters,\n                        as values made available during the process, or both). [1]\n extendable-output      A function on bit strings in which the output can be extended to any\n function               desired length. Approved XOFs (such as those specified in FIPS 202 [6])\n                        are designed to satisfy the following properties as long as the specified\n                        output length is sufficiently long to prevent trivial attacks:\n                         1.  (One-way) It is computationally infeasible to find any input that\n                             maps to any new pre-specified output.\n                         2.  (Collision-resistant) It is computationally infeasible to find any\n                             two distinct inputs that map to the same output. [7, adapted]\n fresh random value     A previously unused output of a random bit generator.\n hash function          A function on bit strings in which the length of the output is fixed.\n                        Approved hash functions (such as those specified in FIPS 180 [8] and\n                        FIPS 202 [6]) are designed to satisfy the following properties:\n\n2"
  },
  {
    "doc_id": "NIST.FIPS.205",
    "source_path": "data/raw_pdfs/NIST.FIPS.205.pdf",
    "page_number": 13,
    "text": "FIPS 205                                   STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n\n                     1.  (One-way) It is computationally infeasible to find any input that\n                         maps to any new pre-specified output\n                     2.  (Collision-resistant) It is computationally infeasible to find any\n                         two distinct inputs that map to the same output. [1]\nhash value          See message digest.\nkey                 A parameter used in conjunction with a cryptographic algorithm that\n                    determines its operation. Examples applicable to this standard include:\n                     1.   The computation of a digital signature from data, and\n                     2.   The verification of a digital signature. [1]\nkey pair            A public key and its corresponding private key. [1]\nmessage             The data that is signed. Also known as signed data during the signature\n                    verification and validation process. [1]\nmessage digest      The result of applying a hash function to a message. Also known as a\n                    hash value. [1]\nnon-repudiation     A service that is used to provide assurance of the integrity and origin\n                    of data in such a way that the integrity and origin can be verified and\n                    validated by a third party as having originated from a specific entity in\n                    possession of the private key (i.e., the signatory). [1]\nowner               A key pair owner is the entity authorized to use the private key of a\n                    key pair. [1]\nparty               An individual (person), organization, device, or process. Used inter-\n                    changeably with entity. [1]\nprivate key         A cryptographic key that is used with an asymmetric (public-key) cryp-\n                    tographic algorithm. The private key is uniquely associated with the\n                    owner and is not made public. The private key is used to compute a\n                    digital signature that may be verified using the corresponding public\n                    key. [1]\npseudorandom        A process or data produced by a process is said to be pseudorandom\n                    when the outcome is deterministic yet also effectively random as long\n                    as the internal action of the process is hidden from observation. For\n                    cryptographic purposes, â€œeffectively randomâ€ means â€œcomputation-\n                    ally indistinguishable from random within the limits of the intended\n                    security strength.â€ [1]\npublic key          A cryptographic key that is used with an asymmetric (public-key) cryp-\n                    tographic algorithm and is associated with a private key. The public\n                    key is associated with an owner and may be made public. In the case\n                    of digital signatures, the public key is used to verify a digital signature\n                    that was generated using the corresponding private key. [1]\n\n3"
  },
  {
    "doc_id": "NIST.FIPS.205",
    "source_path": "data/raw_pdfs/NIST.FIPS.205.pdf",
    "page_number": 14,
    "text": "FIPS 205                                       STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n\nsecurity category        A number associated with the security strength of a post-quantum\n                         cryptographic algorithm, as specified by NIST (see [9, Sect. 5.6]).\nsecurity strength        A number associated with the amount of work (i.e., the number of\n                         operations) that is required to break a cryptographic algorithm or\n                         system. [1]\nshall                    Used to indicate a requirement of this standard. [1]\nshould                   Used to indicate a strong recommendation but not a requirement of\n                         this standard. Ignoring the recommendation could result in undesir-\n                         able results. [1]\nsignatory                The entity that generates a digital signature on data using a private\n                         key. [1]\nsignature generation     The process of using a digital signature algorithm and a private key to\n                         generate a digital signature on data. [1]\nsignature validation     The (mathematical) verification of the digital signature and obtain-\n                         ing the appropriate assurances (e.g., public-key validity, private-key\n                         possession, etc.). [1]\nsignature verification   The process of using a digital signature algorithm and a public key to\n                         verify a digital signature on data. [1]\nsigned data              The data or message upon which a digital signature has been computed.\n                         Also see message. [1]\nverifier                 The entity that verifies the authenticity of a digital signature using the\n                         public key. [1]\n\n2.2    Acronyms\nADRS                     Address\nADRSá¶œ                    Compressed Address\nAES                      Advanced Encryption Standard\nDER                      Distinguished Encoding Rules\nFIPS                     Federal Information Processing Standard\nFORS                     Forest of Random Subsets\nITL                      Information Technology Laboratory\nMGF                      Mask Generation Function\nNIST                     National Institute of Standards and Technology\nOID                      Object Identifier\nPQC                      Post-Quantum Cryptography\nPRF                      Pseudorandom Function\n\n                                               4"
  },
  {
    "doc_id": "NIST.FIPS.205",
    "source_path": "data/raw_pdfs/NIST.FIPS.205.pdf",
    "page_number": 15,
    "text": "FIPS 205                              STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n\nSHA            Secure Hash Algorithm\nSHAKE          Secure Hash Algorithm KECCAK\nSP             Special Publication\nRFC            Request for Comments\nWOTSâº          Winternitz One-Time Signature Plus\nXMSS           eXtended Merkle Signature Scheme\nXOF            eXtendable-Output Function\n\n2.3     Mathematical Symbols\nğ‘‹ âˆ¥ ğ‘Œ        The concatenation of two arrays ğ‘‹ and ğ‘Œ. If ğ‘‹ is an array of length â„“ğ‘¥ ,\n               and ğ‘Œ is an array of length â„“ğ‘¦, then ğ‘ = ğ‘‹ âˆ¥ ğ‘Œ is an array of length\n               â„“ğ‘¥ + â„“ğ‘¦ such that\n\n                            ğ‘[ğ‘–] = { ğ‘‹[ğ‘–]          if  0 â‰¤ ğ‘– < â„“ğ‘¥\n                                    ğ‘Œ [ğ‘– âˆ’ â„“ğ‘¥ ]     if  â„“ğ‘¥ â‰¤ ğ‘– < â„“ğ‘¥ + â„“ğ‘¦.\n\nğ‘‹[ğ‘– âˆ¶ ğ‘—]     A subarray of ğ‘‹. If ğ‘‹ is an array of length â„“ğ‘¥ , 0 â‰¤ ğ‘– < ğ‘— â‰¤ â„“ğ‘¥ , and\n               ğ‘Œ   = ğ‘‹[ğ‘– âˆ¶ ğ‘—], then ğ‘Œ is an array of length ğ‘— âˆ’ ğ‘– such that ğ‘Œ [ğ‘˜] =\n               ğ‘‹[ğ‘– + ğ‘˜] for 0 â‰¤ ğ‘˜ < ğ‘— âˆ’ ğ‘–.\nTruncâ„“(ğ‘‹)     A truncation function that outputs the leftmost â„“ bytes of the input\n               byte string ğ‘‹. If ğ‘Œ = Truncâ„“(ğ‘‹), then ğ‘Œ is a byte string (array) of\n               length â„“ such that ğ‘Œ [ğ‘–] = ğ‘‹[ğ‘–] for 0 â‰¤ ğ‘– < â„“ (i.e., ğ‘Œ = ğ‘‹[0 âˆ¶ â„“]).\n|ğ‘‹|           The length (in bytes) of byte string ğ‘‹.\nâŒˆğ‘âŒ‰           The ceiling of ğ‘; the smallest integer that is greater than or equal to ğ‘.\n               For example, âŒˆ5âŒ‰ = 5, âŒˆ5.3âŒ‰ = 6, and âŒˆâˆ’2.1âŒ‰ = âˆ’2. [1]\nâŒŠğ‘âŒ‹           The floor of ğ‘; the largest integer that is less than or equal to ğ‘. For\n               example, âŒŠ5âŒ‹ = 5, âŒŠ5.3âŒ‹ = 5, and âŒŠâˆ’2.1âŒ‹ = âˆ’3. [1]\nğ‘ mod ğ‘›      The unique remainder ğ‘Ÿ, 0 â‰¤ ğ‘Ÿ â‰¤ (ğ‘› âˆ’ 1), when integer ğ‘ is divided\n               by the positive integer ğ‘›. For example, 23 mod 7 = 2. [1]\nğ‘ â‹… ğ‘        The product of ğ‘ and ğ‘. For example, 3 â‹… 5 = 15.\nğ‘ğ‘           ğ‘ raised to the power ğ‘. For example, 2âµ = 32.\nlogâ‚‚ ğ‘¥        The base 2 logarithm of ğ‘¥. For example, logâ‚‚(16) = 4.\n0b             The prefix to a number that is represented in binary.\n0x             The prefix to a number that is represented in hexadecimal. [1, adapted]\nğ‘ â‰« ğ‘        The logical right shift of ğ‘ by ğ‘ positions (i.e., ğ‘ â‰« ğ‘ =   ğ‘\n                                                                                âŒŠğ‘/2 âŒ‹). For\n               example, 0x73 â‰« 4 = 7. [10, adapted]\n\n                                     5"
  },
  {
    "doc_id": "NIST.FIPS.205",
    "source_path": "data/raw_pdfs/NIST.FIPS.205.pdf",
    "page_number": 16,
    "text": "FIPS 205      STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n\nğ‘ â‰ª ğ‘       The logical left shift of ğ‘ by ğ‘ positions (i.e., ğ‘ â‰ª ğ‘ = ğ‘ â‹… 2ğ‘). For\n              example, 0x73 â‰ª 4 = 0x730. [10, adapted]\nğ‘ âŠ• ğ‘       The bitwise exclusive-or of ğ‘ and ğ‘. For example, 115 âŠ• 1 = 114\n              (115 âŠ• 1 = 0b01110011 âŠ• 0b00000001 = 0b01110010 = 114).\nğ‘  â† ğ‘¥       In pseudocode, this notation means that the variable ğ‘  is set to the\n              value of the expression ğ‘¥.\nğ‘    $      ğ‘›\n   â†\n     âˆ’ ğ”¹     In pseudocode, this notation means that the variable ğ‘  is set to a\n              byte string of length ğ‘› chosen at random. A fresh random value is\n              generated for each time this step is performed.\nâŠ¥             A symbol indicating failure or the lack of output from an algorithm.\n\n6"
  },
  {
    "doc_id": "NIST.FIPS.205",
    "source_path": "data/raw_pdfs/NIST.FIPS.205.pdf",
    "page_number": 17,
    "text": "FIPS 205                                STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n\n3.  Overview of the SLH-DSA Signature Scheme\n\nSLH-DSA is a stateless hash-based signature scheme that is constructed using other hash-based\nsignature schemes as components: (1) a few-time signature scheme, forest of random subsets\n(FORS), and (2) a multi-time signature scheme, the eXtended Merkle Signature Scheme (XMSS).\n                              XMSS is constructed using the hash-based one-time signature scheme Winternitz One-Time\nSignature Plus (WOTSâº) as a component.Â²\nConceptually, an SLH-DSA key pair consists of a very large set of FORS key pairs.Â³ The few-time\nsignature scheme FORS allows each key pair to safely sign a small number of messages. An\nSLH-DSA signature is created by computing a randomized hash of the message, using part of the\nresulting message digest to pseudorandomly select a FORS key, and signing the remaining part of\nthe message digest with that key. An SLH-DSA signature consists of the FORS signature and the\ninformation that authenticates the FORS public key. The authentication information is created\nusing XMSS signatures.\n                         XMSS is a multi-time signature scheme that is created using a combination of WOTSâº one-time\nsignatures and Merkle hash trees [13]. An XMSS key consists of 2â„â€² WOTSâº keys and can sign\n2â„â€² messages. The WOTSâº public keys are formed into a Merkle hash tree, and the root of the\ntree is the XMSS public key. (The Merkle hash tree formed from the WOTSâº keys is also referred\nto as an XMSS tree.) An XMSS signature consists of a WOTSâº signature and an authentication\npath within the Merkle hash tree for the WOTSâº public key.                          In Figure 1, triangles represent\n                       XMSS trees, squares represent the WOTSâº public keys, and circles represent the interior nodes\nof the hash tree.                       Within an XMSS tree, the square and circles that are filled in represent the\nauthentication path for the WOTSâº public key needed to verify the signature.\n                     The authentication information for a FORS public key is a hypertree signature. A hypertree is a\ntree of XMSS trees, as depicted in Figure 1. The tree consists of ğ‘‘ layersâ´ in which the top layer\n(layer ğ‘‘ âˆ’ 1) consists of a single XMSS tree, the next layer down (layer ğ‘‘ âˆ’ 2) consists of 2â„â€²\n                  XMSS trees, and the lowest layer (layer 0) consists of 2(ğ‘‘âˆ’1)â„â€² XMSS trees. The public key of each\nXMSS key at layers 0 through ğ‘‘ âˆ’ 2 is signed by an XMSS key at the next higher layer. The XMSS\nkeys at layer 0 collectively have 2ğ‘‘â„â€²                          = 2â„ WOTSâº keys, which are used to sign the 2â„ FORS\npublic keys in the SLH-DSA key pair. The sequence of ğ‘‘ XMSS signatures needed to authenticate\na FORS public key when starting with the public key of the XMSS key at layer ğ‘‘ âˆ’ 1 is a hypertree\nsignature. An SLH-DSA signature consists of a FORS signature along with a hypertree signature.\n                         An SLH-DSA public key (Figure 16) contains two ğ‘›-byte components: (1) PK.root, which is the\npublic key of the XMSS key at layer ğ‘‘ âˆ’ 1, and (2) PK.seed, which is used to provide domain\nseparation between different SLH-DSA key pairs. An SLH-DSA private key (Figure 15) consists of\nan ğ‘›-byte seed SK.seed that is used to pseudorandomly generate all of the secret values for the\n                       WOTSâº and FORS keys and an ğ‘›-byte key SK.prf that is used in the generation of the randomized\nhash of the message. An SLH-DSA private key also includes copies of PK.root and PK.seed, as\nthese values are needed during both signature generation and signature verification.\n\n2The WOTS+ and XMSS schemes that are used as components of SLH-DSA are not the same as the WOTS+ and\nXMSS schemes in RFC 8391 [11] and SP 800-208 [12].\n3For the parameter sets in this standard, an SLH-DSA key pair contains 263 , 264 , 266 , or 268 FORS keys, which are\npseudorandomly generated from a single seed.\n4For the parameter sets in this standard, ğ‘‘ is 7, 8, 17, or 22.\n                                                  7"
  },
  {
    "doc_id": "NIST.FIPS.205",
    "source_path": "data/raw_pdfs/NIST.FIPS.205.pdf",
    "page_number": 18,
    "text": "    FIPS 205    STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n\n                PK.root\n\n                layer ğ‘‘ âˆ’ 1 = 2\n\n    WOTSâº signature\n\n    layer 1\n\n                   Merkle tree node\nWOTSâº signature    WOTSâº public key\n\n        layer 0    FORS public key\n\n    WOTSâº signature\n\n    FORS signature\n    Message\n\n                          Figure 1. An SLH-DSA signature\n\n    The WOTSâº one-time signature scheme is specified in Section 5, and the XMSS multi-time sig-\n    nature scheme is specified in Section 6. Section 7 specifies the generation and verification of\n    hypertree signatures. The FORS few-time signature scheme is specified in Section 8.   Finally,\n    Section 9 specifies the SLH-DSA key generation, signature, and verification functions. As the\n     WOTSâº, XMSS, hypertree, and FORS schemes described in this standard are not intended for\n    use as stand-alone signature schemes, only the components of the schemes necessary to imple-\n    ment SLH-DSA are described. In particular, these sections do not include functions for key pair\n    generation, and a signature verification function is only specified for hypertree signatures.\n    When used in this standard, WOTSâº, XMSS, and FORS signatures are implicitly verified using\n    functions to generate public keys from messages and signatures (see Sections 5.3, 6.3, and\n    8.4). When verifying an SLH-DSA signature, the randomized hash of the message and the FORS\n    signature are used to compute a candidate FORS public key. The candidate FORS public key and\n    the WOTSâº signature from the layer 0 XMSS key are used to compute a candidate WOTSâº public\n    key, which is then used in conjunction with the corresponding authentication path to compute a\n    candidate XMSS public key. The candidate layer 0 XMSS public key is used along with the layer 1\n\n                                                8"
  },
  {
    "doc_id": "NIST.FIPS.205",
    "source_path": "data/raw_pdfs/NIST.FIPS.205.pdf",
    "page_number": 19,
    "text": "FIPS 205                             STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n\nXMSS signature to compute a candidate layer 1 XMSS public key. This process is repeated until a\ncandidate layer ğ‘‘ âˆ’ 1 public key has been computed. SLH-DSA signature verification succeeds if\nthe computed candidate layer ğ‘‘ âˆ’ 1 XMSS public key is the same as the SLH-DSA public key root\nPK.root.\n\n3.1  Additional Requirements\nThis section specifies requirements for cryptographic modules that implement SLH-DSA. Sec-\ntion 3.2 discusses issues that implementers of cryptographic modules should take into considera-\ntion but that are not requirements. SP 800-89, Recommendation for Obtaining Assurances for\nDigital Signature Applications [3], specifies requirements that apply to the use of digital signature\nschemes.\n\nRandomness generation. SLH-DSA key generation (Algorithm 21) requires the generation of three\nrandom ğ‘›-byte values: PK.seed, SK.seed, and SK.prf, where ğ‘› is 16, 24, or 32, depending on\nthe parameter set. For each invocation of key generation, each of these values shall be a fresh\n(i.e., not previously used) random value generated using an approved random bit generator\n(RBG), as prescribed in SP 800-90A, SP 800-90B, and SP 800-90C [14, 15, 16]. Moreover, the RBG\nused shall have a security strength of at least 8ğ‘› bits. See Table 2 for the value of ğ‘› for each\nparameter set.\n\nDestruction of sensitive data. Data used internally by key generation and signing algorithms in\nintermediate computation steps could be used by an adversary to gain information about the\nprivate key and thereby compromise security. The data used internally by verification algorithms\nis similarly sensitive for some applications, including the verification of signatures that are used as\nbearer tokens (i.e., authentication secrets) or signatures on plaintext messages that are intended\nto be confidential. Intermediate values of the verification algorithm may reveal information\nabout its inputs (i.e., the message, signature, and public key), and in some applications, security\nor privacy requires one or more of these inputs to be confidential. Therefore, implementations of\nSLH-DSA shall ensure that any local copies of the inputs and any potentially sensitive intermediate\ndata are destroyed as soon as they are no longer needed.\n\nKey checks. SP 800-89 imposes requirements for the assurance of public-key validity and private-\nkey possession. In the case of SLH-DSA, where public-key validation is required, implementations\nshall verify that the public key is 2ğ‘› bytes in length. When the assurance of private key possession\nis obtained via regeneration, the owner of the private key shall check that the private key is 4ğ‘›\nbytes in length and shall use SK.seed and PK.seed to recompute PK.root and compare the\nnewly generated value with the value in the private key currently held.\n\nFloating-point arithmetic. Implementations of SLH-DSA shall not use floating-point arithmetic,\nas rounding errors in floating point operations may lead to incorrect results in some cases. In all\npseudocode in this standard in which division is performed (e.g., ğ‘¥/ğ‘¦) and ğ‘¦ may not divide ğ‘¥,\neither âŒŠğ‘¥/ğ‘¦âŒ‹ or âŒˆğ‘¥/ğ‘¦âŒ‰ is used. Both of these can be computed without floating-point arithmetic,\nas ordinary integer division ğ‘¥/ğ‘¦ computes âŒŠğ‘¥/ğ‘¦âŒ‹, and âŒˆğ‘¥/ğ‘¦âŒ‰ = âŒŠ(ğ‘¥ + ğ‘¦ âˆ’ 1)/ğ‘¦âŒ‹ for non-negative\nintegers ğ‘¥ and positive integers ğ‘¦.\n\n9"
  },
  {
    "doc_id": "NIST.FIPS.205",
    "source_path": "data/raw_pdfs/NIST.FIPS.205.pdf",
    "page_number": 20,
    "text": "FIPS 205                                                 STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n\nWhile the value of ğ‘™ğ‘’ğ‘›â‚‚ (see Equation 5.3) may be computed without using floating-point arith-\nmetic (see Algorithm 1), it is recommended that this value be precomputed. For all parameter\nsets in this standard, ğ‘™ğ‘’ğ‘›â‚‚ is 3.\n\nAlgorithm 1 gen_lenâ‚‚ (ğ‘›, ğ‘™ğ‘”ğ‘¤)\nComputes ğ‘™ğ‘’ğ‘›â‚‚ (Equation 5.3).\nInput: Security parameter ğ‘›, bits per hash chain ğ‘™ğ‘”ğ‘¤.\nOutput: ğ‘™ğ‘’ğ‘›â‚‚.\n 1:    ğ‘¤ â† 2ğ‘™ğ‘”ğ‘¤                                                   â–· Equation 5.1\n 2:    ğ‘™ğ‘’ğ‘›â‚ â† âŒŠ 8â‹…ğ‘›+ğ‘™ğ‘”ğ‘¤âˆ’1 âŒ‹                                    â–· Equation 5.2\n                       ğ‘™ğ‘”ğ‘¤\n 3:    ğ‘šğ‘ğ‘¥_ğ‘â„ğ‘’ğ‘ğ‘˜ğ‘ ğ‘¢ğ‘š = ğ‘™ğ‘’ğ‘›â‚ â‹… (ğ‘¤ âˆ’ 1)       â–· maximum possible checksum value\n 4:    ğ‘™ğ‘’ğ‘›â‚‚ â† 1                                       â–· maximum value that may be signed using\n 5:    ğ‘ğ‘ğ‘ğ‘ğ‘ğ‘–ğ‘¡ğ‘¦ â† ğ‘¤                             â–· ğ‘™ğ‘’ğ‘›â‚‚ hash chains is ğ‘¤ğ‘™ğ‘’ğ‘›â‚‚ âˆ’ 1 = ğ‘ğ‘ğ‘ğ‘ğ‘ğ‘–ğ‘¡ğ‘¦ âˆ’ 1\n 6:    while ğ‘ğ‘ğ‘ğ‘ğ‘ğ‘–ğ‘¡ğ‘¦ â‰¤ ğ‘šğ‘ğ‘¥_ğ‘â„ğ‘’ğ‘ğ‘˜ğ‘ ğ‘¢ğ‘š do\n 7:     ğ‘™ğ‘’ğ‘›â‚‚ â† ğ‘™ğ‘’ğ‘›â‚‚ + 1\n 8:     ğ‘ğ‘ğ‘ğ‘ğ‘ğ‘–ğ‘¡ğ‘¦ â† ğ‘ğ‘ğ‘ğ‘ğ‘ğ‘–ğ‘¡ğ‘¦ â‹… ğ‘¤\n 9:    end while\n10:    return ğ‘™ğ‘’ğ‘›â‚‚\n\n3.2    Implementation Considerations\nThis section discusses some implementation considerations for SLH-DSA.\n\nDo not support component use. As WOTSâº, XMSS, FORS, and hypertree signature schemes are\nnot approved for use as stand-alone signature schemes, cryptographic modules should not make\ninterfaces to these components available to applications. SP 800-208 [12] specifies approved\nstateful hash-based signature schemes.\n\nSide-channel and fault attacks. For signature schemes, the secrecy of the private key is critical.\nCare must be taken to protect implementations against attacks, such as side-channel attacks\nor fault attacks [17, 18, 19, 20, 21]. A cryptographic device may leak critical information with\nside-channel analysis or attacks that allow internal data or keying material to be extracted without\nbreaking the cryptographic primitives.\n\n10"
  },
  {
    "doc_id": "NIST.FIPS.205",
    "source_path": "data/raw_pdfs/NIST.FIPS.205.pdf",
    "page_number": 21,
    "text": "FIPS 205                                      STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n\n4.   Functions and Addressing\n\n4.1  Hash Functions and Pseudorandom Functions\nThe specification of SLH-DSA makes use of six functions â€” PRFğ‘šğ‘ ğ‘”, Hğ‘šğ‘ ğ‘”, PRF, Tâ„“, H, and\nF â€” that are all implemented using hash functions or XOFs with fixed output lengths. The inputs\nand output of each function are byte strings. In the following definitions, ğ”¹ = {0, â€¦ , 255}\ndenotes the set of all bytes, ğ”¹ğ‘› denotes the set of byte strings of length ğ‘› bytes, and ğ”¹âˆ— denotes\nthe set of all byte strings. The ADRS input is described in Section 4.2.\n    â€¢ PRFğ‘šğ‘ ğ‘”(SK.prf, ğ‘œğ‘ğ‘¡_ğ‘Ÿğ‘ğ‘›ğ‘‘, ğ‘€ ) (ğ”¹ğ‘› Ã— ğ”¹ğ‘› Ã— ğ”¹âˆ— â†’ ğ”¹ğ‘›) is a pseudorandom function\n     (PRF) that generates the randomizer (ğ‘…) for the randomized hashing of the message to be\n     signed.\n    â€¢ Hğ‘šğ‘ ğ‘”(ğ‘…, PK.seed, PK.root, ğ‘€ ) (ğ”¹ğ‘› Ã— ğ”¹ğ‘› Ã— ğ”¹ğ‘› Ã— ğ”¹âˆ— â†’ ğ”¹ğ‘š ) is used to generate the\n     digest of the message to be signed.\n    â€¢ PRF(PK.seed, SK.seed, ADRS) (ğ”¹ğ‘› Ã— ğ”¹ğ‘› Ã— ğ”¹Â³Â²            â†’ ğ”¹ğ‘›) is a PRF that is used to\n     generate the secret values in WOTSâº and FORS private keys.\n    â€¢ Tâ„“(PK.seed, ADRS, ğ‘€â„“) (ğ”¹ğ‘› Ã— ğ”¹Â³Â² Ã— ğ”¹â„“ğ‘› â†’ ğ”¹ğ‘›) is a hash function that maps an\n     â„“ğ‘›-byte message to an ğ‘›-byte message.\n    â€¢ H(PK.seed, ADRS, ğ‘€â‚‚) (ğ”¹ğ‘› Ã— ğ”¹Â³Â² Ã— ğ”¹2ğ‘› â†’ ğ”¹ğ‘›) is a special case of Tâ„“ that takes a\n     2ğ‘›-byte message as input.\n    â€¢ F(PK.seed, ADRS, ğ‘€â‚) (ğ”¹ğ‘› Ã— ğ”¹Â³Â² Ã— ğ”¹ğ‘› â†’ ğ”¹ğ‘›) is a hash function that takes an ğ‘›-byte\n     message as input and produces an ğ‘›-byte output.\nThe specific instantiations for these functions differ for different parameter sets and are specified\nin Section 11.\n\n4.2  Addresses\nFour of the functions described in Section 4.1 take a 32-byte address (i.e., ADRS) as input. An\nADRS consists of public values that indicate the position of the value being computed by the\nfunction. A different ADRS value is used for each call to each function. In the case of PRF,\nthis is used to generate a large number of different secret values from a single seed. In the case\nof Tâ„“, H, and F, it is used to mitigate multi-target attacks. In the pseudocode, where addresses\nare passed as parameters, they may be passed either by reference or by value.\nThe structure of an ADRS conforms to word boundaries, with each word being 4 bytes long\nand values encoded as unsigned integers in big-endian byte order (see Figure 2). The first word\nof ADRS specifies the layer address, which is the height of an XMSS tree within the hypertree.\nTrees on the bottom layer have a height of zero, and the single XMSS tree at the top has a height\nof ğ‘‘ âˆ’ 1 (see Figure 1). The next three words of ADRS specify the tree address, which is the\nposition of an XMSS tree within a layer of the hypertree. The leftmost XMSS tree in a layer has a\ntree address of zero, and the rightmost XMSS tree in layer ğ¿ has a tree address of 2(ğ‘‘âˆ’1âˆ’ğ¿)â„â€² âˆ’ 1.\nThe next word is used to specify the type of the address, which differs depending on the use case.\n\n                                            11"
  },
  {
    "doc_id": "NIST.FIPS.205",
    "source_path": "data/raw_pdfs/NIST.FIPS.205.pdf",
    "page_number": 22,
    "text": "FIPS 205    STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n\nThere are seven different types of address used in SLH-DSA, as described below.âµ The address\ntype determines how the final 12 bytes of the address are to be interpreted. The algorithms\nin this standard are written based on the assumption that whenever the type in an ADRS is\nchanged, the final 12 bytes of the address are initialized to zero.\n\n                            layer address            4 bytes\n\n                             tree address           12 bytes\n\n                                       ğ‘¡ğ‘¦ğ‘ğ‘’      4 bytes\n\n                                                    12 bytes\n\n                                                                Figure 2. Address (ADRS)\n\n                            The type is set to WOTS_HASH (i.e., ğ‘¡ğ‘¦ğ‘ğ‘’ = 0) for a WOTSâº hash address (see Figure 3), which is\nused when computing hash chains in WOTSâº. When type is WOTS_HASH, the next word encodes\nthe key pair address, which is the index of the WOTSâº key pair within the XMSS tree specified\nby the layer and tree addresses, with the leftmost WOTSâº key having an index of zero and the\nrightmost WOTSâº key having an index of 2â„â€² âˆ’ 1. Next is the chain address, which encodes the\nindex of the chain within WOTSâº, followed by the hash address, which encodes the address of\nthe hash function within the chain.\n layer address                                                layer address\n\n tree address                                                  tree address\n\n ğ‘¡ğ‘¦ğ‘ğ‘’ = 0 (WOTS_HASH)                                   ğ‘¡ğ‘¦ğ‘ğ‘’ = 1 (WOTS_PK)\n   key pair address         4 bytes                          key pair address  4 bytes\n    chain address           4 bytes                            ğ‘ğ‘ğ‘‘ğ‘‘ğ‘–ğ‘›ğ‘” = 0  8 bytes\n     hash address           4 bytes\n\n Figure 3. WOTSâº hash address          Figure 4. WOTSâº public-key compression address\n\nThe type is set to WOTS_PK (i.e., ğ‘¡ğ‘¦ğ‘ğ‘’ = 1) when compressing WOTSâº public keys (see Figure 4).\n                              As when the type is WOTS_HASH, the next word encodes the index of the WOTSâº key pair within\nthe XMSS tree specified by the layer and tree addresses. The remaining two words of ADRS\nare not needed and are set to zero.\n                              The type is set to TREE (i.e., ğ‘¡ğ‘¦ğ‘ğ‘’ = 2) when computing the hashes within the XMSS tree (see\nFigure 5). For this type of address, the next word is always set to zero. The following word\n5The type word will have a value of 0, 1, 2, 3, 4, 5, or 6. In order to improve readability, these values will be\n referred to in this standard by the constants WOTS_HASH, WOTS_PK, TREE, FORS_TREE, FORS_ROOTS, WOTS_PRF,\n and FORS_PRF, respectively.\n                                                 12"
  },
  {
    "doc_id": "NIST.FIPS.205",
    "source_path": "data/raw_pdfs/NIST.FIPS.205.pdf",
    "page_number": 23,
    "text": "FIPS 205                                     STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n\nencodes the height of the node within the tree that is being computed, and the final word\nencodes the index of the node at that height.\n\n                            layer address\n\n                             tree address\n\n                           ğ‘¡ğ‘¦ğ‘ğ‘’ = 2 (TREE)\n                             ğ‘ğ‘ğ‘‘ğ‘‘ğ‘–ğ‘›ğ‘” = 0     4 bytes\n                             tree height            4 bytes\n                              tree index            4 bytes\n\n                                                             Figure 5. Hash tree address\n\n                            The type is set to FORS_TREE (i.e., ğ‘¡ğ‘¦ğ‘ğ‘’ = 3) when computing hashes within the FORS tree (see\n                            Figure 6). The next word is the key pair address, which encodes the FORS key that is used. The\n                              value is the same as the key pair address for the WOTSâº key used to sign the FORS key (see\n                            Figure 3 and Figure 4). The next two words â€” the tree height and tree index â€” encode the node\nwithin the FORS tree that is being computed. The tree height starts with zero for the leaf nodes.\n                            The tree index is counted continuously across the ğ‘˜ different FORS trees. The leftmost node in\n                           the leftmost tree has an index of zero, and the rightmost node in the rightmost tree at level ğ‘—\nhas an index of ğ‘˜ â‹… 2(ğ‘âˆ’ğ‘—) âˆ’ 1, where ğ‘ is the height of the tree.\n\n layer address = 0                                    layer address = 0\n\n    tree address                                         tree address\n\nğ‘¡ğ‘¦ğ‘ğ‘’ = 3 (FORS_TREE)                            ğ‘¡ğ‘¦ğ‘ğ‘’ = 4 (FORS_ROOTS)\n  key pair address         4 bytes                     key pair address  4 bytes\n    tree height            4 bytes                       ğ‘ğ‘ğ‘‘ğ‘‘ğ‘–ğ‘›ğ‘” = 0  8 bytes\n            tree index     4 bytes\n\n            Figure 6. FORS tree address      Figure 7. FORS tree roots compression address\n\n                              The type is set to FORS_ROOTS (i.e., ğ‘¡ğ‘¦ğ‘ğ‘’ = 4) when compressing the ğ‘˜ FORS tree roots (see\n                            Figure 7). The next word is the key pair address, which has the same meaning as it does in the\nFORS_TREE address. The remaining two words of ADRS are not needed and are set to zero.\n                            The type is set to WOTS_PRF (i.e., ğ‘¡ğ‘¦ğ‘ğ‘’ = 5) when generating secret values for WOTSâº keys (see\n                            Figure 8). The values for the other words in the address are set to the same values as for the\nWOTS_HASH address (Figure 3) used for the chain. The hash address is always set to zero.\n\n13"
  },
  {
    "doc_id": "NIST.FIPS.205",
    "source_path": "data/raw_pdfs/NIST.FIPS.205.pdf",
    "page_number": 24,
    "text": "    FIPS 205                                    STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n\n                layer address                  layer address = 0\n\n                tree address                      tree address\n\n     ğ‘¡ğ‘¦ğ‘ğ‘’ = 5 (WOTS_PRF)                  ğ‘¡ğ‘¦ğ‘ğ‘’ = 6 (FORS_PRF)\n       key pair address              4 bytes    key pair address          4 bytes\n        chain address                4 bytes    tree height = 0           4 bytes\n                hash address = 0     4 bytes       tree index             4 bytes\n\n     Figure 8. WOTSâº key generation address     Figure 9. FORS key generation address\n\n    The type is set to FORS_PRF (i.e., ğ‘¡ğ‘¦ğ‘ğ‘’ = 6) when generating secret values for FORS keys (see\n    Figure 9). The values for the other words in the address are set to the same values as for the\n    FORS_TREE address (Figure 6) used for the same leaf node.\n\n    4.3  Member Functions\n    The algorithms in this standard make use of member functions. If a complex data structure\n    (e.g., an ADRS) contains a component ğ‘‹, then ADRS.getX() returns the value of ğ‘‹, and\n    ADRS.setX(ğ‘Œ) sets the component ğ‘‹ in ADRS to the value held by ğ‘Œ. If a data structure ğ‘ \n    contains multiple instances of ğ‘‹, then ğ‘ .getX(ğ‘–) returns the value of the ğ‘–áµ—Ê° instance of ğ‘‹ in ğ‘ .\n    For example, if ğ‘  is a FORS signature (Figure 14), then ğ‘ .getAUTH(ğ‘–) returns the authentication\n    path for the ğ‘–áµ—Ê° tree.\n    Whenever the type in an address changes, the final 12 bytes of the address are initialized to zero.\n    The member function ADRS.setTypeAndClear(ğ‘Œ) for addresses sets the ğ‘¡ğ‘¦ğ‘ğ‘’ of the ADRS to\n    ğ‘Œ and sets the final 12 bytes of the ADRS to zero.â¶\n    Table 1 shows alternative notation for each of the member functions that operates on addresses.\n\n                                 Table 1. Member functions for addresses\n\nMember function\nADRS.setLayerAddress(ğ‘™)\nADRS.setTreeAddress(ğ‘¡)\nADRS.setTypeAndClear(ğ‘Œ)\nADRS.setKeyPairAddress(ğ‘–)\nADRS.setChainAddress(ğ‘–)\nADRS.setTreeHeight(ğ‘–)\nADRS.setHashAddress(ğ‘–)\nADRS.setTreeIndex(ğ‘–)\nğ‘– â† ADRS.getKeyPairAddress()\nğ‘– â† ADRS.getTreeIndex()\n Expanded notation\nADRS â† toByte(ğ‘™, 4) âˆ¥ ADRS[4 âˆ¶ 32]\nADRS â† ADRS[0 âˆ¶ 4] âˆ¥ toByte(ğ‘¡, 12) âˆ¥ ADRS[16 âˆ¶ 32]\nADRS â† ADRS[0 âˆ¶ 16] âˆ¥ toByte(ğ‘Œ , 4) âˆ¥ toByte(0, 12)\nADRS â† ADRS[0 âˆ¶ 20] âˆ¥ toByte(ğ‘–, 4) âˆ¥ ADRS[24 âˆ¶ 32]\nADRS â† ADRS[0 âˆ¶ 24] âˆ¥ toByte(ğ‘–, 4) âˆ¥ ADRS[28 âˆ¶ 32]\n\nADRS â† ADRS[0 âˆ¶ 28] âˆ¥ toByte(ğ‘–, 4)\n\nğ‘– â† toInt(ADRS[20 âˆ¶ 24], 4)\nğ‘– â† toInt(ADRS[28 âˆ¶ 32], 4)\n\n                                       6As noted in Section 4.2, the type (ğ‘Œ) is an integer. However, in the pseudocode, the constants WOTS_HASH, WOTS_PK,\n    TREE, FORS_TREE, FORS_ROOTS, WOTS_PRF, and FORS_PRF are used in order to improve readability.\n                                                                                                14"
  },
  {
    "doc_id": "NIST.FIPS.205",
    "source_path": "data/raw_pdfs/NIST.FIPS.205.pdf",
    "page_number": 25,
    "text": "FIPS 205                                           STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n\n4.4    Arrays, Byte Strings, and Integers\nIf ğ‘‹ is a byte string of length ğ‘›, then ğ‘‹[ğ‘–] for ğ‘– âˆˆ {0, â€¦ , ğ‘› âˆ’ 1} will refer to the ğ‘–áµ—Ê° element in\nthe string ğ‘‹. If ğ‘‹ is an array of ğ‘š ğ‘›-byte strings, then ğ‘‹[ğ‘–] for ğ‘– âˆˆ {0, â€¦ , ğ‘š âˆ’ 1} will refer to\nthe ğ‘–áµ—Ê° ğ‘›-byte string in ğ‘‹, and ğ‘‹ will refer to the ğ‘š â‹… ğ‘›-byte string ğ‘‹[0] âˆ¥ ğ‘‹[1] âˆ¥ â€¦ ğ‘‹[ğ‘š âˆ’ 1].\n        A byte string may be interpreted as the big-endian representation of an integer. In such cases, a\nbyte string ğ‘‹ of length ğ‘› is converted to the integer\n\n                           ğ‘‹[0] â‹… 256ğ‘›âˆ’1 + ğ‘‹[1] â‹… 256ğ‘›âˆ’2 + â€¦ ğ‘‹[ğ‘› âˆ’ 2] â‹… 256 + ğ‘‹[ğ‘› âˆ’ 1].\n\nSimilarly, an integer ğ‘¥ may be converted to a byte string of length ğ‘› by finding coefficients\nğ‘¥â‚€, ğ‘¥â‚, â€¦ ğ‘¥ğ‘›âˆ’2, ğ‘¥ğ‘›âˆ’1 âˆˆ {0, â€¦ , 255} such that\n\n                        ğ‘¥ = ğ‘¥â‚€ â‹… 256ğ‘›âˆ’1 + ğ‘¥â‚ â‹… 256ğ‘›âˆ’2 + â€¦ ğ‘¥ğ‘›âˆ’2 â‹… 256 + ğ‘¥ğ‘›âˆ’1\n\nand then setting the byte string to be ğ‘¥â‚€ğ‘¥â‚ â€¦ ğ‘¥ğ‘›âˆ’2ğ‘¥ğ‘›âˆ’1.\nAlgorithm 2 is a function that converts a byte string ğ‘‹ of length ğ‘› to an integer, and Algorithm 3\nis a function that converts an integer ğ‘¥ to a byte string of length ğ‘›.\n\nAlgorithm 2 toInt(ğ‘‹, ğ‘›)\nConverts a byte string to an integer.\nInput: ğ‘›-byte string ğ‘‹.\nOutput: Integer value of ğ‘‹.\n 1:    ğ‘¡ğ‘œğ‘¡ğ‘ğ‘™ â† 0\n 2:    for ğ‘– from 0 to ğ‘› âˆ’ 1 do\n 3:         ğ‘¡ğ‘œğ‘¡ğ‘ğ‘™ â† 256 â‹… ğ‘¡ğ‘œğ‘¡ğ‘ğ‘™ + ğ‘‹[ğ‘–]\n 4:    end for\n 5:    return ğ‘¡ğ‘œğ‘¡ğ‘ğ‘™\n\nAlgorithm 3 toByte(ğ‘¥, ğ‘›)\nConverts an integer to a byte string.\nInput: Integer ğ‘¥, string length ğ‘›.\nOutput: Byte string of length ğ‘› containing binary representation of ğ‘¥ in big-endian byte-order.\n 1:    ğ‘¡ğ‘œğ‘¡ğ‘ğ‘™ â† ğ‘¥\n 2:    for ğ‘– from 0 to ğ‘› âˆ’ 1 do\n 3:     ğ‘†[ğ‘› âˆ’ 1 âˆ’ ğ‘–] â† ğ‘¡ğ‘œğ‘¡ğ‘ğ‘™ mod 256                 â–· least significant 8 bits of ğ‘¡ğ‘œğ‘¡ğ‘ğ‘™\n 4:     ğ‘¡ğ‘œğ‘¡ğ‘ğ‘™ â† ğ‘¡ğ‘œğ‘¡ğ‘ğ‘™ â‰« 8\n 5:    end for\n 6:    return ğ‘†\n\n15"
  },
  {
    "doc_id": "NIST.FIPS.205",
    "source_path": "data/raw_pdfs/NIST.FIPS.205.pdf",
    "page_number": 26,
    "text": "FIPS 205                                                    STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n\nFor the WOTSâº and FORS schemes, the messages to be signed need to be split into a sequence\nof ğ‘-bit strings, where each ğ‘-bit string is interpreted as an integer between 0 and 2ğ‘ âˆ’ 1.â· This\nis the equivalent of creating the base-2ğ‘ representation of the message. The base_2áµ‡ function\n(Algorithm 4) takes a byte string ğ‘‹, a bit string length ğ‘, and an output length ğ‘œğ‘¢ğ‘¡_ğ‘™ğ‘’ğ‘› as input\nand returns an array of base-2ğ‘ integers that represent the first ğ‘œğ‘¢ğ‘¡_ğ‘™ğ‘’ğ‘› â‹… ğ‘ bits of ğ‘‹ if the\nindividual bytes in ğ‘‹ are encoded as 8-bit strings in big-endian bit order. ğ‘‹ must be at least\nâŒˆğ‘œğ‘¢ğ‘¡_ğ‘™ğ‘’ğ‘› â‹… ğ‘/8âŒ‰ bytes in length. As the value of ğ‘ğ‘–ğ‘¡ğ‘  will never exceed ğ‘ + 7, a ğ‘ + 7-bit unsigned\ninteger is sufficient to store ğ‘¡ğ‘œğ‘¡ğ‘ğ‘™ (i.e., ğ‘¡ğ‘œğ‘¡ğ‘ğ‘™ may be stored as a 32-bit unsigned integer).\n\nAlgorithm 4 base_2áµ‡(ğ‘‹, ğ‘, ğ‘œğ‘¢ğ‘¡_ğ‘™ğ‘’ğ‘›)\nComputes the base 2ğ‘ representation of ğ‘‹.\nInput: Byte string ğ‘‹ of length at least âŒˆ ğ‘œğ‘¢ğ‘¡_ğ‘™ğ‘’ğ‘›â‹…ğ‘ âŒ‰, integer ğ‘, output length ğ‘œğ‘¢ğ‘¡_ğ‘™ğ‘’ğ‘›.\n                                                    8\nOutput: Array of ğ‘œğ‘¢ğ‘¡_ğ‘™ğ‘’ğ‘› integers in the range [0, â€¦ , 2ğ‘ âˆ’ 1].\n 1:    ğ‘–ğ‘› â† 0\n 2:    ğ‘ğ‘–ğ‘¡ğ‘  â† 0\n 3:    ğ‘¡ğ‘œğ‘¡ğ‘ğ‘™ â† 0\n 4:    for ğ‘œğ‘¢ğ‘¡ from 0 to ğ‘œğ‘¢ğ‘¡_ğ‘™ğ‘’ğ‘› âˆ’ 1 do\n 5:     while ğ‘ğ‘–ğ‘¡ğ‘  < ğ‘ do\n 6:         ğ‘¡ğ‘œğ‘¡ğ‘ğ‘™ â† (ğ‘¡ğ‘œğ‘¡ğ‘ğ‘™ â‰ª 8) + ğ‘‹[ğ‘–ğ‘›]\n 7:         ğ‘–ğ‘› â† ğ‘–ğ‘› + 1\n 8:         ğ‘ğ‘–ğ‘¡ğ‘  â† ğ‘ğ‘–ğ‘¡ğ‘  + 8\n 9:     end while\n10:     ğ‘ğ‘–ğ‘¡ğ‘  â† ğ‘ğ‘–ğ‘¡ğ‘  âˆ’ ğ‘\n11:     ğ‘ğ‘ğ‘ ğ‘’ğ‘[ğ‘œğ‘¢ğ‘¡] â† (ğ‘¡ğ‘œğ‘¡ğ‘ğ‘™ â‰« ğ‘ğ‘–ğ‘¡ğ‘ ) mod 2ğ‘\n12:    end for\n13:    return ğ‘ğ‘ğ‘ ğ‘’ğ‘\n\n7ğ‘ will be the value of ğ‘™ğ‘”ğ‘¤ when the base_2b function is used in WOTS+, and ğ‘ will be the value of ğ‘ when the\nbase_2b function is used in FORS. For the parameter sets in this standard, ğ‘™ğ‘”ğ‘¤ is 4, and ğ‘ is 6, 8, 9, 12, or 14.\n16"
  },
  {
    "doc_id": "NIST.FIPS.205",
    "source_path": "data/raw_pdfs/NIST.FIPS.205.pdf",
    "page_number": 27,
    "text": "FIPS 205                               STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n\n5.   Winternitz One-Time Signature Plus Scheme\n\n     This section describes the WOTSâº one-time signature scheme that is a component of SLH-DSA.\n     WOTSâº uses two parameters. The security parameter ğ‘› is the length in bytes of the messages\n   that may be signed as well as the length of the private key elements, public key elements, and\n   signature elements. For the parameter sets specified in this standard, ğ‘› may be 16, 24, or 32\n   (see Table 2). The second parameter ğ‘™ğ‘”ğ‘¤ indicates the number of bits that are encoded by each\n  hash chain that is used.â¸ ğ‘™ğ‘”ğ‘¤ is 4 for all parameter sets in this standard. These parameters are\nused to compute four additional values:\n\n                                       ğ‘¤ = 2ğ‘™ğ‘”ğ‘¤                              (5.1)\n\n                                           ğ‘™ğ‘’ğ‘›â‚ = âŒˆ 8ğ‘› âŒ‰                     (5.2)\n                                       ğ‘™ğ‘”ğ‘¤\n\n                                ğ‘™ğ‘’ğ‘›â‚‚ = âŒŠ logÂ²(ğ‘™ğ‘’ğ‘›Â¹ â‹… (ğ‘¤ âˆ’ 1)) âŒ‹ + 1       (5.3)\n                                       ğ‘™ğ‘”ğ‘¤\n                                         ğ‘™ğ‘’ğ‘› = ğ‘™ğ‘’ğ‘›â‚ + ğ‘™ğ‘’ğ‘›â‚‚              (5.4)\n\nWhen ğ‘™ğ‘”ğ‘¤ = 4, ğ‘¤ = 16, ğ‘™ğ‘’ğ‘›â‚ = 2ğ‘›, ğ‘™ğ‘’ğ‘›â‚‚ = 3, and ğ‘™ğ‘’ğ‘› = 2ğ‘› + 3.\n A WOTSâº private key consists of ğ‘™ğ‘’ğ‘› secret values of length ğ‘›. In SLH-DSA, these are all generated\n    from an ğ‘›-byte seed SK.seed using a PRF. Chains of length ğ‘¤ are then created from the secret\nvalues using a chaining function, and the end values from each of the chains are public values. The\n  WOTSâº public key is computed as the hash of these public values. In order to create a signature,\n  the 8ğ‘›-bit message is first converted into an array of ğ‘™ğ‘’ğ‘›â‚ base-ğ‘¤ integers. A checksum is then\ncomputed for this string, and the checksum is converted into an array of ğ‘™ğ‘’ğ‘›â‚‚ base-ğ‘¤ integers.\n The signature consists of the appropriate entries from the chains for each of the integers in the\nmessage and checksum arrays.\n   The WOTSâº functions make use of two helper functions: base_2áµ‡ and chain. The base_2áµ‡ function\n   (Section 4.4) is used to break the message to be signed and the checksum value into arrays of\nbase-ğ‘¤ integers. The chain function (Algorithm 5) is used to compute the hash chains.\n  The chain function takes an ğ‘›-byte string ğ‘‹ and integers ğ‘  and ğ‘– (where ğ‘– + ğ‘  < ğ‘¤) as input and\n returns the result of iterating a hash function F on the input ğ‘  times, starting from an index of\nğ‘–.â¹ The chain function also requires as input PK.seed, which is part of the SLH-DSA public key,\nand an address ADRS. The type in ADRS must be set to WOTS_HASH, and the layer address,\n  tree address, key pair address, and chain address must be set to the address of the chain being\n    computed. The chain function updates the hash address in ADRS with each iteration to specify\nthe current position in the chain prior to ADRSâ€™s use in F.\n\n8In [10], the Winternitz parameter ğ‘¤ is used as the second WOTS+ parameter, where ğ‘¤ indicates the length of the\n\n9hash chains that are used. This standard uses the parameter ğ‘™ğ‘”ğ‘¤ = log2(ğ‘¤) to simplify notation.\nA start index of 0 indicates the beginning of the chain.\n                                                        17"
  },
  {
    "doc_id": "NIST.FIPS.205",
    "source_path": "data/raw_pdfs/NIST.FIPS.205.pdf",
    "page_number": 28,
    "text": "FIPS 205                                               STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n\nAlgorithm 5 chain(ğ‘‹, ğ‘–, ğ‘ , PK.seed, ADRS)\nChaining function used in WOTSâº.\nInput: Input string ğ‘‹, start index ğ‘–, number of steps ğ‘ , public seed PK.seed, address ADRS.\nOutput: Value of F iterated ğ‘  times on ğ‘‹.\n 1:    ğ‘¡ğ‘šğ‘ â† ğ‘‹\n 2:    for ğ‘— from ğ‘– to ğ‘– + ğ‘  âˆ’ 1 do\n 3:     ADRS.setHashAddress(ğ‘—)\n 4:     ğ‘¡ğ‘šğ‘ â† F(PK.seed, ADRS, ğ‘¡ğ‘šğ‘)\n 5:    end for\n 6:    return ğ‘¡ğ‘šğ‘\n\n5.1    WOTS+ Public-Key Generation\nThe wots_pkGen function (Algorithm 6) generates WOTSâº public keys. It takes SK.seed and\nPK.seed from the SLH-DSA private key and an address as input. The type in the address ADRS\nmust be set to WOTS_HASH, and the layer address, tree address, and key pair address must encode\nthe address of the WOTSâº public key to be generated.\nLines 4 through 9 in Algorithm 6 generate the public values, as described in Section 5. For each\nof the ğ‘™ğ‘’ğ‘› public values, the corresponding secret value is generated in lines 5 and 6, and the\nchain function is called to compute the end value of the chain of length ğ‘¤. Once the ğ‘™ğ‘’ğ‘› public\nvalues are computed, they are compressed into a single ğ‘›-byte value in lines 10 through 13.\n\nAlgorithm 6 wots_pkGen(SK.seed, PK.seed, ADRS)\nGenerates a WOTSâº public key.\nInput: Secret seed SK.seed, public seed PK.seed, address ADRS.\nOutput: WOTSâº public key ğ‘ğ‘˜.\n 1:    skADRS â† ADRS                   â–· copy address to create key generation key address\n 2:    skADRS.setTypeAndClear(WOTS_PRF)\n 3:    skADRS.setKeyPairAddress(ADRS.getKeyPairAddress())\n 4:    for ğ‘– from 0 to ğ‘™ğ‘’ğ‘› âˆ’ 1 do\n 5:     skADRS.setChainAddress(ğ‘–)\n 6:     ğ‘ ğ‘˜ â† PRF(PK.seed, SK.seed, skADRS)                â–· compute secret value for chain ğ‘–\n 7:     ADRS.setChainAddress(ğ‘–)\n 8:     ğ‘¡ğ‘šğ‘[ğ‘–] â† chain(ğ‘ ğ‘˜, 0, ğ‘¤ âˆ’ 1, PK.seed, ADRS)  â–· compute public value for chain ğ‘–\n 9:    end for\n10:    wotspkADRS â† ADRS                   â–· copy address to create WOTSâºpublic key address\n11:    wotspkADRS.setTypeAndClear(WOTS_PK)\n12:    wotspkADRS.setKeyPairAddress(ADRS.getKeyPairAddress())\n13:    ğ‘ğ‘˜ â† Tğ‘™ğ‘’ğ‘› (PK.seed, wotspkADRS, ğ‘¡ğ‘šğ‘)           â–· compress public key\n14:    return ğ‘ğ‘˜\n\n18"
  },
  {
    "doc_id": "NIST.FIPS.205",
    "source_path": "data/raw_pdfs/NIST.FIPS.205.pdf",
    "page_number": 29,
    "text": "FIPS 205                                        STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n\n5.2  WOTS+ Signature Generation\nA WOTSâº signature is an array of ğ‘™ğ‘’ğ‘› byte strings of length ğ‘›, as shown in Figure 10. The wots_sign\nfunction (Algorithm 7) generates the signature by converting the ğ‘›-byte message ğ‘€Â¹â° into an\narray of ğ‘™ğ‘’ğ‘›â‚ base-ğ‘¤ integers (line 2). A checksum is computed over ğ‘€ (lines 3 through 5). The\nchecksum is converted to a byte string, which is then converted into an array of ğ‘™ğ‘’ğ‘›â‚‚ base-ğ‘¤\nintegers (lines 6 and 7). The ğ‘™ğ‘’ğ‘›â‚‚ integers that represent the checksum are appended to the ğ‘™ğ‘’ğ‘›â‚\nintegers that represent the message (line 7).Â¹Â¹ For each of the ğ‘™ğ‘’ğ‘› base-ğ‘¤ integers, the signature\nconsists of the corresponding node in one of the hash chains. For each of these integers, lines\n   12 and 13 compute the secret value for the hash chain, and lines 14 and 15 compute the node in\nthe hash chain that corresponds to the integer. The selected nodes are concatenated to form\nthe WOTSâº signature.\n\n   sigâ‚’â‚œâ‚› [0]                                     ğ‘› bytes\n       â‹¯\nsigâ‚’â‚œâ‚› [ğ‘™ğ‘’ğ‘› âˆ’ 1]                               ğ‘› bytes\n\n                               Figure 10. WOTSâº signature data format\n\nIn addition to the ğ‘›-byte message to be signed, wots_sign takes SK.seed and PK.seed from\nthe SLH-DSA private key and an address as input. The type in the address ADRS must be set to\n    WOTS_HASH, and the layer address, tree address, and key pair address must encode the address\nof the WOTSâº key that is used to sign the message.\n\n10In SLH-DSA, the message ğ‘€ that is signed using WOTS+ is either an XMSS public key or a FORS public key.\n11In the case that ğ‘™ğ‘”ğ‘¤ = 4, the ğ‘›-byte message is converted into an array of 2ğ‘› base-16 integers (i.e., hexadecimal\n digits). The checksum is encoded as two bytes with the least significant four bits being zeros, and the most\n significant 12 bits are appended to the message as an array of three base-16 integers.\n          19"
  },
  {
    "doc_id": "NIST.FIPS.205",
    "source_path": "data/raw_pdfs/NIST.FIPS.205.pdf",
    "page_number": 30,
    "text": "FIPS 205    STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n\nAlgorithm 7 wots_sign(ğ‘€, SK.seed, PK.seed, ADRS)\nGenerates a WOTSâº signature on an ğ‘›-byte message.\nInput: Message ğ‘€, secret seed SK.seed, public seed PK.seed, address ADRS.\nOutput: WOTSâº signature ğ‘ ğ‘–ğ‘”.\n 1:    ğ‘ğ‘ ğ‘¢ğ‘š â† 0\n 2:    ğ‘šğ‘ ğ‘” â† base_2áµ‡(ğ‘€, ğ‘™ğ‘”ğ‘¤, ğ‘™ğ‘’ğ‘›â‚)                           â–· convert message to base ğ‘¤\n 3:    for ğ‘– from 0 to ğ‘™ğ‘’ğ‘›â‚ âˆ’ 1 do                                                      â–· compute checksum\n 4:     ğ‘ğ‘ ğ‘¢ğ‘š â† ğ‘ğ‘ ğ‘¢ğ‘š + ğ‘¤ âˆ’ 1 âˆ’ ğ‘šğ‘ ğ‘”[ğ‘–]\n 5:    end for\n 6:    ğ‘ğ‘ ğ‘¢ğ‘š â† ğ‘ğ‘ ğ‘¢ğ‘š â‰ª ((8 âˆ’ ((ğ‘™ğ‘’ğ‘›â‚‚ â‹… ğ‘™ğ‘”ğ‘¤) mod 8)) mod 8)  â–· for ğ‘™ğ‘”ğ‘¤ = 4, left shift by 4\n 7:    ğ‘šğ‘ ğ‘” â† ğ‘šğ‘ ğ‘” âˆ¥ base_2áµ‡ (toByte (ğ‘ğ‘ ğ‘¢ğ‘š, âŒˆ ğ‘™ğ‘’ğ‘›Â²â‹…ğ‘™ğ‘”ğ‘¤ âŒ‰) , ğ‘™ğ‘”ğ‘¤, ğ‘™ğ‘’ğ‘›â‚‚)  â–· convert to base ğ‘¤\n                                                 8\n 8:    skADRS â† ADRS                            â–· copy address to create key generation key address\n 9:    skADRS.setTypeAndClear(WOTS_PRF)\n10:    skADRS.setKeyPairAddress(ADRS.getKeyPairAddress())\n11:    for ğ‘– from 0 to ğ‘™ğ‘’ğ‘› âˆ’ 1 do\n12:     skADRS.setChainAddress(ğ‘–)\n13:     ğ‘ ğ‘˜ â† PRF(PK.seed, SK.seed, skADRS)                           â–· compute chain ğ‘– secret value\n14:     ADRS.setChainAddress(ğ‘–)\n15:     ğ‘ ğ‘–ğ‘”[ğ‘–] â† chain(ğ‘ ğ‘˜, 0, ğ‘šğ‘ ğ‘”[ğ‘–], PK.seed, ADRS)  â–· compute chain ğ‘– signature value\n16:    end for\n17:    return ğ‘ ğ‘–ğ‘”\n\n20"
  },
  {
    "doc_id": "NIST.FIPS.205",
    "source_path": "data/raw_pdfs/NIST.FIPS.205.pdf",
    "page_number": 31,
    "text": "FIPS 205                                         STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n\n5.3    Computing a WOTS+ Public Key From a Signature\n        Verifying a WOTSâº signature involves computing a public-key value from a message and signature\n        value. Verification succeeds if the correct public-key value is computed, which is determined\nby using the computed public-key value along with other information to compute a candidate\nPK.root value and then comparing that value to the known value of PK.root from the SLH-DSA\npublic key. This section describes wots_pkFromSig (Algorithm 8), a function that computes a\ncandidate WOTSâº public key from a WOTSâº signature and corresponding message.\nIn addition to an ğ‘›-byte message ğ‘€ and a ğ‘™ğ‘’ğ‘› â‹… ğ‘›-byte signature ğ‘ ğ‘–ğ‘”, which is interpreted as\nan array of ğ‘™ğ‘’ğ‘› ğ‘›-byte strings, the wots_pkFromSig function takes PK.seed from the SLH-DSA\npublic key and an address as input. The type of the address ADRS must be set to WOTS_HASH,\nand the layer address, tree address, and key pair address must encode the address of the WOTSâº\nkey that was used to sign the message.\nLines 1 through 7 of wots_pkFromSig are the same as lines 1 through 7 of wots_sign (Algorithm 7).\nLines 8 through 11 of wots_pkFromSig compute the end nodes for each of the chains using\nthe signature value as the starting point and the message value to determine the number of\niterations that need to be performed to get to the end node. Finally, as with lines 10 through 13\nof Algorithm 6, the computed public-key values are compressed in lines 12 through 15.\n\nAlgorithm 8 wots_pkFromSig(ğ‘ ğ‘–ğ‘”, ğ‘€, PK.seed, ADRS)\nComputes a WOTSâº public key from a message and its signature.\nInput: WOTSâº signature ğ‘ ğ‘–ğ‘”, message ğ‘€, public seed PK.seed, address ADRS.\nOutput: WOTSâº public key ğ‘ğ‘˜ğ‘ ğ‘–ğ‘” derived from ğ‘ ğ‘–ğ‘”.\n 1:    ğ‘ğ‘ ğ‘¢ğ‘š â† 0\n 2:    ğ‘šğ‘ ğ‘” â† base_2áµ‡(ğ‘€, ğ‘™ğ‘”ğ‘¤, ğ‘™ğ‘’ğ‘›â‚)                           â–· convert message to base ğ‘¤\n 3:    for ğ‘– from 0 to ğ‘™ğ‘’ğ‘›â‚ âˆ’ 1 do                                                      â–· compute checksum\n 4:     ğ‘ğ‘ ğ‘¢ğ‘š â† ğ‘ğ‘ ğ‘¢ğ‘š + ğ‘¤ âˆ’ 1 âˆ’ ğ‘šğ‘ ğ‘”[ğ‘–]\n 5:    end for\n 6:    ğ‘ğ‘ ğ‘¢ğ‘š â† ğ‘ğ‘ ğ‘¢ğ‘š â‰ª ((8 âˆ’ ((ğ‘™ğ‘’ğ‘›â‚‚ â‹… ğ‘™ğ‘”ğ‘¤) mod 8)) mod 8)  â–· for ğ‘™ğ‘”ğ‘¤ = 4, left shift by 4\n 7:    ğ‘šğ‘ ğ‘” â† ğ‘šğ‘ ğ‘” âˆ¥ base_2áµ‡ (toByte (ğ‘ğ‘ ğ‘¢ğ‘š, âŒˆ ğ‘™ğ‘’ğ‘›Â²â‹…ğ‘™ğ‘”ğ‘¤ âŒ‰) , ğ‘™ğ‘”ğ‘¤, ğ‘™ğ‘’ğ‘›â‚‚)  â–· convert to base ğ‘¤\n                                                         8\n 8:    for ğ‘– from 0 to ğ‘™ğ‘’ğ‘› âˆ’ 1 do\n 9:     ADRS.setChainAddress(ğ‘–)\n10:     ğ‘¡ğ‘šğ‘[ğ‘–] â† chain(ğ‘ ğ‘–ğ‘”[ğ‘–], ğ‘šğ‘ ğ‘”[ğ‘–], ğ‘¤ âˆ’ 1 âˆ’ ğ‘šğ‘ ğ‘”[ğ‘–], PK.seed, ADRS)\n11:    end for\n12:    wotspkADRS â† ADRS                        â–· copy address to create WOTSâº public key address\n13:    wotspkADRS.setTypeAndClear(WOTS_PK)\n14:    wotspkADRS.setKeyPairAddress(ADRS.getKeyPairAddress())\n15:    ğ‘ğ‘˜ğ‘ ğ‘–ğ‘” â† Tğ‘™ğ‘’ğ‘› (PK.seed, wotspkADRS, ğ‘¡ğ‘šğ‘)\n16:    return ğ‘ğ‘˜ğ‘ ğ‘–ğ‘”\n\n21"
  },
  {
    "doc_id": "NIST.FIPS.205",
    "source_path": "data/raw_pdfs/NIST.FIPS.205.pdf",
    "page_number": 32,
    "text": "    FIPS 205                 STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n\n    6.   eXtended Merkle Signature Scheme (XMSS)\n\n    XMSS extends the WOTSâº signature scheme into one that can sign multiple messages. A Merkle\n    tree [13] of height â„â€² is used to allow 2â„â€² WOTSâº public keys to be authenticated using a single\n    ğ‘›-byte XMSS public key, which is the root of the Merkle tree.Â¹Â² As each WOTSâº key may be used\n    to sign one message, the XMSS key may be used to sign 2â„â€² messages.\n    An XMSS signature is (â„â€² + ğ‘™ğ‘’ğ‘›) â‹… ğ‘› bytes in length and consists of a WOTSâº signature and an\n    authentication path (see Figure 11). The authentication path is an array of nodes from the Merkle\n    tree â€” one from each level of the tree, except for the root â€” that allows the verifier to compute\n    the root of the tree when used in conjunction with the WOTSâº public key that can be computed\n    from the WOTSâº signature.\n\n      SIGWOTSâ‚Š               ğ‘™ğ‘’ğ‘› â‹… ğ‘›\n                             bytes\n      AUTH[0]                ğ‘› bytes\n         â‹¯\n    AUTH[â„â€² âˆ’ 1]             ğ‘› bytes\n\n                             Figure 11. XMSS signature data format\n\n    6.1  Generating a Merkle Hash Tree\n    The xmss_node function (Algorithm 9) computes the nodes of an XMSS tree. The xmss_node\n    function takes as input SK.seed and PK.seed from the SLH-DSA private key; a target node index\n    ğ‘–, which is the index of the node being computed; a target node height ğ‘§, which is the height\n    within the Merkle tree of the node being computed; and an address. The address ADRS must\n    have the layer address and tree address set to the XMSS tree within which the node is being\n    computed. The target node height and index must satisfy ğ‘§ â‰¤ â„â€² and ğ‘– < 2(â„â€²âˆ’ğ‘§) .\n    Each node in an XMSS tree is the root of a subtree, and Algorithm 9 computes the root of the\n    subtree recursively. If the subtree consists of a single leaf node, then the function simply returns\n    the value of the nodeâ€™s WOTSâº public key (lines 2 through 4). Otherwise, the function computes\n    the roots of the left subtree (line 6) and right subtree (line 7) and hashes them together (lines 8\n    through 11).\n\n12The Merkle tree formed from the 2â„â€² WOTS+ keys of an XMSS key is referred to in this standard as an XMSS tree.\n                                                       22"
  },
  {
    "doc_id": "NIST.FIPS.205",
    "source_path": "data/raw_pdfs/NIST.FIPS.205.pdf",
    "page_number": 33,
    "text": "FIPS 205                               STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n\nAlgorithm 9 xmss_node(SK.seed, ğ‘–, ğ‘§, PK.seed, ADRS)\nComputes the root of a Merkle subtree of WOTSâº public keys.\nInput: Secret seed SK.seed, target node index ğ‘–, target node height ğ‘§, public seed PK.seed,\n       address ADRS.\nOutput: ğ‘›-byte root ğ‘›ğ‘œğ‘‘ğ‘’.\n 1:    if ğ‘§ = 0 then\n 2:     ADRS.setTypeAndClear(WOTS_HASH)\n 3:     ADRS.setKeyPairAddress(ğ‘–)\n 4:     ğ‘›ğ‘œğ‘‘ğ‘’ â† wots_pkGen(SK.seed, PK.seed, ADRS)\n 5:    else\n 6:     ğ‘™ğ‘›ğ‘œğ‘‘ğ‘’ â† xmss_node(SK.seed, 2ğ‘–, ğ‘§ âˆ’ 1, PK.seed, ADRS)\n 7:     ğ‘Ÿğ‘›ğ‘œğ‘‘ğ‘’ â† xmss_node(SK.seed, 2ğ‘– + 1, ğ‘§ âˆ’ 1, PK.seed, ADRS)\n 8:     ADRS.setTypeAndClear(TREE)\n 9:     ADRS.setTreeHeight(ğ‘§)\n10:     ADRS.setTreeIndex(ğ‘–)\n11:     ğ‘›ğ‘œğ‘‘ğ‘’ â† H(PK.seed, ADRS, ğ‘™ğ‘›ğ‘œğ‘‘ğ‘’ âˆ¥ ğ‘Ÿğ‘›ğ‘œğ‘‘ğ‘’)\n12:    end if\n13:    return ğ‘›ğ‘œğ‘‘ğ‘’\n\n6.2    Generating an XMSS Signature\nThe xmss_sign function (Algorithm 10) creates an XMSS signature on an ğ‘›-byte message ğ‘€Â¹Â³ by\ncreating an authentication path (lines 1 through 4) and signing ğ‘€ with the appropriate WOTSâº\nkey (lines 5 through 7). In addition to ğ‘€, xmss_sign takes SK.seed and PK.seed from the\nSLH-DSA private key, an address, and an index as input. The address ADRS must have the layer\naddress and tree address set to the XMSS key that is being used to sign the message, and the\nindex ğ‘–ğ‘‘ğ‘¥ must be the index of the WOTSâº key within the XMSS tree that will be used to sign the\nmessage.\nThe authentication path consists of the sibling nodes of each node that is on the path from\nthe WOTSâº key used to the root. For example, in Figure 12, if the message is signed with ğ¾â‚‚,\nthen ğ¾â‚‚, ğ‘›1,1 , and ğ‘›2,0 are the on path nodes, and the authentication path consists of ğ¾â‚ƒ,\nğ‘›1,0 , and ğ‘›2,1 . In line 2 of Algorithm 10, âŒŠğ‘–ğ‘‘ğ‘¥/2ğ‘—âŒ‹ is the on path node, and âŒŠğ‘–ğ‘‘ğ‘¥/2ğ‘—âŒ‹ âŠ• 1 is the\nauthentication path node. Line 3 computes the value of the authentication path node.\n\n13In SLH-DSA, the message ğ‘€ that is signed using XMSS is either an XMSS public key or a FORS public key.\n23"
  },
  {
    "doc_id": "NIST.FIPS.205",
    "source_path": "data/raw_pdfs/NIST.FIPS.205.pdf",
    "page_number": 34,
    "text": "FIPS 205    STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n\nAlgorithm 10 xmss_sign(ğ‘€, SK.seed, ğ‘–ğ‘‘ğ‘¥, PK.seed, ADRS)\nGenerates an XMSS signature.\nInput: ğ‘›-byte message ğ‘€, secret seed SK.seed, index ğ‘–ğ‘‘ğ‘¥, public seed PK.seed,\n       address ADRS.\nOutput: XMSS signature SIGğ‘‹ğ‘€ğ‘†ğ‘† = (ğ‘ ğ‘–ğ‘” âˆ¥ AUTH).\n 1:    for ğ‘— from 0 to â„â€² âˆ’ 1 do                           â–· build authentication path\n 2:     ğ‘˜ â† âŒŠğ‘–ğ‘‘ğ‘¥/2ğ‘—âŒ‹ âŠ• 1\n 3:     AUTH[ğ‘—] â† xmss_node(SK.seed, ğ‘˜, ğ‘—, PK.seed, ADRS)\n 4:    end for\n 5:    ADRS.setTypeAndClear(WOTS_HASH)\n 6:    ADRS.setKeyPairAddress(ğ‘–ğ‘‘ğ‘¥)\n 7:    ğ‘ ğ‘–ğ‘” â† wots_sign(ğ‘€, SK.seed, PK.seed, ADRS)\n 8:    SIGğ‘‹ğ‘€ğ‘†ğ‘† â† ğ‘ ğ‘–ğ‘” âˆ¥ AUTH\n 9:    return SIGğ‘‹ğ‘€ğ‘†ğ‘†\n\nğ‘›3,0 = H(ğ‘›2,0 âˆ¥ ğ‘›2,1 )\nPPPPP\n                         P\nğ‘›2,0 = H(ğ‘›1,0 âˆ¥ ğ‘›1,1 )    ğ‘›2,1 = H(ğ‘›1,2 âˆ¥ ğ‘›1,3 )\n\nï¿½ï¿½  @@                       ï¿½ï¿½  @@\nğ‘›1,0 = H(ğ¾â‚€ âˆ¥ ğ¾â‚) ğ‘›1,1 = H(ğ¾â‚‚ âˆ¥ ğ¾â‚ƒ) ğ‘›1,2 = H(ğ¾â‚„ âˆ¥ ğ¾â‚…) ğ‘›1,3 = H(ğ¾â‚† âˆ¥ ğ¾â‚‡)\n\nï¿½ï¿½ @@                ï¿½ï¿½  @@               ï¿½ï¿½ @@                ï¿½ï¿½  @@\nğ¾â‚€  ğ¾â‚             ğ¾â‚‚     ğ¾â‚ƒ          ğ¾â‚„  ğ¾â‚…             ğ¾â‚†   ğ¾â‚‡\n                          Figure 12. Merkle hash tree\n\n24"
  },
  {
    "doc_id": "NIST.FIPS.205",
    "source_path": "data/raw_pdfs/NIST.FIPS.205.pdf",
    "page_number": 35,
    "text": "FIPS 205                                      STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n\n6.3    Computing an XMSS Public Key From a Signature\nVerifying an XMSS signature involves computing a public-key value from a message and a signature\nvalue. Verification succeeds if the correct public-key value is computed, which is determined\nby using the computed public-key value along with other information to compute a candidate\nPK.root value and then comparing that value to the known value of PK.root from the SLH-DSA\npublic key. This section describes xmss_pkFromSig (Algorithm 11), a function that computes a\ncandidate XMSS public key from an XMSS signature and corresponding message.\nIn addition to an ğ‘›-byte message ğ‘€ and an (ğ‘™ğ‘’ğ‘›+â„â€² )â‹…ğ‘›-byte signature SIGğ‘‹ğ‘€ğ‘†ğ‘†, xmss_pkFromSig\ntakes PK.seed from the SLH-DSA public key, an address, and an index as input. The address\nADRS must be set to the layer address and tree address of the XMSS key that was used to sign\nthe message, and the index ğ‘–ğ‘‘ğ‘¥ must be the index of the WOTSâº key within the XMSS tree that\nwas used to sign the message.\nAlgorithm 11 begins by computing the WOTSâº public key in lines 1 through 5. The root is then\ncomputed in lines 6 through 18.     Starting with the leaf node (i.e., the WOTSâº public key), a\nnode at each level of the tree is computed by hashing together the node computed in the\nprevious iteration with the corresponding authentication path node. In lines 12 and 15, AUTH is\ninterpreted as an array of â„â€² ğ‘›-byte strings.\n\nAlgorithm 11 xmss_pkFromSig(ğ‘–ğ‘‘ğ‘¥, SIGğ‘‹ğ‘€ğ‘†ğ‘†, ğ‘€, PK.seed, ADRS)\nComputes an XMSS public key from an XMSS signature.\nInput: Index ğ‘–ğ‘‘ğ‘¥, XMSS signature SIGğ‘‹ğ‘€ğ‘†ğ‘† = (ğ‘ ğ‘–ğ‘” âˆ¥ AUTH), ğ‘›-byte message ğ‘€,\n       public seed PK.seed, address ADRS.\nOutput: ğ‘›-byte root value ğ‘›ğ‘œğ‘‘ğ‘’[0].\n 1:    ADRS.setTypeAndClear(WOTS_HASH)        â–· compute WOTSâº pk from WOTSâº ğ‘ ğ‘–ğ‘”\n 2:    ADRS.setKeyPairAddress(ğ‘–ğ‘‘ğ‘¥)\n 3:    ğ‘ ğ‘–ğ‘” â† SIGğ‘‹ğ‘€ğ‘†ğ‘†.getWOTSSig()                           â–· SIGğ‘‹ğ‘€ğ‘†ğ‘†[0 âˆ¶ ğ‘™ğ‘’ğ‘› â‹… ğ‘›]\n 4:    AUTH â† SIGğ‘‹ğ‘€ğ‘†ğ‘†.getXMSSAUTH()            â–· SIGğ‘‹ğ‘€ğ‘†ğ‘†[ğ‘™ğ‘’ğ‘› â‹… ğ‘› âˆ¶ (ğ‘™ğ‘’ğ‘› + â„â€² ) â‹… ğ‘›]\n 5:    ğ‘›ğ‘œğ‘‘ğ‘’[0] â† wots_pkFromSig(ğ‘ ğ‘–ğ‘”, ğ‘€ , PK.seed, ADRS)\n 6:    ADRS.setTypeAndClear(TREE)             â–· compute root from WOTSâº pk and AUTH\n 7:    ADRS.setTreeIndex(ğ‘–ğ‘‘ğ‘¥)\n 8:    for ğ‘˜ from 0 to â„â€² âˆ’ 1 do\n 9:     ADRS.setTreeHeight(ğ‘˜ + 1)\n10:     if âŒŠğ‘–ğ‘‘ğ‘¥/2ğ‘˜âŒ‹ is even then\n11:         ADRS.setTreeIndex(ADRS.getTreeIndex()/2)\n12:         ğ‘›ğ‘œğ‘‘ğ‘’[1] â† H(PK.seed, ADRS, ğ‘›ğ‘œğ‘‘ğ‘’[0] âˆ¥ AUTH[ğ‘˜])\n13:     else\n14:         ADRS.setTreeIndex((ADRS.getTreeIndex() âˆ’ 1)/2)\n15:         ğ‘›ğ‘œğ‘‘ğ‘’[1] â† H(PK.seed, ADRS, AUTH[ğ‘˜] âˆ¥ ğ‘›ğ‘œğ‘‘ğ‘’[0])\n16:     end if\n17:     ğ‘›ğ‘œğ‘‘ğ‘’[0] â† ğ‘›ğ‘œğ‘‘ğ‘’[1]\n18:    end for\n19:    return ğ‘›ğ‘œğ‘‘ğ‘’[0]\n\n                                              25"
  },
  {
    "doc_id": "NIST.FIPS.205",
    "source_path": "data/raw_pdfs/NIST.FIPS.205.pdf",
    "page_number": 36,
    "text": "FIPS 205                                   STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n\n7.   The SLH-DSA Hypertree\n\nSLH-DSA requires a very large number of WOTSâº keys to sign FORS public keys.              As it would\nnot be feasible for the parameter sets in this standard to have a single XMSS key with so many\nWOTSâº keys, SLH-DSA uses a hypertree to sign the FORS keys. As depicted in Figure 1, a hypertree\nis a tree of XMSS trees.          The XMSS keys at the lowest layer are used to sign FORS public keys\n     (Section 8), and the XMSS keys at every other layer are used to sign the XMSS public keys at the\nlayer below.\nThe hypertree has ğ‘‘ layers of XMSS trees with each XMSS tree being a Merkle tree of height â„â€² ,\nso the total height of the hypertree is â„ = ğ‘‘ â‹… â„â€² (see Table 2). The top layer (layer ğ‘‘ âˆ’ 1) is a\nsingle XMSS tree, and the public key of this XMSS key pair (i.e., the root of the Merkle tree) is the\npublic key of the hypertree (PK.root). The next layer down has 2â„â€² XMSS trees, and the public\nkey of each of these XMSS keys is signed by one of the 2â„â€² WOTSâº keys that is part of the top\nlayerâ€™s XMSS key. The lowest layer has 2â„âˆ’â„â€² XMSS trees, providing 2â„ WOTSâº keys to sign FORS\nkeys.\n\n7.1  Hypertree Signature Generation\n      A hypertree signature is (â„ + ğ‘‘ â‹… ğ‘™ğ‘’ğ‘›) â‹… ğ‘› bytes in length and consists of a sequence of ğ‘‘ XMSS\nsignatures, starting with a signature generated using an XMSS key at the lowest layer and ending\nwith a signature generated using the XMSS key at the top layer (see Figure 13).\n\n  XMSS signature SIGXMSS (layer 0)         (â„â€² + ğ‘™ğ‘’ğ‘›) â‹… ğ‘› bytes\n  XMSS signature SIGXMSS (layer 1)         (â„â€² + ğ‘™ğ‘’ğ‘›) â‹… ğ‘› bytes\n                 â‹¯\nXMSS signature SIGXMSS (layer ğ‘‘ âˆ’ 1)      (â„â€² + ğ‘™ğ‘’ğ‘›) â‹… ğ‘› bytes\n\n                         Figure 13. HT signature data format\n\nIn addition to the ğ‘›-byte message ğ‘€,Â¹â´           the ht_sign function (Algorithm 12) takes as input\nSK.seed and PK.seed from the SLH-DSA private key, the index of the XMSS tree at the lowest\nlayer that will sign the message ğ‘–ğ‘‘ğ‘¥ğ‘¡ğ‘Ÿğ‘’ğ‘’, and the index of the WOTSâº key within the XMSS tree\nthat will sign the message ğ‘–ğ‘‘ğ‘¥ğ‘™ğ‘’ğ‘ğ‘“ .\n          Algorithm 12 begins in lines 1 through 3 by signing ğ‘€ with the specified XMSS key using the\n     WOTSâº key within that XMSS key specified by ğ‘–ğ‘‘ğ‘¥ğ‘™ğ‘’ğ‘ğ‘“ . The XMSS public key is obtained (line 5 or\n    14) for each successive layer and signed by the appropriate key at the next higher level (lines 7\nthrough 11).\n\n14In SLH-DSA, the message ğ‘€ that is provided to ht_sign is a FORS public key.\n26"
  },
  {
    "doc_id": "NIST.FIPS.205",
    "source_path": "data/raw_pdfs/NIST.FIPS.205.pdf",
    "page_number": 37,
    "text": "FIPS 205    STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n\nAlgorithm 12 ht_sign(ğ‘€, SK.seed, PK.seed, ğ‘–ğ‘‘ğ‘¥ğ‘¡ğ‘Ÿğ‘’ğ‘’, ğ‘–ğ‘‘ğ‘¥ğ‘™ğ‘’ğ‘ğ‘“ )\nGenerates a hypertree signature.\nInput: Message ğ‘€, private seed SK.seed, public seed PK.seed, tree index ğ‘–ğ‘‘ğ‘¥ğ‘¡ğ‘Ÿğ‘’ğ‘’,\n       leaf index ğ‘–ğ‘‘ğ‘¥ğ‘™ğ‘’ğ‘ğ‘“ .\nOutput: HT signature SIGğ»ğ‘‡.\n 1:    ADRS â† toByte(0, 32)\n 2:    ADRS.setTreeAddress(ğ‘–ğ‘‘ğ‘¥ğ‘¡ğ‘Ÿğ‘’ğ‘’)\n 3:    SIGğ‘¡ğ‘šğ‘ â† xmss_sign(ğ‘€, SK.seed, ğ‘–ğ‘‘ğ‘¥ğ‘™ğ‘’ğ‘ğ‘“ , PK.seed, ADRS)\n 4:    SIGğ»ğ‘‡ â† SIGğ‘¡ğ‘šğ‘\n 5:    ğ‘Ÿğ‘œğ‘œğ‘¡ â† xmss_pkFromSig(ğ‘–ğ‘‘ğ‘¥ğ‘™ğ‘’ğ‘ğ‘“ , SIGğ‘¡ğ‘šğ‘, ğ‘€ , PK.seed, ADRS)\n 6:    for ğ‘— from 1 to ğ‘‘ âˆ’ 1 do\n 7:     ğ‘–ğ‘‘ğ‘¥ğ‘™ğ‘’ğ‘ğ‘“ â† ğ‘–ğ‘‘ğ‘¥ğ‘¡ğ‘Ÿğ‘’ğ‘’ modâ€²2â„â€²    â–· â„â€² least significant bits of ğ‘–ğ‘‘ğ‘¥ğ‘¡ğ‘Ÿğ‘’ğ‘’\n 8:     ğ‘–ğ‘‘ğ‘¥ğ‘¡ğ‘Ÿğ‘’ğ‘’ â† ğ‘–ğ‘‘ğ‘¥ğ‘¡ğ‘Ÿğ‘’ğ‘’ â‰« â„        â–· remove least significant â„â€² bits from ğ‘–ğ‘‘ğ‘¥ğ‘¡ğ‘Ÿğ‘’ğ‘’\n 9:     ADRS.setLayerAddress(ğ‘—)\n10:     ADRS.setTreeAddress(ğ‘–ğ‘‘ğ‘¥ğ‘¡ğ‘Ÿğ‘’ğ‘’)\n11:     SIGğ‘¡ğ‘šğ‘ â† xmss_sign(ğ‘Ÿğ‘œğ‘œğ‘¡, SK.seed, ğ‘–ğ‘‘ğ‘¥ğ‘™ğ‘’ğ‘ğ‘“ , PK.seed, ADRS)\n12:     SIGğ»ğ‘‡ â† SIGğ»ğ‘‡ âˆ¥ SIGğ‘¡ğ‘šğ‘\n13:     if ğ‘— < ğ‘‘ âˆ’ 1 then\n14:     endğ‘Ÿğ‘œğ‘œğ‘¡ â† xmss_pkFromSig(ğ‘–ğ‘‘ğ‘¥ğ‘™ğ‘’ğ‘ğ‘“ , SIGğ‘¡ğ‘šğ‘, ğ‘Ÿğ‘œğ‘œğ‘¡, PK.seed, ADRS)\n15:           if\n16:    end for\n17:    return SIGğ»ğ‘‡\n\n27"
  },
  {
    "doc_id": "NIST.FIPS.205",
    "source_path": "data/raw_pdfs/NIST.FIPS.205.pdf",
    "page_number": 38,
    "text": "FIPS 205                                           STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n\n7.2    Hypertree Signature Verification\nHypertree signature verification works by making ğ‘‘ calls to xmss_pkFromSig (Algorithm 11) and\ncomparing the result to the public key of the hypertree.\nIn addition to the ğ‘›-byte message ğ‘€ and the (â„ + ğ‘‘ â‹… ğ‘™ğ‘’ğ‘›) â‹… ğ‘›-byte signature SIGğ»ğ‘‡, ht_verify\n(Algorithm 13) takes as input PK.seed and PK.root from the SLH-DSA public key, the index of\nthe XMSS tree at the lowest layer that signed the message ğ‘–ğ‘‘ğ‘¥ğ‘¡ğ‘Ÿğ‘’ğ‘’, and the index of the WOTSâº\nkey within the XMSS tree that signed the message ğ‘–ğ‘‘ğ‘¥ğ‘™ğ‘’ğ‘ğ‘“ .\nAt each layer, either the message ğ‘€ or the computed public key of the XMSS key at the lower\nlayer is provided along with the appropriate XMSS signature to xmss_pkFromSig in order to\nobtain the layerâ€™s computed XMSS public key. If the computed XMSS public key of the top layer\ntree is the same as the known hypertree public key, PK.root, then verification succeeds.\n\nAlgorithm 13 ht_verify(ğ‘€, SIGğ»ğ‘‡, PK.seed, ğ‘–ğ‘‘ğ‘¥ğ‘¡ğ‘Ÿğ‘’ğ‘’, ğ‘–ğ‘‘ğ‘¥ğ‘™ğ‘’ğ‘ğ‘“ , PK.root)\nVerifies a hypertree signature.\nInput: Message ğ‘€, signature SIGğ»ğ‘‡, public seed PK.seed, tree index ğ‘–ğ‘‘ğ‘¥ğ‘¡ğ‘Ÿğ‘’ğ‘’, leaf index ğ‘–ğ‘‘ğ‘¥ğ‘™ğ‘’ğ‘ğ‘“ ,\n       HT public key PK.root.\nOutput: Boolean.\n 1:    ADRS â† toByte(0, 32)\n 2:    ADRS.setTreeAddress(ğ‘–ğ‘‘ğ‘¥ğ‘¡ğ‘Ÿğ‘’ğ‘’)                                              â€²\n 3:    SIGğ‘¡ğ‘šğ‘ â† SIGğ»ğ‘‡.getXMSSSignature(0)                   â–· SIGğ»ğ‘‡[0 âˆ¶ (â„        + ğ‘™ğ‘’ğ‘›) â‹… ğ‘›]\n 4:    ğ‘›ğ‘œğ‘‘ğ‘’ â† xmss_pkFromSig(ğ‘–ğ‘‘ğ‘¥ğ‘™ğ‘’ğ‘ğ‘“ , SIGğ‘¡ğ‘šğ‘, ğ‘€ , PK.seed, ADRS)\n 5:    for ğ‘— from 1 to ğ‘‘ âˆ’ 1 do\n 6:     ğ‘–ğ‘‘ğ‘¥ğ‘™ğ‘’ğ‘ğ‘“ â† ğ‘–ğ‘‘ğ‘¥ğ‘¡ğ‘Ÿğ‘’ğ‘’ modâ€²2â„â€²                  â–· â„â€² least significant bits of ğ‘–ğ‘‘ğ‘¥ğ‘¡ğ‘Ÿğ‘’ğ‘’\n 7:     ğ‘–ğ‘‘ğ‘¥ğ‘¡ğ‘Ÿğ‘’ğ‘’ â† ğ‘–ğ‘‘ğ‘¥ğ‘¡ğ‘Ÿğ‘’ğ‘’ â‰« â„        â–· remove least significant â„â€² bits from ğ‘–ğ‘‘ğ‘¥ğ‘¡ğ‘Ÿğ‘’ğ‘’\n 8:     ADRS.setLayerAddress(ğ‘—)\n 9:     ADRS.setTreeAddress(ğ‘–ğ‘‘ğ‘¥ğ‘¡ğ‘Ÿğ‘’ğ‘’)\n10:     SIGğ‘¡ğ‘šğ‘ â† SIGğ»ğ‘‡.getXMSSSignature(ğ‘—)   â–· SIGğ»ğ‘‡[ğ‘— â‹… (â„â€² + ğ‘™ğ‘’ğ‘›) â‹… ğ‘› âˆ¶ (ğ‘— + 1)(â„â€² + ğ‘™ğ‘’ğ‘›) â‹… ğ‘›]\n11:    endğ‘›ğ‘œğ‘‘ğ‘’ â† xmss_pkFromSig(ğ‘–ğ‘‘ğ‘¥ğ‘™ğ‘’ğ‘ğ‘“ , SIGğ‘¡ğ‘šğ‘, ğ‘›ğ‘œğ‘‘ğ‘’, PK.seed, ADRS)\n12:         for\n13:    if ğ‘›ğ‘œğ‘‘ğ‘’ = PK.root then\n14:     return true\n15:    else\n16:     return false\n17:    end if\n\n28"
  },
  {
    "doc_id": "NIST.FIPS.205",
    "source_path": "data/raw_pdfs/NIST.FIPS.205.pdf",
    "page_number": 39,
    "text": "FIPS 205                                         STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n\n8.   Forest of Random Subsets (FORS)\n\nFORS is a few-time signature scheme that is used to sign the digests of the actual messages.\nUnlike WOTSâº, for which forgeries become feasible if a key is used twice [22], the security of a\nFORS key degrades gradually as the number of signatures increases.\nFORS uses two parameters: ğ‘˜ and ğ‘¡ = 2ğ‘ (see Table 2). A FORS private key consists of ğ‘˜ sets of ğ‘¡\nğ‘›-byte strings, all of which are pseudorandomly generated from the seed SK.seed. Each of the\nğ‘˜ sets is formed into a Merkle tree, and the roots of the trees are hashed together to form the\nFORS public key. A signature on a ğ‘˜ â‹… ğ‘-bit message digest consists of ğ‘˜ elements from the private\nkey, one from each set selected using ğ‘ bits of the message digest, along with the authentication\npaths for each of these elements (see Figure 14).\n\n                      private key value (tree 0)     ğ‘› bytes\n                                AUTH (tree 0)        ğ‘ â‹… ğ‘› bytes\n                   â‹¯\n     private key value (tree ğ‘˜ âˆ’ 1)                 ğ‘› bytes\n                      AUTH (tree ğ‘˜ âˆ’ 1)             ğ‘ â‹… ğ‘› bytes\n\n                      Figure 14. FORS signature data format\n\n8.1  Generating FORS Secret Values\nThe fors_skGen function (Algorithm 14) generates the ğ‘›-byte strings of the FORS private key. The\nfunction takes SK.seed and PK.seed from the SLH-DSA private key, an address, and an index\nas input. The ğ‘¡ğ‘¦ğ‘ğ‘’ in the address ADRS must be set to FORS_TREE, and the tree address and\nkey pair address must be set to the index of the WOTSâº key within the XMSS tree that signs the\nFORS key. The layer address must be set to zero. The index ğ‘–ğ‘‘ğ‘¥ is the index of the FORS secret\nvalue within the sets of FORS trees.\n\nAlgorithm 14 fors_skGen(SK.seed, PK.seed, ADRS, ğ‘–ğ‘‘ğ‘¥)\nGenerates a FORS private-key value.\nInput: Secret seed SK.seed, public seed PK.seed, address ADRS, secret key index ğ‘–ğ‘‘ğ‘¥.\nOutput: ğ‘›-byte FORS private-key value.\n 1:  skADRS â† ADRS                               â–· copy address to create key generation address\n 2:  skADRS.setTypeAndClear(FORS_PRF)\n 3:  skADRS.setKeyPairAddress(ADRS.getKeyPairAddress())\n 4:  skADRS.setTreeIndex(ğ‘–ğ‘‘ğ‘¥)\n 5:  return PRF(PK.seed, SK.seed, skADRS)\n\n29"
  },
  {
    "doc_id": "NIST.FIPS.205",
    "source_path": "data/raw_pdfs/NIST.FIPS.205.pdf",
    "page_number": 40,
    "text": "FIPS 205                                 STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n\n8.2    Generating a Merkle Hash Tree\nThe fors_node function (Algorithm 15) computes the nodes of a Merkle tree. It is the same as\nxmss_node, except that the leaf nodes are the hashes of the FORS secret values instead of WOTSâº\npublic keys.\nThe fors_node function takes as input SK.seed and PK.seed from the SLH-DSA private key; a\ntarget node index ğ‘–, which is the index of the node being computed; a target node height ğ‘§, which\nis the height within the Merkle tree of the node being computed; and an address. The address\nADRS must have the layer address set to zero (since the XMSS tree that signs a FORS key is\nalways at layer 0), the tree address set to the XMSS tree that signs the FORS key, the ğ‘¡ğ‘¦ğ‘ğ‘’ set to\nFORS_TREE, and the key pair address set to the index of the WOTSâº key within the XMSS tree\nthat signs the FORS key. The target node height and index must satisfy ğ‘§ â‰¤ ğ‘ and ğ‘– < ğ‘˜ â‹… 2(ğ‘âˆ’ğ‘§).\nEach node in the Merkle tree is the root of a subtree, and Algorithm 15 computes the root of a\nsubtree recursively. If the subtree consists of a single leaf node, then the function simply returns\na hash of the nodeâ€™s private ğ‘›-byte string (lines 2 through 5). Otherwise, the function computes\nthe roots of the left subtree (line 7) and right subtree (line 8) and hashes them together (lines 9\nthrough 11).\n\nAlgorithm 15 fors_node(SK.seed, ğ‘–, ğ‘§, PK.seed, ADRS)\nComputes the root of a Merkle subtree of FORS public values.\nInput: Secret seed SK.seed, target node index ğ‘–, target node height ğ‘§, public seed PK.seed,\n       address ADRS.\nOutput: ğ‘›-byte root ğ‘›ğ‘œğ‘‘ğ‘’.\n 1:    if ğ‘§ = 0 then\n 2:     ğ‘ ğ‘˜ â† fors_skGen(SK.seed, PK.seed, ADRS, ğ‘–)\n 3:     ADRS.setTreeHeight(0)\n 4:     ADRS.setTreeIndex(ğ‘–)\n 5:     ğ‘›ğ‘œğ‘‘ğ‘’ â† F(PK.seed, ADRS, ğ‘ ğ‘˜)\n 6:    else\n 7:     ğ‘™ğ‘›ğ‘œğ‘‘ğ‘’ â† fors_node(SK.seed, 2ğ‘–, ğ‘§ âˆ’ 1, PK.seed, ADRS)\n 8:     ğ‘Ÿğ‘›ğ‘œğ‘‘ğ‘’ â† fors_node(SK.seed, 2ğ‘– + 1, ğ‘§ âˆ’ 1, PK.seed, ADRS)\n 9:     ADRS.setTreeHeight(ğ‘§)\n10:     ADRS.setTreeIndex(ğ‘–)\n11:     ğ‘›ğ‘œğ‘‘ğ‘’ â† H(PK.seed, ADRS, ğ‘™ğ‘›ğ‘œğ‘‘ğ‘’ âˆ¥ ğ‘Ÿğ‘›ğ‘œğ‘‘ğ‘’)\n12:    end if\n13:    return ğ‘›ğ‘œğ‘‘ğ‘’\n\n8.3    Generating a FORS Signature\nThe fors_sign function (Algorithm 16) signs a ğ‘˜ â‹… ğ‘-bit message digest ğ‘šğ‘‘.Â¹âµ In addition to the\nmessage digest, fors_sign takes SK.seed and PK.seed from the SLH-DSA private key and an\naddress as input. The address ADRS must have the layer address set to zero (since the XMSS\n\n15For convenience, fors_sign takes a âŒˆğ‘˜â‹…ğ‘âŒ‰ byte message digest as input and extracts ğ‘˜ â‹… ğ‘ bits to sign.\n                              8\n                                         30"
  },
  {
    "doc_id": "NIST.FIPS.205",
    "source_path": "data/raw_pdfs/NIST.FIPS.205.pdf",
    "page_number": 41,
    "text": "FIPS 205                                       STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n\ntree that signs a FORS key is always at layer 0), the tree address set to the XMSS tree that signs\nthe FORS key, the ğ‘¡ğ‘¦ğ‘ğ‘’ set to FORS_TREE, and the key pair address set to the index of the WOTSâº\nkey within the XMSS tree that signs the FORS key.\nThe fors_sign function splits ğ‘˜â‹…ğ‘ bits of ğ‘šğ‘‘ into ğ‘˜ ğ‘-bit strings (line 2), each of which is interpreted\nas an integer between 0 and ğ‘¡ âˆ’ 1. Each of these integers is used to select a secret value from\none of the ğ‘˜ sets (line 4). For each secret value selected, an authentication path is computed\nand added to the signature (lines 5 through 9).\n\nAlgorithm 16 fors_sign(ğ‘šğ‘‘, SK.seed, PK.seed, ADRS)\nGenerates a FORS signature.\nInput: Message digest ğ‘šğ‘‘, secret seed SK.seed, address ADRS, public seed PK.seed.\nOutput: FORS signature SIGğ¹ ğ‘‚ğ‘…ğ‘† .\n 1:    SIGğ¹ ğ‘‚ğ‘…ğ‘† = NULL b                 â–· initialize SIGğ¹ ğ‘‚ğ‘…ğ‘† as a zero-length byte string\n 2:    ğ‘–ğ‘›ğ‘‘ğ‘–ğ‘ğ‘’ğ‘  â† base_2 (ğ‘šğ‘‘, ğ‘, ğ‘˜)\n 3:    for ğ‘– from 0 to ğ‘˜ âˆ’ 1 do                   â–· compute signature elements\n 4:     SIGğ¹ ğ‘‚ğ‘…ğ‘† â† SIGğ¹ ğ‘‚ğ‘…ğ‘† âˆ¥ fors_skGen(SK.seed, PK.seed, ADRS, ğ‘– â‹… 2ğ‘ + ğ‘–ğ‘›ğ‘‘ğ‘–ğ‘ğ‘’ğ‘ [ğ‘–])\n 5:     for ğ‘— from 0 to ğ‘ âˆ’ 1 do                  â–· compute auth path\n 6:         ğ‘  â† âŒŠğ‘–ğ‘›ğ‘‘ğ‘–ğ‘ğ‘’ğ‘ [ğ‘–]/2ğ‘—âŒ‹ âŠ• 1\n 7:         AUTH[ğ‘—] â† fors_node(SK.seed, ğ‘– â‹… 2ğ‘âˆ’ğ‘— + ğ‘ , ğ‘—, PK.seed, ADRS)\n 8:     end for\n 9:    endSIGğ¹ ğ‘‚ğ‘…ğ‘† â† SIGğ¹ ğ‘‚ğ‘…ğ‘† âˆ¥ AUTH\n10:         for\n11:    return SIGğ¹ ğ‘‚ğ‘…ğ‘†\n\n8.4  Computing a FORS Public Key From a Signature\n  Verifying a FORS signature involves computing a public-key value from a message digest and\na signature value. Verification succeeds if the correct public-key value is computed, which is\ndetermined by verifying the hypertree signature on the computed public-key value using the SLH-\nDSA public key. This section describes fors_pkFromSig (Algorithm 17), a function that computes\na candidate FORS public key from a FORS signature and corresponding message digest.\nIn addition to a message digest ğ‘šğ‘‘ and a ğ‘˜ â‹… (ğ‘ + 1) â‹… ğ‘›-byte signature SIGğ¹ ğ‘‚ğ‘…ğ‘† , fors_pkFromSig\ntakes PK.seed from the SLH-DSA public key and an address as input.Â¹â¶ The address ADRS\nmust have the layer address set to zero (since the XMSS tree that signs a FORS key is always at\nlayer 0), the tree address set to the XMSS tree that signs the FORS key, the ğ‘¡ğ‘¦ğ‘ğ‘’ set to FORS_TREE,\nand the key pair address set to the index of the WOTSâº key within the XMSS tree that signs the\nFORS key.\nThe fors_pkFromSig function begins by computing the roots of each of the ğ‘˜ Merkle trees (lines\n2 through 20). As in fors_sign, ğ‘˜ â‹… ğ‘ bits of the message digest are split into ğ‘˜ ğ‘-bit strings (line\n 1), each of which is interpreted as an integer between 0 and ğ‘¡ âˆ’ 1. The integers are used to\ndetermine the locations in the Merkle trees of the secret values from the signature (lines 3\n16As with fors_sign, fors_pkFromSig takes a âŒˆğ‘˜â‹…ğ‘âŒ‰ byte message digest as input and extracts ğ‘˜ â‹… ğ‘ bits.\n         8\n          31"
  },
  {
    "doc_id": "NIST.FIPS.205",
    "source_path": "data/raw_pdfs/NIST.FIPS.205.pdf",
    "page_number": 42,
    "text": "FIPS 205                                            STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n\nthrough 5). The hashes of the secret values are computed (line 6), and the hash values are used\nalong with the corresponding authentication paths from the signature to compute the Merkle\ntree roots (lines 7 through 19). Once all of the Merkle tree roots have been computed, they are\nhashed together to compute the FORS public key (lines 21 through 24).\n\nAlgorithm 17 fors_pkFromSig(SIGğ¹ ğ‘‚ğ‘…ğ‘† , ğ‘šğ‘‘, PK.seed, ADRS)\nComputes a FORS public key from a FORS signature.\nInput: FORS signature SIGğ¹ ğ‘‚ğ‘…ğ‘† , message digest ğ‘šğ‘‘, public seed PK.seed, address ADRS.\nOutput: FORS public key.\n 1:    ğ‘–ğ‘›ğ‘‘ğ‘–ğ‘ğ‘’ğ‘  â† base_2áµ‡(ğ‘šğ‘‘, ğ‘, ğ‘˜)\n 2:    for ğ‘– from 0 to ğ‘˜ âˆ’ 1 do\n 3:     ğ‘ ğ‘˜ â† SIGğ¹ ğ‘‚ğ‘…ğ‘† .getSK(ğ‘–)              â–· SIGğ¹ ğ‘‚ğ‘…ğ‘† [ğ‘– â‹… (ğ‘ + 1) â‹… ğ‘› âˆ¶ (ğ‘– â‹… (ğ‘ + 1) + 1) â‹… ğ‘›]\n 4:     ADRS.setTreeHeight(0)                                              â–· compute leaf\n 5:     ADRS.setTreeIndex(ğ‘– â‹… 2ğ‘ + ğ‘–ğ‘›ğ‘‘ğ‘–ğ‘ğ‘’ğ‘ [ğ‘–])\n 6:     ğ‘›ğ‘œğ‘‘ğ‘’[0] â† F(PK.seed, ADRS, ğ‘ ğ‘˜)\n 7:     ğ‘ğ‘¢ğ‘¡â„ â† SIGğ¹ ğ‘‚ğ‘…ğ‘† .getAUTH(ğ‘–)  â–· SIGğ¹ ğ‘‚ğ‘…ğ‘† [(ğ‘– â‹… (ğ‘ + 1) + 1) â‹… ğ‘› âˆ¶ (ğ‘– + 1) â‹… (ğ‘ + 1) â‹… ğ‘›]\n 8:     for ğ‘— from 0 to ğ‘ âˆ’ 1 do                      â–· compute root from leaf and AUTH\n 9:         ADRS.setTreeHeight(ğ‘— + 1)\n10:         if âŒŠğ‘–ğ‘›ğ‘‘ğ‘–ğ‘ğ‘’ğ‘ [ğ‘–]/2ğ‘—âŒ‹ is even then\n11:               ADRS.setTreeIndex(ADRS.getTreeIndex()/2)\n12:               ğ‘›ğ‘œğ‘‘ğ‘’[1] â† H(PK.seed, ADRS, ğ‘›ğ‘œğ‘‘ğ‘’[0] âˆ¥ ğ‘ğ‘¢ğ‘¡â„[ğ‘—])\n13:         else\n14:               ADRS.setTreeIndex((ADRS.getTreeIndex() âˆ’ 1)/2)\n15:               ğ‘›ğ‘œğ‘‘ğ‘’[1] â† H(PK.seed, ADRS, ğ‘ğ‘¢ğ‘¡â„[ğ‘—] âˆ¥ ğ‘›ğ‘œğ‘‘ğ‘’[0])\n16:         end if\n17:         ğ‘›ğ‘œğ‘‘ğ‘’[0] â† ğ‘›ğ‘œğ‘‘ğ‘’[1]\n18:     end for\n19:     ğ‘Ÿğ‘œğ‘œğ‘¡[ğ‘–] â† ğ‘›ğ‘œğ‘‘ğ‘’[0]\n20:    end for\n21:    forspkADRS â† ADRS                            â–· copy address to create a FORS public-key address\n22:    forspkADRS.setTypeAndClear(FORS_ROOTS)\n23:    forspkADRS.setKeyPairAddress(ADRS.getKeyPairAddress())\n24:    ğ‘ğ‘˜ â† Tğ‘˜(PK.seed, forspkADRS, ğ‘Ÿğ‘œğ‘œğ‘¡)        â–· compute the FORS public key\n25:    return ğ‘ğ‘˜\n\n32"
  },
  {
    "doc_id": "NIST.FIPS.205",
    "source_path": "data/raw_pdfs/NIST.FIPS.205.pdf",
    "page_number": 43,
    "text": "FIPS 205                                         STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n\n9.   SLH-DSA Internal Functions\n\nSLH-DSA uses the hypertree and the FORS keys to create a stateless hash-based signature scheme.\n                         The SLH-DSA private key contains a secret seed value and a secret PRF key. The public key consists\nof a key identifier PK.seed and the root of the hypertree. A signature is created by hashing\nthe message, using part of the message digest to select a FORS key, signing other bits from the\nmessage digest with the FORS key, and generating a hypertree signature for the FORS key. The\nparameters for SLH-DSA are those specified previously for WOTSâº, XMSS, the SLH-DSA hypertree,\nand FORS (see Table 2).\nSLH-DSA uses one additional parameter ğ‘š, which is the length in bytes of the message digest. It\nis computed as:\n\n                                                          ğ‘š = âŒˆâ„ âˆ’ â„â€² âŒ‰ + âŒˆâ„â€² âŒ‰ + âŒˆğ‘˜ â‹… ğ‘ âŒ‰\n                                              8    8   8\n\nSLH-DSA uses â„ bits of the message digest to select a FORS key: â„ âˆ’ â„â€² bits to select an XMSS\ntree at the lowest layer and â„â€² bits to select a WOTSâº key and corresponding FORS key from that\ntree. ğ‘˜ â‹… ğ‘ bits of the digest are signed by the selected FORS key. While only â„ + ğ‘˜ â‹… ğ‘ bits of the\nmessage digest are used, implementation is simplified by extracting the necessary bits from a\nslightly larger digest.\n                             This section describes the functions for SLH-DSA key generation, signature generation, and\nsignature verification. In the functions in this section, where randomness is required, the random\n                       values are provided as inputs to the functions. The interfaces specified in this section will be used\n                              when testing of SLH-DSA implementations is performed through the Cryptographic Algorithm\n                         Validation Program (CAVP). The key generation function in this section may also be used to obtain\nthe assurance of private key possession via regeneration, as described in Section 3.1.\nOther than for testing purposes, the interfaces for key generation and signature generation\nspecified in this section should not be made available to applications, as any random values\nrequired for key generation and signature generation shall be generated by the cryptographic\nmodule. Section 10 provides guidance on the interfaces to be made available to applications.\n\n9.1  SLH-DSA Key Generation\nSLH-DSA public keys contain two elements (see Figure 16). The first is an ğ‘›-byte public seed\nPK.seed, which is used in many hash function calls to provide domain separation between\ndifferent SLH-DSA key pairs. The second value is the hypertree public key (i.e., the root of the\ntop layer XMSS tree). PK.seed shall be generated using an approved random bit generator (see\n\nSK.seed                ğ‘› bytes\n SK.prf                ğ‘› bytes                        PK.seed      ğ‘› bytes\nPK.seed                ğ‘› bytes                         PK.root     ğ‘› bytes\nPK.root                ğ‘› bytes\n\n            Figure 15. SLH-DSA private key             Figure 16. SLH-DSA public key\n                                                 33"
  },
  {
    "doc_id": "NIST.FIPS.205",
    "source_path": "data/raw_pdfs/NIST.FIPS.205.pdf",
    "page_number": 44,
    "text": "FIPS 205                                         STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n\n[14, 15, 16]), where the instantiation of the random bit generator supports at least 8ğ‘› bits of\nsecurity strength.\n       The SLH-DSA private key contains two random, secret ğ‘›-byte values (see Figure 15). SK.seed is\nused to generate all of the WOTSâº and FORS private key elements. SK.prf is used to generate a\nrandomization value for the randomized hashing of the message in SLH-DSA. The private key\nalso includes a copy of the public key. Both SK.seed and SK.prf shall be generated using an\napproved random bit generator, where the instantiation of the random bit generator supports\nat least 8ğ‘› bits of security strength.\n      Algorithm 18 generates an SLH-DSA key pair. Lines 1 through 3 compute the root of the top layer\n          XMSS tree. Line 4 bundles the three inputs and the computed PK.seed into the private and\npublic keys.\nSLH-DSA signing has two variants â€” â€œhedgedâ€ and deterministic (see Section 9.2) â€” whose keys\nshould only be used for the generation and verification of hedged and deterministic SLH-DSA\ndigital signatures, respectively.\n\nAlgorithm 18 slh_keygen_internal(SK.seed, SK.prf, PK.seed)\nGenerates an SLH-DSA key pair.\nInput: Secret seed SK.seed, PRF key SK.prf, public seed PK.seed\nOutput: SLH-DSA key pair (SK, PK).\n 1:  ADRS â† toByte(0, 32)              â–· generate the public key for the top-level XMSS tree\n 2:  ADRS.setLayerAddress(ğ‘‘ âˆ’ 1)\n 3:  PK.root â† xmss_node(SK.seed, 0, â„â€² , PK.seed, ADRS)\n 4:  return ( (SK.seed, SK.prf, PK.seed, PK.root), (PK.seed, PK.root) )\n\n9.2  SLH-DSA Signature Generation\n         An SLH-DSA signature consists of a randomization string, a FORS signature, and a hypertree\nsignature, as shown in Figure 17.\nGenerating an SLH-DSA signature (Algorithm 19) begins by creating an ğ‘š-byte message digest\n     (lines 2 through 5). A PRF is used to create a message randomizer (line 3), and it is hashed along\n     with the message to create the digest (line 5). Bits are then extracted from the message digest to\nbe signed by the FORS key (line 6), to select an XMSS tree (lines 7 and 9), and to select a WOTSâº\nkey and corresponding FORS key within that XMSS tree (lines 8 and 10). Next, the FORS signature\nis computed (lines 11 through 14), and the corresponding FORS public key is obtained (line 16).\nFinally, the FORS public key is signed (line 17).\n\n                  Randomness R                   ğ‘› bytes\n     FORS signature SIGFORS                      ğ‘˜(1 + ğ‘) â‹… ğ‘› bytes\n       HT signature SIGHT                        (â„ + ğ‘‘ â‹… ğ‘™ğ‘’ğ‘›) â‹… ğ‘› bytes\n\n                                  Figure 17. SLH-DSA signature data format\n\n                                                     34"
  },
  {
    "doc_id": "NIST.FIPS.205",
    "source_path": "data/raw_pdfs/NIST.FIPS.205.pdf",
    "page_number": 45,
    "text": "FIPS 205    STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n\nAlgorithm 19 slh_sign_internal(ğ‘€, SK, ğ‘ğ‘‘ğ‘‘ğ‘Ÿğ‘›ğ‘‘)\nGenerates an SLH-DSA signature.\nInput: Message ğ‘€, private key SK = (SK.seed, SK.prf, PK.seed, PK.root),\n     (optional) additional randomness ğ‘ğ‘‘ğ‘‘ğ‘Ÿğ‘›ğ‘‘.\nOutput: SLH-DSA signature SIG.\n 1:  ADRS â† toByte(0, 32)\n 2:  ğ‘œğ‘ğ‘¡_ğ‘Ÿğ‘ğ‘›ğ‘‘ â† ğ‘ğ‘‘ğ‘‘ğ‘Ÿğ‘›ğ‘‘       â–· substitute ğ‘œğ‘ğ‘¡_ğ‘Ÿğ‘ğ‘›ğ‘‘ â† PK.seed for the deterministic variant\n 3:  ğ‘… â† PRFğ‘šğ‘ ğ‘”(SK.prf, ğ‘œğ‘ğ‘¡_ğ‘Ÿğ‘ğ‘›ğ‘‘, ğ‘€ )                                      â–· generate randomizer\n 4:  SIG â† ğ‘…\n 5:  ğ‘‘ğ‘–ğ‘”ğ‘’ğ‘ ğ‘¡ â† Hğ‘šğ‘ ğ‘”(ğ‘…, PK.seed, PK.root, ğ‘€ )                     â–· compute message digest\n 6:  ğ‘šğ‘‘ â† ğ‘‘ğ‘–ğ‘”ğ‘’ğ‘ ğ‘¡ [0 âˆ¶ âŒˆğ‘˜â‹…ğ‘âŒ‰]                                                           â–· first âŒˆğ‘˜â‹…ğ‘âŒ‰ bytes\n                        8                                          â„âˆ’â„/ğ‘‘                        8\n 7:  ğ‘¡ğ‘šğ‘_ğ‘–ğ‘‘ğ‘¥ğ‘¡ğ‘Ÿğ‘’ğ‘’ â† ğ‘‘ğ‘–ğ‘”ğ‘’ğ‘ ğ‘¡ [âŒˆ ğ‘˜â‹…ğ‘âŒ‰ âˆ¶ âŒˆğ‘˜â‹…ğ‘âŒ‰ + âŒˆ            âŒ‰]        â–· next âŒˆ â„âˆ’â„/ğ‘‘ âŒ‰ bytes\n                                          8  8                     8                             8\n 8:  ğ‘¡ğ‘šğ‘_ğ‘–ğ‘‘ğ‘¥ğ‘™ğ‘’ğ‘ğ‘“ â† ğ‘‘ğ‘–ğ‘”ğ‘’ğ‘ ğ‘¡ [âŒˆ ğ‘˜â‹…ğ‘âŒ‰ + âŒˆ â„âˆ’â„/ğ‘‘ âŒ‰ âˆ¶ âŒˆğ‘˜â‹…ğ‘âŒ‰ + âŒˆ â„âˆ’â„/ğ‘‘ âŒ‰ + âŒˆ â„ âŒ‰] â–· next âŒˆ â„ âŒ‰ bytes\n                                          8       8                     8          8  8ğ‘‘        8ğ‘‘\n 9:  ğ‘–ğ‘‘ğ‘¥ğ‘¡ğ‘Ÿğ‘’ğ‘’ â† toInt (ğ‘¡ğ‘šğ‘_ğ‘–ğ‘‘ğ‘¥ğ‘¡ğ‘Ÿğ‘’ğ‘’, âŒˆ â„âˆ’â„/ğ‘‘ âŒ‰) mod 2â„âˆ’â„/ğ‘‘\n                                               8\n10:  ğ‘–ğ‘‘ğ‘¥ğ‘™ğ‘’ğ‘ğ‘“ â† toInt (ğ‘¡ğ‘šğ‘_ğ‘–ğ‘‘ğ‘¥ğ‘™ğ‘’ğ‘ğ‘“ , âŒˆ â„ âŒ‰) mod 2â„/ğ‘‘\n                                               8ğ‘‘\n11:  ADRS.setTreeAddress(ğ‘–ğ‘‘ğ‘¥ğ‘¡ğ‘Ÿğ‘’ğ‘’)\n12:  ADRS.setTypeAndClear(FORS_TREE)\n13:  ADRS.setKeyPairAddress(ğ‘–ğ‘‘ğ‘¥ğ‘™ğ‘’ğ‘ğ‘“ )\n14:  SIGğ¹ ğ‘‚ğ‘…ğ‘† â† fors_sign(ğ‘šğ‘‘, SK.seed, PK.seed, ADRS)\n15:  SIG â† SIG âˆ¥ SIGğ¹ ğ‘‚ğ‘…ğ‘†\n16:  PKğ¹ ğ‘‚ğ‘…ğ‘† â† fors_pkFromSig(SIGğ¹ ğ‘‚ğ‘…ğ‘† , ğ‘šğ‘‘, PK.seed, ADRS)                            â–· get FORS key\n17:  SIGğ»ğ‘‡ â† ht_sign(PKğ¹ ğ‘‚ğ‘…ğ‘† , SK.seed, PK.seed, ğ‘–ğ‘‘ğ‘¥ğ‘¡ğ‘Ÿğ‘’ğ‘’, ğ‘–ğ‘‘ğ‘¥ğ‘™ğ‘’ğ‘ğ‘“ )\n18:  SIG â† SIG âˆ¥ SIGğ»ğ‘‡\n19:  return SIG\n\n35"
  },
  {
    "doc_id": "NIST.FIPS.205",
    "source_path": "data/raw_pdfs/NIST.FIPS.205.pdf",
    "page_number": 46,
    "text": "FIPS 205                                                             STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n\nThe message randomizer may be set in either a non-deterministic or deterministic way, depending\non whether ğ‘ğ‘‘ğ‘‘ğ‘Ÿğ‘›ğ‘‘ is provided as an input. For the â€œhedgedâ€ variant, ğ‘ğ‘‘ğ‘‘ğ‘Ÿğ‘›ğ‘‘ is provided as an\ninput, and ğ‘œğ‘ğ‘¡_ğ‘Ÿğ‘ğ‘›ğ‘‘ is set to ğ‘ğ‘‘ğ‘‘ğ‘Ÿğ‘›ğ‘‘. The hedged variant is the default and should be used on\nplatforms where side-channel attacks are a concern. When using the hedged version, ğ‘ğ‘‘ğ‘‘ğ‘Ÿğ‘›ğ‘‘\nshall be an ğ‘›-byte random value. While ğ‘ğ‘‘ğ‘‘ğ‘Ÿğ‘›ğ‘‘ should ideally be generated by an approved\nrandom bit generator, other methods for generating fresh random values may be used. For\nthe deterministic variant, ğ‘ğ‘‘ğ‘‘ğ‘Ÿğ‘›ğ‘‘ is not provided as an input, and ğ‘œğ‘ğ‘¡_ğ‘Ÿğ‘ğ‘›ğ‘‘ is set to PK.seed,\nwhich results in signing being deterministic (i.e., signing the same message twice will result in\nthe same signature). The deterministic variant is available for platforms where a random bit\ngenerator is not available.\n\n9.3    SLH-DSA Signature Verification\nAs with signature generation, SLH-DSA signature verification (Algorithm 20) begins by computing\na message digest (line 8) and then extracting ğ‘šğ‘‘ (line 9), ğ‘–ğ‘‘ğ‘¥ğ‘¡ğ‘Ÿğ‘’ğ‘’ (lines 10 and 12), and ğ‘–ğ‘‘ğ‘¥ğ‘™ğ‘’ğ‘ğ‘“\n(lines 11 and 13) from the digest. A candidate FORS public key is then computed (line 17), and\nthe signature on the FORS key is verified (line 18). If this signature verification succeeds, then\nthe correct FORS public key was computed, and the signature SIG on message ğ‘€ is valid.\n\nAlgorithm 20 slh_verify_internal(ğ‘€, SIG, PK)\nVerifies an SLH-DSA signature.\nInput: Message ğ‘€, signature SIG, public key PK = (PK.seed, PK.root).\nOutput: Boolean.\n 1:    if |SIG| â‰  (1 + ğ‘˜(1 + ğ‘) + â„ + ğ‘‘ â‹… ğ‘™ğ‘’ğ‘›) â‹… ğ‘› then\n 2:         return false\n 3:    end if\n 4:    ADRS â† toByte(0, 32)\n 5:    ğ‘… â† SIG.getR()                                                                             â–· SIG[0 âˆ¶ ğ‘›]\n 6:    SIGğ¹ ğ‘‚ğ‘…ğ‘† â† SIG.getSIG_FORS()                                      â–· SIG[ğ‘› âˆ¶ (1 + ğ‘˜(1 + ğ‘)) â‹… ğ‘›]\n 7:    SIGğ»ğ‘‡ â† SIG.getSIG_HT()            â–· SIG[(1 + ğ‘˜(1 + ğ‘)) â‹… ğ‘› âˆ¶ (1 + ğ‘˜(1 + ğ‘) + â„ + ğ‘‘ â‹… ğ‘™ğ‘’ğ‘›) â‹… ğ‘›]\n 8:    ğ‘‘ğ‘–ğ‘”ğ‘’ğ‘ ğ‘¡ â† Hğ‘šğ‘ ğ‘”(ğ‘…, PK.seed, PK.root, ğ‘€ )                     â–· compute message digest\n 9:    ğ‘šğ‘‘ â† ğ‘‘ğ‘–ğ‘”ğ‘’ğ‘ ğ‘¡ [0 âˆ¶ âŒˆğ‘˜â‹…ğ‘âŒ‰]                                                           â–· first âŒˆğ‘˜â‹…ğ‘âŒ‰ bytes\n                          8                                          â„âˆ’â„/ğ‘‘                        8\n10:    ğ‘¡ğ‘šğ‘_ğ‘–ğ‘‘ğ‘¥ğ‘¡ğ‘Ÿğ‘’ğ‘’ â† ğ‘‘ğ‘–ğ‘”ğ‘’ğ‘ ğ‘¡ [âŒˆ ğ‘˜â‹…ğ‘âŒ‰ âˆ¶ âŒˆğ‘˜â‹…ğ‘âŒ‰ + âŒˆ            âŒ‰]    â–· next âŒˆ â„âˆ’â„/ğ‘‘ âŒ‰ bytes\n                                            8  8                     8                             8\n11:    ğ‘¡ğ‘šğ‘_ğ‘–ğ‘‘ğ‘¥ğ‘™ğ‘’ğ‘ğ‘“ â† ğ‘‘ğ‘–ğ‘”ğ‘’ğ‘ ğ‘¡ [âŒˆ ğ‘˜â‹…ğ‘âŒ‰ + âŒˆ â„âˆ’â„/ğ‘‘ âŒ‰ âˆ¶ âŒˆğ‘˜â‹…ğ‘âŒ‰ + âŒˆ â„âˆ’â„/ğ‘‘ âŒ‰ + âŒˆ â„ âŒ‰] â–· next âŒˆ â„ âŒ‰ bytes\n                                            8       8                     8          8  8ğ‘‘        8ğ‘‘\n12:    ğ‘–ğ‘‘ğ‘¥ğ‘¡ğ‘Ÿğ‘’ğ‘’ â† toInt (ğ‘¡ğ‘šğ‘_ğ‘–ğ‘‘ğ‘¥ğ‘¡ğ‘Ÿğ‘’ğ‘’, âŒˆ â„âˆ’â„/ğ‘‘ âŒ‰) mod 2â„âˆ’â„/ğ‘‘\n                                                 8\n13:    ğ‘–ğ‘‘ğ‘¥ğ‘™ğ‘’ğ‘ğ‘“ â† toInt (ğ‘¡ğ‘šğ‘_ğ‘–ğ‘‘ğ‘¥ğ‘™ğ‘’ğ‘ğ‘“ , âŒˆ â„ âŒ‰) mod 2â„/ğ‘‘\n                                                 8ğ‘‘\n14:    ADRS.setTreeAddress(ğ‘–ğ‘‘ğ‘¥ğ‘¡ğ‘Ÿğ‘’ğ‘’)                                              â–· compute FORS public key\n15:    ADRS.setTypeAndClear(FORS_TREE)\n16:    ADRS.setKeyPairAddress(ğ‘–ğ‘‘ğ‘¥ğ‘™ğ‘’ğ‘ğ‘“ )\n17:    PKğ¹ ğ‘‚ğ‘…ğ‘† â† fors_pkFromSig(SIGğ¹ ğ‘‚ğ‘…ğ‘† , ğ‘šğ‘‘, PK.seed, ADRS)\n18:    return ht_verify(PKğ¹ ğ‘‚ğ‘…ğ‘† , SIGğ»ğ‘‡, PK.seed, ğ‘–ğ‘‘ğ‘¥ğ‘¡ğ‘Ÿğ‘’ğ‘’, ğ‘–ğ‘‘ğ‘¥ğ‘™ğ‘’ğ‘ğ‘“ , PK.root)\n\n                                                       36"
  },
  {
    "doc_id": "NIST.FIPS.205",
    "source_path": "data/raw_pdfs/NIST.FIPS.205.pdf",
    "page_number": 47,
    "text": "FIPS 205                                    STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n\n10.         SLH-DSA External Functions\n\nThis section provides guidance on the key generation, signature generation, and signature\nverification functions that should be provided for use by applications. The functions in this\nsection use the functions in Section 9 to implement the underlying SLH-DSA scheme.\n\n10.1        SLH-DSA Key Generation\nAlgorithm 21 generates an SLH-DSA key pair.      Lines 1 through 3 generate the random values\nfor the private and public keys, and line 7 calls slh_keygen_internal to compute PK.root and\nreturn the private and public key. PK.seed, SK.seed, and SK.prf shall be generated using an\napproved random bit generator (see [14, 15, 16]), where the instantiation of the random bit\ngenerator supports at least 8ğ‘› bits of security strength.\n\nAlgorithm 21 slh_keygen()\nGenerates an SLH-DSA key pair.\nInput: (none)\nOutput: SLH-DSA key pair (SK, PK).\n       SK.seed    $     ğ‘›\n               â†\n 1:               âˆ’ ğ”¹            â–· set SK.seed, SK.prf, and PK.seed to random ğ‘›-byte\n       SK.prf  $        ğ‘›\n              â†\n 2:            âˆ’ ğ”¹                     â–· strings using an approved random bit generator\n       PK.seed     $      ğ‘›\n                  â†\n 3:                âˆ’ ğ”¹\n 4:    if SK.seed = NULL or SK.prf = NULL or PK.seed = NULL then\n 5:         return âŠ¥              â–· return an error indication if random bit generation failed\n 6:    end if\n 7:    return slh_keygen_internal(SK.seed, SK.prf, PK.seed)\n\n10.2        SLH-DSA Signature Generation\nThis section presents two versions of SLH-DSA signature generation: a â€œpureâ€ version (slh_sign)\nand a â€œpre-hashâ€ version (hash_slh_sign). Both versions use slh_sign_internal, but they differ\nin how the message input to slh_sign_internal is created from the content to be signed. In the\npure version, the content is signed by slh_sign_internal along with some domain separation\ninformation. In the pre-hash version, a hash of the content is signed by slh_sign_internal along\nwith some domain separation information.\nBoth versions take the content to be signed, the private key, and a context as input. The pre-hash\n                   version also takes as input a hash function or XOF that is to be used to pre-hash the content to\nbe signed. The context string has a maximum length of 255 bytes. By default, the context is the\nempty string. However, applications may specify the use of a non-empty context string.\nThe identifier for a signature (e.g., the object identifier [OID]) should indicate whether the\nsignature is a pure signature or a pre-hash signature. In the case of pre-hash signatures, the\nidentifier should also indicate the hash function or XOF used to compute the pre-hash.Â¹â· While\n17In the case of a XOF, this would also include the length of the output from the XOF.\n                                                                  37"
  },
  {
    "doc_id": "NIST.FIPS.205",
    "source_path": "data/raw_pdfs/NIST.FIPS.205.pdf",
    "page_number": 48,
    "text": "FIPS 205                        STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n\na single key pair may be used for both pure and pre-hash signatures, it is recommended that\neach key pair only be used for one version or the other. If a non-empty context string is to be\nused, this should either be indicated by the signatureâ€™s identifier or the application with which\nthe signature is being used.\nIf the default hedged variant of slh_sign_internal is used, the ğ‘›-byte random value ğ‘ğ‘‘ğ‘‘ğ‘Ÿğ‘›ğ‘‘\nshall be generated by the cryptographic module that runs slh_sign_internal. However, ğ‘€â€² in\nAlgorithms 22 and 23 may be constructed outside of the crytographic module. In the case of\nhash_slh_sign, the hash or XOF of the content to be signed must be computed within a FIPS\n140-validated cryptographic module, but it may be a different cryptographic module than the\none that runs slh_sign_internal.\nIn general, the pure version is preferred. However, for some cryptographic modules that generate\nSLH-DSA signatures, performing lines 3 and 5 of Algorithm 19 may be infeasible if the message ğ‘€\nis large. This may, for example, be the result of the module having limited memory to store the\nmessage to be signed. Similarly, for some cryptographic modules that verify SLH-DSA signatures,\nperforming line 8 of Algorithm 20 may be infeasible if the message ğ‘€ is large. For some use\ncases, these issues may be addressed by signing a digest of the content rather than signing the\ncontent directly.\nIn many cases where the content to be signed is large, hashing of the content is performed at\nthe application level. For example, in the Cryptographic Message Syntax [23], a digest of the\ncontent may be computed, and that digest is signed along with other attributes.   In cases in\nwhich the content is not hashed at the application level, the pre-hash version of SLH-DSA signing\n(Section 10.2.2) may be used.\nTo maintain the same level of security strength when the content is hashed at the application\nlevel or when using the pre-hash version of SLH-DSA, the digest that is signed needs to be\ngenerated using an approved hash function or XOF (e.g., from FIPS 180-4 [8] or FIPS 202 [6]) that\nprovides at least 8ğ‘› bits of classical security strength against both collision and second preimage\nattacks [6, Table 4].Â¹â¸              Verification of a signature created in this way will require the verify function\nto generate a digest from the message in the same way for input to the verification function.\nEven if it is feasible to compute collisions on the hash functions or XOF used to instantiate Hğ‘šğ‘ ğ‘”,\nPRF, PRFğ‘šğ‘ ğ‘”, F, H, and Tğ‘™, there is believed to be no adverse effect on the security of\nSLH-DSA.Â¹â¹ However, if the input to the signing function is a digest of the content, then collisions\non the function used to compute the digest can result in forged messages.\n\n10.2.1      Pure SLH-DSA Signature Generation\nIn the pure version, the content to be signed is prepended with a one-byte domain separator,\none byte that indicates the length of the context string, and the context string.                          The domain\nseparator, which has a value of zero for pure signing, is included to prevent pre-hash signatures\nfrom verifying as pure signatures and vice versa. In the default case in which the context string\n\n18Obtaining at least 8ğ‘› bits of classical security strength against collision attacks requires that the digest to be\n   signed is at least 2ğ‘› bytes in length.\n19As noted in Section 11, applications that require message-bound signatures may be adversely affected if it is\n   feasible to compute collisions on Hğ‘šğ‘ ğ‘”.\n                                             38"
  },
  {
    "doc_id": "NIST.FIPS.205",
    "source_path": "data/raw_pdfs/NIST.FIPS.205.pdf",
    "page_number": 49,
    "text": "FIPS 205                                               STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n\nis empty, pure signing simply involves prepending two zero bytes to the content to be signed\nand passing the result to slh_sign_internal along with the private key and, in the case of hedged\nsigning, an ğ‘›-byte random value.\n\nAlgorithm 22 slh_sign(ğ‘€, ğ‘ğ‘¡ğ‘¥, SK)\nGenerates a pure SLH-DSA signature.\nInput: Message ğ‘€, context string ğ‘ğ‘¡ğ‘¥, private key SK.\nOutput: SLH-DSA signature SIG.\n 1:    if |ğ‘ğ‘¡ğ‘¥| > 255 then\n 2:         return âŠ¥                    â–· return an error indication if the context string is too long\n 3:    end if\n       ğ‘ğ‘‘ğ‘‘ğ‘Ÿğ‘›ğ‘‘  $  ğ‘›\n                    â†\n 4:                  âˆ’ ğ”¹                       â–· skip lines 4 through 7 for the deterministic variant\n 5:    if ğ‘ğ‘‘ğ‘‘ğ‘Ÿğ‘›ğ‘‘ = NULL then\n 6:         return âŠ¥                      â–· return an error indication if random bit generation failed\n 7:    end if\n 8:    ğ‘€â€² â† toByte(0, 1) âˆ¥ toByte(|ğ‘ğ‘¡ğ‘¥|, 1) âˆ¥ ğ‘ğ‘¡ğ‘¥ âˆ¥ ğ‘€\n 9:    SIG â† slh_sign_internal(ğ‘€ â€² , SK, ğ‘ğ‘‘ğ‘‘ğ‘Ÿğ‘›ğ‘‘)    â–· omit ğ‘ğ‘‘ğ‘‘ğ‘Ÿğ‘›ğ‘‘ for the deterministic variant\n10:    return SIG\n\n10.2.2      HashSLH-DSA Signature Generation\nIn the pre-hash version, the message input to slh_sign_internal is the result of applying either a\nhash function or a XOF to the content to be signed. The output of the hash function or XOF is\nprepended by a one-byte domain separator, one byte that indicates the length of the context\nstring, the context string, and the distinguished encoding rules (DER) encoding of the hash\nfunction or XOFâ€™s OID. The domain separator has a value of one for pre-hash signing. The DER\nencoding of the OID includes the tag and length.\nAlgorithm 23 shows the DER encodings of the OIDs for SHA-256, SHA-512, SHAKE128, and\nSHAKE256. However, hash_slh_sign may be used with other hash functions or XOFs. SHA-256\nand SHAKE128 are only appropriate for use with SLH-DSA parameter sets that are claimed to be\nin security category 1 (see Section 11).\n\n39"
  },
  {
    "doc_id": "NIST.FIPS.205",
    "source_path": "data/raw_pdfs/NIST.FIPS.205.pdf",
    "page_number": 50,
    "text": "FIPS 205    STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n\nAlgorithm 23 hash_slh_sign(ğ‘€, ğ‘ğ‘¡ğ‘¥, PH, SK)\nGenerates a pre-hash SLH-DSA signature.\nInput: Message ğ‘€, context string ğ‘ğ‘¡ğ‘¥, pre-hash function PH, private key SK.\nOutput: SLH-DSA signature SIG.\n 1:    if |ğ‘ğ‘¡ğ‘¥| > 255 then\n 2:     return âŠ¥                  â–· return an error indication if the context string is too long\n 3:    end if\n       ğ‘ğ‘‘ğ‘‘ğ‘Ÿğ‘›ğ‘‘  $  ğ‘›\n                    â†\n 4:                  âˆ’ ğ”¹              â–· skip lines 4 through 7 for the deterministic variant\n 5:    if ğ‘ğ‘‘ğ‘‘ğ‘Ÿğ‘›ğ‘‘ = NULL then\n 6:     return âŠ¥                  â–· return an error indication if random bit generation failed\n 7:    end if\n 8:    switch PH do\n 9:     case SHA-256:\n10:          OID â† toByte(0x0609608648016503040201, 11)              â–· 2.16.840.1.101.3.4.2.1\n11:          PHğ‘€ â† SHA-256(ğ‘€)\n12:     case SHA-512:\n13:          OID â† toByte(0x0609608648016503040203, 11)              â–· 2.16.840.1.101.3.4.2.3\n14:          PHğ‘€ â† SHA-512(ğ‘€)\n15:     case SHAKE128:\n16:          OID â† toByte(0x060960864801650304020B, 11)              â–· 2.16.840.1.101.3.4.2.11\n17:          PHğ‘€ â† SHAKE128(ğ‘€, 256)\n18:     case SHAKE256:\n19:          OID â† toByte(0x060960864801650304020C, 11)              â–· 2.16.840.1.101.3.4.2.12\n20:          PHğ‘€ â† SHAKE256(ğ‘€, 512)\n21:     case â€¦                                           â–· other approved hash functions or XOFs\n22:          â€¦\n23:    end switch\n24:    ğ‘€â€² â† toByte(1, 1) âˆ¥ toByte(|ğ‘ğ‘¡ğ‘¥|, 1) âˆ¥ ğ‘ğ‘¡ğ‘¥ âˆ¥ OID âˆ¥ PHğ‘€\n25:    SIG â† slh_sign_internal(ğ‘€ â€² , SK, ğ‘ğ‘‘ğ‘‘ğ‘Ÿğ‘›ğ‘‘)  â–· omit ğ‘ğ‘‘ğ‘‘ğ‘Ÿğ‘›ğ‘‘ for the deterministic variant\n26:    return SIG\n\n40"
  },
  {
    "doc_id": "NIST.FIPS.205",
    "source_path": "data/raw_pdfs/NIST.FIPS.205.pdf",
    "page_number": 51,
    "text": "FIPS 205                                       STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n\n10.3        SLH-DSA Signature Verification\nAlgorithms 24 and 25 present the pure and pre-hash versions of SLH-DSA signature verification\nthat correspond to the pure and pre-hash versions of SLH-DSA signature generation in Sec-\ntion 10.2. These functions construct ğ‘€â€² in the same way as Algorithms 22 and 23, respectively,\nand pass the resulting ğ‘€â€² to slh_verify_internal for verification. As with signature generation,\nğ‘€â€² may be constructed outside of the cryptographic module that performs slh_verify_internal.\nHowever, in the case of hash_slh_verify, the hash or XOF of the content must be computed within\na FIPS 140-validated cryptographic module, which may be a different cryptographic module than\nthe one that performs slh_verify_internal.\nThe identifier associated with the signature should indicate whether the pure or pre-hash version\nof signature verification should be used, and in the pre-hash case, the hash function or XOF to\nuse to compute the pre-hash. A non-empty context string should be used in verification if one is\nspecified in the signatureâ€™s identifier or by the application with which the signature is being used.\n\nAlgorithm 24 slh_verify(ğ‘€, SIG, ğ‘ğ‘¡ğ‘¥, PK)\nVerifies a pure SLH-DSA signature.\nInput: Message ğ‘€, signature SIG, context string ğ‘ğ‘¡ğ‘¥, public key PK.\nOutput: Boolean.\n 1:  if |ğ‘ğ‘¡ğ‘¥| > 255 then\n 2:         return false\n 3:  end if\n 4:  ğ‘€â€² â† toByte(0, 1) âˆ¥ toByte(|ğ‘ğ‘¡ğ‘¥|, 1) âˆ¥ ğ‘ğ‘¡ğ‘¥ âˆ¥ ğ‘€\n 5:  return slh_verify_internal(ğ‘€ â€² , SIG, PK)\n\n41"
  },
  {
    "doc_id": "NIST.FIPS.205",
    "source_path": "data/raw_pdfs/NIST.FIPS.205.pdf",
    "page_number": 52,
    "text": "FIPS 205    STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n\nAlgorithm 25 hash_slh_verify(ğ‘€, SIG, ğ‘ğ‘¡ğ‘¥, PH, PK)\nVerifies a pre-hash SLH-DSA signature.\nInput: Message ğ‘€, signature SIG, context string ğ‘ğ‘¡ğ‘¥, pre-hash function PH, public key PK.\nOutput: Boolean.\n 1:    if |ğ‘ğ‘¡ğ‘¥| > 255 then\n 2:     return false\n 3:    end if\n 4:    switch PH do\n 5:     case SHA-256:\n 6:          OID â† toByte(0x0609608648016503040201, 11)              â–· 2.16.840.1.101.3.4.2.1\n 7:          PHğ‘€ â† SHA-256(ğ‘€)\n 8:     case SHA-512:\n 9:          OID â† toByte(0x0609608648016503040203, 11)              â–· 2.16.840.1.101.3.4.2.3\n10:          PHğ‘€ â† SHA-512(ğ‘€)\n11:     case SHAKE128:\n12:          OID â† toByte(0x060960864801650304020B, 11)              â–· 2.16.840.1.101.3.4.2.11\n13:          PHğ‘€ â† SHAKE128(ğ‘€, 256)\n14:     case SHAKE256:\n15:          OID â† toByte(0x060960864801650304020C, 11)              â–· 2.16.840.1.101.3.4.2.12\n16:          PHğ‘€ â† SHAKE256(ğ‘€, 512)\n17:     case â€¦                                       â–· other approved hash functions or XOFs\n18:          â€¦\n19:    end switch\n20:    ğ‘€â€² â† toByte(1, 1) âˆ¥ toByte(|ğ‘ğ‘¡ğ‘¥|, 1) âˆ¥ ğ‘ğ‘¡ğ‘¥ âˆ¥ OID âˆ¥ PHğ‘€\n21:    return slh_verify_internal(ğ‘€ â€² , SIG, PK)\n\n42"
  },
  {
    "doc_id": "NIST.FIPS.205",
    "source_path": "data/raw_pdfs/NIST.FIPS.205.pdf",
    "page_number": 53,
    "text": "FIPS 205                                         STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n\n11.         Parameter Sets\n\n                                                 This standard approves 12 parameter sets for use with SLH-DSA. A parameter set consists of\nparameters for WOTSâº (ğ‘› and ğ‘™ğ‘”ğ‘¤), XMSS and the SLH-DSA hypertree (â„ and ğ‘‘), and FORS (ğ‘˜\nand ğ‘), as well as instantiations for the functions Hğ‘šğ‘ ğ‘”, PRF, PRFğ‘šğ‘ ğ‘”, F, H, and Tâ„“.\nTable 2 lists the parameter sets that are approved for use.Â²â°         Each parameter set name indicates\nthe hash function family (SHA2 or SHAKE) that is used to instantiate the hash functions, the\nlength in bits of the security parameter ğ‘›, and whether the parameter set was designed to create\nrelatively small signatures (â€˜sâ€™) or to have relatively fast signature generation (â€˜fâ€™). There are six\nsets of values for ğ‘›, ğ‘™ğ‘”ğ‘¤, â„, ğ‘‘, ğ‘˜, and ğ‘ that are approved for use.Â²Â¹     For each of the six sets of\n                                                   values, the functions Hğ‘šğ‘ ğ‘”, PRF, PRFğ‘šğ‘ ğ‘”, F, H, and Tâ„“ may be instantiated using either\nSHAKE [6] or SHA-2 [8]. For the SHAKE parameter sets, the functions shall be instantiated as\nspecified in Section 11.1. For the SHA2 parameter sets, the functions shall be instantiated as\nspecified in Section 11.2.1 if ğ‘› = 16 and shall be instantiated as specified in Section 11.2.2 if\nğ‘› = 24 or ğ‘› = 32.\n\n                                                                              Table 2. SLH-DSA parameter sets\n\n                                                                                  security     pk    sig\n                       ğ‘›     â„      ğ‘‘    â„â€²    ğ‘        ğ‘˜    ğ‘™ğ‘”ğ‘¤     ğ‘š    category    bytes  bytes\n SLH-DSA-SHA2-128s     16     63     7     9     12        14    4          30     1           32     7 856\n SLH-DSA-SHAKE-128s\n SLH-DSA-SHA2-128f     16     66     22    3     6         33    4          34     1           32    17 088\n SLH-DSA-SHAKE-128f\n SLH-DSA-SHA2-192s     24     63     7     9     14        17    4          39     3           48    16 224\n SLH-DSA-SHAKE-192s\n SLH-DSA-SHA2-192f     24     66     22    3     8         33    4          42     3           48    35 664\n SLH-DSA-SHAKE-192f\n SLH-DSA-SHA2-256s     32     64     8     8     14        22    4          47     5           64    29 792\n SLH-DSA-SHAKE-256s\n SLH-DSA-SHA2-256f     32     68     17    4     9         35    4          49     5           64    49 856\n SLH-DSA-SHAKE-256f\n\n                                                 The 12 parameter sets included in Table 2 were designed to meet certain security strength\ncategories defined by NIST in its original Call for Proposals [25] with respect to existential un-\nforgeability under chosen message attack (EUF-CMA) when each key pair is used to sign at most\n2â¶â´ messages.Â²Â² These security strength categories are explained further in SP 800-57, Part 1 [9].\n\n20SP 800-230 [24] specifies additional parameter sets that are approved for use. While key pairs generated for the\n parameter sets specified in this standard may be used to sign up to 264 messages, key pairs generated for the\n parameter sets in SP 800-230 are more limited in the number of signatures that may be generated.\n21In addition to ğ‘›, ğ‘™ğ‘”ğ‘¤, â„, ğ‘‘, ğ‘˜, and ğ‘, Table 2 also lists values for parameters that may be computed from these\n values (â„â€², ğ‘š, public-key size(pk bytes), and signature size(sig bytes)). The security category is the security\n category in which the parameter set is claimed to be [10].\n22If a key pair were used to sign 10 billion (1010 ) messages per second, it would take over 58 years to sign 264\n messages.\n                                                                                             43"
  },
  {
    "doc_id": "NIST.FIPS.205",
    "source_path": "data/raw_pdfs/NIST.FIPS.205.pdf",
    "page_number": 54,
    "text": "    FIPS 205                                      STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n\n    Using this approach, security strength is not described by a single number, such as â€œ128 bits of\n    security.â€ Instead, each parameter set is claimed to be at least as secure as a generic block cipher\nwith a prescribed key size. More precisely, it is claimed that the computational resources needed\n    to break SLH-DSA are greater than or equal to the computational resources needed to break the\n    block cipher when these computational resources are estimated using any realistic model of\n    computation. Different models of computation can be more or less realistic and, accordingly,\n    lead to more or less accurate estimates of security strength. Some commonly studied models\n    are discussed in [26].\n    Concretely, the parameter sets with ğ‘› = 16 are claimed to be in security category 1, the\n    parameter sets with ğ‘› = 24 are claimed to be in security category 3, and the parameter sets with\n    ğ‘› = 32 are claimed to be in security category 5 [10]. For additional discussion of the security\n    strength of SLH-DSA, see [10, 27].\n    Some applications require a property known as message-bound signatures [28, 29], which\n    intuitively requires that it be infeasible for anyone to create a public key and a signature that\n    are valid for two different messages. Signature schemes are not required to have this property\n    under the EUF-CMA security definition used in assigning security categories.          In the case of\n    SLH-DSA, the key pair owner could create two messages with the same signature by finding\n    a collision on Hğ‘šğ‘ ğ‘”. Due to the length of the output of Hğ‘šğ‘ ğ‘”, finding such a collision would\n    be expected to require fewer computational resources than specified for the parameter setsâ€™\n    claimed security categories in all cases except SLH-DSA-SHA2-128f and SLH-DSA-SHAKE-128f.Â²Â³\n    Therefore, applications that require message-bound signatures should either take the expected\n    cost of finding collisions on Hğ‘šğ‘ ğ‘” into account when choosing an appropriate parameter set or\n    apply a technique (e.g., the BUFF transformation [29]) to obtain the message-bound signatures\n    property.\n\n    11.1        SLH-DSA Using SHAKE\n    Hğ‘šğ‘ ğ‘”, PRF, PRFğ‘šğ‘ ğ‘”, F, H, and Tâ„“ shall be instantiated as follows for the SLH-DSA-SHAKE-\n    128s, SLH-DSA-SHAKE-128f, SLH-DSA-SHAKE-192s, SLH-DSA-SHAKE-192f, SLH-DSA-SHAKE-256s,\n    and SLH-DSA-SHAKE-256f parameter sets:\n    Hğ‘šğ‘ ğ‘”(ğ‘…, PK.seed, PK.root, ğ‘€) = SHAKE256(ğ‘… âˆ¥ PK.seed âˆ¥ PK.root âˆ¥ ğ‘€ , 8ğ‘š)\n    PRF(PK.seed, SK.seed, ADRS) = SHAKE256(PK.seed âˆ¥ ADRS âˆ¥ SK.seed, 8ğ‘›)\n    PRFğ‘šğ‘ ğ‘”(SK.prf, ğ‘œğ‘ğ‘¡_ğ‘Ÿğ‘ğ‘›ğ‘‘, ğ‘€) = SHAKE256(SK.prf âˆ¥ ğ‘œğ‘ğ‘¡_ğ‘Ÿğ‘ğ‘›ğ‘‘ âˆ¥ ğ‘€ , 8ğ‘›)\n    F(PK.seed, ADRS, ğ‘€â‚) = SHAKE256(PK.seed âˆ¥ ADRS âˆ¥ ğ‘€â‚, 8ğ‘›)\n    H(PK.seed, ADRS, ğ‘€â‚‚) = SHAKE256(PK.seed âˆ¥ ADRS âˆ¥ ğ‘€â‚‚, 8ğ‘›)\n    Tâ„“(PK.seed, ADRS, ğ‘€â„“) = SHAKE256(PK.seed âˆ¥ ADRS âˆ¥ ğ‘€â„“, 8ğ‘›)\n\n    11.2        SLH-DSA Using SHA2\n    In Sections 11.2.1 and 11.2.2, the functions MGF1-SHA-256 and MGF1-SHA-512 are MGF1 from\n    Appendix B.2.1 of RFC 8017 [30], where Hash is SHA-256 or SHA-512, respectively. The functions\n\n    23Finding a collision would be expected to require computing Hğ‘šğ‘ ğ‘” for approximately 2(â„+ğ‘˜â‹…ğ‘)/2 different mes-\n    sages.\n          44"
  },
  {
    "doc_id": "NIST.FIPS.205",
    "source_path": "data/raw_pdfs/NIST.FIPS.205.pdf",
    "page_number": 55,
    "text": "    FIPS 205                                    STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n\n    HMAC-SHA-256 and HMAC-SHA-512 are the HMAC function from FIPS 198-1 [31, 32], where ğ»\n    is SHA-256 or SHA-512, respectively.\n    The functions in Sections 11.2.1 and 11.2.2 make use of a compressed version of ADRS (see\n    Figure 18). A compressed address (ADRSğ‘) is a 22-byte string that is the same as an ADRS\n    with the exceptions that the encodings of the layer address and type are reduced to one byte\n    each and the encoding of the tree address is reduced to eight bytes (i.e., ADRSğ‘ = ADRS[3] âˆ¥\n    ADRS[8 âˆ¶ 16] âˆ¥ ADRS[19] âˆ¥ ADRS[20 âˆ¶ 32]). For implementations of the SHA2 parameter\n    sets that store addresses in compressed form (i.e., 22 bytes), the member functions (Section 4.3)\n    are as shown in Table 3 rather than Table 1.\n\n    layer address    1 byte\ntree address       8 bytes\n    ğ‘¡ğ‘¦ğ‘ğ‘’         1 byte\n\n                   12 bytes\n\n    Figure 18. Compressed address (ADRSğ‘)\n\n                       Table 3. Member functions for compressed addresses\n\nMember function\nADRS.setLayerAddress(ğ‘™)\nADRS.setTreeAddress(ğ‘¡)\nADRS.setTypeAndClear(ğ‘Œ)\nADRS.setKeyPairAddress(ğ‘–)\nADRS.setChainAddress(ğ‘–)\nADRS.setTreeHeight(ğ‘–)\nADRS.setHashAddress(ğ‘–)\nADRS.setTreeIndex(ğ‘–)\nğ‘– â† ADRS.getKeyPairAddress()\nğ‘– â† ADRS.getTreeIndex()\n Expanded notation\nADRS â† toByte(ğ‘™, 1) âˆ¥ ADRS[1 âˆ¶ 22]\nADRS â† ADRS[0 âˆ¶ 1] âˆ¥ toByte(ğ‘¡, 8) âˆ¥ ADRS[9 âˆ¶ 22]\nADRS â† ADRS[0 âˆ¶ 9] âˆ¥ toByte(ğ‘Œ , 1) âˆ¥ toByte(0, 12)\nADRS â† ADRS[0 âˆ¶ 10] âˆ¥ toByte(ğ‘–, 4) âˆ¥ ADRS[14 âˆ¶ 22]\nADRS â† ADRS[0 âˆ¶ 14] âˆ¥ toByte(ğ‘–, 4) âˆ¥ ADRS[18 âˆ¶ 22]\n\nADRS â† ADRS[0 âˆ¶ 18] âˆ¥ toByte(ğ‘–, 4)\n\nğ‘– â† toInt(ADRS[10 âˆ¶ 14], 4)\nğ‘– â† toInt(ADRS[18 âˆ¶ 22], 4)\n\n    11.2.1  SLH-DSA Using SHA2 for Security Category 1\n    Hğ‘šğ‘ ğ‘”, PRF, PRFğ‘šğ‘ ğ‘”, F, H, and Tâ„“ shall be instantiated as follows for the SLH-DSA-SHA2-128s\n    and SLH-DSA-SHA2-128f parameter sets:\n    Hğ‘šğ‘ ğ‘”(ğ‘…, PK.seed, PK.root, ğ‘€) =\n            MGF1-SHA-256(ğ‘… âˆ¥ PK.seed âˆ¥ SHA-256(ğ‘… âˆ¥ PK.seed âˆ¥ PK.root âˆ¥ ğ‘€ ), ğ‘š)\n\n                                         45"
  },
  {
    "doc_id": "NIST.FIPS.205",
    "source_path": "data/raw_pdfs/NIST.FIPS.205.pdf",
    "page_number": 56,
    "text": "FIPS 205                           STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n\nPRF(PK.seed, SK.seed, ADRS) =\n\nPRF         Truncğ‘›(SHA-256(PK.seed âˆ¥ toByte(0, 64 âˆ’ ğ‘›) âˆ¥ ADRSğ‘ âˆ¥ SK.seed))\nğ‘šğ‘ ğ‘”(SK.prf, ğ‘œğ‘ğ‘¡_ğ‘Ÿğ‘ğ‘›ğ‘‘, ğ‘€) =\n\nF(PK.seed,  Truncğ‘›(HMAC-SHA-256(SK.prf, ğ‘œğ‘ğ‘¡_ğ‘Ÿğ‘ğ‘›ğ‘‘ âˆ¥ ğ‘€ ))\n            ADRS, ğ‘€â‚) =                                        ğ‘\n\nH(PK.seed,  Truncğ‘›(SHA-256(PK.seed âˆ¥ toByte(0, 64 âˆ’ ğ‘›) âˆ¥ ADRS   âˆ¥ ğ‘€â‚))\n            ADRS, ğ‘€â‚‚) =                                        ğ‘\n\nT (PK.seed, Truncğ‘›(SHA-256(PK.seed âˆ¥ toByte(0, 64 âˆ’ ğ‘›) âˆ¥ ADRS   âˆ¥ ğ‘€â‚‚))\nâ„“           ADRS, ğ‘€â„“) =                                        ğ‘\n            Truncğ‘›(SHA-256(PK.seed âˆ¥ toByte(0, 64 âˆ’ ğ‘›) âˆ¥ ADRS   âˆ¥ ğ‘€â„“))\n\n11.2.2      SLH-DSA Using SHA2 for Security Categories 3 and 5\nHğ‘šğ‘ ğ‘”, PRF, PRFğ‘šğ‘ ğ‘”, F, H, and Tâ„“ shall be instantiated as follows for the SLH-DSA-SHA2-192s,\nSLH-DSA-SHA2-192f, SLH-DSA-SHA2-256s, and SLH-DSA-SHA2-256f parameter sets:\nHğ‘šğ‘ ğ‘”(ğ‘…, PK.seed, PK.root, ğ‘€) =\n            MGF1-SHA-512(ğ‘… âˆ¥ PK.seed âˆ¥ SHA-512(ğ‘… âˆ¥ PK.seed âˆ¥ PK.root âˆ¥ ğ‘€ ), ğ‘š)\nPRF(PK.seed, SK.seed, ADRS) =\n\nPRF         Truncğ‘›(SHA-256(PK.seed âˆ¥ toByte(0, 64 âˆ’ ğ‘›) âˆ¥ ADRSğ‘ âˆ¥ SK.seed))\n     ğ‘šğ‘ ğ‘”(SK.prf, ğ‘œğ‘ğ‘¡_ğ‘Ÿğ‘ğ‘›ğ‘‘, ğ‘€) =\n\nF(PK.seed,  Truncğ‘›(HMAC-SHA-512(SK.prf, ğ‘œğ‘ğ‘¡_ğ‘Ÿğ‘ğ‘›ğ‘‘ âˆ¥ ğ‘€ ))\n            ADRS, ğ‘€â‚) =                                        ğ‘\n\nH(PK.seed,  Truncğ‘›(SHA-256(PK.seed âˆ¥ toByte(0, 64 âˆ’ ğ‘›) âˆ¥ ADRS   âˆ¥ ğ‘€â‚))\n            ADRS, ğ‘€â‚‚) =                                          ğ‘\n\nT (PK.seed, Truncğ‘›(SHA-512(PK.seed âˆ¥ toByte(0, 128 âˆ’ ğ‘›) âˆ¥ ADRS    âˆ¥ ğ‘€â‚‚))\nâ„“           ADRS, ğ‘€â„“) =                                          ğ‘\n            Truncğ‘›(SHA-512(PK.seed âˆ¥ toByte(0, 128 âˆ’ ğ‘›) âˆ¥ ADRS    âˆ¥ ğ‘€â„“))\n\n46"
  },
  {
    "doc_id": "NIST.FIPS.205",
    "source_path": "data/raw_pdfs/NIST.FIPS.205.pdf",
    "page_number": 57,
    "text": "FIPS 205                                  STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n\nReferences\n\n [1]  National Institute of Standards and Technology (2023) Digital Signature Standard (DSS).\n      (Department of Commerce, Washington, D.C.), Federal Information Processing Standards\n      Publications (FIPS) NIST FIPS 186-5. https://doi.org/10.6028/NIST.FIPS.186-5.\n [2]  National Institute of Standards and Technology (2024) Guideline for Using Cryptographic\n      Standards in the Federal Government: Cryptographic Mechanisms. (National Institute of\n      Standards and Technology, Gaithersburg, MD), NIST Special Publication (SP) 800-175B, Rev.\n      2. [Forthcoming: will be available at https://csrc.nist.gov/publications].\n [3]  National Institute of Standards and Technology (2024) Recommendation for Obtaining\n      Assurances for Digital Signature Applications. (National Institute of Standards and Technol-\n      ogy, Gaithersburg, MD), NIST Special Publication (SP) 800-89, Rev. 1. [Forthcoming: will be\n      available at https://csrc.nist.gov/publications].\n [4]  Aumasson JP, Bernstein DJ, Beullens W, Dobraunig C, Eichlseder M, Fluhrer S, Gazdag\n      SL, HÃ¼lsing A, Kampanakis P, KÃ¶lbl S, Lange T, Lauridsen MM, Mendel F, Niederhagen R,\n      Rechberger C, Rijneveld J, Schwabe P, Westerbaan B (2020) SPHINCSâº â€“ Submission to the\n      NIST post-quantum project, v.3.\n [5]  Barker EB, Chen L, Roginsky AL, Vassilev A, Davis R, Simon S (2019) Recommendation for\n      Pair-Wise Key-Establishment Using Integer Factorization Cryptography. (National Institute\n      of Standards and Technology, Gaithersburg, MD), NIST Special Publication (SP) 800-56B,\n      Rev. 2. https://doi.org/10.6028/NIST.SP.800-56Br2.\n [6]  National Institute of Standards and Technology (2015) SHA-3 Standard: Permutation-Based\n      Hash and Extendable-Output Functions. (Department of Commerce, Washington, DC),\n      Federal Information Processing Standards Publication (FIPS) NIST FIPS 202. https://doi.org/\n      10.6028/NIST.FIPS.202.\n [7]  Kelsey JM, Chang SjH, Perlner RA (2016) SHA-3 Derived Functions: cSHAKE, KMAC, Tuple-\n      Hash and ParallelHash. (National Institute of Standards and Technology, Gaithersburg, MD),\n      NIST Special Publication (SP) 800-185. https://doi.org/10.6028/NIST.SP.800-185.\n [8]  National Institute of Standards and Technology (2015) Secure Hash Standard (SHS). (De-\n      partment of Commerce, Washington, D.C.), Federal Information Processing Standards\n      Publication (FIPS) NIST FIPS 180-4. https://doi.org/10.6028/NIST.FIPS.180-4.\n [9]  National Institute of Standards and Technology (2024) Recommendation for Key Manage-\n      ment: Part 1 â€“ General. (National Institute of Standards and Technology, Gaithersburg,\n      MD), NIST Special Publication (SP) 800-57 Part 1, Rev 6. [Forthcoming: will be available at\n      https://csrc.nist.gov/publications].\n[10]  Aumasson JP, Bernstein DJ, Beullens W, Dobraunig C, Eichlseder M, Fluhrer S, Gazdag\n      SL, HÃ¼lsing A, Kampanakis P, KÃ¶lbl S, Lange T, Lauridsen MM, Mendel F, Niederhagen R,\n      Rechberger C, Rijneveld J, Schwabe P, Westerbaan B (2022) SPHINCSâº â€“ Submission to\n      the NIST post-quantum project, v.3.1. Available at https://sphincs.org/data/sphincs+-r3.1-\n      specification.pdf.\n\n47"
  },
  {
    "doc_id": "NIST.FIPS.205",
    "source_path": "data/raw_pdfs/NIST.FIPS.205.pdf",
    "page_number": 58,
    "text": "FIPS 205                                      STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n\n[11]  HÃ¼lsing A, Butin D, Gazdag SL, Rijneveld J, Mohaisen A (2018) XMSS: eXtended Merkle\n      Signature Scheme. (Internet Research Task Force (IRTF)), IRTF Request for Comments (RFC)\n      8391. https://doi.org/10.17487/RFC8391.\n[12]  Cooper DA, Apon D, Dang QH, Davidson MS, Dworkin MJ, Miller CA (2020) Recommendation\n      for Stateful Hash-Based Signature Schemes. (National Institute of Standards and Technology,\n      Gaithersburg, MD), NIST Special Publication (SP) 800-208. https://doi.org/10.6028/NIST.SP.\n      800-208.\n[13]  Merkle RC (1979) Secrecy, Authentication, and Public Key Systems. Ph.D. thesis. Stanford\n      university, .\n[14]  Barker EB, Kelsey JM (2015) Recommendation for Random Number Generation Using\n      Deterministic Random Bit Generators. (National Institute of Standards and Technology,\n      Gaithersburg, MD), NIST Special Publication (SP) 800-90A, Rev. 1. https://doi.org/10.6028/\n      NIST.SP.800-90Ar1.\n[15]  SÃ¶nmez Turan M, Barker EB, Kelsey JM, McKay KA, Baish ML, Boyle M (2018) Recom-\n      mendation for the Entropy Sources Used for Random Bit Generation. (National Institute\n      of Standards and Technology, Gaithersburg, MD), NIST Special Publication (SP) 800-90B.\n      https://doi.org/10.6028/NIST.SP.800-90B.\n[16]  Barker EB, Kelsey JM, McKay KA, Roginsky AL, SÃ¶nmez Turan M (2022) Recommendation for\n      Random Bit Generator (RBG) Constructions. (National Institute of Standards and Technology,\n      Gaithersburg, MD), NIST Special Publication (SP) 800-90C 4pd. https://doi.org/10.6028/\n      NIST.SP.800-90C.4pd.\n[17]  Kannwischer MJ, GenÃªt A, Butin D, KrÃ¤mer J, Buchmann J (2018) Differential Power Analysis\n      of XMSS and SPHINCS. Constructive Side-Channel Analysis and Secure Design, eds Fan J,\n      Gierlichs B (Springer International Publishing, Cham), pp 168â€“188. https://doi.org/10.1007/\n      978-3-319-89641-0_10.\n[18]  Castelnovi L, Martinelli A, Prest T (2018) Grafting Trees: A Fault Attack Against the SPHINCS\n      Framework. Post-Quantum Cryptography, eds Lange T, Steinwandt R (Springer International\n      Publishing, Cham), pp 165â€“184. https://doi.org/10.1007/978-3-319-79063-3_8.\n[19]  GenÃªt A, Kannwischer MJ, Pelletier H, McLauchlan A (2018) Practical Fault Injection Attacks\n      on SPHINCS, Cryptology ePrint Archive preprint. https://ia.cr/2018/674.\n[20]  Amiet D, Leuenberger L, Curiger A, Zbinden P (2020) FPGA-based SPHINCS+ Implementa-\n      tions: Mind the Glitch. 2020 23rd Euromicro Conference on Digital System Design (DSD), pp\n      229â€“237. https://doi.org/10.1109/DSD51259.2020.00046.\n[21]  GenÃªt A (2023) On Protecting SPHINCS+ Against Fault Attacks. IACR Transactions on Cryp-\n      tographic Hardware and Embedded Systems 2023(2):80â€“114. https://doi.org/10.46586/\n      tches.v2023.i2.80-114.\n[22]  Groot Bruinderink L, HÃ¼lsing A (2018) â€œOops, I Did It Againâ€ â€“ Security of One-Time Signatures\n      Under Two-Message Attacks. Selected Areas in Cryptography â€“ SAC 2017, eds Adams C,\n      Camenisch J (Springer International Publishing, Cham), pp 299â€“322. https://doi.org/10.\n      1007/978-3-319-72565-9_15.\n\n                                48"
  },
  {
    "doc_id": "NIST.FIPS.205",
    "source_path": "data/raw_pdfs/NIST.FIPS.205.pdf",
    "page_number": 59,
    "text": "FIPS 205                                    STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n\n[23]  Housley R (2009) Cryptographic Message Syntax (CMS). (Internet Engineering Task Force\n      (IETF)), IETF Request for Comments (RFC) 5652. https://doi.org/10.17487/RFC5652.\n[24]  National Institute of Standards and Technology (2024) Recommendation for Additional\n      Stateless Hash-Based Digital Signature Parameter Sets. (National Institute of Standards and\n      Technology, Gaithersburg, MD), NIST Special Publication (SP) 800-230. [Forthcoming: will\n      be available at https://csrc.nist.gov/publications].\n[25]  National Institute of Standards and Technology (2016) Submission Requirements and Eval-\n      uation Criteria for the Post-Quantum Cryptography Standardization Process. Available\n      at https://csrc.nist.gov/CSRC/media/Projects/Post-Quantum-Cryptography/documents/\n      call-for-proposals-final-dec-2016.pdf.\n[26]  Alagic G, Apon D, Cooper DA, Dang QH, Dang T, Kelsey JM, Lichtinger J, Liu YK, Miller CA,\n      Moody D, Peralta R, Perlner RA, Robinson A, Smith-Tone D (2022) Status Report on the\n      Third Round of the NIST Post-Quantum Cryptography Standardization Process. (National\n      Institute of Standards and Technology, Gaithersburg, MD), NIST Interagency or Internal\n      Report (IR) NIST IR 8413-upd1, includes updates as of September 26, 2022. https://doi.org/\n      10.6028/NIST.IR.8413-upd1.\n[27]  HÃ¼lsing A, Kudinov M (2022) Recovering the Tight Security Proof of SPHINCSâº. Advances in\n      Cryptology â€“ ASIACRYPT 2022, eds Agrawal S, Lin D (Springer Nature Switzerland, Cham),\n      pp 3â€“33. https://doi.org/10.1007/978-3-031-22972-5_1.\n[28]  Stern J, Pointcheval D, Malone-Lee J, Smart NP (2002) Flaws in Applying Proof Methodologies\n      to Signature Schemes. Advances in Cryptology â€” CRYPTO 2002, ed Yung M (Springer Berlin\n      Heidelberg, Berlin, Heidelberg), pp 93â€“110. https://doi.org/10.1007/3-540-45708-9_7.\n[29]  Cremers C, DÃ¼zlÃ¼ S, Fiedler R, Janson C, Fischlin M (2021) BUFFing Signature Schemes\n      Beyond Unforgeability and the Case of Post-Quantum Signatures. 2021 IEEE Symposium on\n      Security and Privacy (SP) (IEEE Computer Society, Los Alamitos, CA, USA), pp 1696â€“1714.\n      https://doi.org/10.1109/SP40001.2021.00093.\n[30]  Moriarty K, Kaliski B, Jonsson J, Rusch A (2016) PKCS #1: RSA Cryptography Specifications\n      Version 2.2. (Internet Engineering Task Force (IETF)), IETF request for comments (RFC) 8017.\n      https://doi.org/10.17487/RFC8017.\n[31]  National Institute of Standards and Technology (2008) The Keyed-Hash Message Authentica-\n      tion Code (HMAC). (Department of Commerce, Washington, DC), Federal Information Pro-\n      cessing Standards Publication (FIPS) NIST FIPS 198-1. https://doi.org/10.6028/NIST.FIPS.198-\n      1.\n[32]  Krawczyk H, Bellare M, Canetti R (1997) HMAC: Keyed-Hashing for Message Authentication.\n      (Internet Engineering Task Force (IETF)), IETF request for comments (RFC) 2104. https:\n      //doi.org/10.17487/RFC2104.\n[33]  Stern M (2021) Re: Diversity of signature schemes. Available at https://groups.google.com/\n      a/list.nist.gov/g/pqc-forum/c/2LEoSpskELs/m/LkUdQ5mKAwAJ.\n[34]  Antonov S (2022) ROUND 3 OFFICIAL COMMENT: SPHINCS+. Available at https://groups.\n      google.com/a/list.nist.gov/g/pqc-forum/c/FVItvyRea28/m/mGaRi5iZBwAJ.\n\n                                            49"
  },
  {
    "doc_id": "NIST.FIPS.205",
    "source_path": "data/raw_pdfs/NIST.FIPS.205.pdf",
    "page_number": 60,
    "text": "FIPS 205    STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n\n[35]  Perlner R, Kelsey J, Cooper D (2022) Breaking Category Five SPHINCSâº with SHA-256. Post-\n      Quantum Cryptography, eds Cheon JH, Johansson T (Springer International Publishing,\n      Cham), pp 501â€“522. https://doi.org/10.1007/978-3-031-17234-2_23.\n\n50"
  },
  {
    "doc_id": "NIST.FIPS.205",
    "source_path": "data/raw_pdfs/NIST.FIPS.205.pdf",
    "page_number": 61,
    "text": "FIPS 205                                      STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n\nAppendix A â€” Differences From the SPHINCS+ Submission\n\n       This standard is based on Version 3.1 of the SPHINCSâº specification [10] and contains several\nminor modifications compared to Version 3 [4], which was submitted at the beginning of round\nthree of the NIST PQC Standardization process:\n  â€¢ Two new address types â€” WOTS_PRF and FORS_PRF â€” were defined for WOTSâº and FORS\n    secret key value generation.\n  â€¢ PK.seed was added as an input to PRF in order to mitigate multi-key attacks.\n  â€¢ For the category 3 and 5 SHA2 parameter sets, SHA-256 was replaced by SHA-512 in Hğ‘šğ‘ ğ‘”,\n    PRFğ‘šğ‘ ğ‘”, H, and Tâ„“ based on weaknesses that were discovered when using SHA-256 to\n    obtain category 5 security [33, 34, 35].\n  â€¢ ğ‘… and PK.seed were added as inputs to MGF1 when computing Hğ‘šğ‘ ğ‘” for the SHA2\n    parameter sets in order to mitigate multi-target long-message second preimage attacks.\n     This standard also differs from the Version 3 specification in its method for extracting bits from\nthe message digest to select a FORS key. This change was made in order to align with the\nreference implementation that was submitted along with the round three specification. The\ndescription of the method for extracting indices for FORS signature generation and verification\nfrom the message digest was also changed due to ambiguity in the submitted specification. The\nmethod described in this standard is not compatible with the method used in the reference\nimplementation that was submitted along with the round three specification. Additionally, line 6\nin both wots_sign and wots_pkFromSig were changed to match the reference implementation,\nas the pseudocode in [10, 4] will sometimes shift ğ‘ğ‘ ğ‘¢ğ‘š by the incorrect amount when ğ‘™ğ‘”ğ‘¤ is not\n4.\n    This standard approves the use of only 12 of the 36 parameter sets defined in [10, 4]. As specified\nin Section 11, only the â€˜simpleâ€™ instances of the SHA2 and SHAKE parameter sets are approved.\n\nA.1 Changes From FIPS 205 Initial Public Draft\n         The differences from Version 3 of the SPHINCSâº specification described in Appendix A were\nincluded in the draft version of this standard (FIPS 205 ipd) that was posted on August 24, 2023.\nBased on comments that were submitted on FIPS 205 ipd, the SLH-DSA signature generation and\n        verification functions were modified to include domain separation cases in which the message\nis signed directly and in which a digest of the message is signed. The changes were made by\nmodifying the inputs to the signing and verification functions (see Algorithms 22, 23, 24, and\n25).\n\n51"
  }
]