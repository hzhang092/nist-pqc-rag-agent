[
  {
    "doc_id": "NIST.SP.800-227",
    "source_path": "data/raw_pdfs/NIST.SP.800-227.pdf",
    "page_number": 1,
    "text": "    NIST Special Publication 800\n    NIST SP 800-227\n\n    Recommendations for Key-Encapsulation\n    Mechanisms\n\nGorjan Alagic\nElaine Barker\n           Lily Chen\n    Dustin Moody\n    Angela Robinson\n    Hamilton Silberg\n         Noah Waller\n\n    This publication is available free of charge from:\n    https://doi.org/10.6028/NIST.SP.800-227\n\n  0\n    NST NATIONAL INSTITUTE OF\n    STANDARDS AND TECHNOLOGY\n  Check for    U.S. DEPARTMENT OF COMMERCE\n  updates"
  },
  {
    "doc_id": "NIST.SP.800-227",
    "source_path": "data/raw_pdfs/NIST.SP.800-227.pdf",
    "page_number": 2,
    "text": "    NIST Special Publication 800\n    NIST SP 800-227\n\nRecommendations for Key-Encapsulation\n    Mechanisms\n\n                        Gorjan Alagic\n    Elaine Barker\n    Lily Chen\n    Dustin Moody\n    Angela Robinson\n                     Hamilton Silberg\n    Noah Waller\n           Computer Security Division\n    Information Technology Laboratory\n\n    This publication is available free of charge from:\n    https://doi.org/10.6028/NIST.SP.800-227\n\n    September 2025\n\n                                                                      U.S. Department of Commerce\n                                                                        Howard Lutnick, Secretary\n    National Institute of Standards and Technology\n    Craig Burkhardt, Acting Under Secretary for Standards and Technology and Acting NIST Director"
  },
  {
    "doc_id": "NIST.SP.800-227",
    "source_path": "data/raw_pdfs/NIST.SP.800-227.pdf",
    "page_number": 3,
    "text": "Certain commercial equipment, instruments, software, or materials, commercial or non-commercial, are\nidentified in this paper in order to specify the experimental procedure adequately. Such identification does\nnot imply recommendation or endorsement of any product or service by NIST, nor does it imply that the\nmaterials or equipment identified are necessarily the best available for the purpose.\nThere may be references in this publication to other publications currently under development by NIST in\naccordance with its assigned statutory responsibilities. The information in this publication, including\nconcepts and methodologies, may be used by federal agencies even before the completion of such\ncompanion publications. Thus, until each publication is completed, current requirements, guidelines, and\nprocedures, where they exist, remain operative. For planning and transition purposes, federal agencies\nmay wish to closely follow the development of these new publications by NIST.\nOrganizations are encouraged to review all draft publications during public comment periods and provide\nfeedback to NIST. Many NIST cybersecurity publications, other than the ones noted above, are available at\nhttps://csrc.nist.gov/publications.\n\nAuthority\nThis publication has been developed by NIST in accordance with its statutory responsibilities under the\nFederal Information Security Modernization Act (FISMA) of 2014, 44 U.S.C. § 3551 et seq., Public Law (P.L.)\n113-283. NIST is responsible for developing information security standards and guidelines, including\nminimum requirements for federal information systems, but such standards and guidelines shall not apply\nto national security systems without the express approval of appropriate federal officials exercising policy\nauthority over such systems. This guideline is consistent with the requirements of the Office of\nManagement and Budget (OMB) Circular A-130.\nNothing in this publication should be taken to contradict the standards and guidelines made mandatory\nand binding on federal agencies by the Secretary of Commerce under statutory authority. Nor should these\nguidelines be interpreted as altering or superseding the existing authorities of the Secretary of Commerce,\nDirector of the OMB, or any other federal official. This publication may be used by nongovernmental\norganizations on a voluntary basis and is not subject to copyright in the United States. Attribution would,\nhowever, be appreciated by NIST.\n\nNIST Technical Series Policies\nCopyright, Use, and Licensing Statements\nNIST Technical Series Publication Identifier Syntax\n\nPublication History\nApproved by the NIST Editorial Review Board on 2025-09-03\n\nHow to cite this NIST Technical Series Publication:\nAlagic G, Barker EB, Chen L, Moody D, Robinson A, Silberg H, Waller N (2025) Recommendations for\nKey-Encapsulation Mechanisms. (National Institute of Standards and Technology, Gaithersburg, MD), NIST\nSpecial Publication (SP) NIST SP 800-227. https://doi.org/10.6028/NIST.SP.800-227\n\nAuthor ORCID iDs\nGorjan Alagic: 0000-0002-0107-6037\nElaine Barker: 0000-0003-0454-0461\nLily Chen: 0000-0003-2726-4279\nDustin Moody: 0000-0002-4868-6684\nAngela Robinson: 0000-0002-1209-0379\nHamilton Silberg: 0009-0004-4178-8954\nNoah Waller: 0000-0002-6979-9725"
  },
  {
    "doc_id": "NIST.SP.800-227",
    "source_path": "data/raw_pdfs/NIST.SP.800-227.pdf",
    "page_number": 4,
    "text": "Contact Information\nsp800-227-comments@nist.gov\n\nAdditional Information\nAdditional information about this publication is available at\nhttps://csrc.nist.gov/pubs/sp/800/227/final, including related content, potential updates,\nand document history.\nAll comments are subject to release under the Freedom of Information Act (FOIA)."
  },
  {
    "doc_id": "NIST.SP.800-227",
    "source_path": "data/raw_pdfs/NIST.SP.800-227.pdf",
    "page_number": 5,
    "text": "NIST SP 800-227\nSeptember 2025\n\nAbstract\n\nA key-encapsulation mechanism (KEM) is a set of algorithms that can be used by two par-\nties under certain conditions to securely establish a shared secret key over a public channel.\nA shared secret key that is established using a KEM can then be used with symmetric-key\ncryptographic algorithms to perform essential tasks in secure communications, such as\nencryption and authentication. This document describes the basic definitions, properties,\nand applications of KEMs. It also provides recommendations for implementing and using\nKEMs in a secure manner.\n\nKeywords\n\ncryptography; encryption; key-encapsulation mechanism; key establishment; public-key\ncryptography.\n\nReports on Computer Systems Technology\n\nThe Information Technology Laboratory (ITL) at the National Institute of Standards and\nTechnology (NIST) promotes the U.S. economy and public welfare by providing technical\nleadership for the Nation’s measurement and standards infrastructure. ITL develops tests,\ntest methods, reference data, proof of concept implementations, and technical analyses\nto advance the development and productive use of information technology. ITL’s respon-\nsibilities include the development of management, administrative, technical, and physical\nstandards and guidelines for the cost-effective security and privacy of other than national\nsecurity-related information in federal information systems. The Special Publication 800-\nseries reports on ITL’s research, guidelines, and outreach efforts in information system se-\ncurity, and its collaborative activities with industry, government, and academic organiza-\ntions.\n\ni"
  },
  {
    "doc_id": "NIST.SP.800-227",
    "source_path": "data/raw_pdfs/NIST.SP.800-227.pdf",
    "page_number": 6,
    "text": "NIST SP 800-227\nSeptember 2025\n\nPatent Disclosure Notice\n\nNOTICE: ITL has requested that holders of patent claims whose use may be required for compliance\nwith the guidance or requirements of this publication disclose such patent claims to ITL. However,\nholders of patents are not obligated to respond to ITL calls for patents and ITL has not undertaken\na patent search in order to identify which, if any, patents may apply to this publication.\nAs of the date of publication and following call(s) for the identification of patent claims whose use\nmay be required for compliance with the guidance or requirements of this publication, no such\npatent claims have been identified to ITL.\nNo representation is made or implied by ITL that licenses are not required to avoid patent infringe-\nment in the use of this publication.\n\nii"
  },
  {
    "doc_id": "NIST.SP.800-227",
    "source_path": "data/raw_pdfs/NIST.SP.800-227.pdf",
    "page_number": 7,
    "text": "NIST SP 800-227\nSeptember 2025\n\n                               Table of Contents\n\n1.  Introduction        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     1\n    1.1.     Background       . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     1\n    1.2.            Scope and Purpose . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     1\n    1.3.           Requirements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     2\n2.  Overview of Key-Encapsulation Mechanisms                  . . . . . . . . . . . . . . . . . . . . .     4\n    2.1.     Overview and Motivation          . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     4\n    2.2.             Basic Definitions and Examples . . . . . . . . . . . . . . . . . . . . . . . . . .     5\n    2.3.     Theoretical Security of KEMs         . . . . . . . . . . . . . . . . . . . . . . . . . . .     8\n3.  Requirements for Secure KEM Implementations                   . . . . . . . . . . . . . . . . . . .    11\n    3.1.     Compliance With NIST Standards and Validation              . . . . . . . . . . . . . . . .    11\n    3.2.     Managing Cryptographic Data            . . . . . . . . . . . . . . . . . . . . . . . . . .    12\n    3.3.     Additional Requirements          . . . . . . . . . . . . . . . . . . . . . . . . . . . . .    14\n4.  Using KEMs Securely in Applications             . . . . . . . . . . . . . . . . . . . . . . . . . .    15\n    4.1.     How to Establish a Key With a KEM            . . . . . . . . . . . . . . . . . . . . . . .    15\n    4.2.     Conditions for Using KEMs Securely           . . . . . . . . . . . . . . . . . . . . . . .    17\n    4.3.     Post Processing of the Shared Secret Key           . . . . . . . . . . . . . . . . . . . .    19\n    4.4.           Key Confirmation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .    20\n             4.4.1.           Creating the MAC Data . . . . . . . . . . . . . . . . . . . . . . . . . .    21\n             4.4.2.     Obtaining the Key-Confirmation Key          . . . . . . . . . . . . . . . . . .    21\n             4.4.3.            Key-Confirmation Example . . . . . . . . . . . . . . . . . . . . . . . .    22\n    4.5.     Proof of Possession for KEM Keys           . . . . . . . . . . . . . . . . . . . . . . . .    24\n    4.6.     Multi-Algorithm KEMs and PQ/T Hybrids              . . . . . . . . . . . . . . . . . . . .    26\n             4.6.1.     Constructing a Composite KEM          . . . . . . . . . . . . . . . . . . . . .    27\n             4.6.2.     Approved Key Combiners          . . . . . . . . . . . . . . . . . . . . . . . .    28\n             4.6.3.     Security Considerations for Composite Schemes             . . . . . . . . . . .    31\n5.         Examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .    33\n    5.1.     Examples of KEMs         . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .    33\n             5.1.1.     A KEM From Diffie-Hellman         . . . . . . . . . . . . . . . . . . . . . . .    33\n             5.1.2.     A KEM From RSA Secret-Value Encapsulation             . . . . . . . . . . . . .    34\n             5.1.3.     ML-KEM      . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .    35\n\n                                                 iii"
  },
  {
    "doc_id": "NIST.SP.800-227",
    "source_path": "data/raw_pdfs/NIST.SP.800-227.pdf",
    "page_number": 8,
    "text": "5.2.         Examples of KEM Applications        . . . . . . . . . . . . . . . . . . . . . . . . . .    35\n             5.2.1.     KEM-DEM Public-Key Encryption        . . . . . . . . . . . . . . . . . . . .    35\n             5.2.2.     Unilateral Authenticated Key Establishment Using a KEM           . . . . . .    37\n             5.2.3.     Ephemeral Authenticated Key Establishment          . . . . . . . . . . . . .    38\n             5.2.4.     Static-Ephemeral Unilateral Authenticated Key Establishment Using\n                        KEMs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .    39\n             5.2.5.             Authenticated Key Establishment Using KEMs . . . . . . . . . . . . .    41\nReferences     . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .    44\nAppendix A.         List of Acronyms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .    48\nAppendix B.   Glossary       . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .    49\nAppendix C.   Cryptographic Components             . . . . . . . . . . . . . . . . . . . . . . . . .    53\n C.1.        Message Authentication Codes (MACs)           . . . . . . . . . . . . . . . . . . . . .    53\n C.2.         Nonces . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .    54\nAppendix D.              Changes From Draft SP 800-227 . . . . . . . . . . . . . . . . . . . . . . .    56\n\n                             List of Tables\n\nTable 1.     Approved MAC algorithms for key confirmation            . . . . . . . . . . . . . . . .    54\n\n                             List of Figures\n\nFig. 1.             Outline of key establishment using a KEM . . . . . . . . . . . . . . . . . . . .     5\nFig. 2.      The IND-CPA security experiment for a KEM Π           . . . . . . . . . . . . . . . . .     9\nFig. 3.                The IND-CCA security experiment for a KEM Π . . . . . . . . . . . . . . . . .     9\nFig. 4.      Simple key establishment using a KEM          . . . . . . . . . . . . . . . . . . . . .    16\nFig. 5.      Key-confirmation example with an ephemeral key pair             . . . . . . . . . . . .    23\nFig. 6.      KEM PoP between a key-pair owner and CA             . . . . . . . . . . . . . . . . . .    25\nFig. 7.                   Sending a message using the KEM-DEM paradigm . . . . . . . . . . . . . . .    36\nFig. 8.      Unilateral authenticated key establishment using a KEM            . . . . . . . . . . .    37\nFig. 9.                 Using a KEM for key establishment with unilateral authentication . . . . . .    39\nFig. 10.     Static-ephemeral unilateral authenticated key establishment using KEMs                .    40\nFig. 11.              Authenticated key establishment using KEMs . . . . . . . . . . . . . . . . . .    42\n\niv"
  },
  {
    "doc_id": "NIST.SP.800-227",
    "source_path": "data/raw_pdfs/NIST.SP.800-227.pdf",
    "page_number": 9,
    "text": "NIST SP 800-227\nSeptember 2025    Recommendations for KEMs\n\n1.    Introduction\n\n1.1.  Background\nA key-establishment scheme is a set of algorithms that can be used to securely establish\na shared secret key between two or more parties.  Such a shared secret key can then be\nused to perform tasks that are suitable for symmetric-key cryptography, such as efficient\nconfidential communication.\nMany widely deployed key-establishment schemes — including those specified in NIST Spe-\ncial Publication (SP) 800-56A [1] and SP 800-56B [2] — are vulnerable to cryptographic at-\ntacks that make use of a large-scale, cryptanalytically relevant quantum computer. In 2016,\nNIST initiated a process to select and standardize a set of post-quantum key-establishment\nschemes (i.e., key-establishment schemes that would not be vulnerable to attacks even\nby cryptanalytically-relevant quantum computers). In response, NIST received feedback\nfrom the cryptographic community that the post-quantum key-establishment schemes\nbest suited for standardization and widespread deployment are key-encapsulation mecha-\nnisms (KEMs). The first KEM standard that resulted from this NIST Post-Quantum Cryptog-\nraphy (PQC) standardization process was ML-KEM, which is specified in Federal Information\nProcessing Standards (FIPS) publication 203 [3].\nAt the time of the standardization of ML-KEM, NIST had not provided extensive guidelines\non the basic definitions, properties, and applications of KEMs. This recommendation is\nmeant to provide these guidelines, supplement the current and future standardization of\nKEMs, and provide recommendations for implementing and using KEMs in a secure man-\nner.\n\n1.2.  Scope and Purpose\nThis recommendation provides guidelines on the basic definitions, properties, and appli-\ncations of KEMs; supplements the current and future standardization of KEMs; and makes\nsome requirements and recommendations for implementing and using KEMs in FIPS 140-\nvalidated cryptographic modules. This recommendation also provides guidelines for ven-\ndors who wish to securely combine keying material produced via approved post-quantum\nmethods with keying material produced via other (potentially quantum-vulnerable) meth-\nods.\nThis recommendation does not discuss how or when to migrate from quantum-vulnerable\nkey-establishment procedures to post-quantum KEMs (see [4]), nor does it provide a spec-\nification for any particular KEM. Such specifications will be provided in a FIPS or an SP, such\nas the specification of ML-KEM in FIPS 203 [3].\nThis recommendation includes explanatory and educational material to aid in the general\nunderstanding of KEMs. While SPs typically only include material that pertains to what is\n\n1"
  },
  {
    "doc_id": "NIST.SP.800-227",
    "source_path": "data/raw_pdfs/NIST.SP.800-227.pdf",
    "page_number": 10,
    "text": "NIST SP 800-227\nSeptember 2025    Recommendations for KEMs\n\napproved, this SP describes KEMs both generally and with respect to what is approved.\nSpecific requirements will be clearly noted with “shall” and “must” statements.\n\n1.3.  Requirements\nConforming implementations of approved KEMs are required to satisfy all of the require-\nments below. Requirements that are testable by a Cryptographic Module Validation Pro-\ngram (CMVP) validation lab are enumerated with the prefix “RS,” and requirements that\nare not testable by a validation lab are enumerated with the prefix “RM.” Each require-\nment is directly quoted from the corresponding referenced section. Requirements RS6,\nRS7, RS8, RS10, and RS11 pertain to key confirmation (Sec. 4.4), which is recommended\nbut not required.\nThe following requirements are testable by a CMVP validation lab (i.e., shall statements):\n RS1  (Section 3.1) KEM implementations shall comply with a specific NIST FIPS or SP that\n      specifies the algorithms of the relevant KEM. For example, a conforming implemen-\n      tation of ML-KEM shall comply with FIPS 203 [3]. 1\n RS2  (Section 3.1) KEM implementations shall follow the guidelines given in FIPS 140-3 [5]\n      and associated implementation guidance.\n RS3  (Section 3.1) KEM implementations shall use approved components with security\n      strengths that meet or exceed the required strength for each KEM parameter set.\n RS4  (Section 3.1) Random bits shall be generated using approved techniques, as de-\n      scribed in the latest revisions of SP 800-90A, SP 800-90B, and SP 800-90C [6–8].\n RS5  (Section 3.2) Except for random seeds and data that can be easily computed from\n      public information, all intermediate values used in any given KEM algorithm (i.e.,\n      KeyGen, Encaps, and Decaps) shall be destroyed before the algorithm terminates.\n RS6  (Section 4.2) If an application uses an ephemeral key pair, the key pair shall be used\n      for only one execution of key-establishment via a KEM and shall be destroyed as\n      soon as possible after its use.\n RS7  (Section 4.4.1) When a nonce is used by the decapsulator during key confirmation\n      (as specified herein), a nonce with a bit length that is (at least) equal to the targeted\n      security strength of the KEM key-establishment process shall be used (see Appendix\n      C.2).\n RS8  (Section 4.4.1) For key confirmation, the MAC algorithm and key-confirmation key\n      used shall have security strengths that are equal to or greater than the desired se-\n      curity strength of the application.\n1The CMVP will perform random input-output tests in an attempt to ascertain whether this requirement is\nsatisfied. Ensuring full functional equivalence to the specification via testing is not possible (see the “must”\nrequirement RM1).\n\n                                         2"
  },
  {
    "doc_id": "NIST.SP.800-227",
    "source_path": "data/raw_pdfs/NIST.SP.800-227.pdf",
    "page_number": 11,
    "text": " NIST SP 800-227\n September 2025    Recommendations for KEMs\n\n RS9  (Section 4.4.2) The key-confirmation key shall only be used for key confirmation and\n      destroyed after use.\nRS10  (Appendix C.1) When key confirmation requires the use of a MAC algorithm, it shall\n      be an approved MAC algorithm (e.g., HMAC, AES-CMAC, KMAC). In addition, AES-\n      GMAC (specified in [9]) is an approved MAC algorithm and may be used.\nRS11  (Appendix C.1) When a MAC tag is used for key confirmation, an entity shall compute\n      the MAC tag on received or derived data using a MAC algorithm with a MacKey that\n      is determined from a shared secret key.\n The following requirements are not testable by a CMVP validation lab (i.e., must state-\n ments):\n RM1 (Section 3.1). Implementations must correctly implement the mathematical func-\n      tionality of the target KEM. 2\n RM2 (Section 4.2) In applications of KEMs, a parameter set with an application-appropriate\n      security strength must be selected (see [10, Section 2.2]).\n RM3 (Section 4.2) If an encapsulating party obtains the static encapsulation key of another\n      party, it must have assurance of the other party’s ownership of the key before or\n      during the execution of key-establishment.\n RM4 (Section 4.2) The devices used to execute KEM algorithms and store any sensitive\n      data (e.g., decapsulation keys) must be appropriately secured.\n RM5 (Section 4.2) The key-establishment process that takes place over the channel used\n      by Alice and Bob must satisfy an application-appropriate notion of integrity.\n\n 2The CMVP will perform random input-output tests in an attempt to ascertain whether this requirement is\n satisfied. Ensuring full functional equivalence to the specification is not possible.\n\n 3"
  },
  {
    "doc_id": "NIST.SP.800-227",
    "source_path": "data/raw_pdfs/NIST.SP.800-227.pdf",
    "page_number": 12,
    "text": "NIST SP 800-227\nSeptember 2025    Recommendations for KEMs\n\n2.     Overview of Key-Encapsulation Mechanisms\n\nThis section provides a high-level overview of KEMs, which are collections of mathemat-\nical functions (some of which include random inputs) and data that specify parameters.\nSection 3 describes how to implement a KEM as a collection of computer programs, and\nSec. 4 describes how to deploy KEMs in applications.\n\n2.1.    Overview and Motivation\nModern symmetric-key cryptography provides a wide range of useful functionalities, in-\ncluding secure and highly efficient computation and communication.      Before symmetric-\nkey cryptography can be used, the participating parties need to establish a shared secret\n(i.e., symmetric) key. One approach to establishing such a key is over a public communi-\ncation channel. Any algorithmic method that establishes a shared secret key over a public\nchannel is called a key-establishment scheme. A general key-establishment scheme can\nrequire multiple rounds of communication and involve any number of parties.\nA KEM is a specific type of key-establishment scheme. Typical key establishment via a KEM\ninvolves two parties (here referred to as Alice and Bob) and consists of the following three\nstages (see Fig. 1):\n    1.  (Key generation) Alice generates a (private) decapsulation key and a (public) encap-\n        sulation key.\n    2.  (Encapsulation) Bob uses Alice’s encapsulation key to generate a shared secret key\n        and an associated ciphertext. The ciphertext is sent to Alice.\n    3.  (Decapsulation) Alice uses the ciphertext and her decapsulation key to compute an-\n        other copy of the shared secret key.\n\nSecurity of KEMs. When a KEM is used as in Fig. 1, the result should be a shared secret\nkey that is random, unknown to adversaries, and identical for Alice and Bob with high\nprobability. Ensuring that security holds in practice is a complex task that relies on three\nconditions:\n    1.  Theoretical security: Selecting a KEM that is well-defined, correct, and satisfies an\n        application-appropriate mathematical notion of security (see Sec. 2.2 and 2.3)\n    2.  Implementation security: Implementing the selected KEM in a real-world algorithm\n        (e.g., a collection of routines) in a secure manner (see Sec. 3)\n    3.  Deployment security: Deploying the implemented KEM in a manner that is secure\n        for the relevant application and using the shared secret key in a secure manner (see\n        Sec. 4.2)\nEach of these three conditions is essential for security. For example, a KEM that is theo-\nretically secure (i.e., satisfies condition 1) but is implemented without side-channel coun-\n\n                                            4"
  },
  {
    "doc_id": "NIST.SP.800-227",
    "source_path": "data/raw_pdfs/NIST.SP.800-227.pdf",
    "page_number": 13,
    "text": "NIST SP 800-227\nSeptember 2025    Recommendations for KEMs\n\nAlice  Bob\n\nKey Generation\n\ndecapsulation key    encapsulation key\n\nDecapsulation  ciphertext    Encapsulation\n\nshared secret key                   shared secret key\n  (Alice’s copy)                    (Bob’s copy)\n\n                     Fig. 1. Outline of key establishment using a KEM\n\ntermeasures (i.e., does not satisfy condition 2) or is deployed on a device with physical\nvulnerabilities (i.e., does not satisfy condition 3) is likely to be insecure in practice.\n\nHistory and development. KEMs were first introduced by Cramer and Shoup [11, 12] as a\nbuilding block for constructing highly efficient public-key encryption (PKE) schemes. Their\napproach combines a KEM with a data encryption mechanism (DEM), which is simply a\nsymmetric-key encryption scheme. The KEM is used to generate a shared secret key, while\nthe DEM is used to encrypt an arbitrarily long stream of messages under that key. This is\ncommonly referred to as the KEM/DEM paradigm (see the HPKE example in Sec. 5.2.1).\nThis approach to constructing highly efficient public-key encryption has been the subject\nof several standards   [1, 2, 11, 13–16]. Most recently, KEMs have attracted significant at-\ntention due to most of the post-quantum key-establishment candidates in the NIST PQC\nstandardization process being KEMs.          This ongoing process has produced one KEM stan-\ndard so far — ML-KEM in FIPS 203 [3] — with more KEM standards likely to follow.\n\n2.2.  Basic Definitions and Examples\nThis section establishes the basic definitions and properties of KEMs. Note that probabilis-\ntic algorithms require randomness, while deterministic algorithms do not.\nDefinition 1. A KEM denoted by Π consists of the following four components:\n1.    Π.ParamSets (parameters): A collection of parameter sets\n\n                                    5"
  },
  {
    "doc_id": "NIST.SP.800-227",
    "source_path": "data/raw_pdfs/NIST.SP.800-227.pdf",
    "page_number": 14,
    "text": "NIST SP 800-227\nSeptember 2025    Recommendations for KEMs\n\n 2.  Π.KeyGen (key-generation algorithm): An efficient probabilistic algorithm that ac-\n     cepts a parameter set p ∈ Π.ParamSets as input and produces an encapsulation key\n     ek and a decapsulation key dk as output\n 3.  Π.Encaps (encapsulation algorithm):        An efficient probabilistic algorithm that ac-\n     cepts a parameter set p ∈ Π.ParamSets and an encapsulation key ek as input and\n     produces a shared secret key K and a ciphertext c as output\n 4.  Π.Decaps (decapsulation algorithm):        An efficient deterministic algorithm that ac-\n     cepts a parameter set p ∈ Π.ParamSets, a decapsulation key dk, and a ciphertext c\n     as input and produces a shared secret key K′ as output\nAs this section views KEMs purely as mathematical objects, the labels p, ek, dk, c, K, and\nK′ in Definition 1 are viewed as abstract variables that represent, for example, numbers\nor bit strings. In implementations, these variables will be represented with concrete data\ntypes (see Sec. 3).\nIn general, Definition 1 only requires some very basic properties from the four components\nthat make up a KEM (see Example 1 below). In order to be useful and secure, a KEM should\nfulfill a number of additional properties. The first such property is correctness of the KEM\nalgorithm. Correctness ensures that, in an ideal setting, the process in Fig. 1 almost always\nproduces the same shared secret key value for both parties.\nDefinition 2. The key-encapsulation correctness experiment for a KEM Π and parameter\nset p ∈ Π.ParamSets consists of the following three steps:\n              1. (ek, dk) ← Π.KeyGen(p)            (perform key generation)      (1)\n              2. (K, c) ← Π.Encaps(p, ek)          (perform encapsulation)       (2)\n              3. K′ ← Π.Decaps(p, dk, c)           (perform decapsulation)       (3)\nThe KEM Π is correct if, for all p ∈ Π.ParamSets, the correctness experiment for p results\nin K = K′ with all but negligible probability.\nRecall that Π.KeyGen and Π.Encaps are probabilistic algorithms. When they are invoked as\nabove (i.e., Π.KeyGen with only a parameter set as input, and Π.Encaps with only a param-\neter set and encapsulation key as input), it is implied that their randomness is generated\ninternally and uniformly at random.       If one wishes to explicitly refer to the randomness\nused by these algorithms, then the following expressions can be used:\n           Key generation (using randomness r):    (ek, dk) ← Π.KeyGen(p; r)     (4)\n            Encapsulation (using randomness s):    (K, c) ← Π.Encaps(p, ek; s)   (5)\nThese expressions can, for example, refer to the process of re-expanding a key pair (ek, dk)\nby running KeyGen using a stored seed r.\nThe following two simple but instructive examples show abstract KEMs that satisfy Defini-\ntion 1 and Definition 2.\n\n                                              6"
  },
  {
    "doc_id": "NIST.SP.800-227",
    "source_path": "data/raw_pdfs/NIST.SP.800-227.pdf",
    "page_number": 15,
    "text": "NIST SP 800-227\nSeptember 2025    Recommendations for KEMs\n\nExample 1: Simple but insecure. As the following example shows, a correct and efficient\nKEM can still be completely insecure. Define a KEM DONOTUSE as follows:\n  • DONOTUSE.ParamSets: Contains a single, empty parameter set\n  • DONOTUSE.KeyGen: On randomness r, outputs dk := r and ek := r\n  • DONOTUSE.Encaps: On input ek and randomness s, outputs K := s and c := s\n  • DONOTUSE.Decaps: On input dk and c, outputs K′ := c\nWhile DONOTUSE is obviously a correct KEM since K′ always equals K, it is also completely\ninsecure since the shared secret key K is transmitted in plaintext. This shows that a KEM\nneeds to satisfy additional properties in order to be secure (see Sec. 2.3).\n\nExample 2: Key transport using PKE. The following is a simple construction of a KEM from\nany PKE scheme. A PKE scheme consists of a collection PKE.ParamSets of parameter sets\nand three algorithms: key generation PKE.KeyGen (that accepts a parameter set), encryp-\ntion PKE.Encrypt (that accepts a parameter set, an encryption key, and a plaintext), and\ndecryption PKE.Decrypt (that accepts a parameter set, a decryption key, and a ciphertext).\nOne can construct a KEM KEMFROMPKE from the PKE scheme as follows:\n  • KEMFROMPKE.ParamSets = PKE.ParamSets\n  • KEMFROMPKE.KeyGen = PKE.KeyGen\n  • KEMFROMPKE.Encaps: On input p, ek and randomness s, output key K := s and\n     ciphertext c ← PKE.Encrypt(p, ek, s).\n  • KEMFROMPKE.Decaps: On input p, dk, and c, output key K′ := PKE.Decrypt(p, dk, c).\nThe efficiency, correctness, and security properties of KEMFROMPKE depend on the respec-\ntive properties of PKE.\n\nKEM examples. Section 5.1 briefly discusses three additional examples of KEMs:\n 1.  ECDH-KEM is a quantum-insecure KEM based on ECDH key exchange (see Sec. 5.1.1).\n 2.  RSASVE-KEM is a quantum-insecure example of RSA key transport (see Sec. 5.1.2).\n 3.  ML-KEM is a lattice-based, NIST-approved post-quantum KEM (see Sec. 5.1.3).\nECDH-KEM and RSASVE-KEM are based on NIST-standardized key-establishment schemes\nthat can easily be viewed as KEMs. ML-KEM is the first key-establishment scheme to be\nstandardized by NIST directly as a KEM.\n\nA remark on key transport and key agreement. There are various ways to categorize two-\nparty key-establishment schemes. One particular categorization distinguishes between key\nagreement and key transport. In key agreement (e.g., a Diffie-Hellman key exchange), both\nparties contribute information that influences the final shared secret key so that neither\n\n                                          7"
  },
  {
    "doc_id": "NIST.SP.800-227",
    "source_path": "data/raw_pdfs/NIST.SP.800-227.pdf",
    "page_number": 16,
    "text": "NIST SP 800-227\nSeptember 2025    Recommendations for KEMs\n\nparty can predetermine it. In key transport (e.g., RSA-OAEP [2]), one party selects the key\nand then transmits it (in some form) to the other party.\nDepending on the internal structure of the encapsulation function, a KEM could be viewed\nas either a key-agreement scheme or a key-transport scheme. For example, the shared\nsecret key in ML-KEM [3] is a function of both the randomness provided by Bob and the\n(randomly generated) encapsulation key of Alice. Therefore, ML-KEM could be viewed as a\nkey-agreement scheme. However, as the example KEMFROMPKE shows, the encapsulation\noperation in a KEM might simply consist of Bob generating the shared secret key and then\nencrypting it, which is key transport.\nAn application can achieve a particular type of key establishment (i.e.,  key agreement\nor key transport) using any KEM by taking appropriate additional steps using standard\nsymmetric-key cryptography techniques. That is, given a KEM Π, Alice and Bob can achieve\nkey agreement by both executing Π.KeyGen, sending the encapsulation keys to each other,\nand completing the steps of key establishment using a KEM. This will result in two sepa-\nrate shared secret keys that can be combined using an appropriate key-derivation method.\nConversely, Π can be used to achieve key transport by following the steps in Fig. 7 and re-\nplacing m with the shared secret key produced by Π.\n\n2.3.  Theoretical Security of KEMs\nThis section discusses the theoretical security of KEMs. Section 3 discusses KEM imple-\nmentation security, and Sec. 4.2 discusses the secure deployment of KEMs.\n\nSemantic security. Informally speaking, a secure key-establishment procedure produces a\nshared secret key K that is uniformly random and unknown to adversaries. This property\nshould hold despite the fact that adversaries can freely observe the messages transmitted\nby Alice and Bob. In the case of KEMs, the encapsulation key ek and ciphertext c should\nreveal no information about the resulting shared secret key K or the decapsulation key dk.\nMoreover, even adversaries who somehow learn some partial information (e.g., if the first\nhalf of K is accidentally leaked) should not be able to combine that information with ek and\nc to learn more (e.g., the last bit of K). This informal notion of security can be rigorously\nformalized, and the resulting definition is called semantic security [17].\n\nPassive adversaries and IND-CPA. The formal way to define semantic security for KEMs\ninvolves an imaginary “ciphertext indistinguishability” experiment (see Fig. 2). In this ex-\nperiment, an adversary is given an encapsulation key ek, a ciphertext c, and either the true\nshared secret key underlying c or a freshly generated random string. The adversary’s goal\nis to distinguish between these scenarios, and they are free to use ek to generate their\nown encapsulations to help them in this task. This experiment is called “indistinguishable\nunder chosen-plaintext attack” (IND-CPA) [17].\n\n8"
  },
  {
    "doc_id": "NIST.SP.800-227",
    "source_path": "data/raw_pdfs/NIST.SP.800-227.pdf",
    "page_number": 17,
    "text": "  NIST SP 800-227\n  September 2025    Recommendations for KEMs\n\nChallenger:  Adversary:\n(ek, dk) ← Π.KeyGen( p)\n(K0, c) ← Π.Encaps( p, ek)\nK1 ← {0, 1}|K⁰|\nb ← {0, 1}\n− ek, c, Kb\n−\n−\n−\n−\n−\n−\n−\n−→\n←−  b′\n−\n−\n−\n−\n−\n−\n−\n−\noutput WIN iff b = b′.\n\nFig. 2. The IND-CPA security experiment for a KEM Π\n\n  Definition 3 (IND-CPA, informal). A KEM Π has indistinguishable ciphertexts (or is IND-CPA)\n  if, for every computationally bounded adversary A, the difference between the probability\n  that A wins the experiment IND-CPA[Π] and 1/2 is negligible.\n  In the IND-CPA experiment, the adversary is free to study the encapsulation key ek and\n  the ciphertext c in order to identify whether Kb is the true key. However, the adversary is\n  not capable of actively interfering with the challenger’s use of the decapsulation key. As a\n  result, IND-CPA only captures security against passive adversaries (i.e., eavesdroppers).\n\n  Challenger:                           Adversary:\n   (ek, dk) ← Π.KeyGen( p)\n   (K0, c) ← Π.Encaps( p, ek)\n   K1 ← {0, 1}|K⁰|\n   b ← {0, 1}\n                             − ek, c, Kb\n                             −\n                               −\n                               −\n                                −\n                                 −\n                                 −\n                                   −\n                                        −→\n                                                              Π.Decaps(dk, ?)\n\n                             ←−  b′\n                               −\n                                −\n                                −\n                                 −\n                                   −\n                                   −\n                                        −\n                                        −\n   output WIN iff b = b′.\n\n                                 Fig. 3. The IND-CCA security experiment for a KEM Π\n\n  Active adversaries and IND-CCA. Real-world experience indicates that adversaries can\n  sometimes actively interfere with key-establishment processes and use this ability to un-\n  cover the shared secret key. For example, an active adversary may be able to convince an\n\n                                                          9"
  },
  {
    "doc_id": "NIST.SP.800-227",
    "source_path": "data/raw_pdfs/NIST.SP.800-227.pdf",
    "page_number": 18,
    "text": "NIST SP 800-227\nSeptember 2025    Recommendations for KEMs\n\nhonest user to decapsulate some ciphertexts of the adversary’s choosing. In such a sce-\nnario, it is natural to ask whether other ciphertexts are still protected. In this setting, IND-\nCPA security is insufficient. Instead, one must consider security against so-called chosen-\nciphertext attacks (CCA)3 [17].\nThe IND-CCA[Π] experiment for a KEM Π is described in Fig. 3. It is similar to the IND-CPA\nexperiment, except that the adversary is now also granted “black-box oracle access” to the\ndecapsulation function c → Π.Decaps(p, dk, c). This means that the adversary is allowed\nto submit ciphertexts c∗ that they generate and get the response K∗ ← Π.Decaps(p, dk, c∗).\nThe only restriction is that they cannot submit the actual ciphertext c produced by the chal-\nlenger since that would make the game trivial to win for any KEM.\nDefinition 4 (IND-CCA, informal). A KEM Π is IND-CCA if, for every computationally bounded\nadversary A, the difference between the probability that A wins the experiment IND-CCA[Π]\nand 1/2 is negligible.\nML-KEM, the first post-quantum KEM standardized by NIST, is believed to satisfy IND-CCA\nsecurity [3].\n\n3IND-CCA as used here is typically referred to as IND-CCA2 in cryptographic literature.\n\n10"
  },
  {
    "doc_id": "NIST.SP.800-227",
    "source_path": "data/raw_pdfs/NIST.SP.800-227.pdf",
    "page_number": 19,
    "text": "NIST SP 800-227\nSeptember 2025    Recommendations for KEMs\n\n3.    Requirements for Secure KEM Implementations\n\nAs discussed in Sec. 2.1, a KEM (as a mathematical object) should satisfy both correctness\n(Definition 2) and an appropriate notion of security (Definition 3 or Definition 4). In order\nfor such a KEM to be used in real-world applications, it needs to be implemented in actual\ncode as part of a cryptographic module. The quality of the resulting implementation has a\ndramatic impact on usability and security in real-world applications.\nThe following subsections detail requirements for cryptographic modules that implement\napproved KEMs. However, adherence to these requirements does not guarantee that a\ngiven implementation will be secure. For a discussion of requirements for applications\nthat make use of a KEM cryptographic module, see Sec. 4.2.\n\n3.1.  Compliance With NIST Standards and Validation\nConforming implementations of approved KEMs are required to comply with the require-\nments outlined in this section as well as all other applicable NIST standards. In addition,\nsuch implementations are required to use only approved cryptographic elements and pass\nFIPS-140 validation.\n\nImplementing according to NIST standards. Implementations shall comply with a specific\nNIST FIPS or SP that specifies the algorithms of the relevant KEM. For example, a conform-\ning implementation of ML-KEM shall comply with FIPS 203 [3]. Each FIPS or SP that speci-\nfies a KEM will have special requirements for the particular scheme in question, including\nspecifications for all algorithms and parameter sets of the relevant KEM. In particular, con-\ncrete data types will be specified for the parameter sets, keys, ciphertexts, and shared\nsecret keys (Definition 1) of the relevant KEM. Assurance of parameter validity is obtained\nby checking the lists of approved parameters in the appropriate publication.\nThe requirements in any FIPS or SP that standardizes a particular KEM are in addition to\nthe general requirements described in this section. Any implementations shall follow the\nguidelines given in FIPS 140-3 [5] and associated implementation guidance.\n\nApproved cryptographic elements. KEMs commonly make use of other cryptographic el-\nements, such as RBGs and hash functions (see Appendix D). Typically, the security of a\nsystem consisting of multiple cryptographic elements is at best as secure as the weakest\nelement.           When not already specified by the KEM parameter set, KEM implementations\nshall use approved cryptographic elements with security strengths that meet or exeed the\nrequired strength for each KEM parameter set. The security strength of the selected pa-\nrameter set should be at least the desired security strength of the application. In addition,\nrandom bits shall be generated using approved techniques, as described in the latest re-\nvisions of SP 800-90A, SP 800-90B, and SP 800-90C [6–8].        For using randomness in key\ngeneration, see SP 800-133 [18].\n\n11"
  },
  {
    "doc_id": "NIST.SP.800-227",
    "source_path": "data/raw_pdfs/NIST.SP.800-227.pdf",
    "page_number": 20,
    "text": "NIST SP 800-227\nSeptember 2025    Recommendations for KEMs\n\nTesting and validation. Mistakes in implementations can easily lead to security vulner-\nabilities or a loss of usability. Therefore, it is crucial that implementations are validated\nfor conformance to NIST cryptographic standards and FIPS 140 by the Cryptographic Al-\ngorithm Validation Program (CAVP) and CMVP. Validation testing checks whether a given\nimplementation correctly computes the desired output for only a small number of (often\nrandomly sampled) inputs. This means that validation testing does not guarantee correct\nfunctioning on all inputs, which is often impossible to ensure. Nonetheless, implementa-\ntions must correctly implement the mathematical functionality of the target KEM. As vali-\ndation only tests input-output behavior, implementations need not follow the exact step-\nby-step algorithmic specifications in the NIST standard that specifies the relevant KEM. Any\nimplementation that produces the correct output for every input will pass validation.\nRequiring equivalence only at the level of input-output functionality (e.g., rather than in\nterms of step-by-step behavior) is desirable, as different implementations can then be op-\ntimized for different goals. For example, some implementations will focus on maximizing\nefficiency, while other implementations will employ numerous side-channel and leakage\nprotection techniques.\n\n3.2.  Managing Cryptographic Data\nKEM implementations need to manage all cryptographic data appropriately, including data\nused during the execution of KEM algorithms (i.e., intermediate values) and data at rest\n(e.g., decapsulation key).     As a cryptographic module has no control over data that exists\noutside of the module (e.g., while in transit from one module to another), such data is\nnot discussed here. However, a cryptographic module can exert control over what data it\noutputs to the outside world (e.g., by ensuring correct implementations of all functions). It\ncan also exert control over what data it accepts from the outside world (e.g., by performing\nappropriate input-checking and importing).\nIn general, cryptographic data needs to be destroyed as soon as it is no longer needed.\nSome examples include destroying intermediate computation values at the end of an algo-\nrithm, destroying the randomness generated by RBGs after encapsulation, and destroying\nkeys after all relevant communication sessions are completed.\n\nInput checking. The correct and secure operation of cryptographic operations depends\ncrucially on the validity of the provided inputs. Even relatively benign faults, such as ac-\ncepting an input that is too long or too short, can have serious security consequences.\nKEM implementations need to perform input checking in an appropriate manner for all\nKEM algorithms (i.e., KeyGen, Encaps, and Decaps). The exact form of the required input\nchecking is described in the FIPS or SP that specifies the relevant KEM.\nSometimes, an input will not need to be checked. Instead, the implementer can acquire\nassurance that the input was validly generated or has already been checked, as in the fol-\nlowing cases:\n\n                                          12"
  },
  {
    "doc_id": "NIST.SP.800-227",
    "source_path": "data/raw_pdfs/NIST.SP.800-227.pdf",
    "page_number": 21,
    "text": "NIST SP 800-227\nSeptember 2025    Recommendations for KEMs\n\n 1.  If the cryptographic module generated an input internally using an algorithm that\n     ensures validity and stored that input in a manner that prevents modification, then\n     the module is not required to check that input. For example, if the module gener-\n     ated a decapsulation key dk via KeyGen and then stored dk in a manner that prevents\n     modification, then the module can later invoke Decaps directly on dk without per-\n     forming any input checking.\n 2.  If the cryptographic module checks an input once and stores that input in a man-\n     ner that prevents modification, then the module is not required to check that input\n     again. For example, if the module performed input-checking on a given encapsula-\n     tion key ek and stored it in a manner that prevents modification, then the module\n     may invoke Encaps directly on ek (even repeatedly) without performing any further\n     input checking.\n 3.  If the cryptographic module imports the relevant input from a trusted third party\n     (TTP), and the TTP can provide assurance that the input does not need input-checking,\n     and the module stores that input in a manner that prevents modification, then the\n     module is not required to check the input.\n\nIntermediate values. All intermediate values used in any given KEM algorithm (i.e., KeyGen,\nEncaps, Decaps) shall be destroyed before the algorithm terminates. However, there are\ntwo exceptions to this rule:\n 1.  A random seed used for key generation may be stored as private data for the purpose\n     of recomputing the same key pair at a later time.\n 2.  Data that can be easily computed from public information (e.g., from the encapsu-\n     lation key) may be stored as public data to improve efficiency.\nWhen values are stored under either of these exceptions, the storage needs to be per-\nformed according to the rules for data at rest.\nThe outputs of a KEM algorithm are not considered to be intermediate values and will thus\nnot be immediately destroyed in typical situations. The format in which outputs and inputs\nare stored depends on the implementation (see the discussion of data formats below.)\n\nData at rest. A cryptographic module that implements a KEM needs to maintain certain\ndata at rest. This can include both private data (e.g., seeds, decapsulation keys) and public\ndata (e.g., encapsulation keys). In general, private data needs to be stored within the cryp-\ntographic module in a manner that is secure against both leakage and unauthorized mod-\nification. Private data needs to be destroyed as soon as it is no longer needed. The import\nand export of private data (e.g., seeds, decapsulation keys, shared secret keys) needs to\nbe performed in a secure manner. In general, public data stored within the cryptographic\nmodule needs to be stored in a manner that is secure against unauthorized modification\n[5, 19].\n\n13"
  },
  {
    "doc_id": "NIST.SP.800-227",
    "source_path": "data/raw_pdfs/NIST.SP.800-227.pdf",
    "page_number": 22,
    "text": "NIST SP 800-227\nSeptember 2025    Recommendations for KEMs\n\nData formats, import, and export. FIPS validation tests input and output the behavior of\nrelevant KEM algorithms using a specific data format. Typically, this format is byte arrays\nthat contain the inputs and outputs described in the FIPS or SP that specifies the relevant\nKEM. This format is required for testing but is not a requirement for internal storage, data\nimport, or data export. A given cryptographic module may choose to store, import, or\nexport data (whether sensitive or not) using other formats. The desired format can vary\nsignificantly depending on the application. For example, some applications might call for\nstoring keys using only a short seed, while other applications might call for storing keys in\nan expanded format that allows for faster computations. In any case, the storage, import,\nand export of sensitive data needs to be performed securely, regardless of the chosen data\nformat.\n\n3.3.  Additional Requirements\nThe following are additional requirements for cryptographic modules that implement ap-\nproved KEMs.\n\nFailures and aborts. Any of the KEM algorithms (i.e., KeyGen, Encaps, Decaps) and their\ncryptographic elements (e.g., DRBGs, hash functions) can potentially fail or abort. This\ncould be a result of normal KEM operations (e.g., decapsulating a ciphertext that was cor-\nrupted by the environment during transmission), a hardware or software failure (e.g., a\nfailed DRBG execution due to a memory fault), or an adversarial attack.          Implementers\nneed to take precautions to ensure that the cryptographic module handles failures and\naborts appropriately. In particular, leaking information about failures and aborts outside\nof the perimeter of the cryptographic module should be avoided.\n\nSide-channel protection.           Cryptographic modules for KEMs should be designed with ap-\npropriate countermeasures against side-channel attacks. This includes protecting against\ntiming attacks with constant-time implementations and protecting memory from leakage.\nUniversal guidelines are unlikely to be helpful as exposure to side-channel attacks varies\nsignificantly with the desired application, and countermeasures are often costly.\n\n14"
  },
  {
    "doc_id": "NIST.SP.800-227",
    "source_path": "data/raw_pdfs/NIST.SP.800-227.pdf",
    "page_number": 23,
    "text": "NIST SP 800-227\nSeptember 2025    Recommendations for KEMs\n\n4.    Using KEMs Securely in Applications\n\nThis section describes how to deploy a KEM in real-world applications in a manner that is\nuseful and secure, assuming that the KEM under discussion satisfies an appropriate notion\nof theoretical security (see Sec. 2.3) and has been securely implemented in a cryptographic\nmodule (see Sec. 3).\n\n4.1.    How to Establish a Key With a KEM\nThis section describes how a KEM can be used to establish a shared secret key between\ntwo parties. The description will go into greater detail than the brief outline in Sec. 2.1.\nHowever, since KEMs are highly flexible and can be used in a wide range of applications\nand contexts, no single description can account for all variations. Section 5 provides more\ndetailed examples of special cases of key establishment using a KEM.\nFor simplicity of exposition, the two parties in the key establishment process will be re-\nferred to as Alice and Bob. It is assumed that Alice and Bob are communicating over a\nsingle bidirectional channel and will only use that channel to transmit data to each other.\nThe key-establishment process using a KEM Π proceeds as follows:\n    1.  Preparation. Before key establishment can begin, a parameter set p ∈ Π.ParamSets\n        needs to be selected. Depending on the application, p may be selected by Alice, by\n        Bob, or through an interactive negotiation between Alice and Bob. The choice of the\n        KEM Π itself could also be made at this stage.\n    2.  Key generation. Alice begins by running the key-generation algorithm in her crypto-\n        graphic module:\n         (ekA, dkA) ← Π.KeyGen(p).                                  (6)\n        During the execution of KeyGen, Alice’s module internally generates private random-\n        ness using an appropriate RBG. Alice then transmits ekA to Bob and keeps dkA pri-\n        vate.\n    3.  Encapsulation. Bob receives ekA from Alice and uses it to execute the encapsulation\n        algorithm in his cryptographic module:\n        (KB, cB) ← Π.Encaps(p, ekA).                                (7)\n        During the execution of Encaps, Bob’s module internally generates private random-\n        ness using an appropriate RBG. Bob then transmits cB to Alice and keeps KB private.\n    4.  Decapsulation. Alice receives cB from Bob and runs the decapsulation algorithm in\n        her module using her decapsulation key and Bob’s ciphertext:\n          KA ← Π.Decaps(dkA, cB).                                   (8)\n        Alice keeps KA private.\n\n                                         15"
  },
  {
    "doc_id": "NIST.SP.800-227",
    "source_path": "data/raw_pdfs/NIST.SP.800-227.pdf",
    "page_number": 24,
    "text": "NIST SP 800-227\nSeptember 2025    Recommendations for KEMs\n\n5.  Using the shared secret key. If the appropriate conditions are satisfied (see Sec. 4.2),\n    then KA will equal KB and can be used by Alice and Bob for any symmetric-key cryp-\n    tographic protocol. A typical choice is to use KA = KB as the key for an authenticated\n    encryption scheme (e.g., AES-GCM [9]), thereby establishing a communication chan-\n    nel between Alice and Bob that satisfies both confidentiality and integrity.\nFigure 4 depicts the high-level stages of this process. Note that some desirable security\nproperties might not be achieved by a protocol of this form and may require additional\nsteps and ingredients.\n\n           Alice:                                       Bob:\n     1.                          ←− Π, p\n                                      −\n                                      −\n                                       −\n                                        −\n                                        −\n                                         −→\n     2. (ekA, dkA) ← Π.KeyGen( p)\n                                 −    ekA\n                                 −\n                                      −\n                                      −\n                                       −\n                                       −\n                                        −\n                                        −\n                                         −→\n     3.                                                 (KB, cB) ← Π.Encaps(ekA)\n                                 ←− cᴮ\n                                      −\n                                       −\n                                       −\n                                        −\n                                        −\n                                         −\n                                         −\n     4. KA ← Π.Decaps(dkA, cB)\n\n     5. output: KA                                      output: KB\n\n                      Fig. 4. Simple key establishment using a KEM\n\nAdditional considerations. Steps 1-5 in the key-establishment process might need to be\nmodified, depending on the security and functionality needs of the application.    Some\ncommon modifications are as follows.\nStatic versus ephemeral key pairs. Consider an application in which Alice independently\ndecides on a parameter set, performs key generation, and publishes the resulting encap-\nsulation key ekA. Alice might then accept many connections from multiple parties over\na long period of time, each initiated via ekA. Each such connection would follow stages\n3-5 described above. While the other party in each connection would always encapsulate\nwith ekA, each ciphertext is generated with new randomness and only applicable to the\nconnection between Alice and that party. In this scenario, Alice’s encapsulation key is said\nto be static.\nIn other applications, Alice might want to use a particular key pair to establish only a single\nconnection (e.g., as part of a protocol that ensures forward secrecy). In that case, she will\nperform key generation, send her encapsulation key ekA to Bob, and discard ekA once the\nconnection with Bob is established. In this scenario, Alice’s encapsulation key is said to be\nephemeral.\n\n                                    16"
  },
  {
    "doc_id": "NIST.SP.800-227",
    "source_path": "data/raw_pdfs/NIST.SP.800-227.pdf",
    "page_number": 25,
    "text": "NIST SP 800-227\nSeptember 2025    Recommendations for KEMs\n\nAuthentication. In most applications, some form of authentication and cryptographic in-\ntegrity checking is required (e.g., to prevent “machine-in-the-middle” attacks).     Assuring\nthis is     highly application-dependent and typically requires additional cryptographic ele-\nments, such as digital signatures and certificates. Section 5.2.4 and Sec. 5.2.3 provide some\nillustrative examples.\nUsing the shared secret key. In some applications, Alice and Bob will use KA and KB directly\nas symmetric keys as soon as the decapsulation and encapsulation stages are successfully\ncompleted, respectively.     If KA = KB, a failure in the desired symmetric-key functionality\nwill likely follow. For other applications, Alice and Bob might need to first post-process KA\nand KB appropriately and then use the results of that post-processing step — if successful\n— as their symmetric keys.       This post-processing might include key derivation steps that\nsecurely produce multiple symmetric keys from the initial shared secret key (see Sec. 4.3).\nIt might also include key confirmation steps to confirm that KA = KB and reject them oth-\nerwise (see Sec. 4.4). In some cases, key confirmation might also involve performing ad-\nditional computations during the encapsulation and decapsulation stages to reduce the\nnumber of communication rounds.\n\n4.2.    Conditions for Using KEMs Securely\nThis section discusses general requirements for securely using approved KEMs in applica-\ntions. As discussed in point 1 below, the first step involves selecting an approved KEM that\nhas been implemented in a validated cryptographic module (see Section 3).   Deploying\nsuch a cryptographic module in applications entails a number of additional requirements\nthat are outlined below. Adherence to these requirements does not guarantee that the\nrelevant KEM application will be secure.      The overall requirements fall into four general\ncategories: KEM algorithm security, device security, channel security, and key usage secu-\nrity.\n1.      KEM algorithm security: The selected KEM Π is approved, appropriate for the ap-\n        plication, and implemented and deployed in a secure manner.\n        Being an approved KEM, Π will satisfy correctness (Definition 2) and either IND-CPA\n        or IND-CCA security (see Section 2.3).         Whenever possible, IND-CCA-secure KEMs\n        should be used. For some specific applications (e.g., ephemeral key establishment),\n        IND-CPA security might be sufficient.\n        Cryptographic module implementation.   The implementations of Π used by Alice\n        and Bob need to satisfy the requirements in Sec. 3. Whether a given implemen-\n        tation is sufficiently secure is an application-dependent question.   For example, an\n        implementation might be secure enough for use on a web server in a physically se-\n        cure location but have insufficient side-channel protections for use on an embedded\n        device.\n\n17"
  },
  {
    "doc_id": "NIST.SP.800-227",
    "source_path": "data/raw_pdfs/NIST.SP.800-227.pdf",
    "page_number": 26,
    "text": "NIST SP 800-227\nSeptember 2025    Recommendations for KEMs\n\n    Parameter set selection. A parameter set of Π with application-appropriate security\n    strength must be selected.\n    KEM key-pair usage. If an application uses an ephemeral key pair, the key pair shall\n    be used for only one execution of key-establishment via a KEM and shall be de-\n    stroyed as soon as possible after its use.\n    If an encapsulating party obtains the static encapsulation key of another party, it\n    must have assurance of the other party’s ownership of the key before or during the\n    execution of key-establishment. This assurance can be obtained from a trusted party\n    (e.g., a certificate authority) or a combination of proof of possession (see Sec. 4.5)\n    and verification of real-world identity.\n2.  Device security: The devices used to execute KEM algorithms and store any sensitive\n    data (e.g., decapsulation keys) must be appropriately secured.\n    Physical protection. Devices need to be appropriately protected against attacks (see\n    [19, Section 5]). This includes protection against leakage, physical intrusion, remote\n    access, and corruption.\n    Secure storage.   Devices need to provide appropriate secure storage for sensitive\n    data (e.g., KEM keys, seeds, shared secret keys, any derived keys) and destroy that\n    data when required by the cryptographic module (see Sec. 3.2). For further guide-\n    lines on key storage considerations, see SP 800-57pt1 [19] and SP 800-152 [10, Sec-\n    tion 2.2].\n3.  Channel security: The key-establishment process that takes place over the channel\n    used by Alice and Bob must satisfy an application-appropriate notion of integrity.\n    Preestablished versus simultaneous. Ensuring the integrity of the key-establishment\n    process could be achieved by first ensuring the integrity of the channel and then\n    performing key establishment. More commonly, integrity is assured simultaneously\n    with key establishment by augmenting the key-establishment process with addi-\n    tional steps and checks (see, e.g., Section 5.2.3).\n    Unilateral versus bilateral authentication. For some applications, only one of the\n    parties is assured of the other’s identity and the integrity of their messages. This is\n    commonly called a unilaterally authenticated key exchange (see Sec. 5.2.3). In other\n    applications, both Alice and Bob require assurances of the other party’s identity and\n    the integrity of their messages. This is commonly called a bilaterally authenticated\n    key exchange.\n    Secure authentication algorithms. For all applications, the cryptographic algorithms\n    (e.g., digital signature algorithms) and other elements (e.g., certificates) required to\n    establish channel integrity need to be selected and deployed securely.\n\n18"
  },
  {
    "doc_id": "NIST.SP.800-227",
    "source_path": "data/raw_pdfs/NIST.SP.800-227.pdf",
    "page_number": 27,
    "text": "NIST SP 800-227\nSeptember 2025    Recommendations for KEMs\n\n4.    Shared-secret-key usage security: The shared secret key produced by the KEM is\n      used appropriately and securely.\n      Shared-secret-key processing and management. Key-derivation and key-confirmation\n      steps are performed appropriately, as required by the application (see Sec. 4.3 and\n      4.4). Each shared secret key and any derived keys are destroyed as soon as they are\n      no longer needed (see Sec. 4.2).\n      Secure symmetric-key algorithms. The KEM shared secret key and any derived keys\n      should only be used with appropriately secure symmetric-key cryptographic algo-\n      rithms. In particular, the security of the symmetric-key algorithms used is appropri-\n      ate for the security provided by the KEM so that the combined algorithm (consisting\n      of key establishment followed by symmetric cryptography operations) fulfills the de-\n      sired security properties.\n\n4.3.  Post Processing of the Shared Secret Key\nCertain key-establishment schemes (e.g., Diffie-Hellman key exchange) can be viewed as\nfirst generating a shared secret and then performing a key-derivation step that transforms\nthe shared secret into one or more shared secret keys. In contrast, KEMs by definition\noutput a key K that is ready to use.\nKey derivation may be required for applications in which the amount of keying material\nneeded does not match the output size of the KEM algorithm (i.e., the length of shared\nsecret key K).\nAs specified in SP 800-108 [20], key derivation consists of applying a key-derivation method\n(KDM) to a key-derivation key. A KDM is an algorithm for transforming a given key-derivation\nkey (possibly with some other data) into keying material (e.g., a list of keys).\nIf additional keying material is needed, a KDM can be used to expand K. If keys with lengths\nless than K are needed, a KDM may be used, or the shared secret key K can be used directly\nas keying material by:\n • Truncating K or\n • Parsing K into non-overlapping segments to derive shorter keys.\nThe derived shorter key is considered a shared secret key if K was a shared secret key. The\nsecurity strength of any derived shorter key is the minimum of the security strength of K,\nthe length of the derived key, and the strength of any KDM used.\nWhen key derivation for a KEM Π is needed, the shared secret key output by Π (i.e., as\nan output of Π.Encaps or Π.Decaps) may be used as a key-derivation key supplied to an\napproved key-derivation method specified in SP 800-108 [20], SP 800-56C [21], or SP 800-\n133 [18]. If a KDM from SP 800-56C is used, the shared secret key of the KEM is used as\n\n19"
  },
  {
    "doc_id": "NIST.SP.800-227",
    "source_path": "data/raw_pdfs/NIST.SP.800-227.pdf",
    "page_number": 28,
    "text": "NIST SP 800-227\nSeptember 2025    Recommendations for KEMs\n\nan input to the KDM in place of the shared secret. A key derivation step is included in the\nexample protocol in Sec. 5.2.3.\n\n4.4.  Key Confirmation\nKey confirmation (KC) refers to the actions taken to provide assurance to one party (i.e., the\nkey-confirmation recipient) that another party (i.e., the key-confirmation provider) pos-\nsesses matching keying material. In the case of KEMs, this confirmation is done for keying\nmaterial that was produced by encapsulation and/or decapsulation.\nKey confirmation should be used during KEM usage, as it may enhance the security prop-\nerties of the overall key-establishment process.        Confirming successful establishment of\nthe shared secret key can also address potential errors in transmission or decapsulation.\nKey confirmation can also act as a proof of possession (see Sec. 4.5).      While this section\nincludes a description of an explicit process, key confirmation can be accomplished in a va-\nriety of other ways. For example, successful use of the shared secret key for authenticated\nencryption can act as key confirmation.\nKey confirmation is typically achieved by exchanging a value that can only be calculated\ncorrectly with very high probability if the key establishment was successful. Some com-\nmon protocols perform key confirmation in a manner that is integrated into the steps of\nthe protocol. For example, bilateral key confirmation is provided during a TLS handshake\nprotocol by the generation and verification of a message authentication code (MAC) over\nall previous messages in the handshake using a symmetric MAC key that was established\nduring the handshake.\nIn some circumstances, it may be appropriate to perform key confirmation by including\ndedicated key-confirmation steps in a key-establishment scheme.           An acceptable method\nfor providing key confirmation during a key-establishment scheme involves the KC provider\ncalculating a MAC tag on MAC_Data and sending the MAC tag to the KC recipient for confir-\nmation of the provider’s correct calculation of the shared secret key. Unilateral key confir-\nmation is provided when only one of the parties serves as the key-confirmation provider. If\nmutual key confirmation is desired (i.e., bilateral key confirmation), then the parties swap\nroles for the second KC process, and the new provider (i.e., the previous recipient) sends\na MAC value on a different data string (i.e., different MAC_Data) to the new recipient (i.e.,\nthe previous provider).\nThis recommendation makes no statement as to the adequacy of other methods.\n\nKey-confirmation key.          The key-confirmation steps specified in this recommendation can\nbe incorporated into any scheme using a KEM to establish a shared secret key. To perform\nkey confirmation, a dedicated KC key will be determined from the shared secret key pro-\nduced by the KEM. The KC provider will use the KC key with an approved MAC algorithm to\ncreate a MAC tag on certain data and provide the tag to the KC recipient. The KC recipient\n\n                                       20"
  },
  {
    "doc_id": "NIST.SP.800-227",
    "source_path": "data/raw_pdfs/NIST.SP.800-227.pdf",
    "page_number": 29,
    "text": "NIST SP 800-227\nSeptember 2025    Recommendations for KEMs\n\nwill then obtain the KC key from their copy of the shared secret key produced by the KEM\nand use it to verify the MAC tag.\n\n4.4.1.  Creating the MAC Data\nDuring key confirmation, the KC provider creates a message with a MAC tag that is com-\nputed on MAC_Data that contains context-specific information.        The MAC_Data is for-\nmatted as follows:\n        MAC_Data = KC_Step_Label ‖ IDP ‖ IDR ‖ EphP ‖ EphR ‖ ExtraP ‖ ExtraR\n • KC_Step_Label is a six-byte character string that indicates that the MAC_Data is\n        used for key confirmation, whether the MAC_Data is used for the first or second\n        key-confirmation message, and the party serving as the KC provider, either the en-\n        capsulator (E) or decapsulator (D). The four valid options are ”KC_1_E”, ”KC_2_E”,\n        ”KC_1_D”, or ”KC_2_D”. As an example, ”KC_1_D” indicates that the decapsu-\n        lator (D) is the KC provider and sends the first KC message. ”KC_2_E” could then\n        be used by the encapsulator (E) to provide bilateral key confirmation.\n • IDP and IDR are the identifiers used to label the KC provider and recipient, respec-\n        tively.\n • EphP and EphR are ephemeral data provided by the KC provider and recipient, re-\n        spectively. The encapsulator’s ephemeral data is the ciphertext. The decapsulator’s\n        ephemeral data is the encapsulation key ek if ek is ephemeral. Otherwise, the de-\n        capsulator’s ephemeral data shall be a nonce with a bit length that is at least equal to\n        the targeted security strength of the KEM key-establishment process (see Appendix\n        C.2).\n        When a nonce is used during key confirmation, it needs to be provided to the en-\n        capsulator to construct MAC_Data for MAC tag generation or verification.\n • ExtraP and ExtraR are optional additional data provided by the KC provider and re-\n        cipient, respectively. This could include additional identifiers, values computed dur-\n        ing the key-establishment process but not transmitted, or any other information that\n        the party wants to include. This information can be known ahead of time by both\n        parties or transmitted during key confirmation.\nThe MAC algorithm and KC_Key used shall have security strengths equal to or greater\nthan the desired security strength of the application. See Appendix C.1 for permitted MAC\nalgorithms and further details.\n\n4.4.2.  Obtaining the Key-Confirmation Key\nIn order to create and validate the MAC tag for the created MAC_Data, the parties cre-\nate a dedicated key-confirmation key (KC_Key). This can be either a portion of the KEM\n\n                                    21"
  },
  {
    "doc_id": "NIST.SP.800-227",
    "source_path": "data/raw_pdfs/NIST.SP.800-227.pdf",
    "page_number": 30,
    "text": "NIST SP 800-227\nSeptember 2025    Recommendations for KEMs\n\nshared secret key or part of the keying material derived from the KEM shared secret key\nwhen using a derivation function (see Sec. 4.3).   The KC_Key shall only be used for key\nconfirmation and destroyed after use. See Appendix C.1 for KC_Key lengths.\nWhen a derivation     function is used.  After      computing the   shared secret value\nand applying the      key-derivation method     to obtain the derived keying    material\nDerived_Keying_Material, the key-confirmation provider uses agreed-upon bit lengths to\nparse Derived_Keying_Material into two parts — the key-confirmation key (KC_Key) and\nthe keys to subsequently protect data (Data_Key):\n         Derived_Keying_Material = KC_Key‖Data_Key.\nWhen a derivation function is NOT used. The key-confirmation provider parses the output\nof the encapsulation process (i.e., KEM_shared_secret_key) into KC_Key and Data_Key:\n          KEM_shared_secret_key = KC_Key‖Data_Key.\n\n4.4.3.  Key-Confirmation Example\nThe key-confirmation process can be achieved in multiple ways. The following example\nshowcases unilateral key confirmation from the encapsulator to the decapsulator, which\ncan be used for a client (e.g., Alice) requesting confirmation of successful key establishment\nfrom a server (e.g., Bob). Figure 5 shows this process. Some desirable security properties\nmight not be achieved by a protocol of this form and may require additional steps and\ningredients.\n 1.     Alice (i.e., decapsulating party) generates a set of ephemeral keys (ek, dk) for KEM\n        Π under the agreed parameter set p. Alice then sends ek, Alice’s identifying string\n        (IDA), and any extra data ExtraA to include in the key confirmation to Bob (i.e., en-\n        capsulating party).\n 2.     Bob performs encapsulation with the received ek to generate ciphertext c and ini-\n        tial key KB0. Bob then derives two keys from KB0: a key-confirmation key KBkc to\n        perform key confirmation and additional keying material KB1.\n 3.     Bob constructs MAC_Data using the following in order:\n         • The constant string ”KC_1_E,” which indicates that Bob (i.e., the encapsulator)\n         is providing key confirmation and that this is the first KC message\n         • IDB, which is Bob’s identifier string\n         • IDA, which is Alice’s identifier string\n         • Ciphertext c, which serves as Bob’s (i.e., the KC provider’s) ephemeral value for\n         the key-confirmation process\n\n22"
  },
  {
    "doc_id": "NIST.SP.800-227",
    "source_path": "data/raw_pdfs/NIST.SP.800-227.pdf",
    "page_number": 31,
    "text": "NIST SP 800-227\nSeptember 2025    Recommendations for KEMs\n\n      Alice (Decapsulator, Client):      Bob (Encapsulator, Server):\n1. (ek, dk) ← Π.KeyGen( p)\n                                       ek, IDA, ExtraA\n                                       −\n                                       −\n                                        −\n                                        −\n                                         −\n                                         −\n                                          −\n                                          −\n                                           −→\n2.                                                      (c, KB0) ← Π.Encaps( p, ek)\n                                                        KBkc||KB1 ← KDF(KB0)\n3.                                                      Construct MAC_Data\n                                                        t ← MAC(KBkc, MAC_Data)\n                                       c, t, IDB, ExtraB\n                                       ←−\n                                        −\n                                         −\n                                         −\n                                          −\n                                          −\n                                           −\n                                           −\n                                                      −\n4. KA0 ← Π.Decaps( p, dk, c)\n      KAkc||KA1 ← KDF(KA0)\n5. Construct MAC_Data\n      if MAC.Ver(KAkc, MAC_Data, t)\n      rejects, abort.\n6. result: KA1  (KAkc destroyed )                       result: KB1  (KBkc destroyed )\n\n                Fig. 5. Key-confirmation example with an ephemeral key pair\n\n       • Encapsulation key ek, which is Alice’s (i.e., the KC recipient’s) ephemeral value\n       for the key-confirmation process\n       • ExtraB, which refers to any extra data that Bob (i.e., the KC provider) would like\n       to include\n       • ExtraA, which refers to the extra data provided by Alice (i.e., the KC recipient)\n      Bob calculates the tag t using KBkc on MAC_Data and sends the following to Alice:\n      1) ciphertext c, 2) the generated tag t, 3) and any extra data ExtraB that Bob included\n      in the MAC_Data.\n 4.   Alice performs decapsulation on the received ciphertext c using the previously gen-\n      erated decapsulation key dk to calculate initial key KA0. Alice then derives two keys\n      from KA0 similarly to Bob (in step 2): key-confirmation key KAkc and additional keying\n      material KA1.\n 5.   Alice constructs MAC_Data as Bob did in step 3 and verifies the received t for the\n      MAC_Data using key KAkc.         Alice aborts if the tag is rejected or continues if it is\n      verified.\n 6.   Alice now has additional assurance that KA1 matches KB1. Alice and Bob destroy the\n      key-confirmation keys KAkc and KBkc and can proceed to use KA1 and KB1 as planned.\n\n23"
  },
  {
    "doc_id": "NIST.SP.800-227",
    "source_path": "data/raw_pdfs/NIST.SP.800-227.pdf",
    "page_number": 32,
    "text": "NIST SP 800-227\nSeptember 2025    Recommendations for KEMs\n\nThis example only provides unilateral key confirmation. If Bob also wanted assurance, an-\nother round of key confirmation can be performed by swapping roles.     During this addi-\ntional round, Alice generates new MAC_Data using KC_2_D as the label and indicating\nherself as the KC provider (see Sec. 4.4.1), generates a tag on new MAC_Data, and sends\nthe new tag to Bob for verification.\n\n4.5.  Proof of Possession for KEM Keys\nA key-pair owner may need to provide proof-of-possession (PoP), which is the assurance\nthat they possess the private decapsulation key corresponding to the public encapsulation\nkey.      In practice, PoP for RSA encryption key pairs (i.e., encryption key, decryption key)\nhas historically been provided by reusing the same keys as a digital signature key pair (i.e.,\nverification key, signing key). A key-pair owner can provide assurance that they possess the\nsecret decryption key by signing a message using the private signing/decryption key. The\nparty seeking assurance can verify the signature using the public verification/encryption\nkey. Unfortunately, this shortcut does not necessarily apply to all KEMs, so it is important\nto consider alternative approaches to providing PoP for KEMs.\nConsider the case in which Bob has obtained another party’s static public encapsulation\nkey and is communicating with a party purporting to be the key-pair owner corresponding\nto that encapsulation key. Bob may seek PoP from the other party before any further\nengagement. One method to obtain PoP is for Bob to participate in a KEM protocol that\nincludes key confirmation (see Sec. 4.4) and in which assurance of the identity of the other\nparty is provided. This method can be used for both static and ephemeral key pairs.\nHowever, for static key pairs, PoP can also be provided in a certificate by a certificate au-\nthority (CA). Consider the case in which Alice is the owner of a static KEM key pair and\nwould like to acquire a certificate establishing her ownership. A certificate authority (CA)\nwould require PoP from Alice prior to issuing and publishing a certificate. Bob could then\nacquire the certificate from either Alice or the CA and would have assurance that Alice pos-\nsesses the private key. Methods for performing PoP by a CA for KEMs are being developed.\nFor illustrative purposes, this section also describes a method proposed in [22] that can\nbe used by a CA to obtain PoP for a private decapsulation key for which a certificate is\nrequested for the corresponding public encapsulation key. In practice, a certificate not\nonly links the identity of the key-pair owner to the static public key,     but it also proves\nthat a key-pair owner possesses the static private key that corresponds to a static public\nkey. For the sake of simplicity, assume that Alice’s identifying information IDAlice has been\nsubmitted to and verified by the CA prior to the protocol run described below.\nSuppose that Alice has generated a static KEM key pair (ek, dk) and wants to obtain a\ncertificate for ek. Let Π, p be the KEM and parameter set associated with (ek, dk).        Let\nSym = (Sym.KeyGen, Sym.Enc, Sym.Dec) denote a symmetric encryption scheme with\ncorresponding key generation, encryption, and decryption algorithms, respectively.         Let\n\n                                      24"
  },
  {
    "doc_id": "NIST.SP.800-227",
    "source_path": "data/raw_pdfs/NIST.SP.800-227.pdf",
    "page_number": 33,
    "text": "NIST SP 800-227\nSeptember 2025    Recommendations for KEMs\n\nH denote a cryptographic hash function. Let Cert.Gen denote the process used by the CA\nto generate a certificate.\n\n      Alice (key pair owner)                               Bob (CA)\n1. static:   (ek, dk)\n      IDAlice\n                                             −  ek, IDAlice\n                                             −\n                                                −\n                                                −\n                                                   −\n                                                   −\n                                                    −\n                                                    −\n                                                     −\n                                                        −\n                                                           −→\n2.                                                           (c, K) ← Π.Encaps( p, ek)\n                                                             cert[ek, p, Alice] ← Cert.Gen(ek, IDAlice)\n                                                             HB ← H(cert[ek, p, Alice])\n                                                             ccert ← Sym.EncK (cert[ek, p, Alice])\n                                             ←− c, cᶜᵉʳᵗ\n                                                −\n                                                 −\n                                                   −\n                                                    −\n                                                    −\n                                                     −\n                                                        −\n                                                           −\n                                                           −\n                                                            −\n3. KA ← Π.Decaps( p, dk, c)\n      cert′[ek, p, Alice] ← Sym.DecKA(ccert)\n      HA ← H(cert′[ek, p, Alice])\n                                             −      HA\n                                             −\n                                                −\n                                                 −\n                                                   −\n                                                    −\n                                                    −\n                                                     −\n                                                        −\n                                                           −\n                                                           −→\n                                                             if HA = HB, abort.\n4.                                                           publish: cert[ek, p, Alice]\n\n                     Fig. 6. KEM PoP between a key-pair owner and CA\n\n       0.  Prior to the protocol initiation, Alice    has submitted her identifying information\n           IDAlice to the CA, and the CA has verified her identity. Throughout the protocol ex-\n           ecution, messages coming from Alice are assumed to be authenticated so that no\n           one can impersonate Alice within the protocol.\n       1.  Alice sends ek, IDAlice to the CA to initiate the protocol.\n       2.  The CA runs Π.Encaps(ek, p) to produce (K, c).    The CA generates the certificate\n           cert[ek, p, Alice] and links Alice’s identity to her encapsulation key ek. The CA com-\n           putes HB, which is the hash of the certificate.   The CA then computes ccert =\n           Sym.EncK(cert[ek, p, Alice]) by encrypting the certificate with the key produced by\n           KEM Π. Finally, the CA sends the two ciphertexts c and ccert to Alice.\n       3.  Alice runs Π.Decaps(p, dk, c) to recover K and decrypts the certificate by comput-\n           ing Sym.DecK(ccert) to obtain the plaintext certificate.   Alice hashes the plaintext\n           certificate and sends the resulting hash value HA to the CA.\n       4.  The CA verifies the received hash value HA against HB, which is the hash of the plain-\n           text certificate cert[ek, p, Alice] generated in step 2. If the two hash values are equal,\n\n                                                25"
  },
  {
    "doc_id": "NIST.SP.800-227",
    "source_path": "data/raw_pdfs/NIST.SP.800-227.pdf",
    "page_number": 34,
    "text": "NIST SP 800-227\nSeptember 2025    Recommendations for KEMs\n\n      the CA sends an acknowledgment to Alice that the certification process was success-\n      ful, and cert[ek, p, Alice] is published for use.\nOnce the CA publishes cert[ek, p, Alice], relying parties using that certificate have assurance\nthat the owner of that certificate (Alice, with identity ” Alice”) possessed the private decap-\nsulation key corresponding to ek when the certificate    was generated and published. If Alice\nmanages to recover the certificate in step 3, this indirectly proves that she possesses the\ncorresponding decapsulation key dk. However, the CA would not receive PoP from Alice\nunless step 4 is completed. This solution requires that the CA has the capabilities to run\nΠ.Encaps(), which may not be true in practice.\n\n4.6.  Multi-Algorithm KEMs and PQ/T Hybrids\nCombining multiple key-establishment schemes into a single key-establishment scheme\ncan be advantageous for some applications (e.g., during the migration to post-quantum\ncryptography). The discussions of such schemes in this document will adhere to the ter-\nminology established in [23].\nA multi-algorithm key-establishment scheme combines shared secret values that are gen-\nerated using two or more key-establishment schemes. The underlying schemes are called\nthe components of the overall scheme.    In general, the multi-algorithm scheme does not\nneed to have the same interface as its components. In this document, for example, multi-\nalgorithm schemes will always be KEMs, while their components need not be.\nA well-designed multi-algorithm scheme will be secure if at least one of the component\nschemes is secure. This may provide some protection against vulnerabilities that are dis-\ncovered in one of the component schemes after deployment. Forexample, the migra-\ntion to post-quantum key-establishment techniques might initially include multi-algorithm\nsolutions that combine one new post-quantum algorithm with one tried-and-tested but\nquantum-vulnerable (or traditional) algorithm. This is   sometimes referred to as hybrid\npost-quantum/traditional (PQ/T) key      establishment.  For example, X-Wing     KEM is a\nhybrid PQ/T KEM built from two components:     ML-KEM (a lattice-based post-quantum\nKEM) and X25519 (a traditional Diffie-Hellman-style key exchange) [24].\nThis section outlines approved approaches for multi-algorithm key establishment, which\nhave two stages:\n 1.   Establish shared secrets. All component key-establishment schemes are run (typi-\n      cally in parallel), resulting in Alice and Bob sharing a collection of shared secrets —\n      one for each component scheme.\n 2.   Combine shared secrets. Alice and Bob individually use a key combiner to combine\n      their individual shared secrets into a single shared secret each. Approved key com-\n      biners are described in Sec. 4.6.2.\n\n26"
  },
  {
    "doc_id": "NIST.SP.800-227",
    "source_path": "data/raw_pdfs/NIST.SP.800-227.pdf",
    "page_number": 35,
    "text": "NIST SP 800-227\nSeptember 2025    Recommendations for KEMs\n\nFor simplicity, the exposition below focuses on a particular case: constructing a single KEM\nfrom two component KEMs. Since both the components and the multi-algorithm scheme\nin this case are of the same type (i.e., KEMs), the result is called a composite KEM. Most key-\nestablishment schemes of interest can easily be expressed as KEMs (see, e.g., ECDH-KEM\nin Sec. 5.1.1 and RSA-KEM in Sec. 5.1.2). Moreover, the hybrid PQ/T application typically\ncalls for two component schemes: one post-quantum scheme, and one traditional scheme.\nThe two-algorithm composite KEM described below is easily adapted to other cases, such\nas combining more than two schemes or combining KEMs with non-KEMs.\n\n4.6.1.     Constructing a Composite KEM\nGiven two KEMs Π1 and Π2, one can construct a composite KEM C[Π1, Π2] via the following\nsequence of steps:\n 1.     Choose parameter sets. Choose a collection C[Π1, Π2].ParamSets of parameter\n        sets. Each parameter set will be a pair p = (p1, p2), where p1 ∈ Π1.ParamSets and\n        p2 ∈ Π2.ParamSets.\n 2.     Select a key combiner. Choose a key combiner algorithm KeyCombine. The inputs\n        to KeyCombine include a pair of shared secret keys (one from Π1 and one from Π2),\n        a pair of ciphertexts, a pair of encapsulation keys, and a parameter set. The output\n        is a single shared secret key. Section 4.6.2 discusses NIST-approved key combiners.\n 3.     Construct a composite key-generation algorithm.            When a parameter set p =\n        (p1, p2) is input, the algorithm C[Π1, Π2].KeyGen will perform:\n        1.  (ek1, dk1) ← Π1.KeyGen(p1).\n        2.  (ek2, dk2) ← Π2.KeyGen(p2).\n        3.  Output composite encapsulation key ek1‖ek2.\n        4.  Output composite decapsulation key dk1‖dk2.\n 4.     Construct a composite encapsulation  algorithm.            When a parameter set p =\n        (p1, p2) and encapsulation key ek1‖ek2 are input, the algorithm C[Π1, Π2].Encaps\n        will perform:\n        1.  (K1, c1) ← Π1.Encaps(p1, ek1).\n        2.  (K2, c2) ← Π2.Encaps(p2, ek2).\n        3.  Output combined shared secret key\n\n                          K ← KeyCombine(K1, K2, c1, c2, ek1, ek2, p).    (9)\n\n        4.  Output composite ciphertext c := c1‖c2.\n\n27"
  },
  {
    "doc_id": "NIST.SP.800-227",
    "source_path": "data/raw_pdfs/NIST.SP.800-227.pdf",
    "page_number": 36,
    "text": "NIST SP 800-227\nSeptember 2025    Recommendations for KEMs\n\n 5.     Construct a composite decapsulation  algorithm.  When a parameter set p =\n        (p1, p2), decapsulation key dk1‖dk2, and ciphertext c1‖c2 are input, the algorithm\n        C[Π1, Π2].Decaps will perform:\n        1.  K′ ← Π1.Decaps(p1, dk1, c1).\n            1\n        2.  K′ ← Π2.Decaps(p2, dk2, c2).\n            2\n        3.  Output combined shared secret key\n\n                         K′ ← KeyCombine(K′ , K′ , c1, c2, ek1, ek2, p).      (10)\n                                             1  2\n\nSince the inputs to KeyCombine include the composite encapsulation key, the decapsulat-\ning party must retain a copy of that key or maintain the ability to recreate it after perform-\ning key generation.\n\nGeneral multi-algorithm schemes. The above construction can be extended in the obvi-\nous way to composite constructions that use more than two component KEMs.              Extend-\ning to the case of a completely general multi-algorithm key-establishment scheme can be\nmore complex, as the components in such a scheme can vary widely. For example, such\nschemes could potentially include pre-shared keys or shared secrets established via quan-\ntum key distribution. Still, most multi-algorithm schemes will likely include a step in which\na series of shared secrets are combined via a key combiner algorithm of a form similar to\nKeyCombine above. In those cases, an approved key combiner discussed in Sec. 4.6.2 shall\nbe used.\n\n4.6.2.     Approved Key Combiners\nThis section describes approved methods for combining shared secrets as part of a multi-\nalgorithm key-establishment scheme. Choosing such a method amounts to selecting a key\ncombiner KeyCombine. At a minimum, KeyCombine accepts two shared secrets as input,\nwhere one or both may be shared secret keys.            Optionally, KeyCombine can also accept\nadditional information, such as ciphertexts, encapsulation keys, parameter sets, or other\ncontext-dependent data (e.g., the composite KEM in Sec. 4.6.1). As output, KeyCombine\nproduces a single shared secret key.\nThis section describes how cryptographic methods standardized in other NIST publications\ncan be used as key combiners under an appropriate interpretation. There are two cate-\ngories of such key combiners:\n 1.     Key combiners from key-derivation methods approved in SP 800-56C [21]\n 2.     Key combiners from key-combination methods approved in SP 800-133 [18]\n\nConcatenation of inputs. The following descriptions involve   invocations of functions\n(e.g., hash functions H : {0, 1}∗ → {0, 1}n) on multiple comma-separated inputs (e.g.,\n\n                                        28"
  },
  {
    "doc_id": "NIST.SP.800-227",
    "source_path": "data/raw_pdfs/NIST.SP.800-227.pdf",
    "page_number": 37,
    "text": "NIST SP 800-227\nSeptember 2025    Recommendations for KEMs\n\nz := H(x, y)).  This should be distinguished from invoking the same function on a single\ninput that is formed by simply concatenating those inputs (e.g., w := H(x‖y)). For exam-\nple, if the lengths of the two inputs can vary, concatenation can have unintended conse-\nquences (e.g., x‖y = x′‖y′ even though (x, y) = (x′, y′)). However, an appropriate encoding\nof a pair (x, y) as a single bitstring can specify the lengths of x and y such that invoking H\non (x, y) is distinct from invoking H on (x′, y′).\nThe interpretation of invoking a function on comma-separated inputs generally depends\non the application and encoding and might also involve specifying the lengths of each in-\ndividual input. In some scenarios, simple concatenation can also be appropriate. In any\ncase, it is important to choose and fix this interpretation in a manner that is appropriate\nfor the given application.\n\nKey derivation in SP 800-56C. SP 800-56C [21] specifies a collection of approved methods\nfor performing key derivation. In SP 800-56C, a key derivation method (KDM) is applied to\na shared secret Z generated as specified in SP 800-56A [1] or SP 800-56B [2] along with\nsome additional input and results in keying material K:\n     K ← KDM(Z, OtherInput).                                                       (11)\nThe key-derivation method KDM can take one of two forms:\n 1.  One-step key derivation. In this case, K is computed by applying a key-derivation\n     function KDF to the two inputs Z and OtherInput.\n                              K ← KDF(Z, OtherInput).                              (12)\n\n 2.  Two-step key derivation. In this case, two functions are required: Extract (which is\n     a randomness extractor) and Expand. The process begins with applying Extract to\n     Z using a salt provided in OtherInput as the seed.   Expand is then applied to the\n     result along with FixedInfo, which is also provided in OtherInput.\n                          K ← Expand Extract salt      FixedInfo\n                              (                   (  , Z),      ).                 (13)\n     In this method, it is required that extraction is applied to the shared secret Z.\nSP 800-56C describes the specific approved choices of KDF, Extract, and Expand as well\nas the format and content of OtherInput. These details will not be discussed in this doc-\nument.\nAs discussed in Sec. 4.3, this publication approves the application of SP 800-56C KDMs\nto the shared secret keys of approved KEMs.       In particular, this means that the quantity\nZ in Equation (11) (and hence, also in (12) and (13)) can be the shared secret key of an\napproved KEM.\n\nKey combiners derived from SP 800-56C. In both one-step and two-step key derivation,\nSP 800-56C allows the shared secret Z to have the form Z = (S1, S2), where S1 is a shared\n\n                29"
  },
  {
    "doc_id": "NIST.SP.800-227",
    "source_path": "data/raw_pdfs/NIST.SP.800-227.pdf",
    "page_number": 38,
    "text": "NIST SP 800-227\nSeptember 2025    Recommendations for KEMs\n\nsecret generated as specified in SP 800-56A [1] or SP 800-56B [2], while S2 is a shared secret\ngenerated in some other (not necessarily approved) manner.         This yields a key combiner\nK ← KDM((S1, S2), OtherInput) for a two-algorithm key-establishment scheme. One can\nalso combine many shared secrets:\n\n                     K ← KDM((S1, S2, · · · , St ), OtherInput).                         (14)\n\nThis publication approves the use of the key combiner (14) for any t > 1 if at least one\nshared secret (i.e., S j for some    j) is generated from the key-establishment methods in SP\n800-56A [1] or SP 800-56B [2] or an approved KEM. If the KDM in the combiner (14) is a\ntwo-step method (i.e., using (13)), extraction is performed with all shared secrets as the\ninput.\nSP 800-56C allows OtherInput to contain an input that is chosen arbitrarily by the pro-\ntocol specification.      This optional input is contained in a parameter called FixedInfo in\nSP 800-56C. By choosing FixedInfo appropriately, one can also construct approved key\ncombiners of the form (14) that receive inputs in addition to shared secrets, such as en-\ncapsulation keys, ciphertexts, parameter sets, and domain separators.\nSeveral key combiners can be generated according to Expression (14). As a simple exam-\nple, consider the following special case.        Choose KDM to be the one-step key-derivation\nmethod, where KDF is an approved hash function. Set OtherInput to contain the list of\nciphertexts and encapsulation keys together with a domain separator domain_sep (possi-\nbly including the parameter set p). Define a key combiner algorithm KeyCombine simply\nby setting\n\nKeyCombine(K1, K2, c1, c2, ek1, ek2, p) := H(K1, K2, c1, c2, ek1, ek2, domain_sep).  (15)\n\nOne can then instantiate the composite KEM example from Sec. 4.6 by using this key com-\nbiner. The resulting composite KEM will have a shared secret key whose length is the out-\nput length of H.\n\nKey combiners derived from SP 800-133. SP 800-133 [18] provides three approved meth-\nods for combining cryptographic keys that were generated in an approved way.            These\nmethods can be broadly described as concatenation, XORing, and key extraction using\nHMAC. Some of these methods can also be applied to just a single key.         As discussed in\nSec. 4.3, these methods are approved for key derivation for approved KEMs.\nWhen combining multiple keys K1, K2, . . . , Kt , the key-combination methods found in SP\n800-133 [18] require every key K j for j  ∈ {1, 2, . . . , t } to be generated using approved\nmethods.          These methods can be used directly as key combiners for constructing multi-\nalgorithm schemes in cases where all of the component schemes are approved, and each\none produces a key.          Any protocol using multi-algorithm KEMs with a concatenation key\ncombiner should ensure that the final shared secret key from the key combiner is passed\nthrough a KDF before use.\n\n                                          30"
  },
  {
    "doc_id": "NIST.SP.800-227",
    "source_path": "data/raw_pdfs/NIST.SP.800-227.pdf",
    "page_number": 39,
    "text": "NIST SP 800-227\nSeptember 2025    Recommendations for KEMs\n\n4.6.3.  Security Considerations for Composite Schemes\nThe typical goal of a composite KEM construction is to ensure that security will hold if any\nof the component KEMs is secure. There are some important security considerations when\nconstructing composite KEMs.\n\nTheoretical security. The two main security properties that KEMs can satisfy (see Sec. 2.3)\nare:\n    1.  IND-CPA security (i.e., security against passive eavesdropping attacks)\n    2.  IND-CCA security (i.e., security against active attacks)\nA well-constructed composite KEM C[Π1, Π2] should preserve the security properties of\nits component KEMs Π1 and Π2.       This crucially depends on how the composite KEM is\nconstructed and the choice of the key combiner.\nAn important example is when the goal is active (i.e., IND-CCA) security, but only one of\nthe two schemes Π1 and Π2 is itself IND-CCA, and the designer of the composite scheme\nmay not know which one it is. In this case, the choice of the key combiner is particularly\nrelevant. As shown in [24], the straightforward key combiner\n\n                                    K ← KDF(K1, K2)                               (16)\n\nthat only uses the two shared secret keys K1 (of Π1) and K2 (of Π2) does not preserve\nIND-CCA security, regardless of the properties of the KDF. So, for example, the scheme\nΠ2 could be so broken that C[Π1, Π2] is not IND-CCA, even if Π1 is IND-CCA and regardless\nof what KDF is used.\nTherefore, NIST encourages the use of key combiners that generically preserve IND-CCA\nsecurity, in the sense that the combined scheme is IND-CCA, provided at least one of the\ningredient KEMs is IND-CCA. One example of such a key combiner is as in (15).    Let H\ndenote a hash function from the SHA-3 family, which is approved for use in one-step key\nderivation in SP 800-56C [21]. Define the key combiner KeyCombineCCA as follows (recalling\nthe notation in Sec. 4.6):                                      H\n     • Inputs from Π1: ek1, c1, K1\n     • Inputs from Π2: ek2, c2, K2\n     • Output: H(K1, K2, c1, c2, ek1, ek2, domain_sep)\nThe domain separator domain_sep should be used to uniquely identify the composite\nscheme in use (e.g., Π1, Π2, order of composition, choice of parameter set, key combiner,\nKDF). As shown in [25], KeyCombineCCA preserves IND-CCA security if H is modeled as a\nrandom oracle. Note that [25] does  H\n                                 not incorporate encapsulation keys into the combiner,\nas this is not needed to achieve the IND-CCA-preserving property. However, including en-\n\n31"
  },
  {
    "doc_id": "NIST.SP.800-227",
    "source_path": "data/raw_pdfs/NIST.SP.800-227.pdf",
    "page_number": 40,
    "text": "NIST SP 800-227\nSeptember 2025    Recommendations for KEMs\n\ncapsulation keys can have other potential advantages in secure protocols, such as binding\nthe final shared secret to the identities of the participating parties.\n\nSecurity in practice. While composite schemes are meant to increase security, they nec-\nessarily add a layer of additional complexity to the basic KEM framework. This additional\ncomplexity will be reflected in implementations and applications and could introduce se-\ncurity vulnerabilities. Moreover, adding composite schemes introduces additional choices\nin protocols, which could also introduce vulnerabilities (e.g., in the form of “downgrade\nattacks”). Implementers and users should be aware of the potential challenges in imple-\nmenting and deploying composite schemes.\n\n32"
  },
  {
    "doc_id": "NIST.SP.800-227",
    "source_path": "data/raw_pdfs/NIST.SP.800-227.pdf",
    "page_number": 41,
    "text": "NIST SP 800-227\nSeptember 2025    Recommendations for KEMs\n\n5.    Examples\n\nThis section is meant to help readers understand some aspects of how KEMs are con-\nstructed. It only provides examples, not requirements or specific guidelines.\n\n5.1.    Examples of KEMs\nThe following subsections discuss three key-encapsulation mechanisms: ECDH-KEM, RSA-\nKEM, and ML-KEM. While ECDH and RSA key transport are not typically described as KEMs,\nthe discussions below will give a high-level description of how both can be naturally viewed\nas KEMs. The goal of these descriptions is illustrative only. As FIPS 203 already contains a\ncomplete description of ML-KEM, the discussion below will simply reference the relevant\nparts of FIPS 203 [3].\n\n5.1.1.  A KEM From Diffie-Hellman\nA KEM may be constructed from a Diffie-Hellman (DH) key-agreement scheme. The high-\nlevel idea is that, if the two parties in a DH scheme send their messages in sequential order\n(e.g., Alice first, then Bob), then:\n    1.  The public message and private randomness of Alice can be viewed as an encapsu-\n        lation key and a decapsulation key, respectively, and\n    2.  The public message of Bob can be viewed as a ciphertext.\nFor example, a KEM can be constructed from the C(1e, 1s, ECC CDH) Scheme from SP 800-\n56A [1] as follows:\n     • ECDH-KEM.ParamSets. The parameter sets are the same as those specified for ECDH\n        in Sec. 5.5.1.2 of SP 800-56A.\n     • ECDH-KEM.KeyGen. The key-generation algorithm is the same as the one specified\n        in Sec. 5.6.1.2 of SP 800-56A. Alice generates a static key pair and makes the static\n        public key available as the encapsulation key. Bob generates an ephemeral key pair\n        when initiating the key establishment with Alice.\n     • ECDH-KEM.Encaps. To encapsulate, perform Party U’s actions from Sec. 6.2.2.2 of SP\n        800-56A. The output is the key (i.e., the derived secret keying material) along with\n        the ciphertext (i.e., the ephemeral public key Qe,U ).\n     • ECDH-KEM.Decaps. To decapsulate, perform Party V’s actions from Sec. 6.2.2.2 of\n        SP 800-56A. The output key is the derived secret keying material.\nThe use of this KEM requires that all assumptions for the scheme specified in SP 800-56A\nare met and that all necessary assurances have been obtained.   This KEM is IND-CPA-\nsecure if the computational Elliptic Curve Diffie Hellman problem is hard for parameter set\nParamSets. The computational Elliptic Curve Diffie Hellman problem is efficiently solved by\n\n                                      33"
  },
  {
    "doc_id": "NIST.SP.800-227",
    "source_path": "data/raw_pdfs/NIST.SP.800-227.pdf",
    "page_number": 42,
    "text": "NIST SP 800-227\nSeptember 2025    Recommendations for KEMs\n\na quantum computer so this KEM is considered to be quantum-vulnerable, as mentioned in\nSection 2.2. This KEM is not claimed to be IND-CCA-secure. In similar ways, KEMs could be\nconstructed from the C(1e, 1s, FFC DH), C(2e, 0s, ECC CDH), and C(2e, 0s, FFC DH) schemes.\n\n5.1.2.  A KEM From RSA Secret-Value Encapsulation\nAs discussed in Sec. 2.2, any PKE scheme can be used to construct a KEM. A concrete exam-\nple of this is RSA Secret-Value Encapsulation (RSASVE)4 with an agreed-upon key-derivation\nmethod applied to the shared secret value Z to derive a shared secret key. The high-level\nidea is described as follows:\n 1.     Alice sends an RSA public key to Bob.     Optionally, Alice can also send some other\n        public information to Bob, such as a nonce for key derivation.\n 2.     Bob generates a secret value and encapsulates it with Alice’s RSA public key to pro-\n        duce the ciphertext. A key is derived from the secret value. The output of encapsu-\n        lation is the ciphertext and the derived key. The ciphertext is sent to Alice.\n 3.     Alice decapsulates the ciphertext using her RSA private key to obtain the secret value\n        that is used to derive the key.\nFor example, a KEM can be constructed from RSASVE from SP 800-56B [2] as follows:\n 1.     RSASVE-KEM.ParamSets. The parameter set is the binary length of the modulus\n        (specified in Table 2, Sec. 6.3 of SP 800-56B) along with the exponent e.\n 2.     RSASVE-KEM.KeyGen.   The key-generation algorithm is specified in Sec. 6.3 of SP\n        800-56B (also see Appendix C.2 of FIPS 186-5).\n 3.     RSASVE-KEM.Encaps.   To encapsulate,  Bob (in       his role as Party U) performs\n        RSASVE.GENERATE, as specified in Sec. 7.2.1.2 of SP 800-56B. The output is the ci-\n        phertext and a secret value Z. Bob applies the agreed-upon key-derivation method\n        to the secret value Z to derive a shared secret key.\n 4.     RSASVE-KEM.Decaps.   To decapsulate,  Alice   (in   her role as Party V) performs\n        RSASVE.RECOVER using the ciphertext from Bob, as specified in Sec. 7.2.1.3 of SP\n        800-56B. The output is the secret value Z.    Alice applies     the agreed-upon key-\n        derivation method to the secret value Z to derive a shared secret key.\nUsing this KEM requires that all assumptions for the scheme specified in SP 800-56B are\nmet and that all necessary assurances have been obtained. This KEM is IND-CPA-secure if\nthe computational RSA problem is hard for parameter set ParamSets. The computational\nRSA problem is efficiently solved by a quantum computer so this KEM is considered to be\n\n4Note that RSASVE is NOT a standalone approved scheme. It is a component of the approved KAS1 and KAS2\nschemes.\n\n        34"
  },
  {
    "doc_id": "NIST.SP.800-227",
    "source_path": "data/raw_pdfs/NIST.SP.800-227.pdf",
    "page_number": 43,
    "text": "NIST SP 800-227\nSeptember 2025    Recommendations for KEMs\n\nquantum-vulnerable, as mentioned in Section 2.2. This KEM is not claimed to be IND-CCA-\nsecure. In similar ways, KEMs could be constructed from RSA-OAEP-basic, as specified in\nSec. 9.2.3 of SP 800-56B.\n\n5.1.3.  ML-KEM\nML-KEM is a high-performance, general-purpose, lattice-based key-encapsulation mecha-\nnism. It is a NIST-approved KEM and was standardized in FIPS 203 [3]. ML-KEM is based on\nCRYSTALS-Kyber [26], which was a candidate in the NIST PQC standardization process. It is\nbelieved to satisfy IND-CCA security (Definition 4), even against adversaries in possession\nof a cryptanalytically relevant quantum computer [17, 27, 28]. The asymptotic, theoreti-\ncal security of ML-KEM is based on the presumed hardness of the Module Learning with\nErrors (MLWE) problem [29, 30].\nFIPS 203 directly describes ML-KEM as a KEM in a manner that closely matches the notation\nof this document. Specifically, the components of ML-KEM are described in FIPS 203 as\nfollows [3]:\n • ML-KEM.ParamSets. There are three parameter sets described in Sec. 8 of FIPS 203:\n        ML-KEM-512, ML-KEM-768, and ML-KEM-1024.\n • ML-KEM.KeyGen. The key-generation algorithm of ML-KEM is specified as Algorithm\n        19 in Sec. 7.1 of FIPS 203.\n • ML-KEM.Encaps. The encapsulation algorithm of ML-KEM is specified as Algorithm\n        20 in Sec. 7.2 of FIPS 203.\n • ML-KEM.Decaps. The decapsulation algorithm of ML-KEM is specified as Algorithm\n        21 in Sec. 7.3 of FIPS 203.\nThis document treats parameter sets as an explicit input for the KEM algorithms KeyGen,\nEncaps, and Decaps. By contrast, the algorithms of ML-KEM described in FIPS 203 expect\nthe chosen parameter set to be stored in a set of global variables that are accessible to\neach of the algorithms of ML-KEM. This is only a difference in presentation and does not\nimply any particular implementation requirement.\n\n5.2.    Examples of KEM Applications\nThis section provides a high-level overview of several example applications of KEMs.\n\n5.2.1.  KEM-DEM Public-Key Encryption\nA KEM can be combined with a symmetric-key encryption scheme to yield very effi-\ncient public-key encryption. This is sometimes referred to as the KEM-DEM paradigm for\nPKE [17]. Examples include El Gamal encryption [31] and the Elliptic Curve Integrated En-\ncryption Scheme (ECIES) standardized in ANSI X9.63 [15].\n\n                                     35"
  },
  {
    "doc_id": "NIST.SP.800-227",
    "source_path": "data/raw_pdfs/NIST.SP.800-227.pdf",
    "page_number": 44,
    "text": "NIST SP 800-227\nSeptember 2025    Recommendations for KEMs\n\nThe prescription for constructing a KEM-DEM PKE scheme is as follows. Let Π be a KEM,\nand let Ξ = (Encrypt, Decrypt) be a symmetric-key encryption scheme.    One then con-\nstructs a PKE called KD-PKE as follows:\n • KD-PKE.ParamSets = Π.ParamSets\n • KD-PKE.KeyGen = Π.KeyGen\n • KD-PKE.Encrypt: given input parameter set p, ek, and message m:\n  1.  Compute (K, cΠ) ← Π.Encaps(p, ek).\n  2.  Compute cΞ ← Ξ.Encrypt(K, m).\n  3.  Output (cΠ, cΞ).\n • KD-PKE.Decrypt: given input p, dk, and (cΠ, cΞ),\n  1.  Compute K′ ← Π.Decaps(p, dk, cΠ).\n  2.  Output m′ ← Ξ.Decrypt(K′, cΞ).\nHere, the keys of Ξ are assumed to be the same length as the shared secret keys pro-\nduced by Π.   If not, appropriate key-derivation steps (see Sec. 4.3) can be added to\nKD-PKE.Encrypt and KD-PKE.Decrypt to transform the shared secret key of Π into a key\nthat is appropriate for use with Ξ.\nFigure 7 shows the procedure for sending an encrypted message m from Bob to Alice using\nKD-PKE. In this description, Alice selects the parameter set p.\n\n     Alice                                  Bob\n     (ek, dk) ← Π.KeyGen( p)\n                                   −    ek, p\n                                       −\n                                       −\n                                        −\n                                        −\n                                         −\n                                         −\n                                             −→\n                                               (K, cΠ) ← Π.Encaps( p, ek)\n                                               cΞ ← Ξ.Encrypt(K, m)\n                                   ←− cΠ, cΞ\n                                        −\n                                        −\n                                         −\n                                         −\n                                             −\n                                             −\n                                              −\n     K′ ← Π.Decaps( p, dk, cΠ)\n     m ← Ξ.Decrypt(K′, cΞ)\n\n                 Fig. 7. Sending a message using the KEM-DEM paradigm\n\nThis same procedure can also be used to perform key transport by choosing m uniformly\nat random as the key to be transported. This allows one to perform key transport using\nany KEM, even one that does not natively perform key transport (e.g., ML-KEM).\n\n36"
  },
  {
    "doc_id": "NIST.SP.800-227",
    "source_path": "data/raw_pdfs/NIST.SP.800-227.pdf",
    "page_number": 45,
    "text": "NIST SP 800-227\nSeptember 2025    Recommendations for KEMs\n\n5.2.2.    Unilateral Authenticated Key Establishment Using a KEM\nMost applications of key establishment require at least one party (typically, a server) to\nauthenticate their identity. One approach to achieving this is for the server to acquire a\ncertificate of authenticity for their long-term, static KEM encapsulation key. This certificate\ncan then be provided to a client as proof that the key is associated with the server’s identity.\nAn example description of key establishment in this setting is given below and depicted in\nFig. 8. The example uses a simplified key confirmation process (see Sec. 4.4).\n\n          Alice (server)                              Bob (client)\n    1. static:  (ek, dk)\n                cert[ek, p, Alice]\n                                  −cert[ek, p, Alice]\n                                  −\n                                     −\n                                        −\n                                        −\n                                         −\n                                         −\n                                          −\n                                          −\n                                           −→\n    2.                                                 if cert[ek, p, Alice] invalid, abort.\n                                                       (KB, c) ← Π.Encaps( p, ek)\n                                  ←−     c\n                                     −\n                                        −\n                                        −\n                                         −\n                                         −\n                                          −\n                                          −\n                                           −\n                                                     −\n                                                     −\n    3. KA ← Π.Decaps( p, dk, c)\n    4. t ← MAC(KA, c)\n                                  −      t\n                                  −\n                                     −\n                                        −\n                                        −\n                                         −\n                                          −\n                                          −\n                                           −\n                                                    −→\n                                                       if MAC.Ver(KB, c,t) rejects, abort.\n    5. result: KA                                      result: KB\n\n                Fig. 8. Unilateral authenticated key establishment using a KEM\n\n 1.     At the outset, Alice has a long-term, static key pair that she generated earlier via\n        (ek, dk) ← Π.KeyGen(p).   Here, Π is some KEM, and p is some parameter set of\n        Π. Alice also has a certificate cert[ek, p, Alice] that contains ek and p and associates\n        them both with Alice’s identity.\n 2.     When Bob wants to connect to Alice, he acquires cert[ek, p, Alice] (e.g., from Alice),\n        verifies that the certificate is valid, and extracts ek and p from the certificate. He\n        then performs encapsulation with ek, saves the resulting shared secret key KB, and\n        sends the ciphertext c to Alice.\n 3.     Alice decapsulates c and gets a shared secret key KA.\n 4.     Alice and Bob then perform a simplified key-confirmation step. Alice uses a MAC\n        algorithm to generate a tag t ← MAC(KA, c) for the ciphertext c and sends t to Bob.\n        Bob then runs MAC verification using KB and aborts unless the tag t is accepted.    If\n        the tag is accepted, Bob knows that Alice’s key KA and his key KB are the same (i.e.,\n        they share the same key).\n\n                                           37"
  },
  {
    "doc_id": "NIST.SP.800-227",
    "source_path": "data/raw_pdfs/NIST.SP.800-227.pdf",
    "page_number": 46,
    "text": "NIST SP 800-227\nSeptember 2025    Recommendations for KEMs\n\n 5.     Alice and Bob can now use their shared secret key to communicate efficiently and\n        securely using symmetric-key cryptography.\nIf the KEM Π is secure, then only a holder of the decapsulation key dk (corresponding to\nthe encapsulation key ek in the certificate) should be able to generate a valid MAC tag in\nstep 4.\n\n5.2.3.  Ephemeral Authenticated Key Establishment\nThis section describes an alternative approach to unilaterally authenticated key establish-\nment using a KEM. Compared to the example in Sec. 5.2.2, Alice and Bob will now have the\nopposite roles in the protocol. Specifically, Bob is now the authenticated party (e.g., a web\nserver), while Alice is the unauthenticated party (e.g., a browser client). Ephemeral KEM\nkey-pair generation will now be performed by the client (i.e., Alice), and Alice will discard\nthe KEM key pair once the connection is established. The server will not use a long-term,\nstatic KEM key pair but will need to establish his identity through other means.      In this\nexample, identity establishment will be done via a certificate that associates a particular\ndigital signature verification key with Bob’s identity.\nThe following ingredients are required. Let Σ be a digital signature scheme with algorithms\nΣ.KeyGen, Σ.Sign, and Σ.Ver. As before, KEM key pairs are denoted by (ek, dk).        Digital\nsignature key pairs are denoted by (vk, sk), where vk is a public verification key and sk is\nthe corresponding private signing key.\nThe protocol proceeds as follows (see Fig. 9.)\n 1.     At the outset, Bob has previously generated    a static    digital signature key pair\n        (vkB, skB) and procured a certificate cert[vkB, Bob] that associates the public veri-\n        fication key with his identity.\n 2.     When connecting to Bob, Alice generates an ephemeral KEM key pair (ekA, dkA) and\n        sends the encapsulation key ekA and her chosen parameter set p to Bob, keeping\n        the decapsulation key dkA private.\n 3.     Bob performs encapsulation using ekA, which results in a KEM ciphertext cB and a\n        shared secret key KB. Bob then uses his private signing key skB to sign the transcript\n        of all communications with Alice, including what he will send in this transmission.\n        This transcript includes ekA, p, vkB, cB, and Bob’s certificate cert[vkB, Bob]. He then\n        sends the certificate, signature, and ciphertext to Alice. Finally, he applies a key-\n        derivation function KDF to KB in order to produce two symmetric keys K′      and K′′,\n        destroys KB, and keeps K′ and K′′ private.                          B            B\n                             B         B\n 4.     Next, Alice performs two checks. First, she checks the validity of Bob’s claimed cer-\n        tificate with the appropriate certification authority. Second, she verifies Bob’s signa-\n        ture on the transcript. If either check fails, Alice aborts. Otherwise, she decapsulates\n\n38"
  },
  {
    "doc_id": "NIST.SP.800-227",
    "source_path": "data/raw_pdfs/NIST.SP.800-227.pdf",
    "page_number": 47,
    "text": "  NIST SP 800-227\n  September 2025    Recommendations for KEMs\n\nAlice (client)  Bob (server)\n1.  static:  (vkB, skB)\ncert[vkB, Bob]\n2. (ekA, dkA) ← Π.KeyGen( p)\n−  ekA, p\n−\n−\n−\n−\n−\n−\n−\n−\n−\n−→\n3.  (KB, cB) ← Π.Encaps( p, ekA)\nσ ← Σ.Sign(skB, transcript)\n(K′ , K′′) ← KDF(KB)\nB  B\ncert[vkB, Bob], σ, cB\n←−\n−\n−\n−\n−\n−\n−\n−\n−\n−\n−\n4. if cert[vkB, Bob] invalid, abort.\nif Σ.Ver(vkB, σ, transcript) = ⊥, abort.\nKA ← Π.Decaps( p, dkA, cB)\n\n(K′ , K′′) ← KDF(KA)\nA  A\n\n5. result: K′ , K′′  result: K′ , K′′\nA  A  B  B\n\nFig. 9. Using a KEM for key establishment with unilateral authentication\n\n          cB and keeps the resulting shared secret key KA private. She also derives two keys\n          K′ and K′′ via KDF applied to KA and destroys KA.\n          A  A\n  5.      Alice and Bob can now use the keys K′ and K′′ for symmetric-key cryptography. For\n          example, they could use K′ for  A     A  ′′\n                                  A       encryption and KA for authentication.\n\n  5.2.4.  Static-Ephemeral Unilateral Authenticated Key Establishment Using KEMs\n  This section presents a static-ephemeral key-establishment scheme with unilateral authen-\n  tication, as described in [32]. The scheme combines a shared secret key generated by a\n  static KEM key pair with a shared secret key produced by a freshly generated, ephemeral\n  KEM key pair. Just as in Example 5.2.2, one party possesses a static KEM key pair that is\n  associated with a certificate.\n  In this example, Alice and Bob’s key pairs are generated using the same KEM Π and param-\n  eter set p. In this case, Π and p are determined by Bob’s certificate. Note that Bob may use\n  the same static key pair to perform key establishment with many different parties. To see\n  how different KEMs might be used within one authenticated key-establishment scheme,\n  see Example 5.2.5.\n\n  39"
  },
  {
    "doc_id": "NIST.SP.800-227",
    "source_path": "data/raw_pdfs/NIST.SP.800-227.pdf",
    "page_number": 48,
    "text": "NIST SP 800-227\nSeptember 2025    Recommendations for KEMs\n\nKEMTLS is a protocol with similar elements to this example, though it includes additional\nfeatures that are not presented here [33]. In particular, KEMTLS utilizes KEM-based au-\nthentication and also combines two shared secret keys: one generated by a static KEM key\npair and one by an ephemeral KEM key pair.\nIn this example, H denotes a KDF, and Bob is authenticated while Alice is not. Note that the\nchoice of KDF for H in [32] is a cryptographic hash function. There is no key-confirmation\nstep in this scheme, but one may easily incorporate such a step if desired.\n\n        Alice (client)                                      Bob (server)\n  1.                                                         static:  (ekB, dkB)\n                                                                      cert[ekB, p, Bob]\n                                           cert[ekB, p, Bob]\n                                         ←−\n                                           −\n                                            −\n                                            −\n                                             −\n                                             −\n                                              −\n                                              −\n                                                     −\n                                                      −\n  2. if cert[ekB, p, Bob] invalid, abort.\n        (ek, dk) ← Π.KeyGen( p)\n        (KB, cB) ← Π.Encaps( p, ekB)\n                                         −  ek, p, cB\n                                         −\n                                           −\n                                           −\n                                            −\n                                            −\n                                             −\n                                             −\n                                              −\n                                                     −\n                                                     −→\n  3.                                                         (K, c) ← Π.Encaps( p, ek)\n                                                             K′ ← Π.Decaps( p, dkB, cB)\n                                                             B\n                                         ←−  c\n                                           −\n                                            −\n                                            −\n                                             −\n                                             −\n                                              −\n                                              −\n                                                     −\n                                                      −\n                                                            −\n  4. K′ ← Π.Decaps( p, dk, c)\n\n  5. result: H(K′, KB)                                       result: H(K, K′ )\n                                                                        B\n\n        Fig. 10. Static-ephemeral unilateral authenticated key establishment using KEMs\n\n 1.  At the outset, Bob has a long-term, static key pair that he generated earlier via\n     (ekB, dkB) ← Π.KeyGen(p). Here, Π is some KEM, and p is some parameter set of\n     Π. Bob also has a certificate cert[ekB, p, Bob] that contains ekB and p and associates\n     them both with Bob’s identity.\n 2.  When Alice wants to connect to Bob, she acquires cert[ekB, p, Bob] (e.g., from Bob),\n     verifies that the certificate is valid, and extracts ekB and p from the certificate. She\n     then performs encapsulation with ekB, saves the resulting shared secret key KB, and\n     sends the ciphertext cB to Bob. Alice additionally generates an ephemeral KEM key\n     pair (ek, dk) using the same KEM Π and parameter set p and sends the encapsulation\n     key ek and relevant parameter set p to Bob, keeping the private decapsulation key\n     dk private.\n\n40"
  },
  {
    "doc_id": "NIST.SP.800-227",
    "source_path": "data/raw_pdfs/NIST.SP.800-227.pdf",
    "page_number": 49,
    "text": "NIST SP 800-227\nSeptember 2025    Recommendations for KEMs\n\n 3.     Bob uses (p, ek) to perform encapsulation, which results in a KEM ciphertext c and\n        shared secret key K. Bob also performs decapsulation using (p, dkB, cB) to produce\n        another shared secret key K′ . Bob sends ciphertext c to Alice.\n                             B\n 4.     Alice uses c, p, and dk to run decapsulation and recover her copy of the ephemeral\n        shared secret key K′.\n 5.     Alice and Bob combine their copies of the shared ephemeral secret key K′ (K) and\n        the shared secret key KB (K′ ) that was computed using Bob’s static key pair. A hash\n        function H is applied to theB\n                             result to establish a final shared secret key.\nIt is assumed that if the certificate is valid, then only Bob is capable of performing decap-\nsulation of ciphertexts that were encapsulated using ekB.\n\n5.2.5.  Authenticated Key Establishment Using KEMs\nThis section presents a bilaterally authenticated key-establishment scheme using KEMs, as\ndescribed in [32]. In this example, both Alice and Bob are authenticated using static KEM\nkey pairs associated with certificates. The KEM shared secret keys produced using their\nstatic key pairs contribute to the final key and a shared secret key produced using a freshly\ngenerated ephemeral KEM key pair. This scheme achieves weak forward secrecy [32, 34].\nAlice’s static key pair may correspond to a different KEM than the one associated with Bob’s\nstatic key pair as the choices of KEM and parameter set used by Alice and Bob are deter-\nmined by their certificates. As such, both parties must be able to operate using each other’s\nKEM encapsulation algorithm. Moreover, the ephemeral KEM key pair may correspond to\na third, completely different KEM. To capture this possibility, let (ΠA, pA), (ΠB, pB), and\n(Π, p) denote the KEM algorithm and parameter set associated with Alice’s static key pair,\nBob’s static key pair, and the ephemeral KEM key pair, respectively.   This notation allows\nfor the possibility that ΠA = ΠB = Π and pA = pB = p. Additionally, parameter sets are\nformatted differently for different KEMs (e.g., lattice-based KEMs might include lattice di-\nmension, while code-based KEMs include code length and dimension).          Therefore, if two\nKEMs Πi and Π j are distinct, the corresponding parameter sets are likely also distinct.\nAs with other examples, Alice and Bob will need to negotiate which KEM Π and parameter\nset p they will use for the ephemeral key pair prior to protocol execution. As in Example\n5.2.3, H denotes a KDF. Note that in [32] H is chosen to be a cryptographic hash function.\nThere is no key-confirmation step included in this example, but one could be added.\n 1.     At  the outset, Alice and    Bob each have a long-term, static   key     pair.  Al-\n        ice has (ekA, dkA), and Bob has (ekB, dkB), which were     generated     earlier  via\n        ΠA.KeyGen(pA) and ΠB.KeyGen(pB), respectively. Alice and Bob also have certifi-\n        cates cert[ekA, pA, Alice] and cert[ekB, pB, Bob], respectively, which contain their cor-\n        responding public keys and associate them to their respective identities.\n\n41"
  },
  {
    "doc_id": "NIST.SP.800-227",
    "source_path": "data/raw_pdfs/NIST.SP.800-227.pdf",
    "page_number": 50,
    "text": "  NIST SP 800-227\n  September 2025    Recommendations for KEMs\n\nAlice (client)  Bob (server)\n1. static:  (ekA, dkA)  static:  (ekB, dkB)\ncert[ekA, pA, Alice]  cert[ekB, pB, Bob]\n\n−cert[ekᴬ, pᴬ, Alice]\n−\n−\n−\n−\n−\n−\n−\n−\n−\n−→\ncert[ekB, pB, Bob]\n←−\n−\n−\n−\n−\n−\n−\n−\n−\n−\n−\n2. if cert[ekB, pB, Bob] invalid, abort.  if cert[ekA, pA, Alice] invalid, abort.\n(ek, dk) ← Π.KeyGen( p)\n(KB, cB) ← ΠB.Encaps( pB, ekB)\n−  ek, cB\n−\n−\n−\n−\n−\n−\n−\n−\n−\n−→\n3.  (K, c) ← Π.Encaps( p, ek)\n(KA, cA) ← ΠA.Encaps( pA, ekA)\nK′ ← ΠB.Decaps( pB, dkB, cB)\nB\n←−   c, cA\n−\n−\n−\n−\n−\n−\n−\n−\n−\n−\n4. K′ ← Π.Decaps( p, dk, c)\nK′ ← ΠA.Decaps( pA, dkA, cA)\nA\n\n5. result: H(K′, K′ , KB)  result: H(K, KA, K′ )\nA  B\n\nFig. 11. Authenticated key establishment using KEMs\n\n  2.  When Alice wants to connect to Bob, she acquires cert[ekB, pB, Bob] (e.g., from Bob),\n      verifies that the certificate is valid, and extracts ekB, pB from the certificate. Bob also\n      acquires and verifies Alice’s certificate in this step.\n      Alice then performs encapsulation with Bob’s static public key ekB, saves the result-\n      ing shared secret key KB, and sends the ciphertext cB to Bob. Alice additionally gen-\n      erates an ephemeral KEM key pair (ek, dk) and sends the encapsulation key ek and\n      relevant parameter set p to Bob, keeping the private decapsulation key dk private.\n  3.  Bob uses (p, ek) to perform encapsulation, which results in a KEM ciphertext c and\n      shared secret key K. Bob extracts ekA and pA from Alice’s certificate and then per-\n      forms encapsulation with ekA and pA to generate KA and cA.\n      Bob also performs decapsulation using (pB, dkB, cB) to produce another shared se-\n      cret key K′ . Bob sends ciphertexts c and cA to Alice.\n      B\n  4.  Alice uses c, p, and dk to run decapsulation and recover her copy of the ephemeral\n      shared secret key K′. Alice additionally uses cA, pA, and dkA to run decapsulation\n      and recover her copy of the long-term shared secret key K′ .\n                                                             A\n\n                            42"
  },
  {
    "doc_id": "NIST.SP.800-227",
    "source_path": "data/raw_pdfs/NIST.SP.800-227.pdf",
    "page_number": 51,
    "text": "NIST SP 800-227\nSeptember 2025    Recommendations for KEMs\n\n5.  Alice and Bob combine their copies of the shared ephemeral secret key K′ (K) and\n    static shared secret keys K′ and KB (KA and K′ .) and apply a KDF H to establish a\n    final shared secret key.  A    B\n\n43"
  },
  {
    "doc_id": "NIST.SP.800-227",
    "source_path": "data/raw_pdfs/NIST.SP.800-227.pdf",
    "page_number": 52,
    "text": "    NIST SP 800-227\n    September 2025    Recommendations for KEMs\n\n    References\n\n [1]  Barker EB, Chen L, Roginsky A, Vassilev A, Davis R (2018) Recommendation for\n      Pair-Wise Key-Establishment Schemes Using Discrete Logarithm Cryptography\n      (Depart-ment of Commerce, Washington, D.C.), NIST Special Publication (SP) NIST\n      SP 800-56Ar3. https://doi.org/10.6028/NIST.SP.800-56Ar3\n [2]  Barker EB, Chen L, Roginsky A, Vassilev A, Davis R, Simon S (2019) Recommendation\n      for Pair-Wise Key-Establishment Using Integer Factorization Cryptography\n      (Depart-ment of Commerce, Washington, D.C.), NIST Special Publication (SP) NIST\n      SP 800-56Br2. https://doi.org/10.6028/NIST.SP.800-56Br2\n [3]  National Institute of Standards and Technology (2024) Module-Lattice-Based Key-\n      Encapsulation Mechanism Standard (Department of Commerce, Washington, D.C.),\n      Federal Information Processing  Standards Publications (FIPS) NIST       FIPS   203.\n      https://doi.org/10.6028/NIST.FIPS.203\n [4]  Moody D, Perlner R, Regenscheid A, Robinson A, Cooper D (2024) Transition to Post-\n      Quantum Cryptography Standards (Department of Commerce, Washington, D.C.),\n      NIST Internal Report (IR) NIST IR 8547ipd. https://doi.org/10.6028/NIST.IR.8547.ipd\n [5]  National Institute of Standards and Technology (2019) Security Requirements for\n      Cryptographic Modules (Department of Commerce, Washington, D.C.), Federal In-\n      formation Processing Standards Publications (FIPS) NIST FIPS 140-3,. https://doi.org/\n      10.6028/NIST.FIPS.140-3\n [6]  Barker EB, Kelsey J (2015) Recommendation for Random Number Generation Using\n      Deterministic Random Bit Generators (Department of Commerce, Washington, D.C.),\n      NIST Special Publication (SP) NIST SP 800-90Ar1. https://doi.org/10.6028/\n      NIST.SP.800-90Ar1\n [7]  Sönmez Turan M, Barker E, Kelsey J, McKay K, Baish M, Boyle M (2018) Recom-\n      mendation for the Entropy Sources Used for Random Bit Generation (Department\n      of Commerce, Washington, D.C.), NIST Special Publication (SP) NIST SP 800-90B.\n      https://doi.org/10.6028/NIST.SP.800-90B\n [8]  Barker EB, Kelsey JM, McKay KA, Roginsky AL, Sönmez Turan M (2025) Recommenda-\n      tion for Random Bit Generator (RBG) Constructions (National Institute of Standards\n      and Technology, Gaithersburg, MD), NIST Special Publication (SP) NIST SP\n      800-90C. https://doi.org/10.6028/NIST.SP.800-90C\n [9]  Dworkin M (2007) Recommendation for Block Cipher Modes of Operation:            Ga-\n      lois/Counter Mode (GCM) and GMAC (National Institute of Standards and Technology,\n      Gaithersburg, MD), NIST Special Publication (SP) NIST SP 800-38D. https://doi.org/\n      10.6028/NIST.SP.800-38D\n[10]  Barker E, Branstad D, Smid M (2015) A Profile for U.S. Federal Cryptographic Key\n      Man-agement Systems (CKMS) (National Institute of Standards and Technology,\n      Gaithers-burg, MD), NIST Special Publication (SP) NIST SP 800-152. https://\n      doi.org/10.6028/NIST.SP.800-152\n\n    44"
  },
  {
    "doc_id": "NIST.SP.800-227",
    "source_path": "data/raw_pdfs/NIST.SP.800-227.pdf",
    "page_number": 53,
    "text": "NIST SP 800-227\nSeptember 2025    Recommendations for KEMs\n\n[11]  Shoup V (2001) A Proposal for an ISO Standard for Public Key Encryption, Cryptology\n      ePrint Archive, Paper 2001/112. Available at https://eprint.iacr.org/2001/112.\n[12]  Cramer R, Shoup V (2003) Design and analysis of practical public-key encryption\n      schemes secure against adaptive chosen ciphertext attack. SIAM Journal on Comput-\n      ing 33(1):167–226. https://doi.org/10.1137/S0097539702403773\n[13]  Herranz J, Hofheinz D, Kiltz E (2006) Some (in)sufficient conditions for secure hybrid\n      encryption, Cryptology ePrint Archive, Paper 2006/265. Available at https://eprint.i\n      acr.org/2006/265.\n[14]  Brainard J, Kaliski B, Turner S, Randall J (2010) Use of the RSA-KEM Key Transport\n      Algorithm in the Cryptographic Message Syntax (CMS), RFC 5990. https://doi.org/\n      10.17487/RFC5990.\n[15]  American National Standards Institute (2011) ANSI X9.63-2011, (R2017) - Public Key\n      Cryptography for the Financial Services Industry: Key Agreement and Key Transport\n      Using Elliptic Curve Cryptography (Accredited Standards Committee X9, Annapolis,\n      MD). Available at https://webstore.ansi.org/standards/ascx9/ansix9442007r2017.\n[16]  American National Standards Institute (2007) ANSI X9.44-2007 (R2017), Public Key\n      Cryptography for the Financial Services Industry: Key Establishment Using Integer\n      Factorization Cryptography (Accredited Standards Committee X9, Annapolis, MD).\n      Available at https://webstore.ansi.org/standards/ascx9/ansix9442007r2017.\n[17]  Katz J, Lindell Y (2020) Introduction to Modern Cryptography (Chapman & Hall/CRC,\n      Boca Raton, FL), 3rd Ed.\n[18]  Barker EB, Roginsky A, Davis R (2020) Recommendation for Cryptographic Key Gen-\n      eration (Department of Commerce, Washington, D.C.), NIST Special Publication (SP)\n      NIST SP 800-133r2. https://doi.org/10.6028/NIST.SP.800-133r2\n[19]  Barker E (2020) Recommendation for Key Management: Part 1 – General (National\n      Institute of Standards and Technology, Gaithersburg, MD), NIST Special Publication\n      (SP) NIST SP 800-57pt1r5. https://doi.org/10.6028/NIST.SP.800-57pt1r5\n[20]  Chen L (2022) Recommendation for Key Derivation Using Pseudorandom Functions\n      (National Institute of Standards and Technology, Gaithersburg, MD), NIST Special\n      Publication (SP) NIST SP 800-108r1-upd1, Includes updates as of February 2, 2024.\n      https://doi.org/10.6028/NIST.SP.800-108r1-upd1\n[21]  Barker EB, Chen L, Davis R (2020) Recommendation for Key-Derivation Methods in\n      Key-Establishment Schemes (Department of Commerce, Washington, D.C.), NIST Spe-\n      cial Publication (SP) NIST SP 800-56Cr2. https://doi.org/10.6028/NIST.SP.800-56Cr2\n[22]  Brockhaus H, von Oheimb D, Ounsworth M, Gray J (2025) Internet X.509 Public Key\n      Infrastructure – Certificate Management Protocol (CMP), RFC 9810. https://doi.org/\n      10.17487/RFC9810.\n[23]  Driscoll F, Parsons M, Hale B (2024) Terminology for Post-Quantum Traditional Hy-\n      brid Schemes (Internet Engineering Task Force), Internet-Draft draft-ietf-pquip-pqt-\n      hybrid-terminology-05. Work in Progress. Available at https://datatracker.ietf.org/d\n      oc/draft-ietf-pquip-pqt-hybrid-terminology/05/.\n\n45"
  },
  {
    "doc_id": "NIST.SP.800-227",
    "source_path": "data/raw_pdfs/NIST.SP.800-227.pdf",
    "page_number": 54,
    "text": "NIST SP 800-227\nSeptember 2025    Recommendations for KEMs\n\n[24]  Barbosa M, Connolly D, Duarte JD, Kaiser A, Schwabe P, Varner K, Westerbaan B (2024)\n     X-Wing. IACR Communications in Cryptology 1(1). https://doi.org/10.62056/a3qj89n\n      4e\n[25]  Giacon F, Heuer F, Poettering B (2018) KEM combiners. Public-Key Cryptography – PKC\n      2018, eds Abdalla M, Dahab R (Springer International Publishing, Cham), pp 190–218.\n[26]  Avanzi R, Bos J, Ducas L, Kiltz E, Lepoint T, Lyubashekvsky V, Schanck JM, Schwabe\n      P, Seiler G, Stehlé D (2021) CRYSTALS-Kyber Algorithm Specifications and Supporting\n      Documentation (version 3.02). Available at https://pq-crystals.org/kyber/data/kyb\n      er-specification-round3-20210804.pdf.\n[27]  Avanzi R, Bos J, Ducas L, Kiltz E, Lepoint T, Lyubashevsky V, Schanck JM, Schwabe P,\n      Seiler G, Stehlé D (2020) CRYSTALS-Kyber Algorithm Specifications and Supporting\n      Documentation, Third-round submission to the NIST’s post-quantum cryptography\n      standardization process. Available at https://csrc.nist.gov/Projects/post-quantum-c\n      ryptography/post-quantum-cryptography-standardization/round-3-submissions.\n[28]  Almeida JB, Olmos SA, Barbosa M, Barthe G, Dupressoir F, Grégoire B, Laporte V,\n      Léchenet JC, Low C, Oliveira T, Pacheco H, Quaresma M, Schwabe P, Strub PY (2024)\n      Formally verifying Kyber Episode V: Machine-checked IND-CCA security and correct-\n      ness of ML-KEM in EasyCrypt, Cryptology ePrint Archive, Paper 2024/843. Available\n      at https://eprint.iacr.org/2024/843.\n[29]  Regev O (2005) On Lattices, Learning with Errors, Random Linear Codes, and Cryp-\n      tography. Proceedings of the Thirty-Seventh Annual ACM Symposium on Theory of\n      Computing STOC ’05 (Association for Computing Machinery, New York, NY, USA), pp\n      84–93. https://doi.org/10.1145/1060590.1060603.\n[30]  Langlois A, Stehlé D (2015) Worst-case to average-case reductions for module\n      lattices. Designs, Codes and Cryptography 75(3):565–599. https://doi.org/10.1007/\n      s10623-09938-4.\n[31]  ElGamal T (1985) A public key cryptosystem and a signature scheme based on discrete\n      logarithms. IEEE transactions on information theory 31(4):469–472. https://doi.org/\n      10.1109/TIT.1985.1057074\n[32]  Bos J, Ducas L, Kiltz E, Lepoint T, Lyubashevsky V, Schanck JM, Schwabe P, Seiler\n      G, Stehle D (2018) CRYSTALS - Kyber: A CCA-Secure Module-Lattice-Based KEM.\n      2018 IEEE European    Symposium on Security and Privacy (EuroSP), pp 353–367.\n      https://doi.org/10.1109/EuroSP.2018.00032\n[33]  Schwabe P, Stebila D, Wiggers T (2020) Post-quantum TLS without handshake signa-\n      tures. Proceedings of the 2020 ACM SIGSAC Conference on Computer and Communi-\n      cations Security, pp 1461–1480. https://doi.org/10.1145/3372297.3423350\n[34]  Canetti R, Krawczyk H (2001) Analysis of key-exchange protocols and their use\n      for building secure channels. Advances in Cryptology — EUROCRYPT 2001\n      (Springer, Berlin, Heidelberg), pp 453–474. https://\n      doi.org/10.1007/3-540-44987-6_28\n[35]  Sönmez Turan M, Brandão LTAN (2024) Keyed-Hash Message Authentication Code\n      (HMAC): Specification of HMAC and Recommendations for Message Authentication\n\n                                          46"
  },
  {
    "doc_id": "NIST.SP.800-227",
    "source_path": "data/raw_pdfs/NIST.SP.800-227.pdf",
    "page_number": 55,
    "text": "NIST SP 800-227\nSeptember 2025    Recommendations for KEMs\n\n      (National Institute of Standards and Technology, Gaithersburg, MD), NIST Special Pub-\n      lication (SP) NIST SP 800-224 ipd. https://doi.org/10.6028/NIST.SP.800-224.ipd\n[36]  Dworkin M (2010) Recommendation for Block Cipher Modes of Operation:     Three\n      Variants of Ciphertext Stealing for CBC Mode (National Institute of Standards and\n      Technology, Gaithersburg, MD), NIST Special Publication (SP) NIST SP 800-38B.\n      https://doi.org/10.6028/NIST.SP.800-38B\n[37]  Kelsey J, Chang SJ, Perlner R (2016) SHA-3 Derived Functions: cSHAKE, KMAC, Tuple-\n      Hash and ParallelHash (Department of Commerce, Washington, D.C.), NIST Special\n      Publication (SP) NIST SP 800-185. https://doi.org/10.6028/NIST.SP.800-185\n\n47"
  },
  {
    "doc_id": "NIST.SP.800-227",
    "source_path": "data/raw_pdfs/NIST.SP.800-227.pdf",
    "page_number": 56,
    "text": "NIST SP 800-227\nSeptember 2025    Recommendations for KEMs\n\nAppendix A. List of Acronyms\n\nCAVP Cryptographic Algorithm Verification Program\nCMVP Cryptographic Module Verification Program\nDRBG Deterministic Random Bit Generator\nFIPS Federal Information Processing Standards\nIND-CCA Indistinguishability under Chosen Ciphertext Attack\nIND-CPA Indistinguishability under Chosen Plaintext Attack\nITL Information Technology Laboratory\nKC  Key Confirmation\nKDF Key-Derivation Function\nKDM Key-Derivation Method\nKEM Key-Encapsulation Mechanism\nMAC Message Authentication Code\nML-KEM Module-Lattice-Based Key-Encapsulation Mechanism\nNIST National Institute of Standards and Technology\nPKE Public-Key Encryption\nPoP Proof of Possession\nRBG Random Bit Generator\nSP Special Publication\nTLS Transport Layer Security\nTTP  Trusted Third Party\n\n48"
  },
  {
    "doc_id": "NIST.SP.800-227",
    "source_path": "data/raw_pdfs/NIST.SP.800-227.pdf",
    "page_number": 57,
    "text": "NIST SP 800-227\nSeptember 2025    Recommendations for KEMs\n\nAppendix B. Glossary\n\nThis section is informative.\napproved   FIPS-approved and/or NIST-recommended.     An algorithm or technique that is\n        either 1) specified in a FIPS or NIST recommendation, 2) adopted in a FIPS or NIST\n        recommendation, or 3) specified in a list of NIST-approved security functions.\nciphertext      With regard to KEMs, a bit string that is produced by the encapsulation algo-\n        rithm and used as an input to the decapsulation algorithm.\ncomputationally bounded adversary   An adversarial algorithm that is constrained in run-\n        ning time and memory, and is thus unlikely to break a cryptosystem under con-\n        sideration.       The nature of the constraints depends on the context, including the\n        desired security strength of the cryptosystem.\ncryptanalytically relevant quantum computer           A device capable of using quantum algo-\n        rithms to break a cryptosystem that is secure against classical (i.e., non-quantum)\n        computers.\ndecapsulation       The process of applying the Decaps algorithm of a KEM. This algorithm ac-\n        cepts a KEM ciphertext and the decapsulation key as input and produces a shared\n        secret key as output.\ndecapsulation key             A cryptographic key produced by a KEM during key generation and\n        used during decapsulation.\ndestroy     An action applied to a key or other piece of secret data. After a key or piece of\n        secret data is destroyed, no information about its value can be recovered.\nefficient (cryptographic) algorithm      An algorithm whose running time is practical for the\n        relevant security strength.\nencapsulation The process of applying the Encaps algorithm of a KEM. This algorithm ac-\n        cepts the encapsulation key as input, requires private randomness, and produces\n        a shared secret key and an associated ciphertext as output.\nencapsulation key             A cryptographic key produced by a KEM during key generation and\n        used by the encapsulation algorithm.\nephemeral key A cryptographic key that is   generated for each execution of a crypto-\n        graphic process (e.g., key establishment) and meets other requirements of the\n        key type (e.g., unique to each message or session).\nhash function A function on arbitrarily long bit strings in which the length of the output is\n        fixed. At a minimum, the hash function must be one-way and collision-resistant.\n\n49"
  },
  {
    "doc_id": "NIST.SP.800-227",
    "source_path": "data/raw_pdfs/NIST.SP.800-227.pdf",
    "page_number": 58,
    "text": "NIST SP 800-227\nSeptember 2025    Recommendations for KEMs\n\nidentifier A bit string that is associated with a person, device, or organization. It may be\n an identifying name or something more abstract (e.g., a string consisting of an IP\n address).\nkey agreement   A (pair-wise) key-establishment procedure in which the resultant secret\n keying material is a function of information contributed by both participants so\n that neither party can predetermine the value of the secret keying material inde-\n pendent of the contributions of the other party. Contrast with key transport.\nkey combiner  A function that takes multiple keys or shared secret values as input (possibly\n along with other information) and produces a single combined key.\nkey confirmation    A procedure that provides assurance to one party (i.e., key-confirmation\n recipient) that another party (i.e., key-confirmation provider) possesses the cor-\n rect secret keying material and/or shared secret from which that secret keying\n material is derived.\nkey-confirmation provider    The party that provides assurance to the other party (i.e., the\n recipient) that the two parties have indeed established a shared secret key or other\n keying material.\nkey-confirmation recipient     The party that receives assurance from the other party (i.e.,\n the provider) that the two parties have indeed established a shared secret key or\n other keying material.\nkey-derivation method        A method used to derive keying material from initial shared se-\n crets and possibly other information.\nkey-derivation key    A key used as an input to a key-derivation method to derive additional\n keying material.\nkey-encapsulation mechanism (KEM) A set of three cryptographic algorithms:            KeyGen\n (key generation), Encaps (encapsulation), and Decaps (decapsulation). These al-\n gorithms can be used by two parties to securely establish a shared secret key over\n a public channel.\nkey establishment  A procedure that results in secret keying material that is shared among\n different parties.           Key agreement, using a KEM, and key transport are all types of\n key establishment.\nkeying material       A bit string such that any non-overlapping, contiguous segments of the\n string with required lengths can be used as secret keys, secret initialization vectors,\n and other secret parameters.\nkey pair      A set of two keys with the property that one key can be made public, while the\n other key must be kept private.         In this publication, this could refer to either the\n (encapsulation key, decapsulation key) key pair of a KEM or the (encryption key,\n decryption key) key pair of a public-key encryption (PKE) scheme .\n\n                                  50"
  },
  {
    "doc_id": "NIST.SP.800-227",
    "source_path": "data/raw_pdfs/NIST.SP.800-227.pdf",
    "page_number": 59,
    "text": "NIST SP 800-227\nSeptember 2025    Recommendations for KEMs\n\nkey transport  A (pair-wise) key-establishment procedure whereby one party (i.e.,  the\n      sender) selects a value for the secret keying material and then securely distributes\n      the value to another party (i.e., the receiver). Contrast with key agreement.\nmessage authentication code (MAC) A family of symmetric-key cryptographic algorithms\n      that act on input data of arbitrary length to produce an output value of a specified\n      length (i.e., the MAC of the input data). The MAC can be employed to authenticate\n      the origin of the input data and/or provide data integrity protection.\nmessage authentication code (MAC) tag Data obtained from the output of a MAC algo-\n      rithm (possibly by truncation) that can be used by an entity to securely verify the\n      integrity and origin of the information used as input to the MAC algorithm.\nmust Indicates a requirement of this recommendation that might not be testable by a\n      CMVP testing lab.\nnegligible Extremely small.  Typically quantifies the probability of an undesirable event\n      that might occur during the lifetime of a cryptosystem (including during attacks by\n      computationally bounded adversaries).\nparty An individual (person), organization, device, or process. In this recommendation,\n      there are typically two parties (e.g., Party A and Party B, Alice and Bob) that jointly\n      perform the key-establishment process using a KEM.\npost-quantum algorithm A cryptographic algorithm that is believed to be secure, even\n      against adversaries who possess a cryptanalytically relevant quantum computer.\npseudorandom   A process (or data produced by a process) whose outcome is determinis-\n      tic yet also appears effectively random if the internal action of the process is hid-\n      den from observation.  For cryptographic purposes, “effectively random” means\n      “computationally indistinguishable from random within the limits of the intended\n      security strength.”\npublic channel A communication channel between two honest parties that can be ob-\n      served and compromised by third parties.\nquantum-vulnerable algorithm A cryptographic algorithm that is believed to be secure\n      against adversaries who possess only a classical computer but is known to be in-\n      secure against adversaries who possess a cryptanalytically relevant quantum com-\n      puter.\nsecurity strength A number associated with the amount of work that is required to break\n      a cryptographic algorithm or system.\nseed  A bit string used as input to a pseudorandom process.\nshall Used to indicate a requirement of this document that will be tested by a CMVP test-\n      ing lab.\n\n                                      51"
  },
  {
    "doc_id": "NIST.SP.800-227",
    "source_path": "data/raw_pdfs/NIST.SP.800-227.pdf",
    "page_number": 60,
    "text": "NIST SP 800-227\nSeptember 2025    Recommendations for KEMs\n\nshared secret A secret value that has been computed during a key-establishment scheme,\n        is known by all participating parties, and is         used as input to a key-derivation\n        method to produce keying material.\nshared secret key     A shared secret that can be used directly as keying material or as a sym-\n        metric key.\nshould  Used to indicate a strong recommendation but not a requirement of this docu-\n        ment. Ignoring the recommendation could lead to undesirable results.\nside-channel attack             An attack enabled by the leakage of information from a deployed\n        cryptosystem. Characteristics that could be exploited in a side-channel attack in-\n        clude timing, power consumption, and electromagnetic and acoustic emissions.\nstatic key A key that is intended for use for a relatively long period of time and is typically\n        intended for use in many instances of a cryptographic key-establishment scheme.\n        Contrast with ephemeral key.\nsymmetric-key algorithm          A cryptographic algorithm that uses the same secret key for an\n        operation and its complement (e.g., encryption and decryption). Also called a\n        secret-key algorithm.\ntrusted third party An entity other than the owner and verifier that is trusted by the\n        owner, the verifier, or both to provide certain services.\n\n52"
  },
  {
    "doc_id": "NIST.SP.800-227",
    "source_path": "data/raw_pdfs/NIST.SP.800-227.pdf",
    "page_number": 61,
    "text": "NIST SP 800-227\nSeptember 2025    Recommendations for KEMs\n\nAppendix C. Cryptographic Components\n\nAppendix C.1. Message Authentication Codes (MACs)\nA MAC algorithm defines a family of cryptographic functions that is parameterized by a\nsymmetric key. It is computationally infeasible to determine the MAC of a newly formed\nMAC_Data output value without knowledge of the KC_Key value, even if one has seen\nthe MACs corresponding to other MAC_Data values that were computed using that same\nKC_Key value.\nThe input to a MAC algorithm includes a symmetric key KC_Key and a binary data string\nMAC_Data that serves as the “message.”  That is, a MAC computation is represented as\nMAC(KC_Key, MAC_Data). In this recommendation, a MAC algorithm is used if key con-\nfirmation is performed during key establishment (see Sec. 4.4).\nWhen key confirmation requires the use of a MAC algorithm, it shall be an approved MAC\nalgorithm (i.e., HMAC, AES-CMAC, or KMAC). HMAC is specified in SP 800-224 [35] and\nrequires the use of an approved hash function. AES-CMAC is specified in SP 800-38B [36]\nfor the AES block cipher algorithm specified in FIPS 197. KMAC is specified in SP 800-185\n[37]. In addition, AES-GMAC (specified in [9]) is an approved MAC algorithm and may be\nused.\nWhen a MAC tag (MacTag) is used for key confirmation, an entity shall compute the MAC\ntag on received or derived data using a MAC algorithm with a KC_Key that is determined\nfrom a shared secret key. The MAC tag is sent to the other entity participating in the key-\nestablishment scheme in order to provide assurance that the shared secret key or derived\nkeying material was correctly computed. MacTag computation and verification are de-\nscribed below.\n\nMAC Tag Computation for Key Confirmation. Key confirmation can be performed as one\nor more additional steps in a KEM scheme. The computation of a MAC tag is represented\nas follows:\n              MacTag = TMacTagBits[MAC(KC_Key, MAC_Data)].\nTo compute a MacTag:\n1.   The agreed-upon MAC algorithm (see Table 1) is used with KC_Key to compute the\n     MAC on MAC_Data, where KC_Key is a symmetric key, and MAC_Data represents\n     the input “message” data. The minimum length of KC_Key is specified in Table 1.\n     KC_Key is obtained from the the shared secret key, as specified in Sec. 4.4.2.\n     The output of the MAC algorithm MacOut put is a bit string whose length in bits is\n     MacOut putBits.\n\n53"
  },
  {
    "doc_id": "NIST.SP.800-227",
    "source_path": "data/raw_pdfs/NIST.SP.800-227.pdf",
    "page_number": 62,
    "text": "NIST SP 800-227\nSeptember 2025    Recommendations for KEMs\n\n                  Table 1. Approved MAC algorithms for key confirmation\n\n MAC Algorithm  MacOutputBits             Permissible KC_Key                        Supported Security\n                                          Lengths (μ bits)                          Strengths for Key\n                                                                                    Confirmation (s bits)\n HMAC_SHA-256        256\n HMAC_SHA-512/256    256\n HMAC_SHA-384        384\n HMAC_SHA-512        512                                                            128 ≤ s ≤ 256\n HMAC_SHA3-256       256                          s ≤ μ ≤ 512\n HMAC_SHA3-384       384\n HMAC_SHA3-512       512\n KMAC128         ≤ 22040 − 1                                                           s = 128\n KMAC256                                                                            128 ≤ s ≤ 256\n AES-128-CMAC        128                          μ = 128                              s = 128\n AES-192-CMAC        128                          μ = 192                           128 ≤ s ≤ 192\n AES-256-CMAC        128                          μ = 256                           128 ≤ s ≤ 256\n AES-128-GMAC        128                          μ = 128                              s = 128\n AES-192-GMAC        128                          μ = 192                           128 ≤ s ≤ 192\n AES-256-GMAC        128                          μ = 256                           128 ≤ s ≤ 256\n\n 2.  The MacOut put  bits                         are input to the truncation function TMacTagBits, which re-\n     turns  the  leftmost (i.e., initial) bits of                     MacOut put to be used as the value of\n     MacTag. MacTagBits needs to be less than or equal to MacOut putBits long. When\n     MacTagBits equals MacOut putBits, TMacTagBits acts as the identity function.                       The\n     minimum value for MacTagBits is 64.\n\nMacTag Verification for Key Confirmation. To verify a received MacTag (i.e., received dur-\ning key confirmation), a new Mac tag MacTag′ is computed using the values of KC_Key,\nMacTagBits, and MAC_Data generated by the recipient (as specified                   in         Sec. 4.4.1).\nMacTag′ is compared with the received MacTag.     If their values are equal, then it may\nbe inferred that the same KC_Key, MacTagBits, and MAC_Data values were used in the\ntwo MacTag computations.\n\nAppendix C.2. Nonces\nA nonce is a time-varying value with a negligible chance of repeating. A decapsulator may\nbe required to provide a public nonce that is used for key-confirmation purposes.                  This\ncircumstance arises when the decapsulator’s public key is static.\nA nonce may be composed of one or more of the following components, though other\ncomponents may also be appropriate:\n\n54"
  },
  {
    "doc_id": "NIST.SP.800-227",
    "source_path": "data/raw_pdfs/NIST.SP.800-227.pdf",
    "page_number": 63,
    "text": "NIST SP 800-227\nSeptember 2025    Recommendations for KEMs\n\n 1.  A random bit string that is generated anew for each nonce using an approved ran-\n     dom bit generator. A nonce containing a component of this type is called a random\n     nonce.\n 2.  A timestamp of sufficient resolution so that it is different each time it is used.\n 3.  A monotonically increasing sequence number.\n 4.  A combination of a timestamp and a monotonically increasing sequence num-\n     ber such that the sequence number is reset when and only when the timestamp\n     changes. For example, a timestamp may show the date but not the time of day, so\n     a sequence number is appended that will not repeat during a particular day.\nWhen a nonce is required for key-confirmation purposes as specified in this recommen-\ndation, it should be a random nonce that contains a random bit string output from an\napproved random bit generator, where both the security strength supported by the in-\nstantiation of the random bit generator and the bit length of the random bit string are\ngreater than or equal to the targeted security strength of the key-establishment scheme\nin which the nonce is used during key confirmation. When feasible, the bit length of the\nrandom bit string should be at least twice the targeted security strength. For details con-\ncerning the security strength supported by an instantiation of a random bit generator, see\nthe SP 800-90 series of publications [6–8].\nAs part of the proper implementation of this recommendation, system users and/or agents\ntrusted to act on their behalf should determine whether the components selected for in-\nclusion in any required nonces meet their security requirements.\n\n55"
  },
  {
    "doc_id": "NIST.SP.800-227",
    "source_path": "data/raw_pdfs/NIST.SP.800-227.pdf",
    "page_number": 64,
    "text": "NIST SP 800-227\nSeptember 2025    Recommendations for KEMs\n\nAppendix D. Changes From Draft SP 800-227\n\n1.  Section numbers have shifted due to reorganization.\n2.  Section 4.5 was added to address discussions from the NIST KEM workshop and writ-\n    ten public comments about how the unique functionality of RSA allows for special\n    procedures to achieve proof of possession that does not generally apply to KEMs.\n3.  To align with existing requirements in SP800-56A and SP800-56B, additional require-\n    ments were added to Sec. 4.1 and 4.2 for ephemeral and static KEM key-pairs,\n    namely:\n       • Additional shall statement in Sec. 4.2: Ephemeral key pairs shall be used in only\n        one execution of key-establishment via a KEM and shall be destroyed as soon\n        as possible after use.\n       • Additional must statement in Sec. 4.2:  If an encapsulating party obtains\n        the static encapsulation key of another party, it must have assurance of the\n        other party’s ownership of the key before or during the execution of key-\n        establishment.  This assurance can be obtained from a trusted party (e.g., a\n        certificate authority) or a combination of proof of possession and verification\n        of real-world identity.\n4.  In Sec. 4.6.2, the concatenation of inputs to hash functions was modified to be\n    comma separated. Public comments noted that concatenation may not be appro-\n    priate, depending on the protocol or context.\n5.  Two examples were added to Sec. 5 (Sec. 5.2.4 and 5.2.5) to illustrate how to use\n    KEMs to achieve authenticated key establishment. Additionally, existing examples\n    were updated.\n6.  Section 4.3 was updated with guidelines on how to create keys that are smaller than\n    the output KEM key. Public comments noted this as particularly relevant for ML-\n    KEM, which outputs 256-bit keys at all security levels.\n7.  A public comment noted that a “shall” requirement in Sec. 4.4 was overly restrictive\n    in permitting KEM parameters of one security level to be used alongside lower secu-\n    rity level protocols (e.g., running ML-KEM 768 at 128 bits of security). This has been\n    updated accordingly.\n\n56"
  }
]