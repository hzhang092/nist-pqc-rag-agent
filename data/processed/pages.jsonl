{"doc_id": "NIST.FIPS.203", "source_path": "data/raw_pdfs/NIST.FIPS.203.pdf", "page_number": 1, "text": "  FIPS 203\n\n  Federal Information Processing Standards Publication\n\n  Module-Lattice-Based\n  Key-Encapsulation Mechanism Standard\n\n  Category: Computer Security                         Subcategory: Cryptography\n\n  Information Technology Laboratory\n  National Institute of Standards and Technology\n  Gaithersburg, MD 20899-8900\n\n  This publication is available free of charge from:\n  https://doi.org/10.6028/NIST.FIPS.203\n\n  Published August 13, 2024\n\n  U.S. Department of Commerce\n  Gina M. Raimondo, Secretary\n\n 0 National Institute of Standards and Technology\n  Laurie E. Locascio, NIST Director and Under Secretary of Commerce for Standards and Technology\n\nCheck\n   for\nupdates"}
{"doc_id": "NIST.FIPS.203", "source_path": "data/raw_pdfs/NIST.FIPS.203.pdf", "page_number": 2, "text": "        Foreword\n\nThe Federal Information Processing Standards (FIPS) Publication Series of the National Institute of Stan-\ndards and Technology is the official series of publications relating to standards and guidelines developed\nunder 15 U.S.C. 278g-3, and issued by the Secretary of Commerce under 40 U.S.C. 11331.\nComments concerning this Federal Information Processing Standard publication are welcomed and should\nbe submitted using the contact information in the â€œInquiries and Commentsâ€ clause of the announcement\nsection.\n\n                Kevin M. Stine, Director\n                Information Technology Laboratory"}
{"doc_id": "NIST.FIPS.203", "source_path": "data/raw_pdfs/NIST.FIPS.203.pdf", "page_number": 3, "text": "FIPS 203     MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\n\n             Abstract\nA key-encapsulation mechanism (KEM) is a set of algorithms that, under certain conditions, can be\nused by two parties to establish a shared secret key over a public channel. A shared secret key that\nis securely established using a KEM can then be used with symmetric-key cryptographic algorithms\nto perform basic tasks in secure communications, such as encryption and authentication. This\nstandard specifies a key-encapsulation mechanism called ML-KEM. The security of ML-KEM is\nrelated to the computational difficulty of the Module Learning with Errors problem. At present,\nML-KEM is believed to be secure, even against adversaries who possess a quantum computer.\nThis standard specifies three parameter sets for ML-KEM. In order of increasing security strength\nand decreasing performance, these are ML-KEM-512, ML-KEM-768, and ML-KEM-1024.\n\nKeywords: computer security; cryptography; encryption; Federal Information Processing Stan-\ndards; key-encapsulation mechanism; lattice-based cryptography; post-quantum; public-key\ncryptography."}
{"doc_id": "NIST.FIPS.203", "source_path": "data/raw_pdfs/NIST.FIPS.203.pdf", "page_number": 4, "text": "FIPS 203                            MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\n\n    Federal Information Processing Standards Publication 203\n\n    Published:                      August 13, 2024\n    Effective:                      August 13, 2024\n\n                Announcing the\n    Module-Lattice-Based Key-Encapsulation\n              Mechanism Standard\n\nFederal Information Processing Standards (FIPS) publications are developed by the National\nInstitute of Standards and Technology (NIST) under 15 U.S.C. 278g-3 and issued by the Secretary\nof Commerce under 40 U.S.C. 11331.\n1.  Name of Standard. Module-Lattice-Based Key-Encapsulation Mechanism Standard (FIPS\n    203).\n2.  Category of Standard. Computer Security. Subcategory. Cryptography.\n3.  Explanation. A cryptographic key (or simply â€œkeyâ€) is represented in a computer as a string of\n    bits. A shared secret key is a cryptographic key that is computed jointly by two parties (e.g.,\n    Alice and Bob) using a set of algorithms. Under certain conditions, these algorithms ensure\n    that both parties will produce the same key and that this key is secret from adversaries. Such\n    a shared secret key can then be used with symmetric-key cryptographic algorithms (specified\n    in other NIST standards) to perform tasks such as encryption and authentication of digital\n    information.\n    This standard specifies a set of algorithms for establishing a shared secret key. While there\n    are many methods for establishing a shared secret key, the particular method described in\n    this standard is a key-encapsulation mechanism (KEM).\n    In a KEM, the computation of the shared secret key begins with Alice generating a decapsu-\n    lation key and an encapsulation key. Alice keeps the decapsulation key private and makes\n    the encapsulation key available to Bob. Bob then uses Aliceâ€™s encapsulation key to generate\n    one copy of a shared secret key along with an associated ciphertext. Bob then sends the\n    ciphertext to Alice. Finally, Alice uses the ciphertext from Bob along with Aliceâ€™s private\n    decapsulation key to compute another copy of the shared secret key.\n    The security of the particular KEM specified in this standard is related to the computational\n    difficulty of solving certain systems of noisy linear equations, specifically the Module Learn-\n    ing With Errors (MLWE) problem. At present, it is believed that this particular method of\n    establishing a shared secret key is secure, even against adversaries who possess a quantum\n    computer. In the future, additional KEMs may be specified and approved in FIPS publications\n    or in NIST Special Publications.\n4.  Approving Authority. Secretary of Commerce.\n5.  Maintenance Agency. Department of Commerce, National Institute of Standards and Tech-\n    nology, Information Technology Laboratory (ITL).\n\n                                    i"}
{"doc_id": "NIST.FIPS.203", "source_path": "data/raw_pdfs/NIST.FIPS.203.pdf", "page_number": 5, "text": "FIPS 203                               MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\n\n6.  Applicability. Federal Information Processing Standards apply to information systems used or\n    operated by federal agencies or by a contractor of an agency or other organization on behalf\n    of an agency. They do not apply to national security systems as defined in 44 U.S.C. 3552.\n    This standard, or other FIPS or NIST Special Publications that specify alternative mechanisms,\n    shall be used wherever the establishment of a shared secret key (or shared secret from which\n    keying material can be generated) is required for federal applications, including the use of\n    such a key with symmetric-key cryptographic algorithms, in accordance with applicable Office\n    of Management and Budget and agency policies.\n    The adoption and use of this standard are available to private and commercial organizations.\n7.  Implementations. A key-encapsulation mechanism may be implemented in software, firmware,\n    hardware, or any combination thereof. For every computational procedure that is specified\n    in this standard, a conforming implementation may replace the given set of steps with any\n    mathematically equivalent set of steps. In other words, different procedures that produce\n    the correct output for every input are permitted.\n    NIST will develop a validation program to test implementations for conformance to the\n    algorithms in this standard.  Information about validation programs is available at https:\n //csrc.nist.gov/projects/cmvp. Example values will be available at https://csrc.nist.gov/proj\n    ects/cryptographic-standards-and-guidelines/example-values.\n8.  Other Approved Security Functions. Implementations that comply with this standard\n    shall employ cryptographic algorithms that have been approved for protecting Federal\n    Government-sensitive information.         Approved cryptographic algorithms and techniques\n    include those that are either:\n    (a)  Specified in a Federal Information Processing Standards (FIPS) publication,\n    (b)  Adopted in a FIPS or NIST recommendation, or\n    (c)  Specified in the list of approved security functions in SP 800-140C.\n9.  Export Control. Certain cryptographic devices and technical data regarding them are subject\n    to federal export controls. Exports of cryptographic modules that implement this standard\n    and technical data regarding them must comply with all federal laws and regulations and\n    be licensed by the Bureau of Industry and Security of the U.S. Department of Commerce.\n    Information about export regulations is available at https://www.bis.doc.gov.\n10. Patents. NIST has entered into two patent license agreements to facilitate the adoption of\n    NISTâ€™s announced selection of the PQC key-encapsulation mechanism CRYSTALS-KYBER. NIST\n    and the licensing parties share a desire, in the public interest, the licensed patents be freely\n    available to be practiced by any implementer of the ML-KEM algorithm as published by NIST.\n    ML-KEM is the name given to the algorithm in this standard derived from CRYSTALS-KYBER.\n    For a summary and extracts from the license, please see https://csrc.nist.gov/csrc/media/P\n    rojects/post-quantum-cryptography/documents/selected-algos-2022/nist-pqc-license-sum\n    mary-and-excerpts.pdf. Implementation of the algorithm specified in the standard may be\n    covered by U.S. and foreign patents of which NIST is not aware.\n\nii"}
{"doc_id": "NIST.FIPS.203", "source_path": "data/raw_pdfs/NIST.FIPS.203.pdf", "page_number": 6, "text": "FIPS 203                                  MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\n\n11. Implementation Schedule. This standard becomes effective immediately upon final publica-\n tion.\n12. Specifications. Federal Information Processing Standards (FIPS) 203, Module-Lattice-Based\n Key-Encapsulation Mechanism Standard (affixed).\n13. Qualifications. In applications, the security guarantees of a KEM only hold under certain\n conditions (see SP 800-227 [1]). One such condition is the secrecy of several values, including\n the randomness used by the two parties, the decapsulation key, and the shared secret key\n itself. Users shall, therefore, guard against the disclosure of these values.\nWhile it is the intent of this standard to specify general requirements for implementing\n ML-KEM algorithms, conformance to this standard does not ensure that a particular imple-\n mentation is secure. It is the responsibility of the implementer to ensure that any module\n that implements a key establishment capability is designed and built in a secure manner.\n Similarly, the use of a product containing an implementation that conforms to this standard\n does not guarantee the security of the overall system in which the product is used. The re-\n sponsible authority in each agency or department shall ensure that an overall implementation\n provides an acceptable level of security.\n NIST will continue to follow developments in the analysis of the ML-KEM algorithm. As with\n its other cryptographic algorithm standards, NIST will formally reevaluate this standard every\n five years.\n Both this standard and possible threats that reduce the security provided through the use of\n this standard will undergo review by NIST as appropriate, taking into account newly available\n analysis and technology. In addition, the awareness of any breakthrough in technology or\n any mathematical weakness of the algorithm will cause NIST to reevaluate this standard and\n provide necessary revisions.\n14. Waiver Procedure. The Federal Information Security Management Act (FISMA) does not allow\n for waivers to Federal Information Processing Standards (FIPS) that are made mandatory by\n the Secretary of Commerce.\n15. Where to Obtain Copies of the Standard. This publication is available by accessing https:\n//csrc.nist.gov/publications. Other computer security publications are available at the same\nwebsite.\n16. How to Cite This Publication. NIST has assigned NIST FIPS 203 as the publication identifier\n for this FIPS, per the NIST Technical Series Publication Identifier Syntax. NIST recommends\n that it be cited as follows:\n            National Institute of Standards and Technology (2024) Module-Lattice-Based Key-\n            Encapsulation Mechanism Standard. (Department of Commerce, Washington,\n            D.C.), Federal Information Processing Standards Publication (FIPS) NIST FIPS 203.\n            https://doi.org/10.6028/NIST.FIPS.203\n17. Inquiries and Comments. Inquiries and comments about this FIPS may be submitted to\n fips-203-comments@nist.gov.\n\niii"}
{"doc_id": "NIST.FIPS.203", "source_path": "data/raw_pdfs/NIST.FIPS.203.pdf", "page_number": 7, "text": "    FIPS 203    MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\n\nFederal Information Processing Standards Publication 203\n\n                 Specification for the\n         Module-Lattice-Based Key-Encapsulation\n                   Mechanism Standard\n\n                                          Table of Contents\n\n    1  Introduction                                                              1\n       1.1     Purpose and Scope                                                 1\n       1.2     Context                                                           1\n\n    2  Terms, Acronyms, and Notation                                             2\n       2.1     Terms and Definitions                                             2\n       2.2     Acronyms                                                          4\n       2.3     Mathematical Symbols                                              5\n       2.4     Interpreting the Pseudocode                                       6\n               2.4.1      Data Types                                             7\n               2.4.2      Loop Syntax                                            7\n               2.4.3      Arithmetic With Arrays of Integers                     7\n               2.4.4      Representations of Algebraic Objects                   8\n               2.4.5      Arithmetic With Polynomials and NTT Representations    9\n               2.4.6      Matrices and Vectors                                   9\n               2.4.7      Arithmetic With Matrices and Vectors                  10\n               2.4.8      Applying Algorithms to Arrays, Examples               11\n\n    3  Overview of the ML-KEM Scheme                                            12\n       3.1     Key-Encapsulation Mechanisms                                     12\n       3.2     The ML-KEM Scheme                                                13\n       3.3     Requirements for ML-KEM Implementations                          15\n\n    4  Auxiliary Algorithms                                                     18\n       4.1     Cryptographic Functions                                          18\n       4.2     General Algorithms                                               20\n               4.2.1      Conversion and Compression Algorithms                 20\n               4.2.2      Sampling Algorithms                                   22\n       4.3     The Number-Theoretic Transform                                    24\n\n                                                  iv"}
{"doc_id": "NIST.FIPS.203", "source_path": "data/raw_pdfs/NIST.FIPS.203.pdf", "page_number": 8, "text": "FIPS 203                               MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\n\n            4.3.1  Multiplication in the NTT Domain                                 27\n\n5  The K-PKE Component Scheme                                                       28\n   5.1      K-PKE Key Generation                                                    28\n   5.2      K-PKE Encryption                                                        29\n   5.3      K-PKE Decryption                                                        31\n\n6  Main Internal Algorithms                                                         32\n   6.1      Internal Key Generation                                                 32\n   6.2      Internal Encapsulation                                                  32\n   6.3      Internal Decapsulation                                                  33\n\n7  The ML-KEM Key-Encapsulation Mechanism                                           35\n   7.1      ML-KEM Key Generation                                                   35\n   7.2      ML-KEM Encapsulation                                                    36\n   7.3      ML-KEM Decapsulation                                                    37\n\n8  Parameter Sets                                                                   39\n\nReferences                                                                          41\n\nAppendix A â€” Precomputed Values for the NTT                                         44\n\nAppendix B â€” SampleNTT Loop Bounds                                                  46\n\nAppendix C â€” Differences From the CRYSTALS-KYBER Submission                         47\n   C.1      Differences Between CRYSTALS-KYBER and FIPS 203 Initial Public Draft    47\n   C.2      Changes From FIPS 203 Initial Public Draft                              47\n\nv"}
{"doc_id": "NIST.FIPS.203", "source_path": "data/raw_pdfs/NIST.FIPS.203.pdf", "page_number": 9, "text": "FIPS 203                                              MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\n\n                                    List of Tables\n\nTable 1     Decapsulation failure rates for ML-KEM                                                  15\nTable 2     Approved parameter sets for ML-KEM                                                      39\nTable 3     Sizes (in bytes) of keys and ciphertexts of ML-KEM                                      39\nTable 4     While-loop limits and probabilities of occurrence for SampleNTT                         46\n\n                                    List of Figures\n\nFigure 1        A simple view of key establishment using a KEM                                      12\n\n                                    List of Algorithms\nAlgorithm 1      ForExample()          . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     8\nAlgorithm 2      SHAKE128example(strâ‚, â€¦ , strğ‘š , ğ‘â‚, â€¦ , ğ‘â„“)       . . . . . . . . . . . . .    19\nAlgorithm 3      BitsToBytes(ğ‘)         . . . . . . . . . . . . . . . . . . . . . . . . . . . .    20\nAlgorithm 4      BytesToBits(ğµ)         . . . . . . . . . . . . . . . . . . . . . . . . . . . .    20\nAlgorithm 5      ByteEncodeğ‘‘(ğ¹ ) . . . . . . . . . . . . . . . . . . . . . . . . . . . .          22\nAlgorithm 6      ByteDecodeğ‘‘(ğµ) . . . . . . . . . . . . . . . . . . . . . . . . . . . .           22\nAlgorithm 7      SampleNTT(ğµ)           . . . . . . . . . . . . . . . . . . . . . . . . . . . .    23\nAlgorithm 8      SamplePolyCBDğœ‚(ğµ)           . . . . . . . . . . . . . . . . . . . . . . . . .    23\nAlgorithm 9      NTT(ğ‘“)         . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .    26\nAlgorithm 10     NTTâˆ’1(ğ‘“)         . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .    26\nAlgorithm 11     MultiplyNTTs(ğ‘“, ğ‘”)Ì‚       . . . . . . . . . . . . . . . . . . . . . . . . . .    27\nAlgorithm 12     BaseCaseMultiply(ğ‘â‚€, ğ‘â‚, ğ‘â‚€, ğ‘â‚, ğ›¾)    . . . . . . . . . . . . . . . . . .    27\nAlgorithm 13     K-PKE.KeyGen(ğ‘‘)          . . . . . . . . . . . . . . . . . . . . . . . . . . .    29\nAlgorithm 14     K-PKE.Encrypt(ekPKE, ğ‘š, ğ‘Ÿ) . . . . . . . . . . . . . . . . . . . . . . .         30\nAlgorithm 15     K-PKE.Decrypt(dkPKE, ğ‘)        . . . . . . . . . . . . . . . . . . . . . . . .    31\nAlgorithm 16     ML-KEM.KeyGen_internal(ğ‘‘, ğ‘§)          . . . . . . . . . . . . . . . . . . . .    32\nAlgorithm 17     ML-KEM.Encaps_internal(ek, ğ‘š)            . . . . . . . . . . . . . . . . . . .    33\nAlgorithm 18     ML-KEM.Decaps_internal(dk, ğ‘)          . . . . . . . . . . . . . . . . . . . .    34\nAlgorithm 19     ML-KEM.KeyGen() . . . . . . . . . . . . . . . . . . . . . . . . . . .              35\nAlgorithm 20     ML-KEM.Encaps(ek) . . . . . . . . . . . . . . . . . . . . . . . . . .              37\nAlgorithm 21     ML-KEM.Decaps(dk, ğ‘)           . . . . . . . . . . . . . . . . . . . . . . . .    38\n\nvi"}
{"doc_id": "NIST.FIPS.203", "source_path": "data/raw_pdfs/NIST.FIPS.203.pdf", "page_number": 10, "text": "FIPS 203                               MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\n\n1.   Introduction\n\n1.1  Purpose and Scope\nThis standard specifies the Module-Lattice-Based Key-Encapsulation Mechanism (ML-KEM). A\nkey-encapsulation mechanism (KEM) is a set of algorithms that can be used to establish a shared\nsecret key between two parties communicating over a public channel. A KEM is a particular type\nof key establishment scheme. Other NIST-approved key establishment schemes are specified\nin NIST Special Publication (SP) 800-56A, Recommendation for Pair-Wise Key-Establishment\nSchemes Using Discrete Logarithm-Based Cryptography [2], and SP 800-56B, Recommendation\nfor Pair-Wise Key Establishment Schemes Using Integer Factorization Cryptography [3].\nThe key establishment schemes specified in SP 800-56A and SP 800-56B are vulnerable to\nattacks that use sufficiently-capable quantum computers. ML-KEM is an approved alternative\nthat is presently believed to be secure, even against adversaries in possession of a large-scale\nfault-tolerant quantum computer.       ML-KEM is derived from the round-three version of the\nCRYSTALS-KYBER KEM [4], a submission in the NIST Post-Quantum Cryptography Standardization\nproject. For the differences between ML-KEM and CRYSTALS-KYBER, see Appendix C.\nThis standard specifies the algorithms and parameter sets of the ML-KEM scheme.      It aims\nto provide sufficient information to implement ML-KEM in a manner that can pass validation\n(see https://csrc.nist.gov/projects/cryptographic- module- validation- program).        For\ngeneral definitions and properties of KEMs, including requirements for the secure use of KEMs\nin applications, see SP 800-227 [1].\nThis standard specifies three parameter sets for ML-KEM that offer different trade-offs in security\nstrength versus performance.      All three parameter sets of ML-KEM are approved to protect\nsensitive, non-classified communication systems of the U.S. Federal Government.\n\n1.2  Context\nOver the past several years, there has been steady progress toward building quantum computers.\nIf large-scale quantum computers are realized, the security of many commonly used public-key\ncryptosystems will be at risk. This would include key-establishment schemes and digital signature\nschemes whose security depends on the difficulty of solving the integer factorization and discrete\nlogarithm problems (both over finite fields and elliptic curves). As a result, in 2016, NIST initiated\na public Post-Quantum Cryptography (PQC) Standardization process to select quantum-resistant\npublic-key cryptographic algorithms. A total of 82 candidate algorithms were submitted to NIST\nfor consideration.\nAfter three rounds of evaluation and analysis, NIST selected the first four algorithms for stan-\ndardization. These algorithms are intended to protect sensitive U.S. Government information\nwell into the foreseeable future, including after the advent of cryptographically-relevant quan-\ntum computers. This standard specifies a variant of the selected algorithm CRYSTALS-KYBER, a\nlattice-based key-encapsulation mechanism (KEM) designed by Peter Schwabe, Roberto Avanzi,\nJoppe Bos, LÃ©o Ducas, Eike Kiltz, TancrÃ¨de Lepoint, Vadim Lyubashevsky, John Schanck, Gregor\nSeiler, Damien StehlÃ©, and Jintai Ding [4]. Throughout this standard, the KEM specified here will\nbe referred to as ML-KEM, as it is based on the Module Learning With Errors assumption.\n\n                                       1"}
{"doc_id": "NIST.FIPS.203", "source_path": "data/raw_pdfs/NIST.FIPS.203.pdf", "page_number": 11, "text": "FIPS 203                                   MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\n\n2.   Terms, Acronyms, and Notation\n\n2.1  Terms and Definitions\n approved               FIPS-approved and/or NIST-recommended. An algorithm or technique\n                        that is either 1) specified in a FIPS or NIST recommendation, 2) adopted\n                        in a FIPS or NIST recommendation, or 3) specified in a list of NIST-approved\n                        security functions.\n(KEM) ciphertext        A bit string that is produced by encapsulation and used as an input to\n                        decapsulation.\n cryptographic          The set of hardware, software, and/or firmware that implements ap-\n module                 proved cryptographic functions (including key generation) that are con-\n                        tained within the cryptographic boundary of the module.\n decapsulation          The process of applying the Decaps algorithm of a KEM. This algorithm\n                        accepts a KEM ciphertext and the decapsulation key as input and pro-\n                        duces a shared secret key as output.\n decapsulation key      A cryptographic key produced by a KEM during key generation and used\n                        during the decapsulation process. The decapsulation key must be kept\n                        private and must be destroyed after it is no longer needed. (See Section\n                        3.3.)\n decryption key         A cryptographic key that is used with a PKE in order to decrypt cipher-\n                        texts into plaintexts. The decryption key must be kept private and must\n                        be destroyed after it is no longer needed.\n destroy                An action applied to a key or other piece of secret data. After a piece\n                        of secret data is destroyed, no information about its value can be re-\n                        covered.\n encapsulation          The process of applying the Encaps algorithm of a KEM. This algorithm\n                        accepts the encapsulation key as input, requires private randomness,\n                        and produces a shared secret key and an associated ciphertext as out-\n                        put.\n encapsulation key      A cryptographic key produced by a KEM during key generation and used\n                        during the encapsulation process. The encapsulation key can be made\n                        public. (See Section 3.3.)\n encryption key         A cryptographic key that is used with a PKE in order to encrypt plaintexts\n                        into ciphertexts. The encryption key can be made public.\n equivalent process     Two processes are equivalent if the same output is produced when the\n                        same values are input to each process (either as input parameters, as\n                        values made available during the process, or both).\n fresh random value     An output that was produced by a random bit generator and has not\n                        been previously used.\n\n                                           2"}
{"doc_id": "NIST.FIPS.203", "source_path": "data/raw_pdfs/NIST.FIPS.203.pdf", "page_number": 12, "text": "FIPS 203                                MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\n\nhash function         A function on bit strings in which the length of the output is fixed.\n                      Approved hash functions (such as those specified in FIPS 180 [5] and\n                      FIPS 202 [6]) are designed to satisfy the following properties:\n                       1.  (One-way) It is computationally infeasible to find any input that\n                           maps to any new pre-specified output.\n                       2.  (Collision-resistant) It is computationally infeasible to find any two\n                           distinct inputs that map to the same output.\ninput checking        Examination of a potential input to an algorithm for the purpose of\n                      determining whether it conforms to certain requirements.\nkey                   A bit string that is used in conjunction with a cryptographic algorithm,\n                      such as the encapsulation and decapsulation keys (of a KEM), the shared\n                      secret key (produced by a KEM), and the encryption and decryption\n                      keys (of a PKE). (See Section 3.3.)\nkey-encapsulation     A set of three cryptographic algorithms (KeyGen, Encaps, and Decaps)\nmechanism (KEM)       that can be used by two parties to establish a shared secret key over a\n                      public channel.\nkey establishment     A procedure that results in secret keying material that is shared among\n                      different parties.\nkey pair              A set of two keys with the property that one key can be made public\n                      while the other key must be kept private. In this standard, this could\n                      refer to either the (encapsulation key, decapsulation key) key pair of a\n                      KEM or the (encryption key, decryption key) key pair of a PKE.\nlittle-endian         The property of a byte string having its bytes positioned in order of\n                      increasing significance. In particular, the leftmost (first) byte is the\n                      least significant, and the rightmost (last) byte is the most significant.\n                      The term â€œlittle-endianâ€ may also be applied in the same manner to\n                      bit strings (e.g., the 8-bit string 11010001 corresponds to the byte\n                      2â° + 2Â¹ + 2Â³ + 2â· = 139).\nparty                 An individual person, organization, device, or process. In this specifica-\n                      tion, there are two parties (e.g., Party A and Party B, or Alice and Bob)\n                      who jointly perform the key establishment process using a KEM.\npseudorandom          A process (or data produced by a process) is said to be pseudorandom\n                      when the outcome is deterministic yet also appears random as long\n                      as the internal action of the process is hidden from observation. For\n                      cryptographic purposes, â€œeffectively randomâ€ means â€œcomputationally\n                      indistinguishable from random within the limits of the intended security\n                      strength.â€\npublic channel        A communication channel between two parties. Such a channel can be\n                      observed and possibly also corrupted by third parties.\n\n3"}
{"doc_id": "NIST.FIPS.203", "source_path": "data/raw_pdfs/NIST.FIPS.203.pdf", "page_number": 13, "text": "FIPS 203                      MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\n\npublic-key            A set of three cryptographic algorithms (KeyGen, Encrypt, and Decrypt)\nencryption scheme     that can be used by two parties to send secret data over a public channel.\n(PKE)                 Also known as an asymmetric encryption scheme.\nshared secret         A secret value that has been computed during a key-establishment\n                      scheme, is known by both participants, and is used as input to a key-\n                      derivation method to produce keying material.\nshared secret key     A shared secret that can be used directly as a cryptographic key in\n                      symmetric-key cryptography. It does not require additional key deriva-\n                      tion. The shared secret key must be kept private and must be destroyed\n                      when no longer needed.\nsecurity category     A number associated with the security strength of a post-quantum\n                      cryptographic algorithm, as specified by NIST (see [7]).\nsecurity strength     A number associated with the amount of work (i.e., the number of op-\n                      erations) that is required to break a cryptographic algorithm or system.\nshall                 Used to indicate a requirement of this standard.\nshould                Used to indicate a strong recommendation but not a requirement of\n                      this standard. Ignoring the recommendation could lead to undesirable\n                      results.\n\n2.2    Acronyms\nAES        Advanced Encryption Standard\nCBD        Centered Binomial Distribution\nFIPS       Federal Information Processing Standard\nKEM        Key-Encapsulation Mechanism\nLWE        Learning with Errors\nMLWE       Module Learning with Errors\nNIST       National Institute of Standards and Technology\nNISTIR     NIST Interagency or Internal Report\nNTT        Number-Theoretic Transform\nPKE        Public-Key Encryption\nPQC        Post-Quantum Cryptography\nPRF        Pseudorandom Function\nRBG        Random Bit Generator\nSHA        Secure Hash Algorithm\n                                4"}
{"doc_id": "NIST.FIPS.203", "source_path": "data/raw_pdfs/NIST.FIPS.203.pdf", "page_number": 14, "text": "FIPS 203                       MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\n\nSHAKE       Secure Hash Algorithm KECCAK\nSP          Special Publication\nXOF         Extendable-Output Function\n\n2.3      Mathematical Symbols\nğ‘›             Denotes the integer 256 throughout this document.\nğ‘             Denotes the prime integer 3329 = 2â¸ â‹… 13 + 1 throughout this document.\nğœ             Denotes the integer 17, which is a primitive ğ‘›-th root of unity modulo ğ‘.\nğ”¹             The set {0, 1, â€¦ , 255} of unsigned 8-bit integers (bytes).\nâ„š              The set of rational numbers.\nâ„¤              The set of integers.\nâ„¤ğ‘š            The ring of integers modulo ğ‘š (i.e., the set {0, 1, â€¦ , ğ‘š âˆ’ 1} equipped with\n               the operations of addition and multiplication modulo ğ‘š.)\nâ„¤ğ‘›            The set of ğ‘›-tuples over â„¤  equipped with â„¤ -module structure. As a data\n      ğ‘š       type, this is the set of     ğ‘š          ğ‘š\n                                         length-ğ‘› arrays whose entries are in â„¤ğ‘š .\nğ‘…ğ‘           The ring â„¤ğ‘ [ğ‘‹]/(ğ‘‹ğ‘› + 1) consisting of polynomials of the form ğ‘“ = ğ‘“â‚€ +\n               ğ‘“â‚ğ‘‹ + â‹¯ + ğ‘“â‚‚â‚…â‚…ğ‘‹Â²âµâµ, where ğ‘“ğ‘— âˆˆ â„¤ğ‘ for all ğ‘—. The ring operations are addi-\n               tion and multiplication modulo ğ‘‹ğ‘› + 1.\nğ‘‡ğ‘           The image of ğ‘…ğ‘ under the number-theoretic transform. Its elements are\n               called â€œNTT representationsâ€ of polynomials in ğ‘…ğ‘ . (See Section 4.3.)\nDğœ‚(ğ‘…ğ‘ )     A certain distribution of polynomials in ğ‘…ğ‘ with small coefficients, from\n              which noise is sampled. The distribution is parameterized by ğœ‚ âˆˆ {2, 3}. (See\n               Section 4.2.2.)\nğ‘† âˆ—           If ğ‘† is a set, this denotes the set of finite-length tuples (or arrays) of elements\n               from the set ğ‘†, including the empty tuple (or empty array).\nğ‘† ğ‘˜          If ğ‘† is a set, this denotes the set of ğ‘˜-tuples (or length-ğ‘˜ arrays) of elements\n               from the set ğ‘†.\nğ‘“ğ‘—           The coefficient of ğ‘‹ğ‘— of a polynomial ğ‘“ = ğ‘“â‚€ + ğ‘“â‚ğ‘‹ + â‹¯ + ğ‘“â‚‚â‚…â‚…ğ‘‹Â²âµâµ âˆˆ ğ‘…ğ‘ .\n\nğ‘“             The element of ğ‘‡ğ‘ that is equal to the NTT representation of a polynomial\n               ğ‘“ âˆˆ ğ‘…ğ‘ . (See Sections 2.4.4 and 4.3.)\nğ¯ğ‘‡, ğ€ğ‘‡     The transpose of a row or column vector ğ¯. In general, the transpose of a\n               matrix ğ€.\n\n5"}
{"doc_id": "NIST.FIPS.203", "source_path": "data/raw_pdfs/NIST.FIPS.203.pdf", "page_number": 15, "text": "FIPS 203                                 MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\n\n   âˆ˜                Denotes linear-algebraic composition with coefficients in ğ‘…ğ‘ or ğ‘‡ğ‘ (e.g.,\n                    ğ€ âˆ˜ ğ¯ denotes the vector resulting from applying matrix ğ€ to vector ğ¯). (See\n                    Section 2.4.7.)\n   Ã—ğ‘‡ğ‘            Denotes the operation on coefficient arrays that implements product in the\n                    ring ğ‘‡ğ‘ . (See Sections 2.4.5 and 4.3.1.)\n  ğ´â€–ğµ             The concatenation of two arrays or bit strings ğ´ and ğµ.\n  ğµ[ğ‘–]            The entry at index ğ‘– in the array ğµ. All arrays have indices that begin at zero.\n  ğµ[ğ‘˜ âˆ¶ ğ‘š]       The subarray (ğµ[ğ‘˜], ğµ[ğ‘˜ + 1], â€¦ , ğµ[ğ‘š âˆ’ 1]) of the array ğµ.\n  |ğµ|              If ğµ is a number, this denotes the absolute value of ğµ. If ğµ is an array, this\n                    denotes its length.\n  âŒˆğ‘¥âŒ‰              The ceiling of ğ‘¥ (i.e., the smallest integer greater than or equal to ğ‘¥).\n  âŒŠğ‘¥âŒ‹              The floor of ğ‘¥ (i.e., the largest integer less than or equal to ğ‘¥).\n  âŒˆğ‘¥âŒ‹              The rounding of ğ‘¥ to the nearest integer. If ğ‘¥ = ğ‘¦ + 1/2 for some ğ‘¦ âˆˆ â„¤, then\n                    âŒˆğ‘¥âŒ‹ = ğ‘¦ + 1.\n âˆ¶=                 Denotes that the left-hand side is defined to be the expression on the right-\n                    hand side.\n ğ‘Ÿ mod ğ‘š          The unique integer ğ‘Ÿâ€² in {0, 1, â€¦ , ğ‘š âˆ’ 1} such that ğ‘š divides ğ‘Ÿ âˆ’ ğ‘Ÿâ€² .\n  BitRevâ‚‡ (ğ‘Ÿ)      Bit reversal of a seven-bit integer ğ‘Ÿ. Specifically, if ğ‘Ÿ = ğ‘Ÿâ‚€ + 2ğ‘Ÿâ‚ + 4ğ‘Ÿâ‚‚ + â‹¯ +\n                    64ğ‘Ÿâ‚† with ğ‘Ÿğ‘– âˆˆ {0, 1}, then BitRevâ‚‡ (ğ‘Ÿ) = ğ‘Ÿâ‚† + 2ğ‘Ÿâ‚… + 4ğ‘Ÿâ‚„ + â‹¯ + 64ğ‘Ÿâ‚€.\n  ğ‘  â† ğ‘¥           In pseudocode, this notation means that the variable ğ‘  is assigned the value\n                    of the expression ğ‘¥.\n  ğ‘     $   ğ”¹â„“     In pseudocode, this notation means that the variable ğ‘  is assigned the value\n        âˆ’\n        â†\n                    of an array of â„“ random bytes. The bytes must be freshly generated using\n                    randomness from an approved RBG. (See Section 3.3.)\n  âŠ¥                 A symbol indicating failure or the lack of output from an algorithm.\n\n2.4       Interpreting the Pseudocode\nThis section outlines the conventions of the pseudocode used to describe the algorithms in\nthis standard.     All algorithms are understood to have access to two global integer constants:\nğ‘› = 256 and ğ‘ = 3329. There are also five global integer variables: ğ‘˜, ğœ‚â‚, ğœ‚â‚‚, ğ‘‘ğ‘¢, and ğ‘‘ğ‘£. All\nother variables are local. The five global variables are set to particular values when a parameter\nset is selected (see Section 8).\nWhen algorithms in this specification invoke other algorithms as subroutines, all arguments (i.e.,\ninputs) are passed by value. In other words, a copy of the inputs is created, and the subroutine\nis invoked with the copy. There is no â€œpassing by reference.â€\nPseudocode assignments are performed using the symbol â€œâ†.â€ For example, the statement\nğ‘§ â† ğ‘¦ means that the variable ğ‘§ is assigned the value of variable ğ‘¦. Pseudocode comparisons\n                                         6"}
{"doc_id": "NIST.FIPS.203", "source_path": "data/raw_pdfs/NIST.FIPS.203.pdf", "page_number": 16, "text": "FIPS 203                                 MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\n\nare performed via the symbol â€œ==.â€ For example, the expression ğ‘¥ == ğ‘¤ is a boolean value\nthat is TRUE if and only if the variables ğ‘¥ and ğ‘¤ have the same value.\nIn regular text (i.e., outside of the pseudocode), a different convention is applied. There, the\n            â€œ=â€ symbol is used both for assigning values and for comparisons, in keeping with standard\nmathematical notation. When emphasis is needed, assignments will be made with â€œâˆ¶=â€ instead.\n       Variables will always have a valid value that is appropriate to their data type, with two exceptions:\n 1.    The outputs of a random bit generator (RBG) have the byte array data type but are also\n       allowed to have the special value NULL. This value indicates that randomness generation\n       failed. This can only occur in ML-KEM.KeyGen and ML-KEM.Encaps.\n 2.    The outputs of ML-KEM.KeyGen and ML-KEM.Encaps have the byte array data type but\n       are also allowed to have the special value âŠ¥. When ML-KEM.KeyGen or ML-KEM.Encaps\n       return the value âŠ¥, this indicates that the algorithm failed due to a failure of randomness\n       generation.\n\n2.4.1       Data Types\nFor variables that represent the input or output of an algorithm, the data type (e.g., bit, byte,\narray of bits) will be explicitly described at the start of the algorithm. For most local variables\nin the pseudocode, the data type is easily deduced from context. For all other variables, the\ndata type will be declared in a comment.         In a single algorithm, the data type of a variable is\ndetermined the first time that the variable is used and will not be changed. Variable names can\nand will be reused across different algorithms, including with different data types.\nIn addition to standard atomic data types (e.g., bits, bytes) and data structures (e.g., arrays),\nintegers modulo ğ‘š (i.e., elements of â„¤ğ‘š ) will also be used as an abstract data type. It is implicit\nthat reduction modulo ğ‘š takes place whenever an assignment is made to a variable in â„¤ğ‘š . For\nexample, for ğ‘§ âˆˆ â„¤ğ‘š and integers ğ‘¥ and ğ‘¦, the statement\n\n                                                     ğ‘§ â† ğ‘¥ + ğ‘¦                                (2.1)\n\nmeans that ğ‘§ is assigned the value ğ‘¥ + ğ‘¦ mod ğ‘š. The pseudocode is agnostic regarding how\nan integer modulo ğ‘š is represented in actual implementations or how modular reduction is\ncomputed.\n\n2.4.2       Loop Syntax\nThe pseudocode will make use of both â€œwhileâ€ and â€œforâ€ loops. The â€œwhileâ€ syntax is self-\nexplanatory. In the case of â€œforâ€ loops, the syntax will be in the style of the programming language\nC. Two simple examples are given in Algorithm 1. The standard mathematical expression (e.g.,\nâˆ‘ğ‘›    (ğ‘– + 3)) will be used for simple summations instead of a â€œforâ€ loop.\nğ‘–â†1\n\n2.4.3       Arithmetic With Arrays of Integers\nThis standard makes extensive use of arrays of integers modulo ğ‘š (i.e., elements of â„¤â„“ ). In a\ntypical case, the relevant values are ğ‘š = ğ‘ = 3329 and â„“ = ğ‘› = 256. Arithmetic with ğ‘š\n                                                                                       arrays in\n                                         7"}
{"doc_id": "NIST.FIPS.203", "source_path": "data/raw_pdfs/NIST.FIPS.203.pdf", "page_number": 17, "text": "FIPS 203                                    MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\n\nAlgorithm 1 ForExample()\nPerforms two simple â€œforâ€ loops.\n 1:    for (ğ‘– â† 0; ğ‘– < 10; ğ‘– ++)\n 2:           ğ´[ğ‘–] â† ğ‘–                         â–· ğ´ is an integer array of length 10\n 3:    end for                                               â–· ğ´ now has the value (0, 1, 2, 3, 4, 5, 6, 7, 8, 9)\n 4:    ğ‘— â† 0\n 5:    for (ğ‘˜ â† 256; ğ‘˜ > 1; ğ‘˜ â† ğ‘˜/2)\n 6:           ğµ[ğ‘—] â† ğ‘˜                         â–· ğµ is an integer array of length 8\n 7:           ğ‘— â† ğ‘— + 1\n 8:    end for                                              â–· ğµ now has the value (256, 128, 64, 32, 16, 8, 4, 2)\n\nâ„¤â„“     will be done as follows. Let ğ‘ âˆˆ â„¤  and ğ‘‹, ğ‘Œ âˆˆ â„¤â„“ . The statements\n ğ‘š                                         ğ‘š    ğ‘š\n                                                  ğ‘ â† ğ‘ â‹… ğ‘‹                                              (2.2)\n                                                  ğ‘Š â† ğ‘‹ + ğ‘Œ                                              (2.3)\n\nwill result in two arrays ğ‘, ğ‘Š âˆˆ â„¤â„“           , with the property that ğ‘[ğ‘–] = ğ‘ â‹… ğ‘‹[ğ‘–] and ğ‘Š [ğ‘–] = ğ‘‹[ğ‘–] + ğ‘Œ [ğ‘–]\nfor all     . Multiplication of arrays ğ‘š â„“\nwhich ğ‘–                                             in â„¤ğ‘š will only be meaningful when ğ‘š = ğ‘ and â„“ = ğ‘› = 256, in\n        case it corresponds to multiplication in a particular ring. This operation will be described\nin (2.8).\n\n2.4.4         Representations of Algebraic Objects\nAn essential operation in ML-KEM is the number-theoretic transform (NTT), which maps a poly-\nnomial ğ‘“ in a certain ring ğ‘…ğ‘ to its â€œNTT representationâ€ ğ‘“ in an isomorphic ring ğ‘‡ğ‘ . The rings ğ‘…ğ‘\nand ğ‘‡ğ‘ and the NTT are discussed in detail in Section 4.3. This standard will represent elements\nof ğ‘…ğ‘ and ğ‘‡ğ‘ in pseudocode using arrays of integers modulo ğ‘ as follows.\nAn element ğ‘“ of ğ‘…ğ‘ is a polynomial of the form\n\n                                   ğ‘“ = ğ‘“â‚€ + ğ‘“â‚ğ‘‹ + â‹¯ + ğ‘“â‚‚â‚…â‚…ğ‘‹Â²âµâµ âˆˆ ğ‘…ğ‘                                 (2.4)\n\nand will be represented in pseudocode by the array\n\n                                          (ğ‘“â‚€, ğ‘“â‚, â€¦ , ğ‘“â‚‚â‚…â‚…) âˆˆ â„¤Â²âµâ¶,                                     (2.5)\n                                                                  ğ‘\n               whose entries contain the coefficients of ğ‘“. Overloading notation, the array in (2.5) will also be\ndenoted by ğ‘“. The ğ‘–-th entry of the array ğ‘“ will thus contain the ğ‘–-th coefficient of the polynomial\nğ‘“ (i.e., ğ‘“[ğ‘–] = ğ‘“ğ‘– ).\n                  An element (sometimes called â€œNTT representationâ€) ğ‘”Ì‚ of ğ‘‡ğ‘ is a tuple of 128 polynomials, each\nof degree at most one. Specifically,\n\n                             ğ‘” = (ğ‘”0,0 + ğ‘”0,1 ğ‘‹, ğ‘”1,0 + ğ‘”1,1 ğ‘‹, â€¦ , ğ‘”127,0 + ğ‘”127,1ğ‘‹) âˆˆ ğ‘‡ğ‘ .    (2.6)\n\n8"}
{"doc_id": "NIST.FIPS.203", "source_path": "data/raw_pdfs/NIST.FIPS.203.pdf", "page_number": 18, "text": "FIPS 203                                     MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\n\nSuch an algebraic object will be represented in pseudocode by the array\n\n                       (ğ‘”0,0 , ğ‘”0,1 , ğ‘”1,0 , ğ‘”1,1 , â€¦ , ğ‘”127,0, ğ‘”127,1) âˆˆ â„¤Â²âµâ¶ .    (2.7)\n                                                                    ğ‘\nOverloading notation, the array in (2.7) will also be denoted by ğ‘”.  In this case, the mapping\nbetween array entries and coefficients is ğ‘”[2ğ‘–] = ğ‘”ğ‘–,0 and ğ‘”[2ğ‘– + 1] = ğ‘”ğ‘–,1 for ğ‘– âˆˆ {0, 1, â€¦ , 127}.\n\nConverting between a polynomial ğ‘“ âˆˆ ğ‘…ğ‘ and its NTT representation ğ‘“ âˆˆ ğ‘‡ğ‘ will be done via the\nalgorithms NTT (Algorithm 9) and NTTâˆ’1 (Algorithm 10). These algorithms act on arrays of\ncoefficients, as described above, and satisfy ğ‘“ = NTT(ğ‘“) and ğ‘“ = NTTâˆ’1(ğ‘“).\n\n2.4.5       Arithmetic With Polynomials and NTT Representations\n                   The algebraic operations of addition and scalar multiplication in ğ‘…ğ‘ and ğ‘‡ğ‘ are done coordinate-\nwise.                      For example, if ğ‘ âˆˆ â„¤ğ‘ and ğ‘“ âˆˆ ğ‘…ğ‘ , the ğ‘–-th coefficient of the polynomial ğ‘ â‹… ğ‘“ âˆˆ ğ‘…ğ‘ is\nequal to ğ‘ â‹… ğ‘“ğ‘–                  mod ğ‘. In pseudocode, elements of both ğ‘…ğ‘ and ğ‘‡ğ‘ are represented by coefficient\narrays (i.e., elements of â„¤Â²âµâ¶). The algebraic operations of addition and scalar multiplication are\nthus performed by      ğ‘\n                                        addition and scalar multiplication of the corresponding coefficient arrays,\nas in (2.3) and (2.2).                        For example, the addition of two NTT representations in pseudocode is\nperformed by a statement of the form â„ â† ğ‘“ + ğ‘”, where â„, ğ‘“, ğ‘” âˆˆ â„¤Â²âµâ¶ are coefficient arrays.\n                                                                      ğ‘\nThe algebraic operations of multiplication in ğ‘…ğ‘ and ğ‘‡ğ‘ are treated as follows.                  For efficiency\nreasons, multiplication in ğ‘…ğ‘ will not be used. The algebraic meaning of multiplication in ğ‘‡ğ‘ is\ndiscussed in Section 4.3.1. In pseudocode, it will be performed by the algorithm MultiplyNTTs\n(Algorithm 11). Specifically, if ğ‘“, ğ‘” âˆˆ â„¤Â²âµâ¶ are a pair of arrays (each representing the NTT of some\npolynomial), then               ğ‘\n\n                     â„ â† ğ‘“ Ã—ğ‘‡ğ‘ ğ‘”  means  â„ â† MultiplyNTTs(ğ‘“, ğ‘”) .                                       (2.8)\n\nThe result is an array â„ âˆˆ â„¤Â²âµâ¶.\n                         ğ‘\n\n2.4.6       Matrices and Vectors\nIn addition to arrays of integers modulo ğ‘, the pseudocode will also make use of arrays whose\nentries are themselves elements of â„¤Â²âµâ¶. For example, an element ğ¯ âˆˆ (â„¤Â²âµâ¶)Â³ will be a length-\n                                      ğ‘                                                  ğ‘\nthree array whose entries ğ¯[0], ğ¯[1], and ğ¯[2] are themselves elements of â„¤Â²âµâ¶ (i.e., arrays). One\ncan think of each of these entries as representing a polynomial in      so                ğ‘\n                                                                    ğ‘…ğ‘                  that ğ¯ itself represents\nan element of the module ğ‘…Â³.\n                           ğ‘\n When arrays are used to represent matrices and vectors whose entries are elements of ğ‘…ğ‘ , they\nwill be denoted with bold letters (e.g., ğ¯ for vectors and ğ€ for matrices). When arrays are used\nto represent matrices and vectors whose entries are elements of ğ‘‡ğ‘ , they will be denoted with a\nâ€œhatâ€ (e.g., ğ¯Ì‚ and ğ€). Unless an explicit transpose operation is performed, it is understood that\nvectors are column vectors. One can then view vectors as the special case of matrices with only\none column.\nConverting between matrices over ğ‘…ğ‘ and matrices over ğ‘‡ğ‘ will be done coordinate-wise. For\n\n                                               9"}
{"doc_id": "NIST.FIPS.203", "source_path": "data/raw_pdfs/NIST.FIPS.203.pdf", "page_number": 19, "text": "FIPS 203                                     MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\n\nexample, if ğ¯ âˆˆ (â„¤Â²âµâ¶)ğ‘˜, then the statement\n                    ğ‘\n                      ğ¯ â† NTT(ğ¯)                                                                        (2.9)\n\nwill result in ğ¯ âˆˆ (â„¤Â²âµâ¶)ğ‘˜ such that ğ¯[ğ‘–]Ì‚ = NTT(ğ¯[ğ‘–]) for all ğ‘–. This involves running NTT a total\nof ğ‘˜ times.          ğ‘\n\n2.4.7       Arithmetic With Matrices and Vectors\nThe following describes how to perform arithmetic with matrices over ğ‘…ğ‘ and ğ‘‡ğ‘ with vectors as\na special case.\nAddition and scalar multiplication are performed coordinate-wise, so the addition of matrices\nover ğ‘…ğ‘ and ğ‘‡ğ‘ is straightforward. In the case of ğ‘‡ğ‘ , scalar multiplication is done via (2.8). For\nexample, if ğ‘“ âˆˆ â„¤Â²âµâ¶ and ğ®, ğ¯ âˆˆ (â„¤Â²âµâ¶)ğ‘˜, then\n                ğ‘      ğ‘\n\n                          ğ° â† ğ‘“ â‹… ğ®                                                                            (2.10)\n                          ğ³ â† ğ® + ğ¯                                                                            (2.11)\n\nwill result in ğ°, ğ³ âˆˆ (â„¤Â²âµâ¶)ğ‘˜ satisfying ğ°[ğ‘–] = ğ‘“ Ã—      ğ®[ğ‘–] and ğ³[ğ‘–] = ğ®[ğ‘–] + ğ¯[ğ‘–] for all ğ‘–. Here, the\nmultiplication and      ğ‘                                 ğ‘‡ğ‘\n                                           addition of individual entries are performed using the appropriate arithmetic\nfor coefficient arrays of elements of ğ‘‡ğ‘ (i.e., as in (2.3)).\nIt will also be necessary to multiply matrices with entries in ğ‘‡ğ‘ , which is done by using standard\nmatrix multiplication with the base-case multiplication (i.e., multiplication of individual entries)\nbeing multiplication in ğ‘‡ğ‘ . If ğ€ and ğ are two matrices with entries in ğ‘‡ğ‘ , their matrix product\n                               will be denoted ğ€ âˆ˜ ğ. Some example pseudocode statements involving matrix multiplication\nare given in (2.12), (2.13), and (2.14). In these examples, ğ€ is a ğ‘˜ Ã— ğ‘˜ matrix, while ğ®Ì‚ and ğ¯Ì‚ are\n                        vectors of length ğ‘˜. All three of these objects are represented in pseudocode by arrays: a ğ‘˜ Ã— ğ‘˜\narray for ğ€ and length-ğ‘˜ arrays for ğ®Ì‚ and ğ¯Ì‚. The entries of ğ€, ğ®Ì‚, and ğ¯Ì‚ are elements of â„¤Â²âµâ¶. In\n        and     , the pseudocode statement on the left produces a new length-                             vector ğ‘\n(2.12)          (2.13)                                                                                    ğ‘˜       whose\nentries are specified on the right. In (2.14), the pseudocode statement on the left computes a\ndot product. The result is in the base ring (i.e., ğ‘‡ğ‘ ) and is represented by an element ğ‘§ of â„¤Â²âµâ¶.\n                                                                                                                   ğ‘\n\nğ‘˜âˆ’1\n                          ğ° â† ğ€ âˆ˜ ğ®                              ğ°[ğ‘–] = âˆ‘ ğ€[ğ‘–, ğ‘—] Ã—ğ‘‡ğ‘ ğ®[ğ‘—]            (2.12)\nğ‘—=0\nğ‘˜âˆ’1\n                          ğ² â† ğ€âŠº âˆ˜ ğ®                             ğ²[ğ‘–] = âˆ‘ ğ€[ğ‘—, ğ‘–] Ã—ğ‘‡ğ‘ ğ®[ğ‘—]            (2.13)\nğ‘—=0\nğ‘˜âˆ’1\n                          ğ‘§ â† ğ®âŠº âˆ˜ ğ¯                        ğ‘§ = âˆ‘ ğ®[ğ‘—] Ã—ğ‘‡ğ‘ ğ¯[ğ‘—]                         (2.14)\nğ‘—=0\nThe multiplication Ã—ğ‘‡ğ‘ of individual entries above is performed using MultiplyNTTs, as described\nin (2.8).\n\n10"}
{"doc_id": "NIST.FIPS.203", "source_path": "data/raw_pdfs/NIST.FIPS.203.pdf", "page_number": 20, "text": "FIPS 203                                            MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\n\n2.4.8       Applying Algorithms to Arrays, Examples\nIn the previous examples, arithmetic over â„¤ğ‘š was extended to arithmetic with arrays over â„¤ğ‘š\nand then further extended to arithmetic with matrices whose entries are themselves arrays over\nâ„¤ğ‘š . Similarly, algorithms defined with a given data type as input will be applied to arrays and\nmatrices over that data type. When the pseudocode invokes such an algorithm on an array or\nmatrix input, it is implied that the algorithm is invoked repeatedly and applied to each entry of\nthe input.\nFor example, consider the function Compressğ‘‘ âˆ¶ â„¤ğ‘ â†’ â„¤â‚‚ğ‘‘ defined in Section 4. It can be invoked\non an array input ğ¹ âˆˆ â„¤Â²âµâ¶ with the statement\n                        ğ‘\n                                    ğ¾ â† Compressğ‘‘(ğ¹ ) .                          (2.15)\n\nThe result will be an array ğ¾ âˆˆ â„¤Â²âµâ¶ such that ğ¾[ğ‘–] = Compress (ğ¹ [ğ‘–]) for every ğ‘– âˆˆ {0, 1, â€¦ , 255}.\nThe computation (2.15)    2ğ‘‘                                     ğ‘‘\n                         involves running the Compress algorithm 256 times.\nFor a second example, consider the algorithm NTT defined in Section 4.3. It takes an array ğ‘“ âˆˆ\nâ„¤Â²âµâ¶ (representing an element of ğ‘…       ) as input and outputs another array ğ‘“ âˆˆ â„¤Â²âµâ¶ (representing\n    ğ‘                              ğ‘                                              ğ‘\nan element of ğ‘‡ ). If the NTT algorithm is invoked on a vector ğ¬ âˆˆ (â„¤Â²âµâ¶)ğ‘˜ (representing an\n                 ğ‘                                                  ğ‘\nelement of ğ‘…ğ‘˜) with the pseudocode statement\n            ğ‘\n            ğ¬ â† NTT(ğ¬) ,                                                            (2.16)\n\nthe result is a vector ğ¬ âˆˆ (â„¤Â²âµâ¶)ğ‘˜ such that ğ¬[ğ‘–] = NTT(ğ¬[ğ‘–]) for all ğ‘– âˆˆ {0, 1, â€¦ , ğ‘˜ âˆ’ 1}. The vector\n                          ğ‘\nğ¬Ì‚ represents an element of ğ‘‡ ğ‘˜. The computation (2.16) involves running the NTT algorithm ğ‘˜\ntimes.                      ğ‘\nFor a third example, consider line 2 of K-PKE.Encrypt in Section 5.2:\n\nğ­ â† ByteDecodeâ‚â‚‚(ekPKE[0 âˆ¶ 384ğ‘˜]) .                                                                    (2.17)\n\nByteDecodeâ‚â‚‚ is defined to receive a byte array of length 32 â‹… 12 = 384 as input and produce\nan integer array in â„¤Â²âµâ¶ as output.       The computation (2.17) is run on the first 384ğ‘˜ bytes of\n                       ğ‘\nbyte array ekPKE and results in ğ­ âˆˆ (â„¤Â²âµâ¶)ğ‘˜. ByteDecode                will thus be applied ğ‘˜ times, once for\neach subarray                             ğ‘  , and will result 12                    256\n                 ekPKE[384 â‹… ğ‘—, 384 â‹… (ğ‘— + 1)]             in an integer array ğ­[ğ‘—] âˆˆ â„¤ğ‘         such that\nğ­[ğ‘—] = ByteDecodeâ‚â‚‚(ekPKE[384 â‹… ğ‘—, 384 â‹… (ğ‘— + 1)]) for each ğ‘— from 0 to ğ‘˜ âˆ’ 1.\n\n11"}
{"doc_id": "NIST.FIPS.203", "source_path": "data/raw_pdfs/NIST.FIPS.203.pdf", "page_number": 21, "text": "    FIPS 203                   MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\n\n    3.   Overview of the ML-KEM Scheme\n\n    This section gives a high-level overview of the ML-KEM scheme.\n\n    3.1  Key-Encapsulation Mechanisms\n    The following is a high-level overview of key-encapsulation mechanisms (KEMs). For details, see\n    SP 800-227 [1].\n    A KEM is a cryptographic scheme that, under certain conditions, can be used to establish a shared\n    secret key between two communicating parties. This shared secret key can then be used for\n    symmetric-key cryptography.\n    A KEM consists of three algorithms and a collection of parameter sets. The three algorithms are:\n     1.  A probabilistic key generation algorithm denoted by KeyGen\n     2.  A probabilistic â€encapsulationâ€ algorithm denoted by Encaps\n     3.  A deterministic â€decapsulationâ€ algorithm denoted by Decaps\n    The collection of parameter sets is used to select a trade-off between security and efficiency.\n    Each parameter set in the collection is a list of specific (typically numerical) values, one for each\n    parameter required by the three algorithms.\n                   Alice                                            Bob\n\n    KeyGen\n\n    decapsulation key    encapsulation key\n\n    Decaps    ciphertext    Encaps\n\nAliceâ€™s copy of the    Bobâ€™s copy of the\n shared secret key     shared secret key\n    ğ¾â€²      ğ¾\n\n    Figure 1. A simple view of key establishment using a KEM\n\n           12"}
{"doc_id": "NIST.FIPS.203", "source_path": "data/raw_pdfs/NIST.FIPS.203.pdf", "page_number": 22, "text": "FIPS 203                                  MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\n\nIn the typical application, a KEM is used to establish a shared secret key between two parties\n(here referred to as Alice and Bob) as described in Figure 1. Alice begins by running KeyGen in\norder to generate a (public) encapsulation key and a (private) decapsulation key. Upon obtaining\n  Aliceâ€™s encapsulation key, Bob runs the Encaps algorithm, which produces Bobâ€™s copy ğ¾ of the\nshared secret key along with an associated ciphertext. Bob sends the ciphertext to Alice, and\n  Alice completes the process by running the Decaps algorithm using her decapsulation key and\nthe ciphertext. This final step produces Aliceâ€™s copy ğ¾â€² of the shared secret key.\n After completing this process, Alice and Bob would like to conclude that their outputs satisfy\nğ¾â€² = ğ¾ and that this value is a secure, random, shared secret key. However, these properties\nonly hold if certain important conditions are satisfied, as discussed in SP 800-227 [1].\n\n3.2  The ML-KEM Scheme\nML-KEM is a key-encapsulation mechanism based on CRYSTALS-KYBER [4], a scheme that was\ninitially described in [8]. The following is a brief and informal description of the computational\nassumption underlying ML-KEM and how the ML-KEM scheme is constructed.\n\n     The computational assumption. The security of ML-KEM is based on the presumed hardness\nof the so-called Module Learning with Errors (MLWE) problem [9], which is a generalization of\nthe Learning With Errors (LWE) problem introduced by Regev in 2005 [10]. The hardness of the\nMLWE problem is itself based on the presumed hardness of certain computational problems in\nmodule lattices [9]. This motivates the name of the scheme ML-KEM.\nIn   the LWE problem, the input is a set of random â€œnoisyâ€ linear equations in some secret\nvariables ğ‘¥ âˆˆ â„¤ğ‘›, and the task is to recover ğ‘¥. The noise in the equations is such that standard\nalgorithms  ğ‘\n            (e.g., Gaussian elimination) are intractable. The LWE problem naturally lends itself to\ncryptographic applications. For example, if ğ‘¥ is interpreted as a secret key, then one can encrypt\na one-bit plaintext value by sampling either an approximately correct linear equation (if the\nplaintext is zero) or a far-from-correct linear equation (if the plaintext is one). Plausibly, only a\nparty in possession of ğ‘¥ can distinguish these two cases. Encryption can then be delegated to\nanother party by publishing a large collection of noisy linear equations, which can be combined\nappropriately by the encrypting party. The result is an asymmetric encryption scheme.\n  The MLWE problem is similar to the LWE problem. An important difference is that, in MLWE, â„¤ğ‘›\n                                                                                        ğ‘\nis replaced by a certain module ğ‘…ğ‘˜, which is constructed by taking the ğ‘˜-fold Cartesian product\nof a certain polynomial ring ğ‘…ğ‘ . Inğ‘particular, the secret in the MLWE problem is an element ğ± of\nthe module ğ‘…ğ‘˜. The ring ğ‘… is discussed in detail in Section 4.3.\n            ğ‘          ğ‘\n\n  The ML-KEM construction. At a high level, the construction of the scheme ML-KEM proceeds in\ntwo steps. First, the ideas discussed previously are used to construct a public-key encryption (PKE)\nscheme from the MLWE problem. Second, this PKE scheme is converted into a key-encapsulation\nmechanism using the so-called Fujisaki-Okamoto (FO) transform [11, 12]. Due to certain prop-\nerties of the FO transform, the resulting KEM provides security in a significantly more general\nattack model than the PKE scheme. As a result, ML-KEM is believed to satisfy so-called IND-CCA2\nsecurity [1, 4, 13, 14].\n\n                             13"}
{"doc_id": "NIST.FIPS.203", "source_path": "data/raw_pdfs/NIST.FIPS.203.pdf", "page_number": 23, "text": "FIPS 203                               MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\n\nThe specification of the ML-KEM algorithms in this standard will follow the same pattern. Specif-\nically, this standard will first describe a public-key encryption scheme called K-PKE (in Section 5)\nand then use the algorithms of K-PKE as subroutines when describing the algorithms of ML-KEM\n(in Sections 6 and 7). The cryptographic transformation from K-PKE to ML-KEM is crucial for\nachieving IND-CCA2 security. The scheme K-PKE is not IND-CCA2-secure and shall not be used as\na stand-alone scheme (see Section 3.3).\nA notable feature of ML-KEM is the use of the number-theoretic transform (NTT). The NTT\nconverts a polynomial ğ‘“ âˆˆ ğ‘…ğ‘ to an alternative representation as a vector ğ‘“ of linear polynomials.\nWorking with NTT representations enables significantly faster multiplication of polynomials.\nOther operations (e.g., addition, rounding, and sampling) can be done in either representation.\nML-KEM satisfies the essential KEM property of correctness. This means that in the absence\nof corruption or interference, the process in Figure 1 will result in ğ¾â€² = ğ¾ with overwhelming\nprobability. ML-KEM also comes with a proof of asymptotic theoretical security in a certain\nheuristic model [4]. Each of the parameter sets of ML-KEM comes with an associated security\nstrength that was estimated based on current cryptanalysis (see Section 8 for details).\n\nParameter sets and algorithms. Recall that a KEM consists of algorithms KeyGen, Encaps, and\nDecaps, along with a collection of parameter sets. In the case of ML-KEM, the three aforemen-\ntioned algorithms are:\n 1.  ML-KEM.KeyGen (Algorithm 19)\n 2.  ML-KEM.Encaps (Algorithm 20)\n 3.  ML-KEM.Decaps (Algorithm 21)\nThese algorithms are described and discussed in detail in Section 7.\nML-KEM comes equipped with three parameter sets:\n  â€¢ ML-KEM-512 (security category 1)\n  â€¢ ML-KEM-768 (security category 3)\n  â€¢ ML-KEM-1024 (security category 5)\nThese parameter sets are described and discussed in detail in Section 8. The security categories\n1-5 are defined in SP 800-57, Part 1 [7]. Each parameter set assigns a particular numerical value\nto five integer variables: ğ‘˜, ğœ‚â‚, ğœ‚â‚‚, ğ‘‘ğ‘¢, and ğ‘‘ğ‘£. The values of these variables in each parameter\nset are given in Table 2 of Section 8. In addition to these five variable parameters, there are also\ntwo constants: ğ‘› = 256 and ğ‘ = 3329.\n\nDecapsulation failures. Provided that all inputs are well-formed and randomness generation is\nsuccessful, the key establishment procedure of ML-KEM will never explicitly fail, meaning that\nboth ML-KEM.Encaps and ML-KEM.Decaps will each output a 256-bit value. Moreover, if no\ncorruption or interference is present, the two 256-bit values produced by ML-KEM.Encaps and\nML-KEM.Decaps will be equal with overwhelming probability (i.e., ğ¾â€² will equal ğ¾ in the process\ndescribed in Figure 1). The event that ğ¾â€² â‰  ğ¾ under these conditions is called a decapsulation\n\n                                       14"}
{"doc_id": "NIST.FIPS.203", "source_path": "data/raw_pdfs/NIST.FIPS.203.pdf", "page_number": 24, "text": "FIPS 203                            MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\n\nfailure. Formally, the decapsulation failure probability is defined to be the probability (conditioned\non no RGB failures) that the process\n\n                     1. (ek, dk) â† ML-KEM.KeyGen()                                          (3.1)\n                     2. (ğ‘, ğ¾) â† ML-KEM.Encaps(ek)                                        (3.2)\n                     3. ğ¾â€² â† ML-KEM.Decaps\n                                    (dk, ğ‘)                                                (3.3)\n\nresults in ğ¾â€² â‰  ğ¾. The probability is taken over uniformly random seeds ğ‘‘, ğ‘§ (sampled in\nML-KEM.KeyGen) and ğ‘š (sampled in ML-KEM.Encaps) and under the heuristic assumption that\nhash functions and XOFs behave like uniformly random functions. The decapsulation failure rates\nfor ML-KEM are listed in Table 1. For details, see Theorem 1 in [8] and the scripts in [15].\n\n                     Table 1. Decapsulation failure rates for ML-KEM\n\n                     Parameter set  Decapsulation failure rate\n                      ML-KEM-512             2âˆ’138.8\n                      ML-KEM-768             2âˆ’164.8\n                     ML-KEM-1024             2âˆ’174.8\n\nTerminology for keys. A KEM involves three different types of keys: encapsulation keys, de-\ncapsulation keys, and shared secret keys. ML-KEM is built on top of the component public-key\nencryption scheme K-PKE, which has two additional key types: encryption keys and decryption\nkeys. In the literature, encapsulation keys and encryption keys are sometimes referred to as\n  â€œpublic keys,â€ while decapsulation keys and decryption keys are sometimes referred to as â€œpri-\n  vate keys.â€ In order to reduce confusion, this standard will not use the terms â€œpublic keyâ€ or\nâ€œprivate key.â€ Instead, keys will be referred to only using the more specific terms, i.e., one of\n â€œencapsulation keyâ€, â€œdecapsulation keyâ€, â€œencryption keyâ€, â€œdecryption keyâ€, and â€œshared secret\nkeyâ€.\n\n3.3   Requirements for ML-KEM Implementations\n   This section describes several requirements for cryptographic modules that implement ML-KEM.\nImplementation requirements specific to particular algorithms will be described in later sections.\n    Additional requirements, including requirements for using ML-KEM in specific applications,\nare given in SP 800-227 [1]. While conforming implementations must adhere to all of these\nrequirements, adherence does not guarantee that the result will be secure (see Point 13 in the\nannouncement).\n\nK-PKE is only a component. The public-key encryption scheme K-PKE described in Section 5 shall\nnot be used as a stand-alone cryptographic scheme. Instead, the algorithms that comprise K-PKE\nmay only be used as subroutines in the algorithms of ML-KEM. In particular, the algorithms\nK-PKE.KeyGen (Algorithm 13), K-PKE.Encrypt (Algorithm 14), and K-PKE.Decrypt (Algorithm 15)\nare not approved for use as a public-key encryption scheme.\n\n                             15"}
{"doc_id": "NIST.FIPS.203", "source_path": "data/raw_pdfs/NIST.FIPS.203.pdf", "page_number": 25, "text": "FIPS 203    MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\n\nControlled access to internal functions. The key-encapsulation mechanism ML-KEM makes use\nof internal, â€œderandomizedâ€ functions ML-KEM.KeyGen_internal, ML-KEM.Encaps_internal, and\nML-KEM.Decaps_internal, specified in Section 6. The interfaces for these functions should not\nbe made available to applications other than for testing purposes. In particular, the sampling of\nrandom values required for key generation (as specified in ML-KEM.KeyGen) and encapsulation\n(as specified in ML-KEM.Encaps) shall be performed by the cryptographic module.\n\nEquivalent implementations. For every algorithm that is specified in this standard, a conforming\nimplementation may replace the given set of steps with any mathematically equivalent set of\nsteps. In other words, the specified algorithm may be replaced with a different procedure that\nproduces the correct output for every input (where â€œinputâ€ includes the specified input as well\nas all parameter values and all randomness).\n\n   Approved usage of the shared secret key. If randomness generation is successful, the values\nğ¾ and ğ¾â€² returned by ML-KEM.Encaps and ML-KEM.Decaps, respectively, are always 256-bit\nvalues. Under appropriate conditions (see Sections 3.1 and 3.2, and SP 800-227 [1]), these values\nmatch (i.e., ğ¾â€² = ğ¾) and can be used directly as a shared secret key for symmetric cryptography.\nIf further key derivation is needed, the final symmetric keys shall be derived from this 256-bit\nshared secret key in an approved manner, as specified in SP 800-108 and SP 800-56C [16, 17].\n      As discussed in Section 3.2, ML-KEM is an IND-CCA2-secure KEM. However, a combined KEM\nthat includes ML-KEM as a component might not meet IND-CCA2 security. Implementers should\nassess the security of any procedure in which the key derivation methods of SP 800-56C are\napplied to ML-KEM in combination with another key establishment procedure. More guidance\nregarding combined KEMs is given in SP 800-227 [1].\n\nRandomness generation. Two algorithms in this standard require the generation of randomness\nas an internal step:         ML-KEM.KeyGen and ML-KEM.Encaps. In pseudocode, this randomness\ngeneration is denoted by a statement of the form ğ‘š  $   ğ”¹Â³Â². A fresh string of random bytes\n                                                    â†\n                                                     âˆ’\nmust be generated for every such invocation. These random bytes shall be generated using an\napproved RBG, as prescribed in SP 800-90A, SP 800-90B, and SP 800-90C [18, 19, 20]. Moreover,\nthis RBG shall have a security strength of at least 128 bits for ML-KEM-512, at least 192 bits for\nML-KEM-768, and at least 256 bits for ML-KEM-1024.\n\nInput checking. The algorithms ML-KEM.Encaps and ML-KEM.Decaps require input checking.\nImplementers shall ensure that ML-KEM.Encaps and ML-KEM.Decaps are only executed on\ninputs that have been checked, as described in Section 7.\n\nDestruction of intermediate values.       Data used in intermediate computation steps of KEM\nalgorithms could be used by an adversary to compromise security. Therefore, implementers\nshall ensure that intermediate data is destroyed as soon as it is no longer needed. In particular,\nfor ML-KEM.KeyGen, ML-KEM.Encaps, and ML-KEM.Decaps, only the designated output can be\nretained in memory after the algorithm terminates. All other data shall be destroyed prior to\n                                                16"}
{"doc_id": "NIST.FIPS.203", "source_path": "data/raw_pdfs/NIST.FIPS.203.pdf", "page_number": 26, "text": "FIPS 203                              MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\n\nthe algorithm terminating.\nThere are two exceptions to this rule:\n 1.  The seed (ğ‘‘, ğ‘§) generated in steps 1 and 2 of ML-KEM.KeyGen can be stored for later\n     expansion using ML-KEM.KeyGen_internal.      As this seed can be used to compute the\n     decapsulation key, it is sensitive data and shall be treated with the same safeguards as a\n     decapsulation key (see SP 800-227 [1]).\n 2.  The matrix ğ€ generated in steps 3-7 of K-PKE.KeyGen (as a subroutine of ML-KEM.KeyGen)\n     can be stored so that it need not be recomputed in later operations (e.g., ML-KEM.Decaps).\n     The same matrix ğ€ is also generated in steps 4-8 of K-PKE.Encrypt (as a subroutine of\n     ML-KEM.Encaps or ML-KEM.Decaps); it can also then be stored. In either case, the matrix\n     ğ€ is data that is easily computed from the public encapsulation key and thus does not\n     require any special protections.\n\nNo floating-point arithmetic. Implementations of ML-KEM shall not use floating-point arithmetic,\nas rounding errors in floating-point operations may lead to incorrect results in some cases. In\nall pseudocode in this standard in which division is performed (e.g., ğ‘¥/ğ‘¦) and ğ‘¦ may not divide\nğ‘¥, either âŒŠğ‘¥/ğ‘¦âŒ‹, âŒˆğ‘¥/ğ‘¦âŒ‰, or âŒˆğ‘¥/ğ‘¦âŒ‹ is used. All of these can be computed without floating-point\narithmetic, as ordinary integer division ğ‘¥/ğ‘¦ computes âŒŠğ‘¥/ğ‘¦âŒ‹, and âŒˆğ‘¥/ğ‘¦âŒ‰ = âŒŠ(ğ‘¥ + ğ‘¦ âˆ’ 1)/ğ‘¦âŒ‹ for\nnon-negative integers ğ‘¥ and positive integers ğ‘¦.\n\n17"}
{"doc_id": "NIST.FIPS.203", "source_path": "data/raw_pdfs/NIST.FIPS.203.pdf", "page_number": 27, "text": "FIPS 203                                   MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\n\n4.   Auxiliary Algorithms\n\n4.1  Cryptographic Functions\nThe algorithms specified in this publication require the use of several cryptographic functions.\nEach function shall be instantiated by means of an approved hash function or an approved\neXtendable-Output Function (XOF), as prescribed below. The relevant hash functions and XOFs\nare described in detail in FIPS 202 [6]. They will be used as follows.\nSHA3-256 and SHA3-512 are hash functions with one variable-length input and one fixed-length\noutput.     In this standard, invocations of these functions on an input ğ‘€ will be denoted by\nSHA3-256(ğ‘€) and SHA3-512(ğ‘€), respectively. The inputs and outputs for both SHA3-256 and\nSHA3-512 are always byte arrays.\nSHAKE128 and SHAKE256 are XOFs with one variable-length input and one variable-length output.\nThis standard will adhere to the following conventions [6]:\n    â€¢ The inputs and outputs for both SHAKE128 and SHAKE256 are always byte arrays.\n    â€¢ When invoking SHAKE128 or SHAKE256, desired output length is always specified in bits.\nFor example, the expression\n                                ğ‘Ÿ âˆ¶= SHAKE128(ğ‘€ , 8 â‹… 64)                              (4.1)\nimplies that ğ‘€ is an array of bytes and that ğ‘Ÿ is an array of 64 bytes.\nThe aforementioned functions play several different roles in the algorithms specified in this\nstandard and will only be invoked using the wrapper functions defined below. Importantly, these\nwrappers will avoid any potential â€œbyte arrayâ€ versus â€œbit-lengthâ€ confusion by only working with\nbytes and byte array lengths.\n\nPseudorandom function (PRF). The function PRF takes a parameter ğœ‚ âˆˆ {2, 3}, one 32-byte\ninput, and one 1-byte input. It produces one (64 â‹… ğœ‚)-byte output. It will be denoted by\n\n                               PRF âˆ¶ {2, 3} Ã— ğ”¹Â³Â² Ã— ğ”¹ â†’ ğ”¹64ğœ‚ ,                           (4.2)\n\nand it shall be instantiated as\n\n                       PRFğœ‚(ğ‘ , ğ‘) âˆ¶= SHAKE256(ğ‘ â€–ğ‘, 8 â‹… 64 â‹… ğœ‚) ,                       (4.3)\n\nwhere ğœ‚ âˆˆ {2, 3}, ğ‘  âˆˆ ğ”¹Â³Â², and ğ‘ âˆˆ ğ”¹. Note that ğœ‚ is only used to specify the desired output\nlength and not to perform domain separation.\n\nHash functions. The specification will also make use of three hash functions H, J and G, which\nare defined as follows.\nThe functions H and J each take one variable-length input and produce one 32-byte output. They\nwill be denoted by H âˆ¶ ğ”¹âˆ— â†’ ğ”¹Â³Â² and J âˆ¶ ğ”¹âˆ— â†’ ğ”¹Â³Â², respectively, and shall be instantiated as\n\n            H(ğ‘ ) âˆ¶= SHA3-256(ğ‘ )          and  J(ğ‘ ) âˆ¶= SHAKE256(ğ‘ , 8 â‹… 32)                (4.4)\n                                           18"}
{"doc_id": "NIST.FIPS.203", "source_path": "data/raw_pdfs/NIST.FIPS.203.pdf", "page_number": 28, "text": "FIPS 203       MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\n\nwhere ğ‘  âˆˆ ğ”¹âˆ—.\nThe function G takes one variable-length input and produces two 32-byte outputs. It will be\ndenoted by G âˆ¶ ğ”¹âˆ— â†’ ğ”¹Â³Â² Ã— ğ”¹Â³Â². The two outputs of G will be denoted by (ğ‘, ğ‘) â† G(ğ‘), where\nğ‘, ğ‘ âˆˆ ğ”¹Â³Â², ğ‘ âˆˆ ğ”¹âˆ—, and G(ğ‘) = ğ‘â€–ğ‘. The function G shall be instantiated as\n\n               G(ğ‘) âˆ¶= SHA3-512(ğ‘) .                                             (4.5)\n\neXtendable-Output Function (XOF). This standard uses a XOF wrapper defined in terms of the\nincremental API for SHAKE128 in SP 800-185 [21]. This SHAKE128 API consists of three functions:\n     â€¢ ctx â† SHAKE128.Init()\n       Initializes a XOF â€œcontextâ€ ctx.\n     â€¢ ctx â† SHAKE128.Absorb(ctx, str)\n       Injects data to be used in the â€œabsorbingâ€ phase of SHAKE128 and updates the context\n       accordingly.\n     â€¢ (ctx, ğµ) â† SHAKE128.Squeeze(ctx, 8 â‹… ğ‘§)\n       Extracts ğ‘§ output bytes produced during the â€œsqueezingâ€ phase of SHAKE128 and updates\n       the context accordingly.\nWhile the above functions are constructed using the Keccak-ğ‘“ permutation rather than the XOF\nSHAKE128 directly, they are defined so that a single SHAKE128 call of the form\n\n                   output â† SHAKE128(strâ‚â€– â€¦ â€–strğ‘š , 8ğ‘â‚ + â€¦ + 8ğ‘â„“)        (4.6)\n\nis equivalent to performing Algorithm 2. This equivalence holds whether or not |strğ‘– | and ğ‘ğ‘— are\nmultiples of the SHAKE128 block length.\n\nAlgorithm 2 SHAKE128example(strâ‚, â€¦ , strğ‘š , ğ‘â‚, â€¦ , ğ‘â„“)\nPerforms a sequence of absorbing operations followed by a sequence of squeezing operations.\nInput: byte arrays strâ‚, â€¦ , strğ‘š .\nInput: positive integers ğ‘â‚, â€¦ , ğ‘â„“. â„“  ğ‘ .\nOutput: a byte array of length âˆ‘ğ‘—=1      ğ‘—\n 1:   ctx â† SHAKE128.Init()                                               â–· initialize context\n 2:   for (ğ‘– â† 1; ğ‘– â‰¤ ğ‘š; ğ‘– ++)\n 3:   endctx â† SHAKE128.Absorb(ctx, strğ‘– )                â–· absorb byte array strğ‘–\n 4:    for\n 5:   for (ğ‘— â† 1; ğ‘— â‰¤ â„“; ğ‘— ++)\n 6:   end(ctx, outğ‘—) â† SHAKE128.Squeeze(ctx, 8 â‹… ğ‘ğ‘—)    â–· squeeze ğ‘ğ‘—-many bytes\n 7:    for\n 8:   output â† outâ‚â€– â€¦ â€–outâ„“                    â–· return the concatenation of all the results\n\nIn this standard, the incremental API for SHAKE128 will only be invoked through a wrapper XOF,\n                                               19"}
{"doc_id": "NIST.FIPS.203", "source_path": "data/raw_pdfs/NIST.FIPS.203.pdf", "page_number": 29, "text": "FIPS 203                                                  MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\n\nwhich is defined as follows.\n  1.    XOF.Init() = SHAKE128.Init().\n  2.    XOF.Absorb(ctx, str) = SHAKE128.Absorb(ctx, str).\n  3.    XOF.Squeeze(ctx, â„“) = SHAKE128.Squeeze(ctx, 8 â‹… â„“).\nNote that XOF.Squeeze requires the input length to be specified in bytes. This is consistent with\nthe convention that all wrapper functions treat inputs and outputs as byte arrays and measure\nthe lengths of all such arrays in terms of bytes.\n\n4.2     General Algorithms\nThis section specifies a number of algorithms that will be used as subroutines in ML-KEM.\n\n4.2.1       Conversion and Compression Algorithms\nThis section specifies several algorithms for converting between bit arrays, byte arrays, and arrays\nof integers modulo ğ‘š. It also specifies a certain operation for compressing integers modulo ğ‘,\nand the corresponding decompression operation.\n\nAlgorithm 3 BitsToBytes(ğ‘)\nConverts a bit array (of a length that is a multiple of eight) into an array of bytes.\nInput: bit array ğ‘ âˆˆ {0, 1}8â‹…â„“.\nOutput: byte array ğµ âˆˆ ğ”¹â„“.\n 1:    ğµ â† (0, â€¦ , 0)\n 2:    for (ğ‘– â† 0; ğ‘– < 8â„“; ğ‘– ++)\n 3:         ğµ [âŒŠğ‘–/8âŒ‹] â† ğµ [âŒŠğ‘–/8âŒ‹] + ğ‘[ğ‘–] â‹… 2ğ‘– mod 8\n 4:    end for\n 5:    return ğµ\n\nAlgorithm 4 BytesToBits(ğµ)\nPerforms the inverse of BitsToBytes, converting a byte array into a bit array.\nInput: byte array ğµ âˆˆ ğ”¹â„“.\nOutput: bit array ğ‘ âˆˆ {0, 1}8â‹…â„“.\n 1:    ğ¶ â† ğµ                                             â–· copy ğµ into array ğ¶ âˆˆ ğ”¹â„“\n 2:    for (ğ‘– â† 0; ğ‘– < â„“; ğ‘– ++)\n 3:      for (ğ‘— â† 0; ğ‘— < 8; ğ‘— ++)\n 4:         ğ‘[8ğ‘– + ğ‘—] â† ğ¶[ğ‘–] mod 2\n 5:         ğ¶[ğ‘–] â† âŒŠğ¶[ğ‘–]/2âŒ‹\n 6:      end for\n 7:    end for\n 8:    return ğ‘\n\n20"}
{"doc_id": "NIST.FIPS.203", "source_path": "data/raw_pdfs/NIST.FIPS.203.pdf", "page_number": 30, "text": "FIPS 203                                 MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\n\nConverting between bits and bytes. The algorithms BitsToBytes (Algorithm 3) and BytesToBits\n(Algorithm 4) convert between bit arrays and byte arrays. The inputs to BitsToBytes and the\noutputs of BytesToBits are bit arrays, with each segment of eight bits representing a byte in\nlittle-endian order. As an example, the 8-bit string 11010001 corresponds to the byte 2â° + 2Â¹ +\n2Â³ + 2â· = 139.\n\nCompression and decompression. Recall that ğ‘ = 3329, and that the bit length of ğ‘ is 12. For\nğ‘‘ < 12, define\n\n                               Compressğ‘‘ âˆ¶ â„¤ğ‘ âŸ¶ â„¤â‚‚ğ‘‘                                       (4.7)\n                               ğ‘¥ âŸ¼ âŒˆ(2ğ‘‘/ğ‘) â‹… ğ‘¥âŒ‹ mod 2ğ‘‘ .\n                      Decompressğ‘‘ âˆ¶ â„¤â‚‚ğ‘‘ âŸ¶ â„¤ğ‘                                              (4.8)\n                               ğ‘¦ âŸ¼ âŒˆ(ğ‘/2ğ‘‘) â‹… ğ‘¦âŒ‹ .\n\nThe input and output types of these functions are integers modulo ğ‘š (see Section 2.4.1). Division\nand rounding in the computation of these functions are performed in the set of rational numbers.\nFloating-point computations shall not be used.\nThe Compress and Decompress algorithms satisfy two important properties. First, decompression\nfollowed by compression preserves the input.  That is, Compressğ‘‘(Decompressğ‘‘(ğ‘¦)) = ğ‘¦ for\nall ğ‘¦ âˆˆ â„¤â‚‚ğ‘‘ and all ğ‘‘ < 12. Second, if ğ‘‘ is large (i.e., close to 12), compression followed by\ndecompression does not significantly alter the value.\n\nEncoding and decoding. The algorithms ByteEncode (Algorithm 5) and ByteDecode (Algorithm\n6) will be used for conversion between integers modulo ğ‘š and bytes. The algorithm ByteEncode\nconverts an array of ğ‘› = 256 integers modulo ğ‘š into a corresponding array of bytes. ByteDecode\nperforms the inverse operation, converting an array of bytes into an array of integers modulo ğ‘š.\nSpecifying the modulus ğ‘š is done as described below.\nFor the following description, it is convenient to view ByteDecode and ByteEncode as converting\nbetween integers and bits. The conversion between bits and bytes is straightforward and done\nusing BitsToBytes and BytesToBits. The valid range of values for the parameter ğ‘‘ is 1 â‰¤ ğ‘‘ â‰¤ 12.\nBit arrays are divided into ğ‘‘-bit segments. The operations are performed in two different ways,\ndepending on the value of ğ‘‘:\n    â€¢ For ğ‘‘ satisfying 1 â‰¤ ğ‘‘ â‰¤ 11, the conversion is one-to-one. ByteDecodeğ‘‘ converts each\n    ğ‘‘-bit segment of its input into one integer modulo 2ğ‘‘, while ByteEncodeğ‘‘ performs the\n    inverse operation.\n      â€¢ For ğ‘‘ = 12, ByteDecodeâ‚â‚‚ produces integers modulo ğ‘ as output, while ByteEncodeâ‚â‚‚\n    receives integers modulo ğ‘ as input. Specifically, ByteDecodeâ‚â‚‚ converts each 12-bit\n    segment of its input into an integer modulo 2Â¹Â² = 4096 and then reduces the result\n    modulo ğ‘. This is no longer a one-to-one operation. Indeed, some 12-bit segments could\n    correspond to an integer greater than ğ‘ âˆ’ 1 = 3328 but less than 4096. However, this\n    cannot occur for arrays produced by ByteEncodeâ‚â‚‚. These aspects of ByteDecodeâ‚â‚‚ and\n\n                                          21"}
{"doc_id": "NIST.FIPS.203", "source_path": "data/raw_pdfs/NIST.FIPS.203.pdf", "page_number": 31, "text": "FIPS 203                                                 MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\n\n        ByteEncodeâ‚â‚‚ will be important when considering checking of the ML-KEM encapsulation\n        key in Section 7.\n\nAlgorithm 5 ByteEncodeğ‘‘(ğ¹ )\nEncodes an array of ğ‘‘-bit integers into a byte array for 1 â‰¤ ğ‘‘ â‰¤ 12.\nInput: integer array ğ¹ âˆˆ â„¤Â²âµâ¶, where ğ‘š = 2ğ‘‘ if ğ‘‘ < 12, and ğ‘š = ğ‘ if ğ‘‘ = 12.\n                           ğ‘š\nOutput: byte array ğµ âˆˆ ğ”¹32ğ‘‘.\n 1:    for (ğ‘– â† 0; ğ‘– < 256; ğ‘– ++)\n 2:      ğ‘ â† ğ¹ [ğ‘–]            ++)                                              â–· ğ‘ âˆˆ â„¤ğ‘š\n 3:      for (ğ‘— â† 0; ğ‘— < ğ‘‘; ğ‘—\n 4:           ğ‘[ğ‘– â‹… ğ‘‘ + ğ‘—] â† ğ‘ mod 2                                         â–· ğ‘ âˆˆ {0, 1}256â‹…ğ‘‘\n 5:           ğ‘ â† (ğ‘ âˆ’ ğ‘[ğ‘– â‹… ğ‘‘ + ğ‘—])/2             â–· note ğ‘ âˆ’ ğ‘[ğ‘– â‹… ğ‘‘ + ğ‘—] is always even\n 6:      end for\n 7:    end for\n 8:    ğµ â† BitsToBytes(ğ‘)\n 9:    return ğµ\n\nAlgorithm 6 ByteDecodeğ‘‘(ğµ)\nDecodes a byte array into an array of ğ‘‘-bit integers for 1 â‰¤ ğ‘‘ â‰¤ 12.\nInput: byte array ğµ âˆˆ ğ”¹32ğ‘‘.\nOutput: integer array ğ¹ âˆˆ â„¤Â²âµâ¶, where ğ‘š = 2ğ‘‘ if ğ‘‘ < 12 and ğ‘š = ğ‘ if ğ‘‘ = 12.\n                                 ğ‘š\n 1:    ğ‘ â† BytesToBits(ğµ)\n 2:    for (ğ‘– â† 0; ğ‘– < 256; ğ‘– ++)\n 3:         ğ¹ [ğ‘–] â† âˆ‘ğ‘‘âˆ’1 ğ‘[ğ‘– â‹… ğ‘‘ + ğ‘—] â‹… 2ğ‘— mod ğ‘š\n 4:    end for           ğ‘—â†0\n 5:    return ğ¹\n\n4.2.2       Sampling Algorithms\nThe algorithms of ML-KEM require two sampling subroutines that are specified in Algorithms 7\nand 8. Both of these algorithms can be used to convert a stream of uniformly random bytes into\na sample from some desired distribution. In this standard, these algorithms will be invoked with\na stream of pseudorandom bytes as the input. It follows that the output will then be a sample\nfrom a distribution that is computationally indistinguishable from the desired distribution.\n\nUniform sampling of NTT representations. The algorithm SampleNTT (Algorithm 7) converts\na seed together with two indexing bytes into a polynomial in the NTT domain. If the seed is\nuniformly random, the resulting polynomial will be drawn from a distribution that is computa-\ntionally indistinguishable from the uniform distribution on ğ‘‡ğ‘ . The output of SampleNTT is an\narray in â„¤Â²âµâ¶ that contains the coefficients of the sampled element of ğ‘‡ (see Section 2.4.4). See\nAppendixğ‘                                                            ğ‘\n            B for a note on (optionally) safely bounding the algorithmâ€™s while-loop iterations.\n\n                                                         22"}
{"doc_id": "NIST.FIPS.203", "source_path": "data/raw_pdfs/NIST.FIPS.203.pdf", "page_number": 32, "text": "FIPS 203                                      MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\n\nAlgorithm 7 SampleNTT(ğµ)\nTakes a 32-byte seed and two indices as input and outputs a pseudorandom element of ğ‘‡ğ‘ .\nInput: byte array ğµ âˆˆ ğ”¹Â³â´.                  â–· a 32-byte seed along with two indices\nOutput: array ğ‘ âˆˆ â„¤Â²âµâ¶.                        â–· the coefficients of the NTT of a polynomial\n                 ğ‘\n 1:    ctx â† XOF.Init()\n 2:    ctx â† XOF.Absorb(ctx, ğµ)                        â–· input the given byte array into XOF\n 3:    ğ‘— â† 0\n 4:    while ğ‘— < 256 do\n 5:     (ctx, ğ¶) â† XOF.Squeeze(ctx, 3)                 â–· get a fresh 3-byte array ğ¶ from XOF\n 6:     ğ‘‘â‚ â† ğ¶[0] + 256 â‹… (ğ¶[1] mod 16)                                     â–· 0 â‰¤ ğ‘‘â‚ < 2Â¹Â²\n 7:     ğ‘‘â‚‚ â† âŒŠğ¶[1]/16âŒ‹ + 16 â‹… ğ¶[2]                                          â–· 0 â‰¤ ğ‘‘â‚‚ < 2Â¹Â²\n 8:     if ğ‘‘â‚ < ğ‘ then                                                                  256\n 9:          ğ‘[ğ‘—] â† ğ‘‘â‚                     â–· ğ‘ âˆˆ â„¤ğ‘\n10:          ğ‘— â† ğ‘— + 1\n11:     end if\n12:     if ğ‘‘â‚‚ < ğ‘ and ğ‘— < 256 then\n13:          ğ‘[ğ‘—] â† ğ‘‘â‚‚\n14:          ğ‘— â† ğ‘— + 1\n15:     end if\n16:    end while\n17:    return ğ‘Ì‚\n\nSampling from the centered binomial distribution. ML-KEM makes use of a special distribution\nDğœ‚(ğ‘…ğ‘ ) of polynomials in ğ‘…ğ‘ with small coefficients. Such polynomials are sometimes referred\nto as â€œerrorsâ€ or â€œnoise.â€ The distribution is parameterized by an integer ğœ‚ âˆˆ {2, 3}. To sample a\npolynomial from Dğœ‚(ğ‘…ğ‘ ), each of its coefficients is independently sampled from a certain cen-\ntered binomial distribution (CBD) on â„¤ğ‘ . The algorithm SamplePolyCBD (Algorithm 8) samples\nthe coefficient array of a polynomial ğ‘“ âˆˆ ğ‘…ğ‘ according to the distribution Dğœ‚(ğ‘…ğ‘ ), provided that\n\nAlgorithm 8 SamplePolyCBDğœ‚(ğµ)\nTakes a seed as input and outputs a pseudorandom sample from the distribution Dğœ‚(ğ‘…ğ‘ ).\nInput: byte array ğµ âˆˆ ğ”¹64ğœ‚ .\nOutput: array ğ‘“ âˆˆ â„¤Â²âµâ¶.                  â–· the coefficients of the sampled polynomial\n                ğ‘\n 1:    ğ‘ â† BytesToBits(ğµ)\n 2:    for (ğ‘– â† 0; ğ‘– < 256; ğ‘– ++)\n 3:     ğ‘¥ â† âˆ‘ğœ‚âˆ’1 ğ‘[2ğ‘–ğœ‚ + ğ‘—]         â–· 0 â‰¤ ğ‘¥ â‰¤ ğœ‚\n                ğ‘—â†0\n 4:     ğ‘¦ â† âˆ‘ğœ‚âˆ’1 ğ‘[2ğ‘–ğœ‚ + ğœ‚ + ğ‘—]    â–· 0 â‰¤ ğ‘¦ â‰¤ ğœ‚\n                ğ‘—â†0\n 5:     ğ‘“[ğ‘–] â† ğ‘¥ âˆ’ ğ‘¦ mod ğ‘           â–· 0 â‰¤ ğ‘“[ğ‘–] â‰¤ ğœ‚ or ğ‘ âˆ’ ğœ‚ â‰¤ ğ‘“[ğ‘–] â‰¤ ğ‘ âˆ’ 1\n 6:    end for\n 7:    return ğ‘“\n\n                                          23"}
{"doc_id": "NIST.FIPS.203", "source_path": "data/raw_pdfs/NIST.FIPS.203.pdf", "page_number": 33, "text": "FIPS 203                          MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\n\nits input is a stream of uniformly random bytes.\n\n4.3  The Number-Theoretic Transform\n   The Number-Theoretic Transform (NTT) can be viewed as a specialized, exact version of the\ndiscrete Fourier transform. In the case of ML-KEM, the NTT is used to improve the efficiency of\nmultiplication in the ring ğ‘…ğ‘ . Recall that ğ‘…ğ‘ is the ring â„¤ğ‘ [ğ‘‹]/(ğ‘‹ğ‘› + 1) of polynomials of the\nform ğ‘“ = ğ‘“â‚€ + ğ‘“â‚ğ‘‹ + â‹¯ + ğ‘“â‚‚â‚…â‚…ğ‘‹Â²âµâµ (where ğ‘“ğ‘— âˆˆ â„¤ğ‘ for all ğ‘—), with the ring operations defined\nby arithmetic modulo ğ‘‹ğ‘› + 1.\nThe ring ğ‘…ğ‘ is isomorphic to another ring ğ‘‡ğ‘ , which is a direct sum of 128 quadratic extensions\nof â„¤ğ‘ . The NTT is a computationally efficient isomorphism between these two rings. When a\npolynomial ğ‘“ âˆˆ ğ‘…ğ‘ is input, the NTT outputs an element ğ‘“ âˆ¶= NTT(ğ‘“) of the ring ğ‘‡ğ‘ , where ğ‘“ is\ncalled the â€œNTT representationâ€ of ğ‘“. The isomorphism property implies that\n\n                                   ğ‘“ Ã—ğ‘…ğ‘ ğ‘” = NTTâˆ’1(ğ‘“ Ã—ğ‘‡ğ‘ ğ‘”),                           (4.9)\n\n  where Ã—ğ‘…ğ‘ and Ã—ğ‘‡ğ‘ denote multiplication in ğ‘…ğ‘ and ğ‘‡ğ‘ , respectively. Moreover, since ğ‘‡ğ‘ is a\nproduct of 128 rings that each consist of polynomials of degree at most one, the operation Ã—ğ‘‡ğ‘\nis much more efficient than the operation Ã—ğ‘…ğ‘ . For these reasons, the NTT is considered to be\nan integral part of ML-KEM and not merely an optimization.\n As the rings ğ‘…ğ‘ and ğ‘‡ğ‘ have a vector space structure over â„¤ğ‘ , the most natural abstract data\ntype to represent elements from either of these rings is â„¤ğ‘›. For this reason, the choice of data\n                                                   ğ‘\nstructure for the inputs and outputs of NTT and NTTâˆ’1 are length-ğ‘› arrays of integers modulo\nğ‘. These arrays are understood to represent elements of ğ‘‡ğ‘ or ğ‘…ğ‘ , respectively (see Section\n2.4.4). Algorithms 9 and 10 describe an efficient means of computing NTT and NTTâˆ’1 in place.\nHowever, to clarify the distinction between the algebraic objects before and after the conversion,\nthe algorithms are written with explicit inputs and outputs. This is consistent with this standardâ€™s\nconvention that all inputs are passed by copy.\n\n    The mathematical structure of the NTT. In ML-KEM, ğ‘ is the prime 3329 = 2â¸ â‹… 13 + 1, and\nğ‘› = 256. There are 128 primitive 256-th roots of unity and no primitive 512-th roots of unity in\nâ„¤ğ‘ . Note that ğœ = 17 âˆˆ â„¤ğ‘ is a primitive 256-th root of unity modulo ğ‘. Thus, ğœ 128 â‰¡ âˆ’1.\nDefine BitRevâ‚‡ (ğ‘–) to be the integer represented by bit-reversing the unsigned 7-bit value that\ncorresponds to the input integer ğ‘– âˆˆ {0, â€¦ , 127}.\nThe polynomial ğ‘‹Â²âµâ¶ + 1 factors into 128 polynomials of degree 2 modulo ğ‘ as follows:\n\n                              127\n                             ğ‘‹Â²âµâ¶ + 1 = âˆ (ğ‘‹Â² âˆ’ ğœ 2BitRevâ‚‡(ğ‘–)+1) .                         (4.10)\n                              ğ‘–=0\n\n  Therefore, ğ‘…ğ‘ âˆ¶= â„¤ğ‘ [ğ‘‹]/(ğ‘‹Â²âµâ¶ + 1) is isomorphic to a direct sum of 128 quadratic extension\n\n24"}
{"doc_id": "NIST.FIPS.203", "source_path": "data/raw_pdfs/NIST.FIPS.203.pdf", "page_number": 34, "text": "FIPS 203                             MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\n\nfields of â„¤ğ‘ , denoted ğ‘‡ğ‘ . Specifically, this ring has the structure\n\n                                 127\n                               ğ‘‡ğ‘ âˆ¶= â¨ â„¤ğ‘ [ğ‘‹]/ (ğ‘‹Â² âˆ’ ğœ 2BitRevâ‚‡(ğ‘–)+1) .                    (4.11)\n                                 ğ‘–=0\n\n    Thus, the NTT representation ğ‘“ âˆˆ ğ‘‡ğ‘ of a polynomial ğ‘“ âˆˆ ğ‘…ğ‘ is the vector that consists of the\ncorresponding residues of degree at most one:\n\n              ğ‘“ âˆ¶= (ğ‘“ mod (ğ‘‹Â² âˆ’ ğœ 2BitRevâ‚‡(0)+1), â€¦ , ğ‘“ mod (ğ‘‹Â² âˆ’ ğœ 2BitRevâ‚‡(127)+1)) .    (4.12)\n\n    As discussed in Section 2.4.4, the algorithms in this standard represent ğ‘“ as an array of 256\nintegers modulo ğ‘. Specifically,\n\n                     ğ‘“ mod (ğ‘‹Â² âˆ’ ğœ 2BitRevâ‚‡(ğ‘–)+1) = ğ‘“[2ğ‘–] + ğ‘“[2ğ‘– + 1]ğ‘‹,                  (4.13)\n\nfor ğ‘– from 0 to 127.\n\n      The ML-KEM NTT algorithms. An algorithm for the ML-KEM NTT is described in Algorithm 9. An\n    algorithm for the inverse operation (NTTâˆ’1) is described in Algorithm 10. These two algorithms\n     will be used to transform elements of ğ‘…ğ‘ to elements of ğ‘‡ğ‘ (using NTT) and vice versa (using\nNTTâˆ’1). In addition, as discussed in Section 2.4.8, these algorithms represent the coordinate-\n   wise transformation of structures over those rings. Specifically, they map matrices/vectors with\n    entries in ğ‘…ğ‘ to matrices/vectors with entries in ğ‘‡ğ‘ (using NTT) and vice versa (using NTTâˆ’1).\nThe values ğœ BitRevâ‚‡(ğ‘–) mod ğ‘ for ğ‘– = 1, â€¦ , 127 used in line 5 of Algorithm 9 and line 5 of Algorithm\n10 may be precomputed into an array. This array is given in Appendix A.\n\n25"}
{"doc_id": "NIST.FIPS.203", "source_path": "data/raw_pdfs/NIST.FIPS.203.pdf", "page_number": 35, "text": "FIPS 203                                       MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\n\nAlgorithm 9 NTT(ğ‘“)\nComputes the NTT representation ğ‘“ of the given polynomial ğ‘“ âˆˆ ğ‘…ğ‘ .\nInput: array ğ‘“ âˆˆ â„¤Â²âµâ¶.                                    â–· the coefficients of the input polynomial\n                   ğ‘\nOutput: array ğ‘“ âˆˆ â„¤Â²âµâ¶.                       â–· the coefficients of the NTT of the input polynomial\n                         ğ‘\n 1:    ğ‘“ â† ğ‘“                                 â–· will compute in place on a copy of input array\n 2:    ğ‘– â† 1\n 3:    for (len â† 128; len â‰¥ 2; len â† len/2)\n 4:     for (start â† 0; start < 256; start â† start + 2 â‹… len)\n 5:               zeta â† ğœ BitRevâ‚‡(ğ‘–) mod ğ‘\n 6:               ğ‘– â† ğ‘– + 1\n 7:               for (ğ‘— â† start; ğ‘— < start + len; ğ‘— ++)\n 8:                ğ‘¡ â† zeta â‹… ğ‘“[ğ‘— + len]                  â–· steps 8-10 done modulo ğ‘\n 9:                ğ‘“[ğ‘— + len] â† ğ‘“[ğ‘—] âˆ’ ğ‘¡\n10:                ğ‘“[ğ‘—] â† ğ‘“[ğ‘—] + ğ‘¡\n11:               end for\n12:     end for\n13:    end for\n14:    return ğ‘“\n\nAlgorithm 10 NTTâˆ’1(ğ‘“)\nComputes the polynomial ğ‘“ âˆˆ ğ‘…ğ‘ that corresponds to the given NTT representation ğ‘“ âˆˆ ğ‘‡ğ‘ .\nInput: array ğ‘“ âˆˆ â„¤Â²âµâ¶.                                   â–· the coefficients of input NTT representation\n                   ğ‘\nOutput: array ğ‘“ âˆˆ â„¤Â²âµâ¶.                              â–· the coefficients of the inverse NTT of the input\n                         ğ‘\n 1:    ğ‘“ â† ğ‘“                                   â–· will compute in place on a copy of input array\n 2:    ğ‘– â† 127\n 3:    for (len â† 2; len â‰¤ 128; len â† 2 â‹… len)\n 4:     for (start â† 0; start < 256; start â† start + 2 â‹… len)\n 5:               zeta â† ğœ BitRevâ‚‡(ğ‘–) mod ğ‘\n 6:               ğ‘– â† ğ‘– âˆ’ 1\n 7:               for (ğ‘— â† start; ğ‘— < start + len; ğ‘— ++)\n 8:                ğ‘¡ â† ğ‘“[ğ‘—]\n 9:                ğ‘“[ğ‘—] â† ğ‘¡ + ğ‘“[ğ‘— + len]                â–· steps 9-10 done modulo ğ‘\n10:                ğ‘“[ğ‘— + len] â† zeta â‹… (ğ‘“[ğ‘— + len] âˆ’ ğ‘¡)\n11:               end for\n12:     end for\n13:    end for\n14:    ğ‘“ â† ğ‘“ â‹… 3303 mod ğ‘                               â–· multiply every entry by 3303 â‰¡ 128âˆ’1 mod ğ‘\n15:    return ğ‘“\n\n26"}
{"doc_id": "NIST.FIPS.203", "source_path": "data/raw_pdfs/NIST.FIPS.203.pdf", "page_number": 36, "text": "FIPS 203                                    MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\n\n4.3.1       Multiplication in the NTT Domain\nThe addition and scalar multiplication of elements of ğ‘‡ğ‘ can be done using the corresponding\ncoordinate-wise arithmetic operations on the coefficient arrays (see Section 2.4.5). This section\ndescribes how to do the remaining ring operation (i.e., multiplication in ğ‘‡ğ‘ ).\n\nRecall from (4.12) that ğ‘“ âˆˆ ğ‘‡ğ‘ is a vector of 128 degree-one residues modulo quadratic polyno-\nmials. Algebraically, multiplication in the ring ğ‘‡ğ‘ consists of independent multiplication in each\nof the 128 coordinates with respect to the quadratic modulus of that coordinate. Specifically,\nthe ğ‘–-th coordinate in ğ‘‡ğ‘ of the product â„ = ğ‘“ Ã—ğ‘‡ğ‘ ğ‘”Ì‚ is determined by the calculation\n\n â„[2ğ‘–] + â„[2ğ‘– + 1]ğ‘‹ = (ğ‘“[2ğ‘–] + ğ‘“[2ğ‘– + 1]ğ‘‹)(ğ‘”[2ğ‘–] + ğ‘”[2ğ‘– + 1]ğ‘‹) mod (ğ‘‹Â² âˆ’ ğœ 2BitRevâ‚‡(ğ‘–)+1).\n                                                                                             (4.14)\n\nAlgorithm 11 MultiplyNTTs(ğ‘“, ğ‘”)\nComputes the product (in the ring ğ‘‡ğ‘ ) of two NTT representations.\nInput: Two arrays ğ‘“ âˆˆ â„¤Â²âµâ¶ and ğ‘” âˆˆ â„¤Â²âµâ¶.           â–· the coefficients of two NTT representations\n                            ğ‘           ğ‘\nOutput: An array â„ âˆˆ â„¤Â²âµâ¶.                           â–· the coefficients of the product of the inputs\n                            ğ‘\n 1:  for (ğ‘– â† 0; ğ‘– < 128; ğ‘– ++)\n 2:         (â„[2ğ‘–], â„[2ğ‘– + 1]) â† BaseCaseMultiply(ğ‘“[2ğ‘–], ğ‘“[2ğ‘– + 1], ğ‘”[2ğ‘–], ğ‘”[2ğ‘– + 1], ğœ 2BitRevâ‚‡(ğ‘–)+1)\n 3:  end for\n 4:  return â„\n\nThus, one can compute the product of two elements of ğ‘‡ğ‘ using the algorithm MultiplyNTTs (Al-\ngorithm 11), which uses BaseCaseMultiply (Algorithm 12) as a subroutine. The values ğœ 2BitRevâ‚‡(ğ‘–)+1\nused in Algorithm 11 may be precomputed and stored in an array (see Appendix A). MultiplyNTTs\nalso enables linear-algebraic arithmetic with matrices and vectors whose entries are in ğ‘‡ğ‘ (see\nSection 2.4.7).\n\nAlgorithm 12 BaseCaseMultiply(ğ‘â‚€, ğ‘â‚, ğ‘â‚€, ğ‘â‚, ğ›¾)\nComputes the product of two degree-one polynomials with respect to a quadratic modulus.\nInput: ğ‘â‚€, ğ‘â‚, ğ‘â‚€, ğ‘â‚ âˆˆ â„¤ğ‘ .                    â–· the coefficients of ğ‘â‚€ + ğ‘â‚ğ‘‹ and ğ‘â‚€ + ğ‘â‚ğ‘‹\nInput: ğ›¾ âˆˆ â„¤ğ‘ .                                                   â–· the modulus is ğ‘‹Â² âˆ’ ğ›¾\nOutput: ğ‘â‚€, ğ‘â‚ âˆˆ â„¤ğ‘ .                 â–· the coefficients of the product of the two polynomials\n 1:  ğ‘â‚€ â† ğ‘â‚€ â‹… ğ‘â‚€ + ğ‘â‚ â‹… ğ‘â‚ â‹… ğ›¾                               â–· steps 1-2 done modulo ğ‘\n 2:  ğ‘â‚ â† ğ‘â‚€ â‹… ğ‘â‚ + ğ‘â‚ â‹… ğ‘â‚€\n 3:  return (ğ‘â‚€, ğ‘â‚)\n\n27"}
{"doc_id": "NIST.FIPS.203", "source_path": "data/raw_pdfs/NIST.FIPS.203.pdf", "page_number": 37, "text": "FIPS 203                              MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\n\n5.   The K-PKE Component Scheme\n\n        This section describes the component scheme K-PKE. As discussed in Section 3.3, K-PKE is not\napproved for use in a stand-alone fashion. It serves only as a collection of subroutines for use in\nthe algorithms of the approved scheme ML-KEM, as described in Section 7.\nK-PKE consists of three algorithms:\n 1.  Key generation (K-PKE.KeyGen)\n 2.  Encryption (K-PKE.Encrypt)\n 3.  Decryption (K-PKE.Decrypt)\n        When K-PKE is instantiated as part of ML-KEM, K-PKE inherits the parameter set selected for\nML-KEM. Each parameter set specifies numerical values for each parameter. While ğ‘› is always\n256 and ğ‘ is always 3329, the values of the remaining parameters ğ‘˜, ğœ‚â‚, ğœ‚â‚‚, ğ‘‘ğ‘¢, and ğ‘‘ğ‘£ vary\namong the three parameter sets. Parameters and parameter sets are described in Section 8.\n     The algorithms in this section do not perform any input checking because they are only invoked as\nsubroutines of the main ML-KEM algorithms. The algorithms of ML-KEM themselves do perform\ninput checking as needed.\nEach of the algorithms of K-PKE is accompanied by a brief, informal description in text. For\nsimplicity, this description is written in terms of vectors and matrices whose entries are elements\nof ğ‘…ğ‘ . In the actual algorithm, most of the computations occur in the NTT domain in order to\nimprove the efficiency of multiplication. The relevant vectors and matrices will then have entries\nin ğ‘‡ğ‘ . Linear-algebraic arithmetic with such vectors and matrices (e.g., line 18 of K-PKE.KeyGen)\nis performed as described in Sections 2.4.7 and 4.3.1. The encryption and decryption keys of\nK-PKE are also stored in the NTT form.\n\n5.1  K-PKE Key Generation\n       The key generation algorithm K-PKE.KeyGen of K-PKE (Algorithm 13) receives a seed as input and\noutputs an encryption key ekPKE and a decryption key dkPKE. As is typically the case for public-key\nencryption, the encryption key can be made public, while the decryption key and the randomness\nmust remain private. Indeed, the encryption key of K-PKE will serve as the encapsulation key of\nML-KEM (see ML-KEM.KeyGen below) and can thus be made public. Meanwhile, the decryption\nkey and seed of K-PKE.KeyGen must remain private as they can be used to perform decapsulation\nin ML-KEM.\n      The matrix ğ€ generated in steps 3-7 of K-PKE.KeyGen can be stored, as specified in Section 3.3.\n     This allows later operations to use ğ€ directly rather than re-expanding it from the public seed ğœŒ.\n\nInformal description. The decryption key of K-PKE.KeyGen is a length-ğ‘˜ vector ğ¬ of elements\nof ğ‘…ğ‘ (i.e., ğ¬ âˆˆ ğ‘…ğ‘˜). Roughly speaking, ğ¬ is a set of secret variables, while the encryption key is\na collection of  ğ‘\n                 â€œnoisyâ€ linear equations (ğ€, ğ€ğ¬ + ğ) in the secret variables ğ¬. The rows of the\nmatrix ğ€ form the equation coefficients. This matrix is generated pseudorandomly using XOF\n       with only a seed stored in the encryption key. The secret ğ¬ and the â€œnoiseâ€ ğ are sampled from\n\n                                                     28"}
{"doc_id": "NIST.FIPS.203", "source_path": "data/raw_pdfs/NIST.FIPS.203.pdf", "page_number": 38, "text": "FIPS 203                                   MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\n\nAlgorithm 13 K-PKE.KeyGen(ğ‘‘)\nUses randomness to generate an encryption key and a corresponding decryption key.\nInput: randomness ğ‘‘ âˆˆ ğ”¹Â³Â².\nOutput: encryption key ekPKE âˆˆ ğ”¹384ğ‘˜+32 .\nOutput: decryption key dkPKE âˆˆ ğ”¹384ğ‘˜ .\n 1:    (ğœŒ, ğœ) â† G(ğ‘‘â€–ğ‘˜)              â–· expand 32+1 bytes to two pseudorandom 32-byte seedsÂ¹\n 2:    ğ‘ â† 0\n 3:    for (ğ‘– â† 0; ğ‘– < ğ‘˜; ğ‘– ++)        â–· generate matrix ğ€âˆˆ (â„¤Â²âµâ¶)ğ‘˜Ã—ğ‘˜\n 4:     for (ğ‘— â† 0; ğ‘— < ğ‘˜; ğ‘— ++)                                             ğ‘\n 5:           ğ€[ğ‘–, ğ‘—] â† SampleNTT(ğœŒâ€–ğ‘—â€–ğ‘–)    â–· ğ‘— and ğ‘– are bytes 33 and 34 of the input\n 6:     end for\n 7:    end for\n 8:    for (ğ‘– â† 0; ğ‘– < ğ‘˜; ğ‘– ++)               â–· generate ğ¬ âˆˆ (â„¤Â²âµâ¶)ğ‘˜\n                                                                                   ğ‘\n 9:     ğ¬[ğ‘–] â† SamplePolyCBD          (PRFğœ‚ (ğœ, ğ‘ ))    â–· ğ¬[ğ‘–] âˆˆ â„¤Â²âµâ¶ sampled from CBD\n10:     ğ‘ â† ğ‘ + 1                     ğœ‚1  1               ğ‘\n11:    end for\n12:    for (ğ‘– â† 0; ğ‘– < ğ‘˜; ğ‘– ++)                          â–· generate ğ âˆˆ (â„¤Â²âµâ¶)ğ‘˜\n                                                                                   ğ‘\n13:     ğ[ğ‘–] â† SamplePolyCBD               (PRFğœ‚ (ğœ, ğ‘ ))    â–· ğ[ğ‘–] âˆˆ â„¤Â²âµâ¶ sampled from CBD\n14:     ğ‘ â† ğ‘ + 1                     ğœ‚1  1                    ğ‘\n15:    end for\n16:    ğ¬ â† NTT(ğ¬)                               â–· run NTT ğ‘˜ times (once for each coordinate of ğ¬)\n17:    ğ â† NTT(ğ)                                                           â–· run NTT ğ‘˜ times\n18:    ğ­ â† ğ€ âˆ˜ ğ¬ +Ì‚ ğÌ‚                                  â–· noisy linear system in NTT domain\n19:    ekPKE â† ByteEncodeâ‚â‚‚(ğ­)â€–ğœŒ                â–· run ByteEncodeâ‚â‚‚ ğ‘˜ times, then append ğ€-seed\n20:    dkPKE â† ByteEncodeâ‚â‚‚(ğ¬)Ì‚                                     â–· run ByteEncodeâ‚â‚‚ ğ‘˜ times\n21:    return (ekPKE, dkPKE)\n\ncentered binomial distributions using randomness expanded from another seed ğœ via PRF. Once\nğ€, ğ¬, and ğ are generated, the computation of the final part ğ­ = ğ€ğ¬ + ğ of the encryption key\ntakes place. The results are appropriately encoded into byte arrays and output.\nIn K-PKE.KeyGen, the choice of parameter set affects the length of the secret ğ¬ (via the parameter\nğ‘˜) and, as a consequence, the sizes of the noise vector ğ and the pseudorandom matrix ğ€. The\nchoice of parameter set also affects the noise distribution (via the parameter ğœ‚â‚) used to sample\nthe entries of ğ¬ and ğ.\n\n5.2    K-PKE Encryption\nThe encryption algorithm K-PKE.Encrypt of K-PKE (Algorithm 14) takes an encryption key ekPKE,\na 32-byte plaintext ğ‘š, and randomness ğ‘Ÿ as input and produces a single output: a ciphertext ğ‘.\n1Byte 33 of the input to G is the module dimension ğ‘˜ âˆˆ {2, 3, 4} âŠ‚ ğ”¹. This is included to establish domain separation\n between the three parameter sets. For implementations that use the seed in place of the private key, this ensures\n that the expansion will produce an unrelated key if the seed is mistakenly expanded using a parameter set other\n than the originally intended one.\n                                                  29"}
{"doc_id": "NIST.FIPS.203", "source_path": "data/raw_pdfs/NIST.FIPS.203.pdf", "page_number": 39, "text": "FIPS 203                                         MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\n\nThe matrix ğ€ generated in steps 4-8 of K-PKE.Encrypt can be stored, as specified in Section 3.3.\nThis allows later operations to use ğ€ directly rather than re-expanding it from the public seed ğœŒ.\n\nAlgorithm 14 K-PKE.Encrypt(ekPKE, ğ‘š, ğ‘Ÿ)\nUses the encryption key to encrypt a plaintext message using the randomness ğ‘Ÿ.\nInput: encryption key ekPKE âˆˆ ğ”¹384ğ‘˜+32 .\nInput: message ğ‘š âˆˆ ğ”¹Â³Â².\nInput: randomness ğ‘Ÿ âˆˆ ğ”¹Â³Â².\nOutput: ciphertext ğ‘ âˆˆ ğ”¹32(ğ‘‘ğ‘¢ğ‘˜+ğ‘‘ğ‘£).\n 1:    ğ‘ â† 0\n 2:    ğ­ â† ByteDecode (ekPKE[0 âˆ¶ 384ğ‘˜])      â–· run ByteDecode  ğ‘˜ times to decode ğ­ âˆˆ (â„¤Â²âµâ¶)ğ‘˜\n       ğœŒ â† ek  [384ğ‘˜ âˆ¶Â¹Â²                                       12            ğ‘\n 3:          PKE       384ğ‘˜ + 32]               â–· extract 32-byte seed from ekPKE\n 4:    for (ğ‘– â† 0; ğ‘– < ğ‘˜; ğ‘– ++)       â–· re-generate matrix ğ€ âˆˆ (â„¤Â²âµâ¶)ğ‘˜Ã—ğ‘˜ sampled in Alg. 13\n 5:     for (ğ‘— â† 0; ğ‘— < ğ‘˜; ğ‘— ++)                                   ğ‘\n 6:             ğ€[ğ‘–, ğ‘—] â† SampleNTT(ğœŒâ€–ğ‘—â€–ğ‘–)    â–· ğ‘— and ğ‘– are bytes 33 and 34 of the input\n 7:     end for\n 8:    end for\n 9:    for (ğ‘– â† 0; ğ‘– < ğ‘˜; ğ‘– ++)                                      â–· generate ğ² âˆˆ (â„¤Â²âµâ¶)ğ‘˜\n                                                                               ğ‘\n10:     ğ²[ğ‘–] â† SamplePolyCBD            (PRFğœ‚ (ğ‘Ÿ, ğ‘ ))      â–· ğ²[ğ‘–] âˆˆ â„¤Â²âµâ¶ sampled from CBD\n11:     ğ‘ â† ğ‘ + 1                     ğœ‚1  1                           ğ‘\n12:    end for\n13:    for (ğ‘– â† 0; ğ‘– < ğ‘˜; ğ‘– ++)                                      â–· generate ğ âˆˆ (â„¤Â²âµâ¶)ğ‘˜\n                                                                                       ğŸ  ğ‘\n14:     ğğŸ [ğ‘–] â† SamplePolyCBD            (PRFğœ‚ (ğ‘Ÿ, ğ‘ ))    â–· ğğŸ [ğ‘–] âˆˆ â„¤Â²âµâ¶ sampled from CBD\n15:     ğ‘ â† ğ‘ + 1                     ğœ‚2         2                    ğ‘\n16:    end for\n17:    ğ‘’â‚‚ â† SamplePolyCBD             (PRFğœ‚ (ğ‘Ÿ, ğ‘ ))               â–· sample ğ‘’â‚‚ âˆˆ â„¤Â²âµâ¶ from CBD\n       ğ² â† NTT(ğ²)                    ğœ‚2   2                             â–· run ğ‘\n18:                                                                            NTT ğ‘˜ times\n19:    ğ® â† NTTâˆ’1(ğ€âŠº âˆ˜ ğ²) + ğğŸ                                       â–· run NTTâˆ’1 ğ‘˜ times\n20:    ğœ‡ â† Decompressâ‚(ByteDecodeâ‚(ğ‘š))\n21:    ğ‘£ â† NTTâˆ’1(ğ­âŠº âˆ˜ ğ²) + ğ‘’â‚‚ + ğœ‡                            â–· encode plaintext ğ‘š into polynomial ğ‘£\n22:    ğ‘â‚ â† ByteEncodeğ‘‘ğ‘¢ (Compressğ‘‘ğ‘¢ (ğ®))             â–· run ByteEncodeğ‘‘ğ‘¢ and Compressğ‘‘ğ‘¢ ğ‘˜ times\n23:    ğ‘â‚‚ â† ByteEncodeğ‘‘ğ‘£ (Compressğ‘‘ğ‘£ (ğ‘£))\n24:    return ğ‘ â† (ğ‘â‚â€–ğ‘â‚‚)\n\nInformal description. The algorithm K-PKE.Encrypt begins by extracting the vector ğ­ and the\nseed from the encryption key. The seed is then expanded to re-generate the matrix ğ€ in the same\nmanner as was done in K-PKE.KeyGen. If ğ­ and ğ€ are derived correctly from an encryption key\nproduced by K-PKE.KeyGen, then they are equal to their corresponding values in K-PKE.KeyGen.\nRecall from the description of key generation that the pair (ğ€, ğ­ = ğ€ğ¬ + ğ) can be thought of as\na system of noisy linear equations in the secret variables ğ¬. One can generate an additional noisy\nlinear equation in the same secret variables â€” without knowing ğ¬ â€” by picking a random linear\n\n30"}
{"doc_id": "NIST.FIPS.203", "source_path": "data/raw_pdfs/NIST.FIPS.203.pdf", "page_number": 40, "text": " FIPS 203                                        MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\n\n combination of the noisy equations in the system (ğ€, ğ­). One can then encode information in the\nâ€œconstant termâ€ (i.e., the entry that is a linear combination of entries of ğ­) of such a combined\n equation. This information can then be deciphered by a party in possession of ğ¬. For example,\n one could encode a single bit by deciding whether or not to significantly alter the constant term,\n thus making either a nearly correct equation that corresponds to the decrypted bit value of 0 or a\n far-from-correct equation that corresponds to the decrypted bit value of 1. In the case of K-PKE,\n the constant term is a polynomial with 256 coefficients, so one can encode more information:\n one bit in each coefficient.\n To this end, K-PKE.Encrypt proceeds by generating a vector ğ² âˆˆ ğ‘…ğ‘˜ and noise terms ğ  âˆˆ ğ‘…ğ‘˜\n and         , all of which are sampled from the centered binomial ğ‘                     ğŸ  ğ‘\n      ğ‘’â‚‚ âˆˆ ğ‘…ğ‘            PRF                           ğ‘Ÿ       distribution using pseudoran-\n domness expanded via              from the input randomness  . One then computes the â€œnew noisy\n equation,â€ which is (up to some details) (ğ€âŠºğ² + ğâ‚, ğ­âŠºğ² + ğ‘’â‚‚). An appropriate encoding ğœ‡ of\n the input message ğ‘š is then added to the latter term in the pair. Finally, the resulting pair (ğ®, ğ‘£)\n is compressed, serialized into a byte array, and output as the ciphertext.\n\n 5.3  K-PKE Decryption\n The decryption algorithm K-PKE.Decrypt of K-PKE (Algorithm 15) takes a decryption key dkPKE\n and a ciphertext ğ‘ as input, requires no randomness, and outputs a plaintext ğ‘š.\n\n Informal description. The algorithm K-PKE.Decrypt begins by recovering a pair (ğ®â€² , ğ‘£â€² ) from the\n ciphertext ğ‘ (see the description of K-PKE.Encrypt). Here, one can think of ğ®â€² as the coefficients\n of the equation and ğ‘£â€² as the constant term. The decryption key dkPKE contains the vector of\n secret variables ğ¬. The decryption algorithm can thus use the decryption key to compute the\n true constant term ğ‘£ = ğ¬âŠºğ®â€² and calculate ğ‘£â€² âˆ’ ğ‘£. The decryption algorithm ends by decoding\n the plaintext message ğ‘š from ğ‘£â€² âˆ’ ğ‘£ and outputting ğ‘š.\n\n Algorithm 15 K-PKE.Decrypt(dkPKE, ğ‘)\n Uses the decryption key to decrypt a ciphertext.\n Input: decryption key dkPKE âˆˆ ğ”¹384ğ‘˜ .\n Input: ciphertext ğ‘ âˆˆ ğ”¹32(ğ‘‘ğ‘¢ğ‘˜+ğ‘‘ğ‘£).\n Output: message ğ‘š âˆˆ ğ”¹Â³Â².\n  1:  ğ‘â‚ â† ğ‘[0 âˆ¶ 32ğ‘‘ğ‘¢ğ‘˜]\n  2:  ğ‘â‚‚ â† ğ‘[32ğ‘‘ğ‘¢ğ‘˜ âˆ¶ 32(ğ‘‘ğ‘¢ğ‘˜ + ğ‘‘ğ‘£)]\n  3:  ğ®â€² â† Decompressğ‘‘ğ‘¢ (ByteDecodeğ‘‘ğ‘¢ (ğ‘â‚)) â–· run Decompressğ‘‘ğ‘¢ and ByteDecodeğ‘‘ğ‘¢ ğ‘˜ times\n  4:  ğ‘£â€² â† Decompressğ‘‘ğ‘£ (ByteDecodeğ‘‘ğ‘£ (ğ‘â‚‚))\n  5:  ğ¬ â† ByteDecodeâ‚â‚‚(dkPKE)                                         â–· run ByteDecodeâ‚â‚‚ ğ‘˜ times\n  6:  ğ‘¤ â† ğ‘£â€² âˆ’ NTTâˆ’1(ğ¬âŠº âˆ˜ NTT(ğ®â€² ))                      â–· run NTT ğ‘˜ times; run NTTâˆ’1 once\n  7:  ğ‘š â† ByteEncodeâ‚(Compressâ‚(ğ‘¤))                      â–· decode plaintext ğ‘š from polynomial ğ‘£\n  8:  return ğ‘š\n\n 31"}
{"doc_id": "NIST.FIPS.203", "source_path": "data/raw_pdfs/NIST.FIPS.203.pdf", "page_number": 41, "text": "FIPS 203                                   MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\n\n6.   Main Internal Algorithms\n\nThis section specifies three algorithms:  ML-KEM.KeyGen_internal, ML-KEM.Encaps_internal,\nand ML-KEM.Decaps_internal. These three algorithms are all deterministic, meaning that their\noutput is completely determined by their input. No randomness is sampled inside of these\nalgorithms. These three algorithms will be used to construct ML-KEM in Section 7. The algorithms\nin this section make use of the parameters ğ‘›, ğ‘, ğ‘˜, ğ‘‘ğ‘¢, and ğ‘‘ğ‘£. The subroutines they invoke\nadditionally make use of the parameters ğœ‚â‚ and ğœ‚â‚‚. While ğ‘› is always 256 and ğ‘ is always 3329,\nthe remaining parameters vary among the possible parameter sets (see Section 8).\nThe interfaces specified in this section will be used to test ML-KEM implementations through\nthe Cryptographic Algorithm Validation Program (CAVP). The key generation function in this\nsection may also be used to re-expand a key from a seed (see Section 3.3), including when\nobtaining assurance of private key possession via regeneration. As prescribed in Section 3.3, the\ninterfaces specified in this section should not be made available to applications other than for\ntesting purposes, and the random seeds (as specified in ML-KEM.KeyGen and ML-KEM.Encaps\nin Section 7) shall be generated by the cryptographic module.\n\n6.1  Internal Key Generation\nThe algorithm ML-KEM.KeyGen_internal (Algorithm 16) accepts two random seeds as input, and\nproduces an encapsulation key and a decapsulation key.\n\nInformal description. The core subroutine of ML-KEM.KeyGen_internal is the key generation\nalgorithm of K-PKE (Algorithm 13). The encapsulation key is simply the encryption key of K-PKE.\nThe decapsulation key consists of the decryption key of K-PKE, the encapsulation key, a hash\nof the encapsulation key, and a random 32-byte value. This random value will be used in the\nâ€implicit rejectionâ€ mechanism of the internal decapsulation algorithm (Algorithm 18).\n\nAlgorithm 16 ML-KEM.KeyGen_internal(ğ‘‘, ğ‘§)\nUses randomness to generate an encapsulation key and a corresponding decapsulation key.\nInput: randomness ğ‘‘ âˆˆ ğ”¹Â³Â².\nInput: randomness ğ‘§ âˆˆ ğ”¹Â³Â².\nOutput: encapsulation key ek âˆˆ ğ”¹384ğ‘˜+32 .\nOutput: decapsulation key dk âˆˆ ğ”¹768ğ‘˜+96 .\n 1:  (ekPKE, dkPKE) â† K-PKE.KeyGen(ğ‘‘)                       â–· run key generation for K-PKE\n 2:  ek â† ekPKE                            â–· KEM encaps key is just the PKE encryption key\n 3:  dk â† (dkPKEâ€–ekâ€–H(ek)â€–ğ‘§)              â–· KEM decaps key includes PKE decryption key\n 4:  return (ek, dk)\n\n6.2  Internal Encapsulation\nThe algorithm ML-KEM.Encaps_internal (Algorithm 17) accepts an encapsulation key and a ran-\ndom byte array as input and outputs a ciphertext and a shared key.\n\n                           32"}
{"doc_id": "NIST.FIPS.203", "source_path": "data/raw_pdfs/NIST.FIPS.203.pdf", "page_number": 42, "text": "FIPS 203                                  MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\n\nAlgorithm 17 ML-KEM.Encaps_internal(ek, ğ‘š)\nUses the encapsulation key and randomness to generate a key and an associated ciphertext.\nInput: encapsulation key ek âˆˆ ğ”¹384ğ‘˜+32 .\nInput: randomness ğ‘š âˆˆ ğ”¹Â³Â².\nOutput: shared secret key ğ¾ âˆˆ ğ”¹Â³Â².\nOutput: ciphertext ğ‘ âˆˆ ğ”¹32(ğ‘‘ğ‘¢ğ‘˜+ğ‘‘ğ‘£).\n 1:  (ğ¾, ğ‘Ÿ) â† G(ğ‘šâ€–H(ek))               â–· derive shared secret key ğ¾ and randomness ğ‘Ÿ\n 2:  ğ‘ â† K-PKE.Encrypt(ek, ğ‘š, ğ‘Ÿ)        â–· encrypt ğ‘š using K-PKE with randomness ğ‘Ÿ\n 3:  return (ğ¾, ğ‘)\n\nInformal description. The core subroutine of ML-KEM.Encaps_internal is the encryption algo-\nrithm of K-PKE, which is used to encrypt a random value ğ‘š into a ciphertext ğ‘. A copy of the\nshared secret key ğ¾ and the randomness used during encryption are derived from ğ‘š and the\nencapsulation key ek via hashing. Specifically, H is applied to ek, and the result is concatenated\nwith ğ‘š and then hashed using G. Finally, the algorithm outputs the shared secret key ğ¾ and the\nciphertext ğ‘.\n\n6.3  Internal Decapsulation\nThe algorithm ML-KEM.Decaps_internal (Algorithm 18) accepts a decapsulation key and a cipher-\ntext as input, does not use any randomness, and outputs a shared secret key.\n\nInformal description. The algorithm ML-KEM.Decaps_internal begins by parsing out the com-\nponents of the decapsulation key dk of ML-KEM. These components are an (encryption key,\ndecryption key) pair for K-PKE, a hash value â„, and a random value ğ‘§. The decryption key of\nK-PKE is then used to decrypt the input ciphertext ğ‘ to get a plaintext ğ‘šâ€² . The decapsulation\nalgorithm then re-encrypts ğ‘šâ€² and computes a candidate shared secret key ğ¾â€² in the same\nmanner as should have been done in encapsulation. Specifically, ğ¾â€² and the encryption ran-\ndomness ğ‘Ÿâ€² are computed by hashing ğ‘šâ€² and the encryption key of K-PKE, and a ciphertext ğ‘â€² is\ngenerated by encrypting ğ‘šâ€² using randomness ğ‘Ÿâ€² . Finally, decapsulation checks whether the\nresulting ciphertext ğ‘â€² matches the provided ciphertext ğ‘. If it does not, the algorithm performs\nan â€œimplicit rejectionâ€: the value of ğ¾â€² is changed to a hash of ğ‘ together with the random value\nğ‘§ stored in the ML-KEM secret key (see the discussion of decapsulation failures in Section    3.2).\nIn either case, decapsulation outputs the resulting shared secret key ğ¾â€² .\nThe â€œimplicit rejectâ€ flag computed in step 9 (by comparing ğ‘ and ğ‘â€² ) is a secret piece of interme-\ndiate data. As specified in the requirements in Section 3.3, this flag shall be destroyed prior to\nML-KEM.Decaps_internal terminating. In particular, returning the value of the flag as an output\nin any form is not permitted.\n\n33"}
{"doc_id": "NIST.FIPS.203", "source_path": "data/raw_pdfs/NIST.FIPS.203.pdf", "page_number": 43, "text": "FIPS 203                                         MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\n\nAlgorithm 18 ML-KEM.Decaps_internal(dk, ğ‘)\nUses the decapsulation key to produce a shared secret key from a ciphertext.\nInput: decapsulation key dk âˆˆ ğ”¹768ğ‘˜+96 .\nInput: ciphertext ğ‘ âˆˆ ğ”¹32(ğ‘‘ğ‘¢ğ‘˜+ğ‘‘ğ‘£).\nOutput: shared secret key ğ¾ âˆˆ ğ”¹Â³Â².\n 1:    dkPKE â† dk[0 âˆ¶ 384ğ‘˜]               â–· extract (from KEM decaps key) the PKE decryption key\n 2:    ekPKE â† dk[384ğ‘˜ âˆ¶ 768ğ‘˜ + 32]            â–· extract PKE encryption key\n 3:    â„ â† dk[768ğ‘˜ + 32 âˆ¶ 768ğ‘˜ + 64]           â–· extract hash of PKE encryption key\n 4:    ğ‘§ â† dk[768ğ‘˜ + 64 âˆ¶ 768ğ‘˜ + 96]          â–· extract implicit rejection value\n 5:    ğ‘šâ€² â€²â†â€²K-PKE.Decrypt(dkPKE, ğ‘)           â–· decrypt ciphertext\n 6:    (ğ¾ , ğ‘Ÿ ) â† G(ğ‘šâ€² â€–â„)Ì„\n 7:    ğ¾ â† J(ğ‘§â€–ğ‘)\n 8:    ğ‘â€² â† K-PKE.Encrypt(ekPKE, ğ‘šâ€² , ğ‘Ÿâ€² )    â–· re-encrypt using the derived randomness ğ‘Ÿâ€²\n 9:    if ğ‘ â‰  ğ‘â€² then\n10:         ğ¾â€² â† ğ¾                             â–· if ciphertexts do not match, â€œimplicitly rejectâ€\n11:    end if\n12:    return ğ¾â€²\n\n34"}
{"doc_id": "NIST.FIPS.203", "source_path": "data/raw_pdfs/NIST.FIPS.203.pdf", "page_number": 44, "text": "FIPS 203                                   MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\n\n7.         The ML-KEM Key-Encapsulation Mechanism\n\nThis section describes the three main algorithms of the ML-KEM scheme:\n  1.       Key generation (ML-KEM.KeyGen)\n  2.       Encapsulation (ML-KEM.Encaps)\n  3.       Decapsulation (ML-KEM.Decaps)\nTo instantiate ML-KEM, one must select a parameter set. Each parameter set is associated with\na particular trade-off between security and performance. The three possible parameter sets are\ncalled ML-KEM-512, ML-KEM-768, and ML-KEM-1024 and are described in detail in Table 2 of\nSection 8. Each parameter set assigns specific numerical values to the individual parameters ğ‘›,\nğ‘, ğ‘˜, ğœ‚â‚, ğœ‚â‚‚, ğ‘‘ğ‘¢, and ğ‘‘ğ‘£. While ğ‘› is always 256 and ğ‘ is always 3329, the remaining parameters\nvary among the three parameter sets. Implementers shall ensure that the three algorithms of\nML-KEM listed above are only invoked with a valid parameter set, and that this parameter set is\nselected appropriately for the desired application. Moreover, implementers shall ensure that the\nparameter set used in any particular invocation of ML-KEM.Encaps or ML-KEM.Decaps matches\nthe parameter set associated to the provided inputs.\n\n7.1        ML-KEM Key Generation\nThe key generation algorithm ML-KEM.KeyGen for ML-KEM (Algorithm 19) accepts no input,\ngenerates randomness internally, and produces an encapsulation key and a decapsulation key.\nWhile the encapsulation key can be made public, the decapsulation key shall remain private.\nThe seed (ğ‘‘, ğ‘§) generated in steps 1 and 2 of ML-KEM.KeyGen can be stored for later expan-\nsion using ML-KEM.KeyGen_internal (see Section 3.3). As the seed can be used to compute\nthe decapsulation key, it is sensitive data and shall be treated with the same safeguards as a\ndecapsulation key (see SP 800-227 [1]).\n\nAlgorithm 19 ML-KEM.KeyGen()\nGenerates an encapsulation key and a corresponding decapsulation key.\nOutput: encapsulation key ek âˆˆ ğ”¹384ğ‘˜+32 .\nOutput: decapsulation key dk âˆˆ ğ”¹768ğ‘˜+96 .\n       ğ‘‘   $ ğ”¹Â³Â²                                              â–· ğ‘‘ is 32 random bytes (see Section 3.3)\n           â†\n 1:         âˆ’\n       ğ‘§   $ ğ”¹Â³Â²                                              â–· ğ‘§ is 32 random bytes (see Section 3.3)\n           â†\n 2:        âˆ’\n 3:    if ğ‘‘ == NULL or ğ‘§ == NULL then\n 4:         return âŠ¥        â–· return an error indication if random bit generation failed\n 5:    end if\n 6:    (ek, dk) â† ML-KEM.KeyGen_internal(ğ‘‘, ğ‘§)    â–· run internal key generation algorithm\n 7:    return (ek, dk)\n\nSecure key establishment depends on the use of key pairs that have been properly generated\nvia ML-KEM.KeyGen. If the owner of a KEM key pair did not generate the key pair but instead\nreceived it from a trusted third party or other source, the owner may optionally perform certain\n                                           35"}
{"doc_id": "NIST.FIPS.203", "source_path": "data/raw_pdfs/NIST.FIPS.203.pdf", "page_number": 45, "text": "FIPS 203                                  MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\n\nchecks on the key pair. While these checks can detect certain corruptions, they do not guarantee\nthat the key pair was properly generated.\n\nKey pair check. To check a candidate key pairÂ¹ (ek, dk), perform the following checks:\n 1.  (Seed consistency) If a seed (ğ‘‘, ğ‘§) is available, run ML-KEM.KeyGen_internal(ğ‘‘, ğ‘§), and\n     verify that the output is equal to (ek, dk).\n 2.  (Encapsulation key check) Check ek as specified in Section 7.2.\n 3.  (Decapsulation key check) Check dk as specified in Section 7.3.\n 4.  (Pair-wise consistency) Perform the following steps:\n            i.   Generate an array of 32 random bytes by performing ğ‘š     $ ğ”¹Â³Â².\n                                                                           â†\n                                                                           âˆ’\n            ii.  Perform (ğ¾, ğ‘) â† ML-KEM.Encaps_internal(ek, ğ‘š).\n     iii.        Perform ğ¾â€² â† ML-KEM.Decaps_internal(dk, ğ‘).\n     iv.         Reject unless ğ¾ == ğ¾â€² .\nIt is important to note that this checking process does not guarantee that the key pair is a properly\nproduced output of ML-KEM.KeyGen.\n\n7.2  ML-KEM Encapsulation\nThe encapsulation algorithm ML-KEM.Encaps of ML-KEM (Algorithm 20) accepts an encapsula-\ntion key as input, generates randomness internally, and outputs a ciphertext and a shared key.\nThis algorithm requires input checking, as specified below.\n\nEncapsulation key check. To check a candidate encapsulation key ek, perform the following:\n 1.  (Type check) If ek is not an array of bytes of length 384ğ‘˜ + 32 for the value of ğ‘˜ specified\n     by the relevant parameter set, then input checking failed.\n 2.  (Modulus check) Perform the computation\n\n                 test â† ByteEncodeâ‚â‚‚(ByteDecodeâ‚â‚‚(ek[0 âˆ¶ 384ğ‘˜]))                     (7.1)\n\n     (see Section 4.2.1). If test â‰  ek[0 âˆ¶ 384ğ‘˜], then input checking failed. This check ensures\n     that the integers encoded in the public key are in the valid range [0, ğ‘ âˆ’ 1].\nIf both checks pass, then ML-KEM.Encaps can be run with input ek âˆ¶= ek.           It is important to\nnote that this checking process does not guarantee that ek is a properly produced output of\nML-KEM.KeyGen.\nML-KEM.Encaps shall not be run with an encapsulation key that has not been checked as above.\nHowever, checking of the encapsulation key need not be performed by the encapsulating party,\n\n1In discussions of input checking, the â€œlow overlineâ€ in the notation indicates that the input has not yet been\nchecked (e.g., ek has not yet been checked, while ek has passed the check).\n                                          36"}
{"doc_id": "NIST.FIPS.203", "source_path": "data/raw_pdfs/NIST.FIPS.203.pdf", "page_number": 46, "text": "FIPS 203                                  MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\n\nnor with every execution of ML-KEM.Encaps. Instead, assurance that these checks have been\nperformed can be acquired through other means (see SP 800-227 [1]).\n\nAlgorithm 20 ML-KEM.Encaps(ek)\nUses the encapsulation key to generate a shared secret key and an associated ciphertext.\nChecked input: encapsulation key ek âˆˆ ğ”¹384ğ‘˜+32 .\nOutput: shared secret key ğ¾ âˆˆ ğ”¹Â³Â².\nOutput: ciphertext ğ‘ âˆˆ ğ”¹32(ğ‘‘ğ‘¢ğ‘˜+ğ‘‘ğ‘£).\n     ğ‘š $   ğ”¹Â³Â²                                  â–· ğ‘š is 32 random bytes (see Section 3.3)\n     â†\n 1:         âˆ’\n 2:  if ğ‘š == NULL then\n 3:         return âŠ¥          â–· return an error indication if random bit generation failed\n 4:  end if\n 5:  (ğ¾, ğ‘) â† ML-KEM.Encaps_internal(ek, ğ‘š)    â–· run internal encapsulation algorithm\n 6:  return (ğ¾, ğ‘)\n\n7.3  ML-KEM Decapsulation\nThe decapsulation algorithm ML-KEM.Decaps of ML-KEM (Algorithm 21) accepts a decapsulation\nkey and an ML-KEM ciphertext as input, does not use any randomness, and outputs a shared\nsecret. This algorithm requires input checking, as specified below.\n\nDecapsulation input check. To check a candidate decapsulation key dk and ciphertext ğ‘, perform\nthe following checks:\n 1.  (Ciphertext type check) If ğ‘ is not a byte array of length 32(ğ‘‘ğ‘¢ğ‘˜ + ğ‘‘ğ‘£) for the values of ğ‘‘ğ‘¢,\n     ğ‘‘ğ‘£, and ğ‘˜ specified by the relevant parameter set, then input checking has failed.\n 2.  (Decapsulation key type check) If dk is not a byte array of length 768ğ‘˜ + 96 for the value of\n     ğ‘˜ specified by the relevant parameter set, then input checking has failed.\n 3.  (Hash check) Perform the computation\n\n                     test â† H(dk[384ğ‘˜ âˆ¶ 768ğ‘˜ + 32])) .                                  (7.2)\n\n     If test â‰  dk[768ğ‘˜ + 32 âˆ¶ 768ğ‘˜ + 64], then input checking has failed.\nIf all of the above checks pass, then ML-KEM.Decaps can be run with inputs dk âˆ¶= dk and ğ‘ âˆ¶= ğ‘. It\nis important to note that this checking process does not guarantee that dk is a properly produced\noutput of ML-KEM.KeyGen, nor that ğ‘ is a properly produced output of ML-KEM.Encaps.\nML-KEM.Decaps shall not be run with a decapsulation key or a ciphertext unless both have\nbeen checked. However, checking of the decapsulation key need not be performed by the\ndecapsulating party, nor with every execution of ML-KEM.Decaps. Instead, assurance that this\ncheck has been performed can be acquired through other means (see SP 800-227 [1]). Ciphertext\nchecking shall be performed with every execution of ML-KEM.Decaps.\n\n37"}
{"doc_id": "NIST.FIPS.203", "source_path": "data/raw_pdfs/NIST.FIPS.203.pdf", "page_number": 47, "text": "FIPS 203                                         MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\n\nAlgorithm 21 ML-KEM.Decaps(dk, ğ‘)\nUses the decapsulation key to produce a shared secret key from a ciphertext.\nChecked input: decapsulation key dk âˆˆ ğ”¹768ğ‘˜+96 .\nChecked input: ciphertext ğ‘ âˆˆ ğ”¹32(ğ‘‘ğ‘¢ğ‘˜+ğ‘‘ğ‘£).\nOutput: shared secret key ğ¾ âˆˆ ğ”¹Â³Â².\n 1:  ğ¾â€² â† ML-KEM.Decaps_internal(dk, ğ‘)         â–· run internal decapsulation algorithm\n 2:  return ğ¾â€²\n\n38"}
{"doc_id": "NIST.FIPS.203", "source_path": "data/raw_pdfs/NIST.FIPS.203.pdf", "page_number": 48, "text": "FIPS 203                                MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\n\n8.   Parameter Sets\n\nML-KEM is equipped with three parameter sets, each of the which comprises five individual\nparameters: ğ‘˜, ğœ‚â‚, ğœ‚â‚‚, ğ‘‘ğ‘¢, and ğ‘‘ğ‘£. There are also two constants: ğ‘› = 256 and ğ‘ = 3329. The\nfollowing is a brief and informal description of the roles played by the variable parameters in the\nalgorithms of K-PKE and ML-KEM. See Section 5 for details.\n    â€¢ The parameter ğ‘˜ determines the dimensions of the matrix ğ€ that appears in K-PKE.KeyGen\n     and K-PKE.Encrypt. It also determines the dimensions of vectors ğ¬ and ğ in K-PKE.KeyGen\n     and the dimensions of vectors ğ² and ğâ‚ in K-PKE.Encrypt.\n    â€¢ The parameter ğœ‚â‚ is required to specify the distribution for generating the vectors ğ¬ and ğ\n     in K-PKE.KeyGen and the vector ğ² in K-PKE.Encrypt.\n    â€¢ The parameter ğœ‚â‚‚ is required to specify the distribution for generating the vectors ğâ‚ and\n     ğ‘’â‚‚ in K-PKE.Encrypt.\n    â€¢ The parameters ğ‘‘ğ‘¢ and ğ‘‘ğ‘£ serve as parameters and inputs for the functions Compress,\n     Decompress, ByteEncode, and ByteDecode in K-PKE.Encrypt and K-PKE.Decrypt.\n       This standard approves the parameter sets given in Table 2. Each parameter set is associated\n     with a required security strength for randomness generation (see Section 3.3). The sizes of the\nML-KEM keys and ciphertexts for each parameter set are summarized in Table 3.\n\n                               Table 2. Approved parameter sets for ML-KEM\n\n                     ğ‘›     ğ‘     ğ‘˜    ğœ‚â‚    ğœ‚â‚‚     ğ‘‘ğ‘¢    ğ‘‘ğ‘£    required RBG strength (bits)\n      ML-KEM-512    256    3329    2     3      2       10      4                   128\n      ML-KEM-768    256    3329    3     2      2       10      4                   192\n     ML-KEM-1024    256    3329    4     2      2       11      5                   256\n\n            Table 3. Sizes (in bytes) of keys and ciphertexts of ML-KEM\n\n             encapsulation key    decapsulation key     ciphertext    shared secret key\n      ML-KEM-512    800                  1632              768                32\n      ML-KEM-768    1184                 2400              1088               32\n     ML-KEM-1024    1568                 3168              1568               32\n\n      A parameter set name can also be said to denote a (parameter-free) KEM. Specifically, ML-KEM-ğ‘¥\ncan be used to denote the parameter-free KEM that results from instantiating the scheme\nML-KEM with the parameter set ML-KEM-ğ‘¥.\n       The three parameter sets included in Table 2 were designed to meet certain security strength\ncategories defined by NIST in its original Call for Proposals [4, 22]. These security strength\ncategories are explained further in SP 800-57, Part 1 [7].\nUsing this approach, security strength is not described by a single number, such as â€œ128 bits of\nsecurity.â€ Instead, each ML-KEM parameter set is claimed to be at least as secure as a generic\n                                                    39"}
{"doc_id": "NIST.FIPS.203", "source_path": "data/raw_pdfs/NIST.FIPS.203.pdf", "page_number": 49, "text": "FIPS 203                                 MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\n\nblock cipher with a prescribed key size or a generic hash function with a prescribed output\nlength. More precisely, it is claimed that the computational resources needed to break ML-KEM\nare greater than or equal to the computational resources needed to break the block cipher or\nhash function when those computational resources are estimated using any realistic model of\ncomputation. Different models of computation can be more or less realistic and, accordingly,\nlead to more or less accurate estimates of security strength. Some commonly studied models\nare discussed in [23].\nConcretely, ML-KEM-512 is claimed to be in security category 1, ML-KEM-768 is claimed to be\nin security category 3, and ML-KEM-1024 is claimed to be in security category 5. For additional\ndiscussion of the security strength of MLWE-based cryptosystems, see [4].\n\nSelecting an appropriate parameter set. When initially establishing cryptographic protections\nfor data, the strongest possible parameter set should be used. This has a number of advantages,\nincluding reducing the likelihood of costly transitions to higher-security parameter sets in the\nfuture.     At the same time, it should be noted that some parameter sets might have adverse\nperformance effects for the relevant application (e.g., the algorithm may be unacceptably slow,\nor objects such as keys or ciphertexts may be unacceptably large).\nNIST recommends using ML-KEM-768 as the default parameter set, as it provides a large security\nmargin at a reasonable performance cost. In cases where this is impractical or even higher\nsecurity is required, other parameter sets may be used.\n\n40"}
{"doc_id": "NIST.FIPS.203", "source_path": "data/raw_pdfs/NIST.FIPS.203.pdf", "page_number": 50, "text": "FIPS 203                                  MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\n\nReferences\n\n [1]  National Institute of Standards     and Technology (2024) Recommendations for key-\n      encapsulation mechanisms, (National Institute of Standards and Technology, Gaithers-\n      burg, MD), NIST Special Publication (SP) 800-227. [Forthcoming;   will be available at\n      https://csrc.nist.gov/publications].\n [2]  Barker EB, Chen L, Roginsky AL, Vassilev A, Davis R (2018) Recommendation for pair-wise\n      key-establishment schemes using discrete logarithm cryptography (National Institute of\n      Standards and Technology, Gaithersburg, MD), NIST Special Publication (SP) 800-56A Revi-\n      sion 3. https://doi.org/10.6028/NIST.SP.800-56Ar3.\n [3]  Barker EB, Chen L, Roginsky AL, Vassilev A, Davis R, Simon S (2019) Recommendation for\n      pair-wise key-establishment using integer factorization cryptography (National Institute\n      of Standards and Technology, Gaithersburg, MD), NIST Special Publication (SP) 800-56B\n      Revision 2. https://doi.org/10.6028/NIST.SP.800-56Br2.\n [4]  Avanzi R, Bos J, Ducas L, Kiltz E, Lepoint T, Lyubashevsky V, Schanck JM, Schwabe P, Seiler G,\n      StehlÃ© D (2020) CRYSTALS-Kyber algorithm specifications and supporting documentation,\n      Third-round submission to the NISTâ€™s post-quantum cryptography standardization process.\n      Available at https://csrc.nist.gov/Projects/post-quantum-cryptography/post-quantum-cry\n      ptography-standardization/round-3-submissions.\n [5]  National Institute of Standards and Technology (2015) Secure hash standard (SHS), (U.S.\n      Department of Commerce, Washington, DC), Federal Information Processing Standards\n      Publication (FIPS) 180-4. https://doi.org/10.6028/NIST.FIPS.180-4.\n [6]  National Institute of Standards and Technology (2015) SHA-3 standard: Permutation-based\n      hash and extendable-output functions, (U.S. Department of Commerce, Washington, DC),\n      Federal Information Processing Standards Publication (FIPS) 202. https://doi.org/10.6028/\n      NIST.FIPS.202.\n [7]  Barker EB (2020) Recommendation for key management: Part 1 - General, (National Institute\n      of Standards and Technology, Gaithersburg, MD), NIST Special Publication (SP) 800-57 Part\n      1, Rev. 5 [or as amended]. https://doi.org/10.6028/NIST.SP.800-57pt1r5.\n [8]  Bos J, Ducas L, Kiltz E, Lepoint T, Lyubashevsky V, Schanck JM, Schwabe P, Seiler G, StehlÃ©\n      D (2018) CRYSTALS-Kyber: A CCA-secure module-lattice-based KEM. 2018 IEEE European\n      Symposium on Security and Privacy (EuroS&P), pp 353â€“367. https://doi.org/10.1109/Euro\n      SP.2018.00032.\n [9]  Langlois A, StehlÃ© D (2015) Worst-case to average-case reductions for module lattices.\n      Designs, Codes and Cryptography 75(3):565â€“599. https://doi.org/10.1007/s10623-014-9\n      938-4.\n[10]  Regev O (2005) On lattices, learning with errors, random linear codes, and cryptography.\n      Proceedings of the Thirty-Seventh Annual ACM Symposium on Theory of Computing STOC\n     â€™05 (Association for Computing Machinery, New York, NY, USA), pp 84â€“â€“93. https://doi.org/\n      10.1145/1060590.1060603.\n\n41"}
{"doc_id": "NIST.FIPS.203", "source_path": "data/raw_pdfs/NIST.FIPS.203.pdf", "page_number": 51, "text": "FIPS 203                              MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\n\n[11]  Fujisaki E, Okamoto T (2013) Secure integration of asymmetric and symmetric encryption\n      schemes. Journal of Cryptology 26:80â€“101. https://doi.org/10.1007/s00145-011-9114-1.\n[12]  Hofheinz D, HÃ¶velmanns K, Kiltz E (2017) A modular analysis of the Fujisaki-Okamoto trans-\n      formation. Theory of Cryptography, eds Kalai Y, Reyzin L (Springer International Publishing,\n      Cham), pp 341â€“371. https://doi.org/10.1007/978-3-319-70500-2_12.\n[13]  Katz J, Lindell Y (2020) Introduction to Modern Cryptography (Chapman & Hall/CRC), 3rd Ed.\n[14]  Almeida JB, Olmos SA, Barbosa M, Barthe G, Dupressoir F, GrÃ©goire B, Laporte V, LÃ©chenet JC,\n      Low C, Oliveira T, Pacheco H, Quaresma M, Schwabe P, Strub PY (2024) Formally verifying Ky-\n      ber episode V: Machine-checked IND-CCA security and correctness of ML-KEM in EasyCrypt,\n      Cryptology ePrint Archive, Paper 2024/843. Available at https://eprint.iacr.org/2024/843.\n[15]  Ducas L, Schanck J (2021) Security estimation scripts for Kyber and Dilithium, Github reposi-\n      tory. Available at https://github.com/pq-crystals/security-estimates.\n[16]  Chen L (2022) Recommendation for key derivation using pseudorandom functions, (National\n      Institute of Standards and Technology, Gaithersburg, MD), NIST Special Publication (SP)\n      800-108r1-upd1, Includes updates as of February 2, 2024. https://doi.org/10.6028/NIST.SP.\n      800-108r1-upd1.\n[17]  Barker EB, Chen L, Davis R (2020) Recommendation for key-derivation methods in key-\n      establishment schemes (National Institute of Standards and Technology, Gaithersburg, MD),\n      NIST Special Publication (SP) 800-56C Revision 2. https://doi.org/10.6028/NIST.SP.800-56C\n      r2.\n[18]  Barker EB, Kelsey JM (2015) Recommendation for random number generation using deter-\n      ministic random bit generators, (National Institute of Standards and Technology, Gaithers-\n      burg, MD), NIST Special Publication (SP) 800-90A, Rev. 1. https://doi.org/10.6028/NIST.SP.\n      800-90Ar1.\n[19]  SÃ¶nmez Turan M, Barker EB, Kelsey JM, McKay KA, Baish ML, Boyle M (2018) Recom-\n      mendation for the entropy sources used for random bit generation, (National Institute\n      of Standards and Technology, Gaithersburg, MD), NIST Special Publication (SP) 800-90B.\n      https://doi.org/10.6028/NIST.SP.800-90B.\n[20]  Barker E, Kelsey J, McKay K, Roginsky A, Turan MS (2024) Recommendation for random bit\n      generator (RBG) constructions, (National Institute of Standards and Technology, Gaithers-\n      burg, MD), NIST Special Publication (SP) 800-90C 4pd. https://doi.org/10.6028/NIST.SP.80\n      0-90C.4pd.\n[21]  Kelsey J, Chang S, Perlner R (2016) SHA-3 Derived Functions: cSHAKE, KMAC, TupleHash\n      and ParallelHash, (National Institute of Standards and Technology, Gaithersburg, MD), NIST\n      Special Publication (SP) 800-185 [or as amended]. https://doi.org/10.6028/NIST.SP.800-1\n      85.\n[22]  National Institute of Standards and Technology (2016) Submission requirements and eval-\n      uation criteria for the post-quantum cryptography standardization process. Available at\n      https://csrc.nist.gov/CSRC/media/Projects/Post-Quantum-Cryptography/documents/call-f\n      or-proposals-final-dec-2016.pdf.\n\n                                      42"}
{"doc_id": "NIST.FIPS.203", "source_path": "data/raw_pdfs/NIST.FIPS.203.pdf", "page_number": 52, "text": "FIPS 203                    MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\n\n[23]  Alagic G, Apon D, Cooper D, Dang Q, Dang T, Kelsey J, Lichtinger J, Liu YK, Miller C, Moody\n      D, Peralta R, Perlner R, Robinson A, Smith-Tone D (2022) Status report on the third round\n      of the NIST post-quantum cryptography standardization process (National Institute of\n      Standards and Technology, Gaithersburg, MD), NIST Interagency or Internal Report (IR)\n      8413. https://doi.org/10.6028/NIST.IR.8413-upd1.\n[24]  CRYSTALS-Kyber submission team (2023) â€œDiscussion about Kyberâ€™s tweaked FO transformâ€,\n      PQC-Forum Post. Available at https://groups.google.com/a/list.nist.gov/g/pqc-forum/c/W\n      FRDl8DqYQ4.\n[25]  CRYSTALS-Kyber submission team (2023) â€œKyber decisions, part 2: FO transformâ€, PQC-\n      Forum Post. Available at https://groups.google.com/a/list.nist.gov/g/pqc-forum/c/C0D3W\n      1KoINY/m/99kIvydoAwAJ.\n\n43"}
{"doc_id": "NIST.FIPS.203", "source_path": "data/raw_pdfs/NIST.FIPS.203.pdf", "page_number": 53, "text": "FIPS 203                                          MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\n\nAppendix A â€” Precomputed Values for the NTT\n\nThe following 128 numbers are the values of ğœ BitRevâ‚‡(ğ‘–) mod ğ‘ for ğ‘– âˆˆ {0, â€¦ , 127}. These numbers\nare used in Algorithms 9 and 10.\n{ 1     1729    2580    3289    2642    630     1897    848\n\n1062    1919    193     797     2786    3260    569     1746\n\n296     2447    1339    1476    3046     56     2240    1333\n\n1426    2094    535     2882    2393    2879    1974    821\n\n289     331     3253    1756    1197    2304    2277    2055\n\n650     1977    2513    632     2865     33     1320    1915\n\n2319    1435    807     452     1438    2868    1534    2402\n\n2647    2617    1481    648     2474    3110    1227    910\n\n 17     2761    583     2649    1637    723     2288    1100\n\n1409    2662    3281    233     756     2156    3015    3050\n\n1703    1651    2789    1789    1847    952     1461    2687\n\n939     2308    2437    2388    733     2337    268     641\n\n1584    2298    2037    3220    375     2549    2090    1645\n\n1063    319     2773    757     2099    561     2466    2594\n\n2804    1092    403     1026    1143    2150    2775    886\n\n1722    1212    1874    1029    2110    2935    885    2154 }\n\n44"}
{"doc_id": "NIST.FIPS.203", "source_path": "data/raw_pdfs/NIST.FIPS.203.pdf", "page_number": 54, "text": "FIPS 203                                        MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\n\nWhen implementing Algorithm 11, the values ğœ 2BitRevâ‚‡(ğ‘–)+1 mod ğ‘ need to be computed. The\nfollowing array contains these values for ğ‘– âˆˆ {0, â€¦ , 127}:\n            { 17     -17       2761     -2761     583      -583      2649     -2649\n\n            1637     -1637     723      -723      2288     -2288     1100     -1100\n\n            1409     -1409     2662     -2662     3281     -3281     233      -233\n\n            756      -756      2156     -2156     3015     -3015     3050     -3050\n\n            1703     -1703     1651     -1651     2789     -2789     1789     -1789\n\n            1847     -1847     952      -952      1461     -1461     2687     -2687\n\n            939      -939      2308     -2308     2437     -2437     2388     -2388\n\n            733      -733      2337     -2337     268      -268      641      -641\n\n            1584     -1584     2298     -2298     2037     -2037     3220     -3220\n\n            375      -375      2549     -2549     2090     -2090     1645     -1645\n\n            1063     -1063     319      -319      2773     -2773     757      -757\n\n            2099     -2099     561      -561      2466     -2466     2594     -2594\n\n            2804     -2804     1092     -1092     403      -403      1026     -1026\n\n            1143     -1143     2150     -2150     2775     -2775     886      -886\n\n            1722     -1722     1212     -1212     1874     -1874     1029     -1029\n\n            2110     -2110     2935     -2935     885      -885      2154     -2154 }\n\n45"}
{"doc_id": "NIST.FIPS.203", "source_path": "data/raw_pdfs/NIST.FIPS.203.pdf", "page_number": 55, "text": "FIPS 203                   MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\n\nAppendix B â€” SampleNTT Loop Bounds\n\nIn SampleNTT (Algorithm 7), the algorithm repeatedly generates byte arrays from the XOF to\ncreate an element of ğ‘‡ğ‘ . If a generated byte array value is out of bounds for a coefficient of ğ‘‡ğ‘ ,\nthe algorithm tries again until all 256 coefficients are created. On average, this while loop will\nresolve within a reasonable number of iterations. However, there may be cases in which the\ngenerated byte arrays are consistently out of bounds and the algorithm may run for a higher\nnumber of iterations.\nImplementations should not bound this loop, if at all possible. An incorrect limit will cause\ninteroperability errors, and the chances for SampleNTT to iterate longer become exponentially\nrare. If an implementation does bound the number of iterations of SampleNTT, it shall not use a\nlimit lower than those presented in Table 4. The calculated probability of SampleNTT exceeding\nthe limit is included and calculated under standard assumptions about the output distributions\nof XOFs and hash functions.\n\n            Table 4. While-loop limits and probabilities of occurrence for SampleNTT\n\nNumber of iterations       Probability of reaching limit\n        280                2âˆ’261\n\nIf a limit is used and the number of iterations exceeds the limit, then the algorithm shall destroy\nall intermediate results. If a return value or exception is produced, it shall be the same value for\nany execution in which the maximum number of iterations is exceeded.\n\n46"}
{"doc_id": "NIST.FIPS.203", "source_path": "data/raw_pdfs/NIST.FIPS.203.pdf", "page_number": 56, "text": "FIPS 203                                        MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\n\nAppendix C â€” Differences From the CRYSTALS-Kyber Submission\n\n This appendix lists the differences between CRYSTALS-KYBER (as described in [4]) and the ML-KEM\nscheme (specified in this document) that result in differing input-output behavior of the main\nalgorithms (i.e., KeyGen, Encaps, Decaps). Since a conforming implementation need only match\nthe input-output behavior of these three algorithms (see â€œImplementationsâ€ and Section 3.3\nbelow), the list does not include any of the numerous differences in how the main algorithms actu-\nally produce outputs from inputs (e.g., via different computational steps or different subroutines),\nnor any differences in presentation between this standard and [4].\n\nC.1   Differences Between CRYSTALS-Kyber and FIPS 203 Initial Pub-\nlic  Draft\n     â€¢ In the third-round specification [4], the shared secret key was treated as a variable-length\n      value whose length depended on how it would be used in the relevant application. In this\n      specification, the length of the shared secret key is fixed to 256 bits. It can be used directly\n      in applications as a symmetric key, or symmetric keys can be derived from it, as specified\n      in Section 3.3.\n     â€¢ The ML-KEM.Encaps and ML-KEM.Decaps algorithms in this specification use a different\n      variant of the Fujisaki-Okamoto transform (see [24, 25]) than the third-round specifica-\n      tion [4]. Specifically, ML-KEM.Encaps no longer includes a hash of the ciphertext in the\n      derivation of the shared secret, and ML-KEM.Decaps has been adjusted to match this\n      change.\n     â€¢ In the third-round specification [4], the initial randomness ğ‘š in the ML-KEM.Encaps algo-\n      rithm was first hashed before being used. Specifically, between lines 1 and 2 in Algorithm\n      20, there was an additional step that performed the operation ğ‘š â† ğ»(ğ‘š). The purpose\n      of this step was to safeguard against the use of flawed randomness generation processes.\n       As this standard requires the use of NIST-approved randomness generation, this step is\n      unnecessary and is not performed in ML-KEM.\n     â€¢ This specification includes explicit input checking steps that were not part of the third-round\n      specification [4]. For example, ML-KEM.Encaps requires that the byte array containing the\n      encapsulation key correctly decodes to an array of integers modulo ğ‘ without any modular\n      reductions.\n\nC.2   Changes From FIPS 203 Initial Public Draft\n      The differences between CRYSTALS-KYBER and ML-KEM as described in Appendix C were included\nin the initial public draft (ipd) of FIPS 203, which was posted on August 24, 2023.     Based on\ncomments submitted on the draft ML-KEM, domain separation was added to K-PKE.KeyGen to\nprevent the misuse of keys generated to target one security level from being used for a different\nsecurity level when saving a key as a seed.\nAdditionally, FIPS 203 ipd had inadvertently swapped the indices of matrix ğ€ in K-PKE.KeyGen and\nK-PKE.Encrypt. This was changed back in the final version of ML-KEM to match CRYSTALS-KYBER.\n\n                                           47"}
{"doc_id": "NIST.FIPS.204", "source_path": "data/raw_pdfs/NIST.FIPS.204.pdf", "page_number": 1, "text": "  FIPS 204\n\n  Federal Information Processing Standards Publication\n\n  Module-Lattice-Based Digital\n  Signature Standard\n\n  Category: Computer Security                         Subcategory: Cryptography\n\n  Information Technology Laboratory\n  National Institute of Standards and Technology\n  Gaithersburg, MD 20899-8900\n\n  This publication is available free of charge from:\n  https://doi.org/10.6028/NIST.FIPS.204\n\n  Published August 13, 2024\n\n  U.S. Department of Commerce\n  Gina M. Raimondo, Secretary\n\n 0 National Institute of Standards and Technology\n  Laurie E. Locascio, NIST Director and Under Secretary of Commerce for Standards and Technology\n\nCheck\n   for\nupdates"}
{"doc_id": "NIST.FIPS.204", "source_path": "data/raw_pdfs/NIST.FIPS.204.pdf", "page_number": 2, "text": "                                                 Foreword\n\n  The Federal Information Processing Standards Publication Series of the National Institute of Standards\nand Technology is the official series of publications relating to standards and guidelines developed under\n    15 U.S.C. 278g-3, and issued by the Secretary of Commerce under 40 U.S.C. 11331.\n   Comments concerning this Federal Information Processing Standard publication are welcomed and should\n  be submitted using the contact information in the â€œInquiries and commentsâ€ clause of the announcement\n    section.\n\n            Kevin M. Stine, Director\n            Information Technology Laboratory"}
{"doc_id": "NIST.FIPS.204", "source_path": "data/raw_pdfs/NIST.FIPS.204.pdf", "page_number": 3, "text": "FIPS 204                         MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n\n                                 Abstract\nDigital signatures are used to detect unauthorized modifications to data and to authenticate the identity\nof the signatory. In addition, the recipient of signed data can use a digital signature as evidence in\ndemonstrating to a third party that the signature was, in fact, generated by the claimed signatory. This is\nknown as non-repudiation since the signatory cannot easily repudiate the signature at a later time. This\nstandard specifies ML-DSA, a set of algorithms that can be used to generate and verify digital signatures.\nML-DSA is believed to be secure, even against adversaries in possession of a large-scale quantum computer.\n\nKeywords: cryptography; digital signatures; Federal Information Processing Standards; lattice; post-\nquantum; public-key cryptography."}
{"doc_id": "NIST.FIPS.204", "source_path": "data/raw_pdfs/NIST.FIPS.204.pdf", "page_number": 4, "text": "FIPS 204                                           MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n\n            Federal Information Processing Standards Publication 204\n\n       Published:                                  August 13, 2024\n       Effective:                                  August 13, 2024\n\n                            Announcing the\n       Module-Lattice-Based Digital Signature Standard\n\nFederal Information Processing Standards (FIPS) publications are developed by the National Institute of\nStandards and Technology (NIST) under 15 U.S.C. 278g-3 and issued by the Secretary of Commerce under\n40 U.S.C. 11331.\n\n1.     Name of Standard. Module-Lattice-Based Digital Signature Standard (FIPS 204).\n\n2.     Category of Standard. Computer Security. Subcategory. Cryptography.\n\n3.     Explanation. This standard specifies ML-DSA, a lattice-based digital signature algorithm for applications\n       that require a digital signature rather than a written signature. Additional digital signature schemes are\n       specified and approved in other NIST Special Publications and FIPS publications (e.g., FIPS 186-5 [1]).\n       A digital signature is represented in a computer as a string of bits and computed using a set of rules\n       and parameters that allow the identity of the signatory and the integrity of the data to be verified.\n       Digital signatures may be generated on both stored and transmitted data.\n       Signature generation uses a private key to generate a digital signature. Signature verification uses\n       a public key that corresponds to but is not the same as the private key. Each signatory possesses a\n       key-pair composed of a private key and a corresponding public key. Public keys may be known by\n       the public, but private keys must be kept secret. Anyone can verify the signature by employing the\n       signatoryâ€™s public key. Only the user who possesses the private key can generate a signature that can\n       be verified by the corresponding public key.\n       The digital signature is provided to the intended verifier along with the signed data. The verifying\n       entity verifies the signature by using the claimed signatoryâ€™s public key. Similar procedures may be\n       used to generate and verify signatures for both stored and transmitted data.\n       This standard specifies several parameter sets for ML-DSA that are approved for use. Additional\n       parameter sets may be specified and approved in future NIST Special Publications.\n\n4.     Approving Authority. Secretary of Commerce.\n\n5.     Maintenance Agency. Department of Commerce, National Institute of Standards and Technology,\n       Information Technology Laboratory (ITL).\n\n6.     Applicability. This standard is applicable to all federal departments and agencies for the protection of\n       sensitive unclassified information that is not subject to section 2315 of Title 10, United States Code,\n       or section 3502 (2) of Title 44, United States Code. Either this standard, FIPS 205, FIPS 186-5, or NIST\n       Special Publication 800-208 shall be used in designing and implementing public-key-based signature\n       systems that federal departments and agencies operate or that are operated for them under contract.\n       In the future, additional digital signature schemes may be specified and approved in FIPS or NIST\n       Special Publications.\n       The adoption and use of this standard are available to private and commercial organizations.\n                                                   i"}
{"doc_id": "NIST.FIPS.204", "source_path": "data/raw_pdfs/NIST.FIPS.204.pdf", "page_number": 5, "text": "FIPS 204    MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n\n7.     Applications. A digital signature algorithm allows an entity to authenticate the integrity of signed\n       data and the identity of the signatory. The recipient of a signed message can use a digital signature as\n       evidence in demonstrating to a third party that the signature was, in fact, generated by the claimed\n       signatory. This is known as non-repudiation since the signatory cannot easily repudiate the signature\n       at a later time. A digital signature algorithm is intended for use in electronic mail, electronic funds\n       transfer, electronic data interchange, software distribution, data storage, and other applications that\n       require data integrity assurance and data origin authentication.\n8.     Implementations. A digital signature algorithm may be implemented in software, firmware, hardware,\n       or any combination thereof.           NIST will develop a validation program to test implementations for\n       conformance to the algorithm in this standard. For every computational procedure that is specified in\n       this standard, a conforming implementation may replace the given set of steps with any mathematically\n       equivalent set of steps. In other words, different procedures that produce the correct output for every\n       input are permitted.\n       Information about validation programs is available at https://csrc.nist.gov/projects/cmvp. Examples\n       for digital signature algorithms are available at https://csrc.nist.gov/projects/cryptographic-standards\n       -and-guidelines/example-values.\n       Agencies are advised that digital signature key pairs shall not be used for other purposes.\n9.     Other Approved Security Functions. Digital signature implementations that comply with this standard\n       shall employ cryptographic algorithms that have been approved for protecting Federal Government-\n       sensitive information. Approved cryptographic algorithms and techniques include those that are\n       either:\n       a.  Specified in a Federal Information Processing Standards (FIPS) publication,\n       b.  Adopted in a FIPS or NIST recommendation, or\n       c.  Specified in the list of approved security functions in SP 800-140C.\n10. Export Control. Certain cryptographic devices and technical data regarding them are subject to federal\n       export controls. Exports of cryptographic modules that implement this standard and technical data\n       regarding them must comply with these federal regulations and be licensed by the Bureau of Industry\n       and Security of the U.S. Department of Commerce. Information about export regulations is available\n       at https://www.bis.doc.gov.\n11. Patents. The algorithm in this standard may be covered by U.S. or foreign patents.\n12. Implementation Schedule. This standard becomes effective immediately upon final publication.\n13. Specifications. Federal Information Processing Standards (FIPS) 204, Module-Lattice-Based Digital\n       Signature Standard (affixed).\n14. Qualifications. The security of a digital signature system depends on maintaining the secrecy of the\n       signatoryâ€™s private keys.    Signatories shall, therefore, guard against the disclosure of their private\n       keys. While it is the intent of this standard to specify general security requirements for generating\n       digital signatures, conformance to this standard does not ensure that a particular implementation is\n       secure. It is the responsibility of an implementer to ensure that any module that implements a digital\n       signature capability is designed and built in a secure manner.\n       Similarly, the use of a product containing an implementation that conforms to this standard does not\n       guarantee the security of the overall system in which the product is used. The responsible authority in\n       each agency or department shall ensure that an overall implementation provides an acceptable level\n       of security.\n                                      ii"}
{"doc_id": "NIST.FIPS.204", "source_path": "data/raw_pdfs/NIST.FIPS.204.pdf", "page_number": 6, "text": "FIPS 204    MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n\n Since a standard of this nature must be flexible enough to adapt to advancements and innovations in\n science and technology, this standard will be reviewed every five years in order to assess its adequacy.\n\n15. Waiver Procedure. The Federal Information Security Management Act (FISMA) does not allow for\n waivers to Federal Information Processing Standards (FIPS) that are made mandatory by the Secretary\n of Commerce.\n\n16. Where to Obtain Copies of the Standard. This publication is available by accessing https://csrc.nist.\n gov/publications. Other computer security publications are available at the same website.\n\n17. How to Cite This Publication. NIST has assigned NIST FIPS 204 as the publication identifier for this\n FIPS, per the NIST Technical Series Publication Identifier Syntax. NIST recommends that it be cited as\n follows:\n  National Institute of Standards and Technology (2024) Module-Lattice-Based Digital Signa-\n  ture Standard. (Department of Commerce, Washington, D.C.), Federal Information Pro-\n  cessing Standards Publication (FIPS) NIST FIPS 204. https://doi.org/10.6028/NIST.FIPS.204\n\n18. Inquiries and Comments. Inquiries and comments about this FIPS may be submitted to fips-204-\n comments@nist.gov.\n\niii"}
{"doc_id": "NIST.FIPS.204", "source_path": "data/raw_pdfs/NIST.FIPS.204.pdf", "page_number": 7, "text": "    FIPS 204    MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n\nFederal Information Processing Standards Publication 204\n\n                 Specification for the\n    Module-Lattice-Based Digital Signature Standard\n\n                                                Table of Contents\n\n    1  Introduction                                                                                               1\n       1.1     Purpose and Scope      . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     1\n       1.2      Context . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     1\n\n    2  Glossary of Terms, Acronyms, and Symbols                                                                   2\n       2.1     Terms and Definitions    . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     2\n       2.2       Acronyms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     5\n       2.3     Mathematical Symbols       . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     5\n       2.4     Notation   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     7\n               2.4.1     Rings  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     7\n               2.4.2     Vectors and Matrices   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     7\n       2.5     NTT Representation     . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     8\n\n    3  Overview of the ML-DSA Signature Scheme                                                                    9\n       3.1     Security Properties    . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     9\n       3.2     Computational Assumptions        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     9\n       3.3     ML-DSA Construction      . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     9\n       3.4     Hedged and Deterministic Signing       . . . . . . . . . . . . . . . . . . . . . . . . . . . .    11\n       3.5      Use of Digital Signatures . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .    11\n       3.6     Additional Requirements      . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .    12\n               3.6.1     Randomness Generation      . . . . . . . . . . . . . . . . . . . . . . . . . . . . .    12\n               3.6.2     Public-Key and Signature Length Checks . . . . . . . . . . . . . . . . . . . .     .    12\n               3.6.3     Intermediate Values    . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .    12\n               3.6.4     No Floating-Point Arithmetic   . . . . . . . . . . . . . . . . . . . . . . . . . . .    13\n       3.7          Use of Symmetric Cryptography . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .    13\n\n    4  Parameter Sets                                                                                            15\n\n    5  External Functions                                                                                        17\n       5.1          ML-DSA Key Generation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .    17\n       5.2     ML-DSA Signing     . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .    17\n       5.3     ML-DSA Verifying     . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .    18\n                                                      iv"}
{"doc_id": "NIST.FIPS.204", "source_path": "data/raw_pdfs/NIST.FIPS.204.pdf", "page_number": 8, "text": "FIPS 204    MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n\n   5.4     Pre-Hash ML-DSA    . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .    18\n           5.4.1  HashML-DSA Signing and Verifying      . . . . . . . . . . . . . . . . . . . . . . . .    19\n6  Internal Functions                                                                                      22\n   6.1     ML-DSA Key Generation (Internal)     . . . . . . . . . . . . . . . . . . . . . . . . . . . .    22\n   6.2     ML-DSA Signing (Internal)  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .    23\n   6.3     ML-DSA Verifying (Internal)  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .    25\n\n7  Auxiliary Functions                                                                                     28\n   7.1     Conversion Between Data Types      . . . . . . . . . . . . . . . . . . . . . . . . . . . . .    28\n   7.2     Encodings of ML-DSA Keys and Signatures      . . . . . . . . . . . . . . . . . . . . . . . .    33\n   7.3     Pseudorandom Sampling      . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .    36\n   7.4     High-Order and Low-Order Bits and Hints      . . . . . . . . . . . . . . . . . . . . . . . .    39\n   7.5     NTT and NTTâˆ’1    . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .    42\n   7.6     Arithmetic Under NTT   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .    45\n\nReferences                                                                                                 47\n\nAppendix A â€” Montgomery Multiplication                                                                     50\n\nAppendix B â€” Zetas Array                                                                                   51\n\nAppendix C â€” Loop Bounds                                                                                   52\n\nAppendix D â€” Differences from the CRYSTALS-DILITHIUM Submission                                            54\n   D.1     Differences Between Version 3.1 and the Round 3 Version of CRYSTALS-DILITHIUM            . .    54\n   D.2     Differences Between Version 3.1 of CRYSTALS-DILITHIUM and FIPS 204 Initial Public Draft         54\n   D.3     Changes From FIPS 204 Initial Public Draft   . . . . . . . . . . . . . . . . . . . . . . . .    54\n\nv"}
{"doc_id": "NIST.FIPS.204", "source_path": "data/raw_pdfs/NIST.FIPS.204.pdf", "page_number": 9, "text": "FIPS 204                                               MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n\n                                          List of Tables\n\n Table 1       ML-DSA parameter sets         . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .           15\n Table 2       Sizes (in bytes) of keys and signatures of ML-DSA . . . . . . . . . . . . . .  .  .  .    .           16\n Table 3       While loop and XOF output limits for a 2âˆ’256 or less probability of failure .  .  .  .    .           52\n\n                                       List of Algorithms\nAlgorithm 1      ML-DSA.KeyGen()             . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .           17\nAlgorithm 2      ML-DSA.Sign(ğ‘ ğ‘˜, ğ‘€, ğ‘ğ‘¡ğ‘¥)       . . . . . . . . . . . . . . . . . . . . . . . . . . .           18\nAlgorithm 3      ML-DSA.Verify(ğ‘ğ‘˜, ğ‘€, ğœ, ğ‘ğ‘¡ğ‘¥)     . . . . . . . . . . . . . . . . . . . . . . . . .           18\nAlgorithm 4      HashML-DSA.Sign(ğ‘ ğ‘˜, ğ‘€, ğ‘ğ‘¡ğ‘¥, PH)         . . . . . . . . . . . . . . . . . . . . . .           20\nAlgorithm 5      HashML-DSA.Verify(ğ‘ğ‘˜, ğ‘€, ğœ, ğ‘ğ‘¡ğ‘¥, PH)       . . . . . . . . . . . . . . . . . . . .           21\nAlgorithm 6                  ML-DSA.KeyGen_internal(ğœ‰) . . . . . . . . . . . . . . . . . . . . . . . . . .          23\nAlgorithm 7                  ML-DSA.Sign_internal(ğ‘ ğ‘˜, ğ‘€â€², ğ‘Ÿğ‘›ğ‘‘) . . . . . . . . . . . . . . . . . . . . . .     25\nAlgorithm 8      ML-DSA.Verify_internal(ğ‘ğ‘˜, ğ‘€â€², ğœ)         . . . . . . . . . . . . . . . . . . . . . .           27\nAlgorithm 9      IntegerToBits(ğ‘¥, ğ›¼)       . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .           28\nAlgorithm 10     BitsToInteger(ğ‘¦, ğ›¼)       . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .           28\nAlgorithm 11     IntegerToBytes(ğ‘¥, ğ›¼)        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .           28\nAlgorithm 12     BitsToBytes(ğ‘¦)         . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .           29\nAlgorithm 13     BytesToBits(ğ‘§)         . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .           29\nAlgorithm 14     CoeffFromThreeBytes(ğ‘0, ğ‘1, ğ‘2)        . . . . . . . . . . . . . . . . . . . . . . . .           29\nAlgorithm 15     CoeffFromHalfByte(ğ‘)           . . . . . . . . . . . . . . . . . . . . . . . . . . . . .           30\nAlgorithm 16     SimpleBitPack(ğ‘¤, ğ‘)         . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .           30\nAlgorithm 17     BitPack(ğ‘¤, ğ‘, ğ‘)     . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .           30\nAlgorithm 18     SimpleBitUnpack(ğ‘£, ğ‘)         . . . . . . . . . . . . . . . . . . . . . . . . . . . . .           31\nAlgorithm 19     BitUnpack(ğ‘£, ğ‘, ğ‘)     . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .           31\nAlgorithm 20     HintBitPack(ğ¡)         . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .           32\nAlgorithm 21     HintBitUnpack(ğ‘¦)         . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .           32\nAlgorithm 22     pkEncode(ğœŒ, ğ­1)       . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .           33\nAlgorithm 23     pkDecode(ğ‘ğ‘˜)        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .           33\nAlgorithm 24     skEncode(ğœŒ, ğ¾, ğ‘¡ğ‘Ÿ, ğ¬1, ğ¬2, ğ­0) . . . . . . . . . . . . . . . . . . . . . . . . . .           34\nAlgorithm 25     skDecode(ğ‘ ğ‘˜)        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .           34\nAlgorithm 26     sigEncode(ğ‘, ğ³, ğ¡)     . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .           35\nAlgorithm 27     sigDecode(ğœ)         . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .           35\nAlgorithm 28     w1Encode(ğ°1)           . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .           35\nAlgorithm 29     SampleInBall(ğœŒ)        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .           36\nAlgorithm 30     RejNTTPoly(ğœŒ)          . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .           37\nAlgorithm 31     RejBoundedPoly(ğœŒ)          . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .           37\nAlgorithm 32     ExpandA(ğœŒ)         . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .           38\nAlgorithm 33     ExpandS(ğœŒ)         . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .           38\nAlgorithm 34              ExpandMask(ğœŒ, ğœ‡) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .         38\nAlgorithm 35     Power2Round(ğ‘Ÿ)           . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .           40\nAlgorithm 36              Decompose(ğ‘Ÿ) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .          40\nAlgorithm 37     HighBits(ğ‘Ÿ)        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .           40\nAlgorithm 38            LowBits(ğ‘Ÿ) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .          41\n\n                                                       vi"}
{"doc_id": "NIST.FIPS.204", "source_path": "data/raw_pdfs/NIST.FIPS.204.pdf", "page_number": 10, "text": "FIPS 204    MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n\nAlgorithm 39     MakeHint(ğ‘§, ğ‘Ÿ)    . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .       41\nAlgorithm 40     UseHint(â„, ğ‘Ÿ)    . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .       41\nAlgorithm 41     NTT(ğ‘¤)     . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .       43\nAlgorithm 42         NTTâˆ’1(ğ‘¤)Ì‚ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .      44\nAlgorithm 43        BitRev8(ğ‘š) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .      44\nAlgorithm 44     AddNTT(ğ‘,Ì‚ ğ‘)   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .       45\nAlgorithm 45        MultiplyNTT(ğ‘,Ì‚ ğ‘) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     45\nAlgorithm 46          AddVectorNTT(ğ¯,Ì‚ ğ°)Ì‚ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     45\nAlgorithm 47     ScalarVectorNTT(ğ‘,Ì‚ ğ¯)Ì‚   . . . . . . . . . . . . . . . . . . . . . . . . . . . . .       46\nAlgorithm 48            MatrixVectorNTT(ğŒ, ğ¯)Ì‚ . . . . . . . . . . . . . . . . . . . . . . . . . . . .     46\nAlgorithm 49     MontgomeryReduce(ğ‘)        . . . . . . . . . . . . . . . . . . . . . . . . . . . . .       50\n\nvii"}
{"doc_id": "NIST.FIPS.204", "source_path": "data/raw_pdfs/NIST.FIPS.204.pdf", "page_number": 11, "text": "FIPS 204                                      MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n\n1.   Introduction\n\n1.1  Purpose and Scope\n  This standard defines a digital signature scheme, which includes a method for digital signature generation\nthat can be used for the protection of binary data (commonly called a â€œmessageâ€) and a method for the\nverification and validation of those digital signatures. NIST Special Publication (SP) 800-175B [2], Guideline\nfor Using Cryptographic Standards in the Federal Government: Cryptographic Mechanisms, includes a\ngeneral discussion of digital signatures.\n    This standard specifies the mathematical steps that need to be performed for key generation, signature\ngeneration, and signature verification. In order for digital signatures to be valid, additional assurances\nare required, such as assurance of identity and of private key possession. SP 800-89, Recommendation\nfor Obtaining Assurances for Digital Signature Applications [3], specifies the required assurances and the\nmethods for obtaining them.\n     The digital signature scheme approved in this standard is the Module-Lattice-Based Digital Signature\n    Algorithm (ML-DSA), which is based on the Module Learning With Errors problem [4]. ML-DSA is believed\nto be secure, even against adversaries in possession of a large-scale fault-tolerant quantum computer. In\nparticular, ML-DSA is believed to be strongly unforgeable, which implies that the scheme can be used to\ndetect unauthorized modifications to data and to authenticate the identity of the signatory (one bound\nto the possession of the private-key).   In addition, a signature generated by this scheme can be used\nas evidence in demonstrating to a third party that the signature was, in fact, generated by the claimed\nsignatory. The latter property is known as non-repudiation since the signatory cannot easily repudiate the\nsignature at a later time.\n  This standard gives algorithms for ML-DSA key generation, signature generation, and signature verification\n    (Section 5), and for supporting algorithms used by them (Section 7). ML-DSA is standardized with three\npossible parameter sets, each of which corresponds to a different security strength. Section 4 describes\nthe global parameters used by these algorithms and enumerates the parameter sets for ML-DSA that are\napproved by this standard. ML-DSA can be used in place of other digital signature schemes specified in\nNIST FIPS and Special Publications (e.g., FIPS 186-5, Digital Signature Standard (DSS) [1]).\n\n1.2  Context\nOver the past several years, there has been steady progress toward building quantum computers. The\nsecurity of many commonly used public-key cryptosystems will be at risk if large-scale quantum computers\nare ever realized. This would include key-establishment schemes and digital signatures that are based on\ninteger factorization and discrete logarithms (both over finite fields and elliptic curves). As a result, in 2016,\nNIST initiated a public Post-Quantum Cryptography (PQC) Standardization process to select quantum-\nresistant public-key cryptographic algorithms for standardization. A total of 82 candidate algorithms were\nsubmitted to NIST for consideration.\nAfter three rounds of evaluation and analysis, NIST selected the first four algorithms for standardization.\nML-DSA is derived from one of the selected schemes, CRYSTALS-DILITHIUM [5, 6], and is intended to protect\nsensitive U.S. Government information well into the foreseeable future, including after the advent of\ncryptographically relevant quantum computers. For the differences between ML-DSA and CRYSTALS-\nDILITHIUM, see Appendix D.\n\n1"}
{"doc_id": "NIST.FIPS.204", "source_path": "data/raw_pdfs/NIST.FIPS.204.pdf", "page_number": 12, "text": "FIPS 204                                             MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n\n2.   Glossary of Terms, Acronyms, and Symbols\n\n2.1  Terms and Definitions\n\n approved                    FIPS-approved and/or NIST-recommended. An algorithm or technique that\n                             is either 1) specified in a FIPS or NIST recommendation, 2) adopted in a FIPS\n                             or NIST recommendation, or 3) specified in a list of NIST-approved security\n                             functions.\n\n assurance of                Confidence that an entity possesses a private key and any associated keying\n possession                  material.\n\n asymmetric                  Cryptography that uses two separate keys to exchange data â€” one to encrypt\n cryptography                or digitally sign the data and one to decrypt the data or verify the digital\n                             signature. Also known as public-key cryptography.\n\n bit string                  An ordered sequence of zeros and ones.\n\n byte                        An integer from the set {0, 1, 2, â€¦, 255}.\n\n byte string                 An ordered sequence of bytes.\n\n certificate                 A set of data that uniquely identifies a public key that has a corresponding\n                             private key and an owner that is authorized to use the key pair. The certificate\n                             contains the ownerâ€™s public key and possibly other information and is digitally\n                             signed by a certification authority (i.e., a trusted party), thereby binding the\n                             public key to the owner.\n\n certification authority     The entity in a public-key infrastructure (PKI) that is responsible for issuing\n (CA)                        certificates and exacting compliance with a PKI policy.\n\n claimed signatory           From the verifierâ€™s perspective, the claimed signatory is the entity that pur-\n                             portedly generated a digital signature.\n\n destroy                     An action applied to a key or a piece of secret data. After a key or a piece of\n                             secret data is destroyed, no information about its value can be recovered.\n\n digital signature           The result of a cryptographic transformation of data that, when properly\n                             implemented, provides a mechanism to verify origin authenticity and data\n                             integrity and to enforce signatory non-repudiation.\n\n entity                      An individual person, organization, device, or process. Used interchangeably\n                            with party.\n\n equivalent process          Two processes are equivalent if the same output is produced when the same\n                             values are input to each process (either as input parameters, as values made\n                             available during the process, or both).\n\n eXtendable-Output           A function on bit strings in which the output can be extended to any desired\n Function (XOF)              length. Approved XOFs (e.g., those specified in FIPS 202 [7]) are designed\n                             to satisfy the following properties as long as the specified output length is\n                             sufficiently long to prevent trivial attacks:\n\n                                       2"}
{"doc_id": "NIST.FIPS.204", "source_path": "data/raw_pdfs/NIST.FIPS.204.pdf", "page_number": 13, "text": "FIPS 204    MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n\n                          1.  (One-way) It is computationally infeasible to find any input that maps to\n                              any new pre-specified output.\n                          2.  (Collision-resistant) It is computationally infeasible to find any two dis-\n                              tinct inputs that map to the same output.\n\nfresh random value      A previously unused output of a random bit generator.\n\nhash function           A function on bit strings in which the length of the output is fixed. Approved\n                         hash functions (such as those specified in FIPS 180 [8] and FIPS 202 [7]) are\n                         designed to satisfy the following properties:\n                          1.  (One-way) It is computationally infeasible to find any input that maps to\n                              any new pre-specified output.\n                          2.  (Collision-resistant) It is computationally infeasible to find any two dis-\n                              tinct inputs that map to the same output.\n\nhash value               See message digest.\n\nkey                     A parameter used in conjunction with a cryptographic algorithm that deter-\n                         mines its operation. Examples of cryptographic algorithms applicable to this\n                         standard include:\n                          1.  The computation of a digital signature from data\n                          2.  The verification of a digital signature\n\nkey pair                A public key and its corresponding private key.\n\nlittle-endian           The property of a byte string having its bytes positioned in order of increasing\n                         significance. In particular, the leftmost (first) byte is the least significant,\n                         and the rightmost (last) byte is the most significant. The term â€œlittle-endianâ€\n                         may also be applied in the same manner to bit strings (e.g., the 8-bit string\n                        11010001 corresponds to the byte 20 + 21 + 23 + 27 = 139).\n\nmessage                 The data that is signed. Also known as signed data during the signature\n                        verification and validation process.\n\nmessage digest          The result of applying a hash function to a message. Also known as a hash\n                        value.\n\nnon-repudiation         A service that is used to provide assurance of the integrity and origin of data\n                         in such a way that the integrity and origin can be verified and validated by\n                         a third party as having originated from a specific entity in possession of the\n                         private key (i.e., the signatory).\n\nowner                   A key pair owner is the entity authorized to use the private key of a key pair.\n\nparty                   An individual person, organization, device, or process. Used interchangeably\n                        with entity.\n\npublic-key              A framework that is established to issue, maintain, and revoke public key\ninfrastructure (PKI)     certificates.\n\n3"}
{"doc_id": "NIST.FIPS.204", "source_path": "data/raw_pdfs/NIST.FIPS.204.pdf", "page_number": 14, "text": "FIPS 204    MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n\nprivate key                A cryptographic key that is used with an asymmetric (public-key) cryptographic\n                           algorithm. The private key is uniquely associated with the owner and is not\n                           made public. The private key is used to compute a digital signature that may\n                           be verified using the corresponding public key.\n\npseudorandom               A process or data produced by a process is said to be pseudorandom when the\n                           outcome is deterministic yet also effectively random as long as the internal\n                           action of the process is hidden from observation. For cryptographic purposes,\n                          â€œeffectively randomâ€ means â€œcomputationally indistinguishable from random\n                           within the limits of the intended security strength.â€\n\npublic key                 A cryptographic key that is used with an asymmetric (public-key) cryptographic\n                           algorithm and is associated with a private key. The public key is associated\n                           with an owner and may be made public. In the case of digital signatures, the\n                           public key is used to verify a digital signature that was generated using the\n                           corresponding private key.\n\nsecurity category          A number associated with the security strength of a post-quantum crypto-\n                           graphic algorithm, as specified by NIST (see [9, Sect. 5.6]).\n\nsecurity strength          A number associated with the amount of work (i.e., the number of operations)\n                           that is required to break a cryptographic algorithm or system.\n\nseed                       A bit string used as input to a pseudorandom process.\n\nshall                      Used to indicate a requirement of this standard.\n\nshould                     Used to indicate a strong recommendation but not a requirement of this\n                           standard. Ignoring the recommendation could lead to undesirable results.\n\nsignatory                  The entity that generates a digital signature on data using a private key.\n\nsignature generation       The process of using a digital signature algorithm and a private key to generate\n                           a digital signature on data.\n\nsignature validation       The mathematical verification of the digital signature along with obtaining the\n                           appropriate assurances (e.g., public-key validity, private-key possession, etc.).\n\nsignature verification     The process of using a digital signature algorithm and a public key to verify a\n                           digital signature on data.\n\nsigned data                The data or message upon which a digital signature has been computed. Also\n                           see message.\n\ntrusted third party        An entity other than the key pair owner and the verifier that is trusted by the\n(TTP)                      owner, the verifier, or both. Sometimes shortened to â€œtrusted party.â€\n\nverifier                   The entity that verifies the authenticity of a digital signature using the public\n                           key of the signatory.\n\n4"}
{"doc_id": "NIST.FIPS.204", "source_path": "data/raw_pdfs/NIST.FIPS.204.pdf", "page_number": 15, "text": "FIPS 204                                     MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n\n2.2      Acronyms\n AES             Advanced Encryption Standard\n API             Application Programming Interface\n DER             Distinguished Encoding Rules\n FIPS            Federal Information Processing Standard\n ML-DSA          Module-Lattice-Based Digital Signature Algorithm\n MLWE            Module Learning With Errors\n NIST            National Institute of Standards and Technology\n NIST IR         NIST Interagency or Internal Report\n NTT             Number Theoretic Transform\n OID             Object Identifier\n PQC             Post-Quantum Cryptography\n RBG             Random Bit Generator\n SHA             Secure Hash Algorithm\n SHAKE           Secure Hash Algorithm KECCAK\n SP              Special Publication\n SUF-CMA         Strongly existentially UnForgeable under Chosen Message Attack\n XOF             eXtendable-Output Function\n\n2.3      Mathematical Symbols\nThe following symbols and mathematical expressions are used in this standard.\n\n ğ‘              The prime number ğ‘ = 223 âˆ’ 213 + 1 = 8380417.\n ğ”¹              The set {0, 1, â€¦ , 255} of integers represented by a byte.\n â„•               The set of natural numbers {1, 2, 3, â€¦}.\n â„¤               The ring of integers.\n â„¤ğ‘š             The ring of integers modulo ğ‘š whose set of elements is {0, 1, â€¦ , ğ‘š âˆ’ 1}.\n â„¤ğ‘›             The set of ğ‘›-tuples over â„¤ğ‘š equipped with the â„¤-module structure.\n       ğ‘š\n ğ‘…              The ring of single-variable polynomials over â„¤ modulo ğ‘‹256 + 1, also denoted by\n                 â„¤[ğ‘‹]/(ğ‘‹256 + 1).\n ğ‘…ğ‘š            The ring of single-variable polynomials over â„¤ğ‘š modulo ğ‘‹256 + 1, also denoted by\n                 â„¤ğ‘š[ğ‘‹]/(ğ‘‹256 + 1).\n                                             5"}
{"doc_id": "NIST.FIPS.204", "source_path": "data/raw_pdfs/NIST.FIPS.204.pdf", "page_number": 16, "text": "FIPS 204    MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n\nğµğœ            The set of all polynomials ğ‘ = âˆ‘255 ğ‘ğ‘–ğ‘‹ğ‘– in ğ‘…ğ‘ that are such that exactly ğœ of the\n                coefficients of ğ‘ are from the setğ‘–=0       , and all other coefficients are zero. (See\n                Section 7.3.)      ğ‘–           {âˆ’1, 1}\nÎ                Used to denote a direct product of two or more rings, where addition and multipli-\n                cation are performed componentwise.\nğ‘‡ğ‘            The ring Î 255 â„¤ğ‘.\n                          ğ‘—=0\nğ´ Ã— ğµ         Cartesian product of two sets ğ´, ğµ.\n[ğ‘, ğ‘]        For two integers ğ‘ â‰¤ ğ‘, [ğ‘, ğ‘] denotes the set of integers {ğ‘, ğ‘ + 1, â€¦ , ğ‘}.\nbitlen ğ‘       The bit length of a positive integer ğ‘. The bit length of ğ‘ is the number of digits that\n                would appear in a base-2 representation of ğ‘, where the most significant digit in\n                the representation is assumed to be a 1 (e.g., bitlen 32 = 6 and bitlen 31 = 5).1\nBitRev8(ğ‘Ÿ)     Bit reversal of an 8-bit integer ğ‘Ÿ. If ğ‘Ÿ = ğ‘Ÿ0 + 2ğ‘Ÿ1 + 4ğ‘Ÿ2 + â€¦ + 128ğ‘Ÿ7 with ğ‘Ÿğ‘– âˆˆ {0, 1},\n                then BitRev8(ğ‘Ÿ) = ğ‘Ÿ7 + 2ğ‘Ÿ6 + 4ğ‘Ÿ5 + â€¦ + 128ğ‘Ÿ0.\n0x              Prefix to an integer written in hexadecimal representation.\nlog2 ğ‘¥         The base 2 logarithm of ğ‘¥. For example, log2(16) = 4.\n mod            If ğ›¼ is a positive integer and ğ‘š âˆˆ â„¤ or ğ‘š âˆˆ â„¤ğ›¼, then ğ‘š mod ğ›¼ denotes the unique\n                element ğ‘šâ€²    âˆˆ â„¤ in the range 0 â‰¤ ğ‘šâ€² < ğ›¼ such that ğ‘š and ğ‘šâ€² are congruent\n                modulo ğ›¼.\n modÂ±           If ğ›¼ is a positive integer and ğ‘š âˆˆ â„¤ or ğ‘š âˆˆ â„¤ğ›¼, then ğ‘š modÂ±ğ›¼ denotes the unique\n                element ğ‘šâ€² âˆˆ â„¤ in the range âˆ’âŒˆğ›¼/2âŒ‰ < ğ‘šâ€² â‰¤ âŒŠğ›¼/2âŒ‹ such that ğ‘š and ğ‘šâ€² are\n                congruent modulo ğ›¼.\nâŒŠğ‘¥âŒ‹            The largest integer less than or equal to the real number ğ‘¥, called the floor of ğ‘¥. For\n                example, âŒŠ2.1âŒ‹ = 2, and âŒŠ4âŒ‹ = 4.\nâŒˆğ‘¥âŒ‰            The least integer greater than or equal to the real number ğ‘¥, called the ceiling of ğ‘¥.\n                For example, âŒˆ5âŒ‰ = 5 and âŒˆ5.3âŒ‰ = 6.\nâ€–â‹…â€–âˆ            The infinity norm.       For an element ğ‘¤ âˆˆ  â„¤, â€–ğ‘¤â€–âˆ = |ğ‘¤|, the absolute value of\n                ğ‘¤. For an element ğ‘¤ âˆˆ â„¤ğ‘,â€–ğ‘¤â€–âˆ = âˆ£ğ‘¤ modÂ±ğ‘âˆ£ . For an element ğ‘¤ of ğ‘… or ğ‘…ğ‘,\n                â€–ğ‘¤â€–âˆ = max0â‰¤ğ‘–<256 â€–ğ‘¤ğ‘–â€–âˆ . For a length-ğ‘š vector ğ° with entries from ğ‘… or ğ‘…ğ‘,\n                â€–ğ°â€–âˆ = max0â‰¤ğ‘–<ğ‘š â€–ğ‘¤[ğ‘–]â€–âˆ .\nğ‘!             The factorial quantity 1 â‹… 2 â‹… 3 â‹… â€¦ â‹… ğ‘. The value 0! is defined as 1.\n(ğ‘)            For ğ‘ â‰¥ ğ‘, the quantity ğ‘!/(ğ‘!(ğ‘ âˆ’ ğ‘)!).\n ğ‘\nğ‘  â† ğ‘¥         In pseudocode, this notation means that the variable ğ‘  is assigned the value of the\n                expression ğ‘¥.\nğ‘  â† ğ”¹â„“        In pseudocode, this notation means that the variable ğ‘  is assigned the value of an\n                array of â„“ random bytes. The bytes must be generated using randomness from an\n                approved RBG. See Section 3.6.1.\n1In this specification, bitlen ğ‘ is only ever called with a small finite number of values for ğ‘, so it may be helpful to\nprecompute bitlen ğ‘ for these values and hard code the results, rather than computing them on the fly.\n                                         6"}
{"doc_id": "NIST.FIPS.204", "source_path": "data/raw_pdfs/NIST.FIPS.204.pdf", "page_number": 17, "text": "FIPS 204    MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n\n   ğ‘¥ âˆˆ ğ‘† â† ğ‘¦        Type casting. The variable ğ‘¥ is assigned a value in a set ğ‘† that is constructed from\n                       the value of an expression ğ‘¦ in a possibly different set ğ‘‡. The set ğ‘‡ and the mapping\n                       from ğ‘‡ to ğ‘† are not explicitly specified, but they should be obvious from the context\n                       in which this statement appears.\n\n   [[ğ‘ < ğ‘]]         A Boolean predicate. A comparison operator inside double square brackets [[ğ‘ < ğ‘]]\n                       denotes that the expression should be evaluated as a Boolean. Booleans can also\n                       be interpreted as elements of â„¤2 with 1 denoting true and 0 denoting false.\n\n   âŸ¨âŸ¨ğ‘“(ğ‘¥)âŸ©âŸ©          A temporary variable that stores the output of a computation ğ‘“(ğ‘¥) so that it can be\n                       used many times without needing to be recomputed. This is equivalent to defining a\n                       temporary variable ğ‘¦ â† ğ‘“(ğ‘¥). Naming the variable âŸ¨âŸ¨ğ‘“(ğ‘¥)âŸ©âŸ© makes the pseudocode\n                       less cluttered.\n\n   ğ‘||ğ‘              Concatenation of two bit or byte strings ğ‘ and ğ‘.\n\n   ğ‘ âˆ˜ ğ‘             Multiplication of ğ‘ and ğ‘ in the ring ğ‘‡ğ‘.\n\n   ğ‘ â‹… ğ‘ or ğ‘ğ‘     Multiplication in any of the rings â„¤, â„¤ğ‘š, ğ‘…, or ğ‘…ğ‘š.\n\n   ğ‘ + ğ‘             Addition of ğ‘ and ğ‘.\n\n   ğ‘/ğ‘               Division of integers. When this notation is used, ğ‘ and ğ‘ are always integers. If ğ‘\n                       cannot be assumed to divide ğ‘, then either âŒŠğ‘/ğ‘âŒ‹ or âŒˆğ‘/ğ‘âŒ‰ is used.\n\n   âŠ¥                   Blank symbol that indicates failure or the lack of an output from an algorithm.\n\n2.4          Notation\n2.4.1         Rings\nElements of the rings â„¤, â„¤ğ‘, â„¤2, ğ‘…, and ğ‘…ğ‘ are denoted by italicized lowercase letters (e.g., ğ‘¤). Elements\nof the ring ğ‘‡ğ‘ are length-256 arrays of elements of â„¤ğ‘, and they are denoted by italicized letters with a\nhat symbol (e.g., ğ‘¤Ì‚). The addition and multiplication of elements of ğ‘‡ğ‘ are performed entry-wise. Thus,\nthe ğ‘–th entry of the product of two elements ğ‘¢Ì‚ and ğ‘£Ì‚ of ğ‘‡ğ‘ is ğ‘¢[ğ‘–] â‹… ğ‘£[ğ‘–] âˆˆ â„¤ğ‘. The multiplication operation\nin ğ‘‡ğ‘ is denoted by the symbol âˆ˜ (see Section 2.3).\nWhen a product ğ‘ â‹… ğ‘ or a sum ğ‘ + ğ‘ is written and either ğ‘ or ğ‘ is a congruence class modulo ğ‘š (i.e., if\neither ğ‘ or ğ‘ is an element of â„¤ğ‘š or ğ‘…ğ‘š), then the product or sum is also understood to be a congruence\nclass modulo ğ‘š (i.e., an element of â„¤ğ‘š or ğ‘…ğ‘š). Likewise, an element of ğ‘… or â„¤ may be â€œtypecastâ€ to an\nelement of ğ‘…ğ‘š or â„¤ğ‘š, respectively, and may be used as the input of a function specified to act on an\nelement of ğ‘…ğ‘š or â„¤ğ‘š, respectively. In both cases, the element itself or its coefficients are mapped from\nâ„¤ to â„¤ğ‘š by taking the unique congruence class modulo ğ‘š that contains the integer.\nThe coefficients of an element ğ‘¤ of ğ‘… or ğ‘…ğ‘š are denoted by ğ‘¤ğ‘– so that ğ‘¤ = ğ‘¤0 + ğ‘¤1ğ‘‹ + â€¦ + ğ‘¤255ğ‘‹255.\nIf ğ‘¤ is in ğ‘… (respectively, ğ‘…ğ‘š) and ğ‘¡ is in â„¤ (respectively, â„¤ğ‘‘), then ğ‘¤(ğ‘¡) denotes the polynomial ğ‘¤ =\nğ‘¤0 + ğ‘¤1ğ‘‹ + â€¦ + ğ‘¤255ğ‘‹255 evaluated at ğ‘‹ = ğ‘¡.\n\n2.4.2         Vectors and Matrices\nVectors with elements in ğ‘… or ğ‘…ğ‘š are denoted by bold lowercase letters (e.g., ğ¯). Matrices with elements\nin ğ‘… or ğ‘…ğ‘š are denoted by bold uppercase letters (e.g., ğ€).\n\n                                                     7"}
{"doc_id": "NIST.FIPS.204", "source_path": "data/raw_pdfs/NIST.FIPS.204.pdf", "page_number": 18, "text": "FIPS 204    MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n\nIf ğ‘† is a ring and ğ¯ is a length-ğ¿ vector over ğ‘†, then the entries in the vector ğ¯ are expressed as\n\n                                     ğ‘£[0], ğ‘£[1], â€¦ , ğ‘£[ğ¿ âˆ’ 1].\n\nThe entries of a ğ¾ Ã— ğ¿ matrix ğ€ over ğ‘† are denoted as ğ€[ğ‘–, ğ‘—], where 0 â‰¤ ğ‘– < ğ¾ and 0 â‰¤ ğ‘— < ğ¿.\nThe set of all length-ğ¿ vectors over ğ‘† is denoted by ğ‘†ğ¿. The set of all ğ¾ Ã— ğ¿ matrices over ğ‘† is denoted\nby ğ‘†ğ¾Ã—ğ¿ . A length-ğ¿ vector can also be treated as an ğ¿ Ã— 1 matrix.\n\n2.5  NTT Representation\nThe Number Theoretic Transform (NTT) is a specific isomorphism between the rings ğ‘…ğ‘ and ğ‘‡ğ‘.         Let\nğœ = 1753 âˆˆ â„¤ğ‘, which is a 512th root of unity. If ğ‘¤ âˆˆ ğ‘…ğ‘, then\n\n                     NTT(ğ‘¤) = (ğ‘¤(ğœ0), ğ‘¤(ğœ1), â€¦ , ğ‘¤(ğœ255)) âˆˆ ğ‘‡ğ‘,                                (2.1)\n\nwhere ğœğ‘– = ğ‘¤(ğœ2BitRevâ‚ˆ(ğ‘–)+1) mod ğ‘. See Section 7.5 for an implementation discussion for NTT and NTTâˆ’1.\nThe motivation for using NTT is that multiplication is considerably faster in the ring ğ‘‡ğ‘. Since NTT is an\nisomorphism, for any ğ‘, ğ‘ âˆˆ ğ‘…ğ‘,  NTT(ğ‘ğ‘) = NTT(ğ‘) âˆ˜ NTT(ğ‘).                                     (2.2)\n\nIf ğ€ is a matrix with entries from ğ‘…ğ‘, then NTT(ğ€) denotes the matrix computed via the entry-wise\napplication of NTT to ğ€. The symbol âˆ˜ is also used to denote the matrix multiplication of matrices with\nentries in ğ‘‡ğ‘. Thus, NTT(ğ€ğ) = NTT(ğ€) âˆ˜ NTT(ğ). Explicit algorithms for linear algebra over ğ‘‡ğ‘ are\ngiven in Section 7.6.\n\n8"}
{"doc_id": "NIST.FIPS.204", "source_path": "data/raw_pdfs/NIST.FIPS.204.pdf", "page_number": 19, "text": "FIPS 204                                  MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n\n3.           Overview of the ML-DSA Signature Scheme\n\nML-DSA is a digital signature scheme based on CRYSTALS-DILITHIUM [6]. It consists of three main algorithms:\nML-DSA.KeyGen (Algorithm 1), ML-DSA.Sign (Algorithm 2), and ML-DSA.Verify (Algorithm 3). The\nML-DSA scheme uses the Fiat-Shamir With Aborts construction [10, 11] and bears the most resemblance\nto the schemes proposed in [12, 13].\n          This document also defines a closely related but domain-separated signature scheme, HashML-DSA, which\ndiffers from ML-DSA in that it includes an additional pre-hashing step before signing. It consists of three\nmain algorithms: ML-DSA.KeyGen (Algorithm 1), which is the same key generation algorithm used for\nML-DSA; HashML-DSA.Sign (Algorithm 4); and HashML-DSA.Verify (Algorithm 5).\n\n3.1          Security Properties\nML-DSA is designed to be strongly existentially unforgeable under chosen message attack (SUF-CMA).\n        That is, it is expected that even if an adversary can get the honest party to sign arbitrary messages, the\nadversary cannot create any additional valid signatures based on the signerâ€™s public key, including on\nmessages for which the signer has already provided a signature.\nBeyond unforgeability, ML-DSA is designed to satisfy additional security properties described in [14].\n\n3.2          Computational Assumptions\nSecurity for lattice-based digital signature schemes is typically related to the Learning With Errors (LWE)\nproblem and the short integer solution (SIS) problem. The LWE problem [15] is to recover a vector ğ¬ âˆˆ â„¤ğ‘›\ngiven a set of random â€œnoisyâ€ linear equations2 satisfied by . The SIS problem is to find a non-zero  ğ‘\n                                                             ğ¬                                    solution\nğ­ âˆˆ â„¤ğ‘› for a given linear system over â„¤ğ‘ of the form ğ€ğ­ = ğŸ such that â€–ğ­â€–  is small. For appropriate\n       ğ‘                                                          âˆ\nchoices of parameters, these problems are intractable for the best known techniques, including Gaussian\nelimination.\n           When the module â„¤ğ‘› in LWE and SIS is replaced by a module over a ring larger than â„¤ğ‘ (e.g., ğ‘…ğ‘), the\nresulting problems  ğ‘\n                    are called Module Learning With Errors (MLWE) [4] and Module Short Integer Solution\n             (MSIS). The security of ML-DSA is based on the MLWE problem over ğ‘…ğ‘ and a nonstandard variant of\nMSIS called SelfTargetMSIS [16].\n\n3.3          ML-DSA Construction\nML-DSA is a Schnorr-like signature with several optimizations. The Schnorr signature scheme applies the\nFiat-Shamir heuristic to an interactive protocol between a verifier who knows ğ‘” (the generator of a group in\n        which discrete logs are believed to be difficult) and the value ğ‘¦ = ğ‘”ğ‘¥ and a prover who knows ğ‘” and ğ‘¥. The\ninteractive protocol, where the prover demonstrates knowledge of ğ‘¥ to the verifier, consists of three steps:\n\n    1.  Commitment: The prover generates a random positive integer ğ‘Ÿ that is less than the order of ğ‘” and\n        commits to its value by sending ğ‘”ğ‘Ÿ to the verifier.\n\n    2.    Challenge: The verifier sends a random positive integer ğ‘ that is less than the order of ğ‘” to the\n        prover.\n\n2Specifically, the LWE problem is to solve a system of equations of the form ğ€ğ¬ + ğ = ğ‘, where ğ€ and ğ‘ are given\nand ğ is not given but known to be small.\n                                                            9"}
{"doc_id": "NIST.FIPS.204", "source_path": "data/raw_pdfs/NIST.FIPS.204.pdf", "page_number": 20, "text": "FIPS 204    MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n\n3.  Response: The prover returns ğ‘  = ğ‘Ÿ âˆ’ ğ‘ğ‘¥ reduced modulo the order of ğ‘”, and the verifier checks\n   whether ğ‘”ğ‘  â‹… ğ‘¦ğ‘ = ğ‘”ğ‘Ÿ.\n\n                                      This protocol is made noninteractive and turned into a signature scheme by replacing the verifierâ€™s random\nchoice of ğ‘ in step 2 with a deterministic process that pseudorandomly derives ğ‘ from a hash of the\ncommitment ğ‘”ğ‘Ÿ concatenated with the message to be signed. For this signature scheme, ğ‘¦ is the public\nkey, and ğ‘¥ is the private key.\n                                          The basic idea of ML-DSA and similar lattice signature schemes is to build a signature scheme from\nan analogous interactive protocol, where a prover who knows matrices ğ€ âˆˆ â„¤ğ¾Ã—ğ¿ , ğ’1 âˆˆ â„¤ğ¿Ã—ğ‘›, and\n    ğ¾Ã—ğ‘› with small coefficients (for          and            ) demonstrates knowledge of  ğ‘    ğ‘\nğ’2 âˆˆ â„¤ğ‘       ğ¾Ã—ğ‘›                       ğ’1      ğ’2                               these matrices to a verifier\nwho knows ğ€ and ğ“ âˆˆ â„¤ğ‘          = ğ€ğ’1 + ğ’2. Such an interactive protocol would proceed as follows:\n\n1.  Commitment: The prover generates ğ² âˆˆ â„¤ğ¿ with small coefficients and commits to its value by\n    sending ğ°  = ğ€ğ² + ğ²                 to the verifier, ğ‘    ğ¾\n             Approx                   2                        where ğ²2 âˆˆ â„¤ğ‘ is a vector with small coefficients.\n2.  Challenge: The verifier sends a vector ğœ âˆˆ â„¤ğ‘› with small coefficients to the prover.\n                                                            ğ‘\n3.  Response: The prover returns ğ³ = ğ² + ğ’1ğœ, and the verifier checks that ğ³ has small coefficients\n    and that ğ€ğ³ âˆ’ ğ“ğœ â‰ˆ ğ°Approx.\n\n                                       As written, the above protocol has a security flaw: the response ğ³ will be biased in a direction related\nto the private value ğ’1. Likewise ğ« = ğ°Approx âˆ’ ğ€ğ³ + ğ“ğœ = ğ²2 + ğ’2ğœ is biased in a direction related\nto the private value ğ’2. However, this flaw can be corrected when converting the interactive protocol\ninto a signature scheme. As with Schnorr signatures, the signer derives the challenge by a pseudorandom\nprocess from a hash of the commitment concatenated with the message. To correct the bias, the signer\napplies rejection sampling to ğ³; if coefficients of ğ³ fall outside of a specified range, the signing process is\naborted, and the signer starts over from a new value of ğ². Likewise, similar rejection sampling must also\nbe applied to ğ«. These checks are analogous to those done at Line 23 of Algorithm 7. In the simplified\nFiat-Shamir With Aborts signature, the public key is (ğ€, ğ“), and the private key is (ğ’1, ğ’2).\nIn the ML-DSA standard, a number of tweaks and modifications are added to this basic framework for\nsecurity or efficiency reasons:\n\n â€¢  To reduce key and signature size and to use fast NTT-based polynomial multiplication, ML-DSA\n    uses module-structured matrices.                      Relative to the basic scheme described above, it replaces\n    dimension-ğ‘› Ã— ğ‘› blocks of matrices and dimension-ğ‘› blocks of vectors with polynomials in the ring\n    ğ‘…ğ‘. Thus, instead of ğ€ âˆˆ â„¤ğ¾Ã—ğ¿ , ğ“ âˆˆ â„¤ğ¾Ã—ğ‘›, ğ’           âˆˆ â„¤ğ¿Ã—ğ‘›, ğ’ âˆˆ â„¤ğ¾Ã—ğ‘›, ğ² âˆˆ â„¤ğ¿, ğœ âˆˆ â„¤ğ‘›, ML-DSA\n                                      ğ‘             ğ‘            1  ğ‘        ğŸ  ğ‘            ğ‘    ğ‘\n    has ğ€ âˆˆ ğ‘…ğ‘˜Ã—â„“, ğ­ âˆˆ ğ‘…ğ‘˜, ğ¬    âˆˆ ğ‘…â„“, ğ¬     âˆˆ ğ‘…ğ‘˜, ğ² âˆˆ ğ‘…â„“, ğ‘ âˆˆ ğ‘…  , where â„“ = ğ¿/ğ‘› and ğ‘˜ = ğ¾/ğ‘›.\n                ğ‘             ğ‘  1        ğ‘   2       ğ‘           ğ‘      ğ‘\n â€¢  To further reduce the size of the public key, the matrix ğ€ is pseudorandomly derived from a 256-bit\n    public seed ğœŒ, which is included in the ML-DSA public key in place of ğ€.\n\n â€¢  For a still further reduction in public key size, the ML-DSA public key substitutes a compressed\n    value ğ­1 for ğ­, which drops the ğ‘‘ low-order bits of each coefficient.\n\n â€¢  To obtain beyond unforgeability (BUFF) properties noted in [14], ML-DSA does not directly sign\n    the message ğ‘€ but rather signs a message representative ğœ‡ that is obtained by hashing the\n    concatenation of a hash of the public key and ğ‘€.\n\n                                                               10"}
{"doc_id": "NIST.FIPS.204", "source_path": "data/raw_pdfs/NIST.FIPS.204.pdf", "page_number": 21, "text": "FIPS 204    MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n\n     â€¢  To reduce signature size, rather than including the commitment ğ°Approx = ğ€ğ²+ğ²2 in the signature,\n        the ML-DSA signature uses a rounded version of ğ° = ğ€ğ² as a commitment ğ°1 and includes only\n        the hash ğ‘ of ğ°1||ğœ‡.\n\n     â€¢  To ensure that ğ°1 can be reconstructed by the verifier from ğ³ and the compressed value ğ­1, the\n        signature must also include a hint ğ¡ âˆˆ ğ‘…ğ‘˜ computed by the signer using the signerâ€™s private key.\n                               2\n     â€¢  Additionally, to ensure correctness, a second stage of rejection sampling must be included (Line 28\n        of Algorithm 7)\n\nIn this document, the abbreviations ML-DSA-44, ML-DSA-65, and ML-DSA-87 are used to refer to ML-DSA\n        with the parameter choices given in Table 1. In these abbreviations, the numerical suffix refers to the\ndimension of the matrix ğ€. For example, in ML-DSA-65, the matrix ğ€ is a 6 Ã— 5 matrix over ğ‘…ğ‘.\n\n3.4     Hedged and Deterministic Signing\nFor ML-DSA to be secure, the signerâ€™s commitment value ğ² must not be used to sign more than one\nmessage, and it must not be easily guessed by an attacker. This requires randomness. In principle, the\nrandomness leading to ğ² can be produced either with the use of fresh randomness at signing time or\npseudorandomly from the message being signed and a precomputed random value included in the signerâ€™s\nprivate key.\nBy default, this standard specifies the signing algorithm to use both types of randomness. This is referred\nto as the â€œhedgedâ€ variant of the signing procedure. The use of fresh randomness during signing helps\nmitigate side-channel attacks, while the use of precomputed randomness protects against the possibility\nthat there may be flaws in the random number generator used by the signer at signing time.\n        This document also permits a fully deterministic variant of the signing procedure in case the signer has\nno access to a fresh source of randomness at signing time. However, the lack of randomness in the\ndeterministic variant makes the risk of side-channel attacks (particularly fault attacks) more difficult to\nmitigate. Therefore, this variant should not be used on platforms where side-channel attacks are a concern\nand where they cannot be otherwise mitigated.\nOnly implementing the hedged variant (i.e., without the deterministic variant) is sufficient to guarantee\ninteroperability. The same verification algorithm will work to verify signatures produced by either variant,\nso implementing the deterministic variant in addition to the hedged variant does not enhance interoper-\nability. The hedged and deterministic signing procedure differ only at line 5 of Algorithm 2 and line 5 of\nAlgorithm 4.\n\n3.5     Use of Digital Signatures\nSecure key management is an essential requirement for the use of digital signatures. This is context-\ndependent and involves more than the key generation, signing, and signature verification algorithms in\nthis document. Guidance for key management is provided in the SP 800-57 series [9, 17, 18].\nDigital signatures are most useful when bound to an identity. Binding a public key to an identity requires\nproof of possession of the private key. In the PKI context, issuing certificates involves assurances of identity\nand proof of possession. When a public-key certificate is not available, users of digital signatures should\ndetermine whether a public key needs to be bound to an identity. Methods for obtaining assurances of\nidentity and proof of possession are provided in [3].\n\n                                             11"}
{"doc_id": "NIST.FIPS.204", "source_path": "data/raw_pdfs/NIST.FIPS.204.pdf", "page_number": 22, "text": "FIPS 204                                            MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n\n3.6    Additional Requirements\nThis section describes several required assurances when implementing ML-DSA. These are in addition to\nthe considerations in Section 3.5.\n\n3.6.1  Randomness Generation\n     Algorithm 1, implementing key generation for ML-DSA, uses an RBG to generate the 256-bit random seed\nğœ‰. The seed ğœ‰ shall be a fresh (i.e., not previously used) random value generated using an approved RBG,\nas prescribed in SP 800-90A, SP 800-90B, and SP 800-90C [19, 20, 21]. Moreover, the RBG used shall have\na security strength of at least 192 bits for ML-DSA-65 and 256 bits for ML-DSA-87. For ML-DSA-44, the\nRBG should have a security strength of at least 192 bits and shall have a security strength of at least 128\nbits. If an approved RBG with at least 128 bits of security but less than 192 bits of security is used, then\nthe claimed security strength of ML-DSA-44 is reduced from category 2 to category 1.\n    Additionally, the value ğ‘Ÿğ‘›ğ‘‘ is generated using an RBG in the default â€œhedgedâ€ variants of Algorithms 2\nand 4 for ML-DSA and HashML-DSA signing, respectively. While this value should ideally be generated by\nan approved RBG, other methods for generating fresh random values may be used. The primary purpose\nof ğ‘Ÿğ‘›ğ‘‘ is to facilitate countermeasures to side-channel attacks and fault attacks on deterministic signatures,\nsuch as [22, 23, 24].3 For this purpose, even a weak RBG may be preferable to the fully deterministic\nvariants of Algorithms 2 and 4.\n\n3.6.2  Public-Key and Signature Length Checks\n  Algorithm 3, implementing verification for ML-DSA, and Algorithm 5, implementing verification for HashML-\nDSA, specify the length of the signature ğœ and the public key ğ‘ğ‘˜ in terms of the parameters described in\n  Table 1. If an implementation of ML-DSA can accept inputs for ğœ or ğ‘ğ‘˜ of any other length, it shall return\nfalse whenever the lengths of either of these inputs differ from their lengths specified in this standard.\nFailing to check the length of ğ‘ğ‘˜ or ğœ may interfere with the security properties that ML-DSA is designed\nto have, like strong unforgeability.\n\n3.6.3  Intermediate Values\n   The data used internally by the key generation and signing algorithms in intermediate computation steps\ncould be used by an adversary to gain information about the private key and thereby compromise security.\n The data used internally by verification algorithms is similarly sensitive for some applications, including\nthe verification of signatures that are used as bearer tokens (i.e., authentication secrets) or the verification\nof signatures on plaintext messages that are intended to be confidential. Intermediate values of the\n   verification algorithm may reveal information about its inputs (i.e., the message, signature, and public\nkey), and in some applications, security or privacy requires one or more of these inputs to be confidential.\n    Therefore, implementations of ML-DSA shall ensure that any potentially sensitive intermediate data is\ndestroyed as soon as it is no longer needed.\nTwo particular cases in which implementations may refrain from destroying intermediate data are:\n\n 1.    The seed ğœ‰ generated in step 1 of ML-DSA.KeyGen can be stored for the purpose of later expansion\n\n3In addition, when signing is deterministic, there is leakage through timing side channels of information about\n the message but not the private key). If the signer does not want to reveal the message being signed, hedged\n signatures should be used (see Section 3.2 in [6]).\n                                                    12"}
{"doc_id": "NIST.FIPS.204", "source_path": "data/raw_pdfs/NIST.FIPS.204.pdf", "page_number": 23, "text": "FIPS 204    MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n\n        using ML-DSA.KeyGen_internal. As the seed can be used to compute the private key, it is sensitive\n        data and shall be treated with the same safeguards as a private key.\n\n2.            The matrix ğ€ generated in step 3 of ML-DSA.KeyGen_internal can be stored so that it need not\n        be recomputed in later operations. Likewise, the matrix ğ€ generated in step 5 of the verification\n        algorithm ML-DSA.Verify_internal can also be stored. In either case, the matrix ğ€ is data that is\n        easily computed from the public key and does not require any special protections.\n\nIn certain situations (e.g., deterministic signing and the verification of confidential messages and signa-\ntures), additional care must be taken to protect implementations against side-channel attacks or fault\nattacks. A cryptographic device may leak critical information through side channels, which allows internal\ndata or keying material to be extracted without breaking the cryptographic primitives.\n\n3.6.4   No Floating-Point Arithmetic\nImplementations of ML-DSA shall not use floating-point arithmetic, as rounding errors in floating point\noperations may lead to incorrect results in some cases. Either âŒŠğ‘¥/ğ‘¦âŒ‹ or âŒˆğ‘¥/ğ‘¦âŒ‰ is used in all pseudocode\nin this standard in which division is performed (e.g., ğ‘¥/ğ‘¦), and ğ‘¦ may not divide ğ‘¥. Both of these can\nbe computed without floating-point arithmetic, as ordinary integer division ğ‘¥/ğ‘¦ computes âŒŠğ‘¥/ğ‘¦âŒ‹, and\nâŒˆğ‘¥/ğ‘¦âŒ‰ = âŒŠ(ğ‘¥ + ğ‘¦ âˆ’ 1)/ğ‘¦âŒ‹ for non-negative integers ğ‘¥ and positive integers ğ‘¦. If ğ‘¦ is a power of two, it\nmay be more efficient to use bit shift operations than integer division.\n\n3.7     Use of Symmetric Cryptography\n            This standard makes use of the functions SHAKE256 and SHAKE128, as defined in FIPS 202 [7]. While FIPS\n202 specifies these functions as inputting and outputting bit strings, most implementations treat inputs\nand outputs as byte strings.\n        This standard will always call these functions with an output length of a multiple of eight bits and treat the\noutput of these functions as a byte string, which will be the same byte string that would result from taking\nthe bit string expected from a literal reading of FIPS 202 and processing it with BitsToBytes. However,\nto allow the signing of messages that are not a whole number of bytes, this document will overload\nSHAKE256 so that its input may be a bit string but will usually be a byte string. The following equivalence\nwill hold for any byte string str and integer â„“ â‰¥ 1:\n\n                                     SHAKE256(str, 8â„“) = SHAKE256(BytesToBits(str), 8â„“).\n\nIn addition to using a mostly byte-oriented variant of the API defined in FIPS 202 for SHAKE256 and\nSHAKE128, this standard sometimes makes use of the incremental API defined in SP 800-185 [25]. This API\nconsists of three functions for each variant of SHAKE. These functions can be used to absorb a sequence\nof arbitrary-length strings and squeeze a sequence of arbitrary-length strings. These functions perform\nbuffering to handle any incomplete data blocks while absorbing or squeezing. For example, for SHAKE256:\n\n     â€¢  ctx â† SHAKE256.Init()\n        Initializes a hash function context.\n\n     â€¢  ctx â† SHAKE256.Absorb(ctx, str)\n        Injects data to be used in the absorbing phase of SHAKE256 and updates context ctx.\n\n13"}
{"doc_id": "NIST.FIPS.204", "source_path": "data/raw_pdfs/NIST.FIPS.204.pdf", "page_number": 24, "text": "FIPS 204    MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n\n â€¢   (ctx, out) â† SHAKE256.Squeeze(ctx, 8â„“)\n     Extracts â„“ output bytes produced during the squeezing phase of SHAKE256 and updates context\n     ctx.\n\nWhile the above functions are specified in terms of the Keccak-ğ‘“ permutation rather than the eXtendable-\nOutput Function (XOF), SHAKE256, they are defined so that any series of commands of the following\nform:\n\n 1.  ctx â† SHAKE256.Init()\n\n 2.  For ğ‘– = 1 to ğ‘š: ctx â† SHAKE256.Absorb(ctx, strğ‘–)\n\n 3.  For ğ‘— = 1 to ğ‘˜: (ctx, outğ‘—) â† SHAKE256.Squeeze(ctx, 8ğ‘ğ‘—)\n\n 4.  output â† out1|| â€¦ ||outğ‘˜\n\nwill yield the same output as a single SHAKE256 call:\n\n         output â† SHAKE256(str1|| â€¦ ||strğ‘š, 8ğ‘1 + â€¦ + 8ğ‘ğ‘˜).\n\nThis equivalence holds whether or not |strğ‘–| and ğ‘ğ‘— are multiples of the SHAKE256 block length.\n\nSince all outputs of SHAKE128 and SHAKE256 in this document give a whole number of bytes, the wrapper\nfunctions H and G are defined as follows:\n\n 1.  H(str, â„“) = SHAKE256(str, 8â„“)\n\n 2.  G(str, â„“) = SHAKE128(str, 8â„“)\n\n 3.  H.Init() = SHAKE256.Init()\n\n 4.  G.Init() = SHAKE128.Init()\n\n 5.  H.Absorb(ctx, str) = SHAKE256.Absorb(ctx, str)\n\n 6.  G.Absorb(ctx, str) = SHAKE128.Absorb(ctx, str)\n\n 7.  H.Squeeze(ctx, â„“) = SHAKE256.Squeeze(ctx, 8â„“)\n\n 8.  G.Squeeze(ctx, â„“) = SHAKE128.Squeeze(ctx, 8â„“)\n\nIn addition to SHAKE128 and SHAKE256, HashML-DSA.Sign and HashML-DSA.Verify may call other\napproved hash functions for pre-hashing. The pseudocode in this standard also treats these functions\nas returning a byte string as output while supporting either a bit string or a byte string as input. Here, it\nshould be noted that the hash functions defined in [8] use different rules (i.e., big-endian ordering) to\nrelate bits, bytes, and words.\n\n14"}
{"doc_id": "NIST.FIPS.204", "source_path": "data/raw_pdfs/NIST.FIPS.204.pdf", "page_number": 25, "text": "FIPS 204                                            MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n\n4.  Parameter Sets\n\n                              Table 1. ML-DSA parameter sets\n\n                 Parameters                          Values assigned by each parameter set\n(see Sections 6.1 and 6.2 of this document)      ML-DSA-44     ML-DSA-65     ML-DSA-87\n           ğ‘ - modulus [see Â§6.1]                8380417       8380417       8380417\n ğœ - a 512th root of unity in â„¤ğ‘ [see Â§7.5]       1753          1753          1753\n  ğ‘‘ - # of dropped bits from ğ­ [see Â§6.1]          13            13            13\n  ğœ - # of Â±1â€™s in polynomial ğ‘ [see Â§6.2]         39            49            60\n   ğœ† - collision strength of ğ‘ [see Â§6.2]         128           192           256\n\n    ğ›¾ ğ›¾Â¹ - coefficient range of ğ² [see Â§6.2]     2Â¹â·           2Â¹â¹           2Â¹â¹\n    2 - low-order rounding range [see Â§6.2]      (ğ‘ âˆ’ 1)/88  (ğ‘ âˆ’ 1)/32    (ğ‘ âˆ’ 1)/32\n    (ğ‘˜, â„“) - dimensions of ğ€ [see Â§6.1]          (4,4)         (6,5)         (8,7)\n      ğœ‚ - private key range [see Â§6.1]              2             4             2\n            ğ›½ = ğœ â‹… ğœ‚ [see Â§6.2]                  78           196           120\n ğœ” - max # of 1â€™s in the hint ğ¡ [see Â§6.2]         80            55            75\n    Challenge entropy log     (Â²âµâ¶) + ğœ [see Â§6.2]  192          225           257\n            Repetitions (see  2  ğœ\n                              explanation below)    4.25          5.1           3.85\n            Claimed security strength            Category 2    Category 3    Category 5\n\nThree ML-DSA parameter sets are included in Table 1. Each parameter set assigns values for all of the\nparameters used in the ML-DSA algorithms for key generation, signing, and verification. For informational\npurposes, some parameters used in the analysis of these algorithms are also included in the table. In\nparticular, â€œrepetitionsâ€ refers to the expected number of repetitions of the main loop in the signing\nalgorithm from eq. 5 in [5]. The names of the parameter sets are of the form â€œML-DSA-ğ‘˜â„“,â€ where (ğ‘˜, â„“)\nare the dimensions of the matrix ğ€.\nThese parameter sets were designed to meet certain security strength categories defined by NIST in its\noriginal Call for Proposals [26]. These security strength categories are explained further in SP 800-57, Part\n1 [9].\nUsing this approach, security strength is not described by a single number, such as â€œ128 bits of security.â€\nInstead, each ML-DSA parameter set is claimed to be at least as secure as a generic block cipher with a\nprescribed key size or a generic hash function with a prescribed output length. More precisely, it is claimed\nthat the computational resources needed to break ML-DSA are greater than or equal to the computational\nresources needed to break the block cipher or hash function when these computational resources are\nestimated using any realistic model of computation. Different models of computation can be more or less\nrealistic and, accordingly, lead to more or less accurate estimates of security strength. Some commonly\nstudied models are discussed in [27].\nConcretely, the parameter set ML-DSA-44 is claimed to be in security strength category 2, ML-DSA-65 is\nclaimed to be in category 3, and ML-DSA-87 is claimed to be in category 5 [6]. For additional discussion of\nthe security strength of MLWE-based cryptosystems, see [28].\nThe sizes of keys and signatures that correspond to each parameter set are given in Table 2. Certain\noptimizations are possible when storing ML-DSA public and private keys. If additional space is available,\none can precompute and store ğ€ to speed up signing and verifying. Alternatively, if one wants to reduce\n                                     15"}
{"doc_id": "NIST.FIPS.204", "source_path": "data/raw_pdfs/NIST.FIPS.204.pdf", "page_number": 26, "text": "FIPS 204    MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n\nthe space needed for the private key, one can store only the 32-byte seed ğœ‰, which is sufficient to generate\nthe other parts of the private key. For additional details, see Section 3.1 in [6].\n\nTable 2. Sizes (in bytes) of keys and signatures of ML-DSA\n\n          Private Key    Public Key  Signature Size\n ML-DSA-44    2560          1312     2420\n ML-DSA-65    4032          1952     3309\n ML-DSA-87    4896          2592     4627\n\n16"}
{"doc_id": "NIST.FIPS.204", "source_path": "data/raw_pdfs/NIST.FIPS.204.pdf", "page_number": 27, "text": "    FIPS 204                                             MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n\n    5.   External Functions\n\n    The signing, verifying, and key generation functions can be split into â€œexternalâ€ and â€œinternalâ€ components\n    to simplify APIs and Cryptographic Algorithm Validation Program (CAVP) testing. The external components\n    generate randomness and perform various checks before calling their internal counterparts. The internal\n    components are deterministic and can assume that the external components did not encounter error\n    conditions.\n    The distinction between external and internal functions also simplifies the presentation of algorithms\n    for signing and verification by grouping the operations that are shared between ML-DSA.Sign and\n    HashML-DSA.Sign in ML-DSA.Sign_internal and grouping the operations that are shared between\n    ML-DSA.Verify and HashML-DSA.Verify in ML-DSA.Verify_internal.\n\n    5.1  ML-DSA Key Generation\n    The key generation algorithm ML-DSA.KeyGen takes no input and outputs a public key and a private key,\n    which are both encoded as byte strings.\n    The algorithm uses an approved RBG to generate a 256-bit (32-byte) random seed ğœ‰ that is given as input\n    to ML-DSA.KeyGen_internal (Algorithm 6), which produces the public and private keys.\n\n    Algorithm 1 ML-DSA.KeyGen()\n    Generates a public-private key pair.\n    Output: Public key ğ‘ğ‘˜ âˆˆ ğ”¹32+32ğ‘˜(bitlen (ğ‘âˆ’1)âˆ’ğ‘‘)\n                and private key ğ‘ ğ‘˜ âˆˆ ğ”¹32+32+64+32â‹…((â„“+ğ‘˜)â‹…bitlen (2ğœ‚)+ğ‘‘ğ‘˜).\n     1:  ğœ‰ â† ğ”¹Â³Â²                                                              â–· choose random seed\n     2:  if ğœ‰  = NULL then\n     3:         return âŠ¥                â–· return an error indication if random bit generation failed\n     4:  end if\n     5:  return ML-DSA.KeyGen_internal (ğœ‰)\n\n    5.2  ML-DSA Signing\n    The signing algorithm ML-DSA.Sign (Algorithm 2) takes a private key, a message, and a context string as\n    input4. It outputs a signature that is encoded as a byte string.\n    For the default â€œhedgedâ€ version of ML-DSA signing, the algorithm (at line 5) uses an approved RBG to\n    generate a 256-bit (32-byte) random seed ğ‘Ÿğ‘›ğ‘‘. If the deterministic variant is desired, then ğ‘Ÿğ‘›ğ‘‘ is set\n    to the fixed zero string {0}32.    The value ğ‘Ÿğ‘›ğ‘‘, the private key, and the encoded message are input to\n    ML-DSA.Sign_internal (Algorithm 7), which produces the signature.\n\n4By default, the context is the empty string, though applications may specify the use of a non-empty context string.\n                                                         17"}
{"doc_id": "NIST.FIPS.204", "source_path": "data/raw_pdfs/NIST.FIPS.204.pdf", "page_number": 28, "text": "FIPS 204                                            MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n\nAlgorithm 2 ML-DSA.Sign(ğ‘ ğ‘˜, ğ‘€, ğ‘ğ‘¡ğ‘¥)\nGenerates an ML-DSA signature.\nInput: Private key ğ‘ ğ‘˜ âˆˆ ğ”¹32+32+64+32â‹…((â„“+ğ‘˜)â‹…bitlen (2ğœ‚)+ğ‘‘ğ‘˜), message ğ‘€ âˆˆ {0, 1}âˆ—,\ncontext string ğ‘ğ‘¡ğ‘¥ (a byte string of 255 or fewer bytes).\nOutput: Signature ğœ âˆˆ ğ”¹ğœ†/4+â„“â‹…32â‹…(1+bitlen (ğ›¾â‚âˆ’1))+ğœ”+ğ‘˜.\n 1:    if |ğ‘ğ‘¡ğ‘¥| > 255 then\n 2:         return âŠ¥          â–· return an error indication if the context string is too long\n 3:    end if\n 4:\n 5:    ğ‘Ÿğ‘›ğ‘‘ â† ğ”¹Â³Â²         â–· for the optional deterministic variant, substitute ğ‘Ÿğ‘›ğ‘‘ â† {0}Â³Â²\n 6:    if ğ‘Ÿğ‘›ğ‘‘ = NULL then\n 7:         return âŠ¥          â–· return an error indication if random bit generation failed\n 8:    end if\n 9:\n10:    ğ‘€â€² â† BytesToBits(IntegerToBytes(0, 1) âˆ¥ IntegerToBytes(|ğ‘ğ‘¡ğ‘¥|, 1) âˆ¥ ğ‘ğ‘¡ğ‘¥) âˆ¥ ğ‘€\n11:    ğœ â† ML-DSA.Sign_internal(ğ‘ ğ‘˜, ğ‘€â€² , ğ‘Ÿğ‘›ğ‘‘)\n12:    return ğœ\n\n5.3    ML-DSA Verifying\n       The verification algorithm ML-DSA.Verify (Algorithm 3) takes a public key, a message, a signature, and a\ncontext string as input. The public key, signature, and context string are all encoded as byte strings, while\nthe message is a bit string. ML-DSA.Verify outputs a Boolean value that is true if the signature is valid\nwith respect to the message and the public key and false if the signature is invalid. The verification is\naccomplished by calling ML-DSA.Verify_internal (Algorithm 8) with the public key, the encoded message,\nand the signature.\n\nAlgorithm 3 ML-DSA.Verify(ğ‘ğ‘˜, ğ‘€, ğœ, ğ‘ğ‘¡ğ‘¥)\nVerifies a signature ğœ for a message ğ‘€.\nInput: Public key ğ‘ğ‘˜ âˆˆ ğ”¹32+32ğ‘˜(bitlen (ğ‘âˆ’1)âˆ’ğ‘‘), message ğ‘€ âˆˆ {0, 1}âˆ—,\nsignature ğœ âˆˆ ğ”¹ğœ†/4+â„“â‹…32â‹…(1+bitlen (ğ›¾â‚âˆ’1))+ğœ”+ğ‘˜,\ncontext string ğ‘ğ‘¡ğ‘¥ (a byte string of 255 or fewer bytes).\nOutput: Boolean.\n 1:    if |ğ‘ğ‘¡ğ‘¥| > 255 then\n 2:         return âŠ¥          â–· return an error indication if the context string is too long\n 3:    end if\n 4:\n 5:    ğ‘€â€² â† BytesToBits(IntegerToBytes(0, 1) âˆ¥ IntegerToBytes(|ğ‘ğ‘¡ğ‘¥|, 1) âˆ¥ ğ‘ğ‘¡ğ‘¥) âˆ¥ ğ‘€\n 6:    return ML-DSA.Verify_internal(ğ‘ğ‘˜, ğ‘€â€² , ğœ)\n\n5.4    Pre-Hash ML-DSA\nFor some cryptographic modules that generate ML-DSA signatures, hashing the message in step 6 of\nML-DSA.Sign_internal may result in unacceptable performance if the message ğ‘€ is large. For example,\n                                                          18"}
{"doc_id": "NIST.FIPS.204", "source_path": "data/raw_pdfs/NIST.FIPS.204.pdf", "page_number": 29, "text": "FIPS 204    MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n\nthe platform may require hardware support for hashing to achieve acceptable performance but lack\nhardware support for SHAKE256 specifically. For some use cases, this may be addressed by signing a\ndigest of the message along with some domain separation information rather than signing the message\ndirectly. This version of ML-DSA is known as â€œpre-hashâ€ ML-DSA or HashML-DSA . In general, the â€œpureâ€\nML-DSA version is preferred.\n While key generation for HashML-DSA is the same as for ML-DSA, it is not the same for the signing algorithm\nHashML-DSA.Sign or the verification algorithm HashML-DSA.Verify. Like ML-DSA, the signing algorithm\nof HashML-DSA takes the content to be signed, the private key, and a context as input, as well as a hash\nfunction or XOF that is to be used to pre-hash the content to be signed. The context string has a maximum\nlength of 255 bytes. By default, the context is the empty string, though applications may specify the use\nof a non-empty context string.\nThe identifier for a signature (e.g., the object identifier [OID]) should indicate whether the signature is a\nML-DSA signature or a pre-hash HashML-DSA signature. In the case of pre-hash signatures, the identifier\nshould also indicate the hash function or XOF used to compute the pre-hash. 5 While a single key pair\nmay be used for both ML-DSA and HashML-DSA signatures, it is recommended that each key pair only\nbe used for one version or the other. If a non-empty context string is to be used, this should either be\nindicated by the signatureâ€™s identifier or by the application with which the signature is being used.\nIf the default â€œhedgedâ€ variant of is used, the 32-byte random value ğ‘Ÿğ‘›ğ‘‘ shall be generated by the\ncryptographic module that generates the signature (i.e., that runs ML-DSA.Sign_internal). However, all\nother steps of signing may be performed outside of the cryptographic module that generates the signature.\nIn the case of pre-hashing, the hash or XOF of the content to be signed must be computed within a FIPS\n     140-validated cryptographic module, but it may be a different cryptographic module than the one that\ngenerates the signature.\nIf the content to be signed is large, hashing of the content is often performed at the application level.\nFor example, in the Cryptographic Message Syntax [29], a digest of the content may be computed, and\nthat digest is signed along with other attributes. If the content is not hashed at the application level, the\npre-hash version of ML-DSA signing may be used.\nIn order to maintain the same level of security strength when the content is hashed at the application level\nor using HashML-DSA , the digest that is signed needs to be generated using an approved hash function\nor XOF (e.g., from FIPS 180 [8] or FIPS 202 [7]) that provides at least ğœ† bits of classical security strength\nagainst both collision and second preimage attacks [7, Table 4].6 The verification of a signature that is\ncreated in this way will require the verify function to generate a digest from the message in the same way\nto be used as input for the verification function.\n\n5.4.1  HashML-DSA Signing and Verifying\nIn the HashML-DSA version, the message input to ML-DSA.Sign_internal is the result of applying either a\nhash function or a XOF to the content to be signed. The output of the hash function or XOF is prepended\nby a one-byte domain separator, one byte that indicates the length of the context string, the context\nstring, and the distinguished encoding rules (DER) encoding of the hash function or XOFâ€™s OID. The domain\nseparator has a value of one for â€œpre-hashâ€ signing. The DER encoding of the OID includes the tag and\nlength.\n\n5In the case of a XOF this would also include the length of the output from the XOF.\n6Obtaining at least ğœ† bits of classical security strength against collision attacks requires that the digest to be signed\nbe at least 2ğœ† bits in length.\n                                                      19"}
{"doc_id": "NIST.FIPS.204", "source_path": "data/raw_pdfs/NIST.FIPS.204.pdf", "page_number": 30, "text": "FIPS 204                                  MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n\nAlgorithm 4 shows the DER encodings of the OIDs for SHA-256, SHA-512, and SHAKE128. However, it may\nbe used with other hash functions or XOFs.\n\nAlgorithm 4 HashML-DSA.Sign(ğ‘ ğ‘˜, ğ‘€ , ğ‘ğ‘¡ğ‘¥, PH)\nGenerate a â€œpre-hashâ€ ML-DSA signature.\nInput: Private key ğ‘ ğ‘˜ âˆˆ ğ”¹32+32+64+32â‹…((â„“+ğ‘˜)â‹…bitlen (2ğœ‚)+ğ‘‘ğ‘˜), message ğ‘€ âˆˆ {0, 1}âˆ—,\ncontext string ğ‘ğ‘¡ğ‘¥ (a byte string of 255 or fewer bytes), pre-hash function PH.\nOutput: ML-DSA signature ğœ âˆˆ ğ”¹ğœ†/4+â„“â‹…32â‹…(1+bitlen (ğ›¾â‚âˆ’1))+ğœ”+ğ‘˜.\n 1:    if |ğ‘ğ‘¡ğ‘¥| > 255 then\n 2:     return âŠ¥                  â–· return an error indication if the context string is too long\n 3:    end if\n 4:\n 5:    ğ‘Ÿğ‘›ğ‘‘ â† ğ”¹Â³Â²         â–· for the optional deterministic variant, substitute ğ‘Ÿğ‘›ğ‘‘ â† {0}Â³Â²\n 6:    if ğ‘Ÿğ‘›ğ‘‘ = NULL then\n 7:     return âŠ¥                  â–· return an error indication if random bit generation failed\n 8:    end if\n 9:\n10:    switch PH do\n11:     case SHA-256:\n12:          OID â† 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x01\n                                                                       â–· 2.16.840.1.101.3.4.2.1\n13:          PHğ‘€ â† SHA256(ğ‘€)\n14:     case SHA-512:\n15:          OID â† 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x03\n                                                                       â–· 2.16.840.1.101.3.4.2.3\n16:          PHğ‘€ â† SHA512(ğ‘€)\n17:     case SHAKE128:\n18:          OID â† 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x0B\n                                                                       â–· 2.16.840.1.101.3.4.2.11\n19:          PHğ‘€ â† SHAKE128(ğ‘€, 256)\n20:     case â€¦\n21:          â€¦\n22:    end switch\n23:    ğ‘€â€² â† BytesToBits(IntegerToBytes(1, 1) âˆ¥ IntegerToBytes(|ğ‘ğ‘¡ğ‘¥|, 1) âˆ¥ ğ‘ğ‘¡ğ‘¥ âˆ¥ OID âˆ¥ PHğ‘€)\n       ğœ â† ML-DSA Sign internal          â€²\n24:                     .    _  (ğ‘ ğ‘˜, ğ‘€ , ğ‘Ÿğ‘›ğ‘‘)\n25:    return ğœ\n\nAlgorithm 5 presents the signature verification for HashML-DSA . This function constructs ğ‘€â€² in the same\nway as Algorithm 4 and passes the resulting ğ‘€â€² to Algorithm ML-DSA.Verify_internal for verification. As\nwith the pre-hash signature generation, ğ‘€â€² may be constructed outside of the cryptographic module\nthat performs ML-DSA.Verify_internal. However, in the case of HashML-DSA , the hash or XOF of the\ncontent must be computed within a FIPS 140-validated cryptographic module, which may be a different\ncryptographic module than the one that performs ML-DSA.Verify_internal.\nAs noted in Section 5.4, the identifier associated with the signature should indicate whether ML-DSA or\n                                           20"}
{"doc_id": "NIST.FIPS.204", "source_path": "data/raw_pdfs/NIST.FIPS.204.pdf", "page_number": 31, "text": "FIPS 204                                            MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n\nthe pre-hash version HashML-DSA of signature verification should be used, as well as the hash function or\nXOF to be used to compute the pre-hash. A non-empty context string should be used in verification if one\nis specified either in the signatureâ€™s identifier or by the application with which the signature is being used.\n\nAlgorithm 5 HashML-DSA.Verify(ğ‘ğ‘˜, ğ‘€ , ğœ, ğ‘ğ‘¡ğ‘¥, PH)\nVerifies a pre-hash HashML-DSA signature.\nInput: Public key ğ‘ğ‘˜ âˆˆ ğ”¹32+32ğ‘˜(bitlen (ğ‘âˆ’1)âˆ’ğ‘‘), message ğ‘€ âˆˆ {0, 1}âˆ—,\nsignature ğœ âˆˆ ğ”¹ğœ†/4+â„“â‹…32â‹…(1+bitlen (ğ›¾â‚âˆ’1))+ğœ”+ğ‘˜,\ncontext string ğ‘ğ‘¡ğ‘¥ (a byte string of 255 or fewer bytes), pre-hash function PH.\nOutput: Boolean.\n 1:    if |ğ‘ğ‘¡ğ‘¥| > 255 then\n 2:     return false\n 3:    end if\n 4:\n 5:    switch PH do\n 6:     case SHA-256:\n 7:          OID â† 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x01\n                                                                           â–· 2.16.840.1.101.3.4.2.1\n 8:          PHğ‘€ â† SHA256(ğ‘€)\n 9:     case SHA-512:\n10:          OID â† 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x03\n                                                                           â–· 2.16.840.1.101.3.4.2.3\n11:          PHğ‘€ â† SHA512(ğ‘€)\n12:     case SHAKE128:\n13:          OID â† 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x0B\n                                                                           â–· 2.16.840.1.101.3.4.2.11\n14:          PHğ‘€ â† SHAKE128(ğ‘€, 256)\n15:     case â€¦\n16:          â€¦\n17:    end switch\n18:    ğ‘€â€² â† BytesToBits(IntegerToBytes(1, 1) âˆ¥ IntegerToBytes(|ğ‘ğ‘¡ğ‘¥|, 1) âˆ¥ ğ‘ğ‘¡ğ‘¥ âˆ¥ OID âˆ¥ PHğ‘€)\n19:    return ML-DSA.Verify_internal(ğ‘ğ‘˜, ğ‘€â€² , ğœ)\n\n21"}
{"doc_id": "NIST.FIPS.204", "source_path": "data/raw_pdfs/NIST.FIPS.204.pdf", "page_number": 32, "text": "FIPS 204                                              MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n\n6.      Internal Functions\n\nThis section describes the functions for ML-DSA key generation, signature generation, and signature\nverification. Where randomness is required, the random values are provided as inputs to the functions.\nThe interfaces specified in this section will be used when testing of ML-DSA implementations is performed\nthrough the CAVP.\nOther than for testing purposes, the interfaces for key generation and signature generation specified\nin this section should not be made available to applications, as any random values required for key\ngeneration and signature generation shall be generated by the cryptographic module. Section 5 provides\nguidance on the interfaces to be made available to applications.7\n\n6.1     ML-DSA Key Generation (Internal)\nThe internal key generation algorithm ML-DSA.KeyGen_internal takes a 32-byte random seed as input\nand outputs a public key and a private key that are both encoded as byte strings.\nThe seed ğœ‰ is expanded as needed using an XOF (i.e., a byte-variant of SHAKE256) denoted by H to produce\nother random values.8 In particular:\n\n     â€¢ A 32-byte public random seed ğœŒ. Using this seed, a polynomial matrix ğ€ âˆˆ ğ‘…ğ‘˜Ã—â„“ is pseudorandomly\n                                                                                  ğ‘\n        sampled9 from ğ‘…ğ‘˜Ã—â„“.\n                       ğ‘\n     â€¢  A 64-byte private random seed ğœŒâ€². Using this seed, the polynomial vectors ğ¬1 âˆˆ ğ‘…â„“ and ğ¬ âˆˆ ğ‘…ğ‘˜\n        are pseudorandomly sampled from the subset of polynomial vectors whose      ğ‘  2                      ğ‘\n                                                                                  coordinate polynomials\n        have short coefficients (i.e., in the range [âˆ’ğœ‚, ğœ‚]).\n     â€¢ A 32-byte private random seed ğ¾ for use during signing.\n\nThe core cryptographic operation computes the public value\n\n                                                      ğ­ = ğ€ğ¬1 + ğ¬2.\n\nThe vector ğ­ together with the matrix ğ€ may be considered an expanded form of the public key. The vector\nğ­ is compressed in the actual public key by dropping the ğ‘‘ least significant bits from each coefficient, thus\nproducing the polynomial vector ğ­1. This compression is an optimization for performance, not security.\nThe low-order bits of ğ­ can be reconstructed from a small number of signatures and, therefore, need not\nbe regarded as secret.\nThe ML-DSA public key ğ‘ğ‘˜ is a byte encoding of the public random seed ğœŒ and the compressed polynomial\nvector ğ­1.\nThe ML-DSA private key ğ‘ ğ‘˜ is a byte encoding of the public random seed ğœŒ, a private random seed ğ¾\nfor use during signing, a 64-byte hash ğ‘¡ğ‘Ÿ of the public key for use during signing, the secret polynomial\n7In some cases, it is permissible to modify the format of the private key in these interfaces (see Sections 4 and 3.6.3.)\n8Single-byte encodings of the parameters ğ‘˜ and â„“ are included in the XOF input for domain separation. For\n implementations that use the seed in place of the private key, this ensures that the expansion will produce an\n unrelated key if the seed is mistakenly expanded using a parameter set other than the one originally intended.\n9More precisely, since only the NTT form of ğ€, ğ€ âˆˆ ğ‘‡ ğ‘˜Ã—â„“ = NTT(ğ€) is needed in subsequent calculations, the\n                                                      ğ‘\n code actually computes ğ€Ì‚ as a pseudorandom sample over ğ‘‡ ğ‘˜Ã—â„“, and the sampling of ğ€ = NTTâˆ’1(ğ€)Ì‚ is only\n implicit (i.e., it could be computed but is not).             ğ‘\n                                                      22"}
{"doc_id": "NIST.FIPS.204", "source_path": "data/raw_pdfs/NIST.FIPS.204.pdf", "page_number": 33, "text": "FIPS 204    MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n\nvectors ğ¬1 and ğ¬2, and a polynomial vector ğ­0 encoding the ğ‘‘ least significant bits of each coefficient of\nthe uncompressed public-key polynomial ğ­.\n\nAlgorithm 6 ML-DSA.KeyGen_internal(ğœ‰)\nGenerates a public-private key pair from a seed.\nInput: Seed ğœ‰ âˆˆ ğ”¹Â³Â²\nOutput: Public key ğ‘ğ‘˜ âˆˆ ğ”¹32+32ğ‘˜(bitlen (ğ‘âˆ’1)âˆ’ğ‘‘)\n       and private key ğ‘ ğ‘˜ âˆˆ ğ”¹32+32+64+32â‹…((â„“+ğ‘˜)â‹…bitlen (2ğœ‚)+ğ‘‘ğ‘˜).\n 1:    (ğœŒ, ğœŒâ€² , ğ¾) âˆˆ ğ”¹Â³Â² Ã— ğ”¹â¶â´ Ã— ğ”¹Â³Â² â† H(ğœ‰||IntegerToBytes(ğ‘˜, 1)||IntegerToBytes(â„“, 1), 128)\n 2:                                                                    â–· expand seed\n 3:    ğ€ â† ExpandA(ğœŒ)                    â–· ğ€ is generated and stored in NTT representation as ğ€\n 4:    (ğ¬â‚, ğ¬â‚‚) â† ExpandS(ğœŒâ€² )\n 5:    ğ­ â† NTTâˆ’1 (ğ€ âˆ˜ NTT(ğ¬â‚)) + ğ¬â‚‚                                â–· compute ğ­ = ğ€ğ¬â‚ + ğ¬â‚‚\n 6:    (ğ­â‚, ğ­â‚€) â† Power2Round(ğ­)                                    â–· compress ğ­\n 7:    â–· PowerTwoRound is applied componentwise (see explanatory text in Section 7.4)\n 8:    ğ‘ğ‘˜ â† pkEncode(ğœŒ, ğ­â‚)\n 9:    ğ‘¡ğ‘Ÿ â† H(ğ‘ğ‘˜, 64)\n10:    ğ‘ ğ‘˜ â† skEncode(ğœŒ, ğ¾, ğ‘¡ğ‘Ÿ, ğ¬â‚, ğ¬â‚‚, ğ­â‚€)    â–· ğ¾ and ğ‘¡ğ‘Ÿ are for use in signing\n11:    return (ğ‘ğ‘˜, ğ‘ ğ‘˜)\n\n6.2  ML-DSA Signing (Internal)\nML-DSA.Sign_internal (Algorithm 7) outputs a signature encoded as a byte string. It takes a private\nkey ğ‘ ğ‘˜ encoded as a byte string, a formatted message ğ‘€â€² encoded as a bit string, and a 32-byte string\nğ‘Ÿğ‘›ğ‘‘ as input. There are two ways that a signing algorithm can use ML-DSA.Sign_internal: â€œhedgedâ€\nand â€œdeterministic.â€ The default â€œhedgedâ€ variants of ML-DSA.Sign and HashML-DSA.Sign use a fresh\nrandom value for ğ‘Ÿğ‘›ğ‘‘, while the optional deterministic variants use the constant byte string {0}32 (see\nSection 3).\nIn both variants, the signer first extracts the following from the private key: the public random seed ğœŒ,\nthe 32-byte private random seed ğ¾, the 64-byte hash of the public key ğ‘¡ğ‘Ÿ, the secret polynomial vectors\nğ¬1 and ğ¬2, and the polynomial vector ğ­0 encoding the ğ‘‘ least significant bits of each coefficient of the\nuncompressed public-key polynomial ğ­. ğœŒ is then expanded to the same matrix ğ€ as in key generation.\nBefore the message ğ‘€ is signed, it is concatenated with the public-key hash ğ‘¡ğ‘Ÿ and hashed down to a\n64-byte message representative ğœ‡ using H.\n   The signer produces an additional 64-byte seed ğœŒâ€³ for private randomness during each signing operation.\nğœŒâ€³ is computed as ğœŒâ€³ â† H(ğ¾||ğ‘Ÿğ‘›ğ‘‘||ğœ‡, 64). In the default hedged variant, ğ‘Ÿğ‘›ğ‘‘ is the output of an RBG,\nwhile in the deterministic variant, ğ‘Ÿğ‘›ğ‘‘ is a 32-byte string that consists entirely of zeros. This is the only\ndifference between the deterministic and hedged variant of ML-DSA.Sign.\n The main part of the signing algorithm consists of a rejection sampling loop in which each iteration of the\nloop either produces a valid signature or an invalid signature whose release would leak information about\nthe private key. The loop is repeated until a valid signature is produced, which can then be encoded as a\nbyte string and output.10 The rejection sampling loop follows the Fiat-Shamir With Aborts paradigm [10]\n\n10Implementations may limit the number of iterations in this loop to not exceed a finite maximum value. If this\n                                                      23"}
{"doc_id": "NIST.FIPS.204", "source_path": "data/raw_pdfs/NIST.FIPS.204.pdf", "page_number": 34, "text": "FIPS 204    MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n\nand (aside from the rejection step) is similar in structure to Schnorr signatures [30] (e.g., EdDSA [31]). The\nsigner first produces a â€œcommitmentâ€ ğ°1 and then pseudorandomly derives a â€œchallengeâ€ ğ‘ from ğ°1 and\nthe message representative ğœ‡. Finally, the signer computes a response ğ³.\nIn more detail, the main computations involved in the rejection sampling loop are as follows:\n\n â€¢  Using the ExpandMask function (Algorithm 34), the seed ğœŒâ€³, and a counter ğœ…, a polynomial vector\n    ğ² âˆˆ ğ‘…â„“ is pseudorandomly sampled from the subset of polynomial vectors whose coefficients are\n       ğ‘\n    moderately short (i.e., in the range [âˆ’ğ›¾1 + 1, ğ›¾1]).\n\n â€¢  From ğ², the signer computes the commitment ğ°1 by computing ğ° = ğ€ğ² and then rounding to a\n    nearby multiple of 2ğ›¾2 using HighBits (Algorithm 37).\n\nâ€¢   ğ°1 and ğœ‡ are concatenated and hashed to produce the commitment hash ğ‘. This uses the function\n    w1Encode (Algorithm 28). The byte string ğ‘ is used to pseudorandomly sample a polynomial ğ‘ âˆˆ ğ‘…ğ‘\n    that has coefficients in {âˆ’1, 0, 1} and Hamming weight ğœ. The sampling is done with the function\n    SampleInBall (Algorithm 29).11\n\n â€¢  The signer computes the response ğ³ = ğ² + ğ‘ğ¬1 and performs various validity checks. If any of the\n    checks fails, the signer will continue the rejection sampling loop.\n\n â€¢  If the checks pass, the signer can compute a hint polynomial ğ¡, which will allow the verifier to\n    reconstruct ğ°1 using the compressed public key along with the other components of the signature.\n    This uses the function MakeHint (Algorithm 39). The signer will then output the final signature,\n    which is a byte encoding of the commitment hash ğ‘, the response ğ³, and the hint ğ¡.\n\nIn addition, there is an alternative way of implementing the validity checks on ğ³ and the computation of\nğ¡, which is described in Section 5.1 of [6]. This method may also be used in implementations of ML-DSA.\nIn Algorithm 7, variables are sometimes used to store products to avoid recomputing them later in the\nsigning algorithm. These precomputed products are denoted in the pseudocode by a pair of double angle\nbrackets enclosing the variables being multiplied (e.g., âŸ¨âŸ¨ğ‘ğ¬1âŸ©âŸ©).\n\noption is used and the maximum number of iterations is exceeded without producing a valid signature, the signing\nalgorithm shall return a constant that represents an error and no other output, destroying the results of the\nunsuccessful signing attempts. See Appendix C.\n11The length of ğ‘ is determined by the desired security with respect to the â€œmessage-bound signaturesâ€ property\ndescribed in [14]. Here, a length of ğœ†/4 bytes or equivalently 2ğœ† bits is required for ğœ† bits of classical security.\n                                              24"}
{"doc_id": "NIST.FIPS.204", "source_path": "data/raw_pdfs/NIST.FIPS.204.pdf", "page_number": 35, "text": "FIPS 204                                             MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n\nAlgorithm 7 ML-DSA.Sign_internal(ğ‘ ğ‘˜, ğ‘€â€² , ğ‘Ÿğ‘›ğ‘‘)\nDeterministic algorithm to generate a signature for a formatted message ğ‘€â€² .\nInput: Private key ğ‘ ğ‘˜ âˆˆ ğ”¹32+32+64+32â‹…((â„“+ğ‘˜)â‹…bitlen (2ğœ‚)+ğ‘‘ğ‘˜), formatted message ğ‘€â€² âˆˆ {0, 1}âˆ—, and\nper message randomness or dummy variable ğ‘Ÿğ‘›ğ‘‘ âˆˆ ğ”¹Â³Â².\nOutput: Signature ğœ âˆˆ ğ”¹ğœ†/4+â„“â‹…32â‹…(1+bitlen (ğ›¾â‚âˆ’1))+ğœ”+ğ‘˜.\n 1:    (ğœŒ, ğ¾, ğ‘¡ğ‘Ÿ, ğ¬â‚, ğ¬â‚‚, ğ­â‚€) â† skDecode(ğ‘ ğ‘˜)\n 2:    ğ¬â‚ â† NTT(ğ¬â‚)\n 3:    ğ¬â‚‚ â† NTT(ğ¬â‚‚)\n 4:    ğ­â‚€ â† NTT(ğ­â‚€)\n 5:    ğ€ â† ExpandA(ğœŒ)                       â–· ğ€ is generated and stored in NTT representation as ğ€\n 6:    ğœ‡ â† H(BytesToBits(ğ‘¡ğ‘Ÿ)||ğ‘€ â€² , 64)          â–· message representative that may optionally be\n       computed in a different cryptographic module\n 7:    ğœŒâ€³ â† H(ğ¾||ğ‘Ÿğ‘›ğ‘‘||ğœ‡, 64)                                        â–· compute private random seed\n 8:    ğœ… â† 0                                                             â–· initialize counter ğœ…\n 9:    (ğ³, ğ¡) â† âŠ¥\n10:    while     (ğ³, ğ¡) = âŠ¥ do                                          â–· rejection sampling loop\n11:     ğ² âˆˆ ğ‘…â„“ â† ExpandMask(ğœŒâ€³ , ğœ…)\n                    ğ‘\n12:     ğ° â† NTTâˆ’1 (ğ€ âˆ˜ NTT(ğ²))\n13:     ğ°â‚ â† HighBits(ğ°)                                                â–· signerâ€™s commitment\n14:                    â–· HighBits is applied componentwise (see explanatory text in Section 7.4)\n15:     ğ‘ â† H(ğœ‡||w1Encode(ğ°â‚), ğœ†/4)                                   â–· commitment hash\n16:     ğ‘ âˆˆ ğ‘…ğ‘ â† SampleInBall(ğ‘)Ìƒ                                     â–· verifierâ€™s challenge\n17:     ğ‘ â† NTT(ğ‘)\n18:     âŸ¨âŸ¨ğ‘ğ¬â‚âŸ©âŸ© â† NTTâˆ’1 (ğ‘ âˆ˜Ì‚ ğ¬â‚)\n19:     âŸ¨âŸ¨ğ‘ğ¬â‚‚âŸ©âŸ© â† NTTâˆ’1 (ğ‘ âˆ˜Ì‚ ğ¬â‚‚)\n20:     ğ³ â† ğ² + âŸ¨âŸ¨ğ‘ğ¬â‚âŸ©âŸ©                                               â–· signerâ€™s response\n21:     ğ«â‚€ â† LowBits(ğ° âˆ’ âŸ¨âŸ¨ğ‘ğ¬â‚‚âŸ©âŸ©)\n22:                    â–· LowBits is applied componentwise (see explanatory text in Section 7.4)\n23:     if   ||ğ³||âˆ â‰¥ ğ›¾â‚ âˆ’ ğ›½ or ||ğ«â‚€||âˆ â‰¥ ğ›¾â‚‚ âˆ’ ğ›½ then (z, h) â† âŠ¥    â–· validity checks\n24:     else\n25:              âŸ¨âŸ¨ğ‘ğ­â‚€âŸ©âŸ© â† NTTâˆ’1 (ğ‘ âˆ˜Ì‚ ğ­â‚€)\n26:              ğ¡ â† MakeHint(âˆ’âŸ¨âŸ¨ğ‘ğ­â‚€âŸ©âŸ©, ğ° âˆ’ âŸ¨âŸ¨ğ‘ğ¬â‚‚âŸ©âŸ© + âŸ¨âŸ¨ğ‘ğ­â‚€âŸ©âŸ©)       â–· Signerâ€™s hint\n27:                    â–· MakeHint is applied componentwise (see explanatory text in Section 7.4)\n28:              if ||âŸ¨âŸ¨ğ‘ğ­â‚€âŸ©âŸ©||âˆ â‰¥ ğ›¾â‚‚ or the number of 1â€™s in ğ¡ is greater than ğœ”, then (z, h) â† âŠ¥\n29:              end if\n30:     end if\n31:     ğœ… â† ğœ… + â„“                                                       â–· increment counter\n32:    end while\n33:    ğœ â† sigEncode(ğ‘, ğ³Ìƒ modÂ±ğ‘, ğ¡)\n34:    return ğœ\n\n6.3    ML-DSA Verifying (Internal)\n                 The algorithm ML-DSA.Verify_internal (Algorithm 8) takes a public key ğ‘ğ‘˜ encoded as a byte string, a\nmessage ğ‘€ encoded as a bit string, and a signature ğœ encoded as a byte string as input. No randomness is\n                                                                  25"}
{"doc_id": "NIST.FIPS.204", "source_path": "data/raw_pdfs/NIST.FIPS.204.pdf", "page_number": 36, "text": "FIPS 204    MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n\nrequired for ML-DSA.Verify_internal. It produces a Boolean value (i.e., a value that is true if the signature\nis valid with respect to the message and public key and false if the signature is invalid) as output. Algorithm 8\nspecifies the lengths of the signature ğœ and the public key ğ‘ğ‘˜ in terms of the parameters described in\nTable 1. If an implementation of ML-DSA.Verify_internal can accept inputs for ğœ or ğ‘ğ‘˜ of any other\nlength, it shall return false whenever the length of either of these inputs differs from its specified length.\n    The verifier first extracts the public random seed ğœŒ and the compressed polynomial vector ğ­1 from the\npublic key ğ‘ğ‘˜ and then extracts the signerâ€™s commitment hash ğ‘, response ğ³, and hint ğ¡ from the signature\nğœ. The verifier may find that the hint was not properly byte-encoded, denoted by the symbol â€œâŠ¥,â€ in\nwhich case the verification algorithm will immediately return false to indicate that the signature is invalid.\nAssuming that the signature is successfully extracted from its byte encoding, the verifier pseudorandomly\nderives ğ€ from ğœŒ, as is done in key generation and signing, and creates a message representative ğœ‡ by\nhashing the concatenation of ğ‘¡ğ‘Ÿ (i.e., the hash of the public key ğ‘ğ‘˜) and the message ğ‘€. The verifier\nthen attempts to reconstruct the signerâ€™s commitment (i.e., the polynomial vector ğ°1) from the public\nkey ğ‘ğ‘˜ and the signature ğœ. In ML-DSA.Sign_internal, ğ°1 is computed by rounding ğ° = ğ€ğ². In\nML-DSA.Verify_internal, the reconstructed value of ğ°1 is called ğ°â€²   since it may have been computed in\na different way if the signature is invalid. This ğ°â€² is computed      1\n                                              1                    through the following process:\n\n â€¢     Derive the challenge polynomial ğ‘ from the signerâ€™s commitment hash ğ‘, just as similarly is done in\n       ML-DSA.Sign_internal.\n\n â€¢     Use the signerâ€™s response ğ³ to compute\n\n                                              ğ°â€²     = ğ€ğ³ âˆ’ ğ‘ğ­1 â‹… 2ğ‘‘.\n                                              Approx\n       Assuming the signature was computed correctly, as in ML-DSA.Sign_internal, it follows that\n\n                 ğ° = ğ€ğ² = ğ€ğ³ âˆ’ ğ‘ğ­ + ğ‘ğ¬2 â‰ˆ ğ°â€²                 = ğ€ğ³ âˆ’ ğ‘ğ­1 â‹… 2ğ‘‘\n                                                              Approx\n\n       because ğ‘ and ğ¬2 have small coefficients, and ğ­1 â‹… 2ğ‘‘ â‰ˆ ğ­ .\n\n â€¢     Use the signerâ€™s hint ğ¡ to obtain ğ°â€² from ğ°â€²  .\n                                   1                  Approx\n\nFinally, the verifier checks that the signerâ€™s response ğ³ and the signerâ€™s hint ğ¡ are valid and that the\nreconstructed ğ°â€² is consistent with the signerâ€™s commitment hash ğ‘. More precisely, the verifier checks\nthat all of the  1\n                 coefficients of ğ³ are sufficiently small (i.e., inâ€²the range (âˆ’(ğ›¾1 âˆ’ ğ›½), ğ›¾1 âˆ’ ğ›½)), ğ¡ contains no\nmore than ğœ” nonzero coefficients, and ğ‘ matches the hash ğ‘ of the message representative ğœ‡ concatenated\nwith ğ°â€² (represented as a byte string). If all of these checks succeed, then ML-DSA.Verify_internal returns\ntrue.  1\n       Otherwise, it returns false.\n\n26"}
{"doc_id": "NIST.FIPS.204", "source_path": "data/raw_pdfs/NIST.FIPS.204.pdf", "page_number": 37, "text": "FIPS 204                                       MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n\nAlgorithm 8 ML-DSA.Verify_internal(ğ‘ğ‘˜, ğ‘€â€² , ğœ)\nInternal function to verify a signature ğœ for a formatted message ğ‘€â€² .\nInput: Public key ğ‘ğ‘˜ âˆˆ ğ”¹32+32ğ‘˜(bitlen (ğ‘âˆ’1)âˆ’ğ‘‘) and message ğ‘€â€² âˆˆ {0, 1}âˆ—.\nInput: Signature ğœ âˆˆ ğ”¹ğœ†/4+â„“â‹…32â‹…(1+bitlen (ğ›¾â‚âˆ’1))+ğœ”+ğ‘˜.\nOutput: Boolean\n 1:    (ğœŒ, ğ­â‚) â† pkDecode(ğ‘ğ‘˜)\n 2:    (ğ‘, ğ³, ğ¡) â† sigDecode(ğœ)            â–· signerâ€™s commitment hash ğ‘, response ğ³, and hint ğ¡\n 3:    if ğ¡ = âŠ¥ then return false                         â–· hint was not properly encoded\n 4:    end if\n 5:    ğ€ â† ExpandA(ğœŒ)                 â–· ğ€ is generated and stored in NTT representation as ğ€\n 6:    ğ‘¡ğ‘Ÿ â† H(ğ‘ğ‘˜, 64)\n 7:    ğœ‡ â† (H(BytesToBits(ğ‘¡ğ‘Ÿ)||ğ‘€ â€² , 64))  â–· message representative that may optionally be\n       computed in a different cryptographic module\n 8:    ğ‘ âˆˆ ğ‘…ğ‘ â† SampleInBall(ğ‘)Ìƒ                       â–· compute verifierâ€™s challenge from ğ‘\n 9:    ğ°â€²   â† NTTâˆ’1 (ğ€ âˆ˜ NTT(ğ³) âˆ’ NTT(ğ‘) âˆ˜ NTT(ğ­      â‹… 2ğ‘‘))  â–· ğ°â€²      = ğ€ğ³ âˆ’ ğ‘ğ­ â‹… 2ğ‘‘\n           Approx                                          1            Approx    1\n10:    ğ°â€² â† UseHint(ğ¡, ğ°â€²           )                   â–· reconstruction of signerâ€™s commitment\n           1             â–· Approx\n11:                        UseHint is applied componentwise (see explanatory text in Section 7.4)\n12:    ğ‘â€²  â† H(ğœ‡||w1Encode(ğ°â€² ), ğœ†/4)                           â–· hash it; this should match ğ‘\n       return [[ ||ğ³||  < ğ›¾ âˆ’ 1              â€²\n13:                  âˆ        1  ğ›½]] and [[ğ‘ = ğ‘ ]]\n\n27"}
{"doc_id": "NIST.FIPS.204", "source_path": "data/raw_pdfs/NIST.FIPS.204.pdf", "page_number": 38, "text": "FIPS 204                              MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n\n7.     Auxiliary Functions\n\nThis section provides pseudocode for subroutines utilized by ML-DSA, including functions for data-type\nconversions, arithmetic, and sampling.\n\n7.1    Conversion Between Data Types\nWhile the primary data type in ML-DSA is a byte string, other data types are used as well. The goal in\nthis section is to construct procedures for translating between the various algebraic objects defined in\nSection 2.3. Algorithms 9â€“13 are intermediate procedures for converting between bit strings, byte strings,\nand integers.\n\nAlgorithm 9 IntegerToBits(ğ‘¥, ğ›¼)\nComputes a base-2 representation of ğ‘¥ mod 2ğ›¼ using little-endian order.\nInput: A nonnegative integer ğ‘¥ and a positive integer ğ›¼.\nOutput: A bit string ğ‘¦ of length ğ›¼.\n 1:    ğ‘¥â€² â† ğ‘¥\n 2:    for ğ‘– from 0 to ğ›¼ âˆ’ 1 do\n 3:     ğ‘¦[ğ‘–] â† ğ‘¥â€² mod 2\n 4:     ğ‘¥â€² â† âŒŠğ‘¥â€² /2âŒ‹\n 5:    end for\n 6:    return ğ‘¦\n\nAlgorithm 10 BitsToInteger(ğ‘¦, ğ›¼)\nComputes the integer value expressed by a bit string using little-endian order.\nInput: A positive integer ğ›¼ and a bit string ğ‘¦ of length ğ›¼.\nOutput: A nonnegative integer ğ‘¥.\n 1:    ğ‘¥ â† 0\n 2:    for ğ‘– from 1 to ğ›¼ do\n 3:     ğ‘¥ â† 2ğ‘¥ + ğ‘¦[ğ›¼ âˆ’ ğ‘–]\n 4:    end for\n 5:    return ğ‘¥\n\nAlgorithm 11 IntegerToBytes(ğ‘¥, ğ›¼)\nComputes a base-256 representation of ğ‘¥ mod 256ğ›¼ using little-endian order.\nInput: A nonnegative integer ğ‘¥ and a positive integer ğ›¼.\nOutput: A byte string ğ‘¦ of length ğ›¼.\n 1:    ğ‘¥â€² â† ğ‘¥\n 2:    for ğ‘– from 0 to ğ›¼ âˆ’ 1 do\n 3:     ğ‘¦[ğ‘–] â† ğ‘¥â€² mod 256\n 4:     ğ‘¥â€² â† âŒŠğ‘¥â€² /256âŒ‹\n 5:    end for\n 6:    return ğ‘¦\n\n                                      28"}
{"doc_id": "NIST.FIPS.204", "source_path": "data/raw_pdfs/NIST.FIPS.204.pdf", "page_number": 39, "text": "FIPS 204                                                  MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n\nAlgorithm 12 BitsToBytes(ğ‘¦)\nConverts a bit string into a byte string using little-endian order.\nInput: A bit string ğ‘¦ of length ğ›¼.\nOutput: A byte string ğ‘§ of length âŒˆğ›¼/8âŒ‰.\n 1:    ğ‘§ âˆˆ ğ”¹âŒˆğ›¼/8âŒ‰ â† 0âŒˆğ›¼/8âŒ‰\n 2:    for ğ‘– from 0 to ğ›¼ âˆ’ 1 do\n 3:         ğ‘§ [âŒŠğ‘–/8âŒ‹] â† ğ‘§ [âŒŠğ‘–/8âŒ‹] + ğ‘¦[ğ‘–] â‹… 2ğ‘– mod 8\n 4:    end for\n 5:    return ğ‘§\n\nAlgorithm 13 BytesToBits(ğ‘§)\nConverts a byte string into a bit string using little-endian order.\nInput: A byte string ğ‘§ of length ğ›¼.\nOutput: A bit string ğ‘¦ of length 8ğ›¼.\n 1:    ğ‘§â€² â† ğ‘§\n 2:    for ğ‘– from 0 to ğ›¼ âˆ’ 1 do\n 3:        for ğ‘— from 0 to 7 do                          â–· convert the byte ğ‘§[ğ‘–] into 8 bits\n 4:             ğ‘¦[8ğ‘– + ğ‘—] â† ğ‘§â€² [ğ‘–] mod 2\n 5:             ğ‘§â€² [ğ‘–] â† âŒŠğ‘§â€² [ğ‘–]/2âŒ‹\n 6:        end for\n 7:    end for\n 8:    return ğ‘¦\n\nAlgorithms 14 and 15 translate byte strings into coefficients of polynomials in ğ‘…. CoeffFromThreeBytes\nuses a 3-byte string to either generate an element of {0, 1, â€¦ , ğ‘ âˆ’ 1} or return the blank symbol âŠ¥.\nCoeffFromHalfByte uses an element of {0, 1, â€¦ , 15} to either generate an element of {âˆ’ğœ‚, âˆ’ğœ‚+1, â€¦ , ğœ‚}\nor return âŠ¥. These two procedures will be used in the uniform sampling algorithms RejNTTPoly and\nRejBoundedPoly, which are discussed in Section 7.3.\n\nAlgorithm 14 CoeffFromThreeBytes(ğ‘â‚€, ğ‘â‚, ğ‘â‚‚)\nGenerates an element of {0, 1, 2, â€¦ , ğ‘ âˆ’ 1} âˆª {âŠ¥}.\nInput: Bytes ğ‘â‚€, ğ‘â‚, ğ‘â‚‚.\nOutput: An integer modulo ğ‘ or âŠ¥.\n 1:    ğ‘â€² â† ğ‘â‚‚\n       2 â€²\n 2:    if ğ‘â‚‚ > 127 then\n 3:         ğ‘â€² â† ğ‘â€² âˆ’ 128                                        â–· set the top bit of ğ‘â€²       to zero\n       end 2       2                                               2\n 4:         if\n 5:    ğ‘§ â† 2Â¹â¶ â‹… ğ‘â€²   + 2â¸ â‹… ğ‘â‚ + ğ‘â‚€                                                â–· 0 â‰¤ ğ‘§ â‰¤ 2Â²Â³ âˆ’ 1\n       if ğ‘§ < ğ‘  2\n 6:                then return ğ‘§                                                    â–· rejection sampling\n 7:    else return âŠ¥\n 8:    end if\n\n                                                          29"}
{"doc_id": "NIST.FIPS.204", "source_path": "data/raw_pdfs/NIST.FIPS.204.pdf", "page_number": 40, "text": "FIPS 204                                           MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n\nAlgorithm 15 CoeffFromHalfByte(ğ‘)\nLet ğœ‚ âˆˆ {2, 4}. Generates an element of {âˆ’ğœ‚, âˆ’ğœ‚ + 1, â€¦ , ğœ‚} âˆª {âŠ¥}.\nInput: Integer ğ‘ âˆˆ {0, 1, â€¦ , 15}.\nOutput: An integer between âˆ’ğœ‚ and ğœ‚, or âŠ¥.\n 1:    if ğœ‚ = 2  and ğ‘ < 15 then return 2 âˆ’ (ğ‘ mod 5)      â–· rejection sampling from {âˆ’2, â€¦ , 2}\n 2:    else\n 3:     if ğœ‚ = 4 and ğ‘ < 9 then return 4 âˆ’ ğ‘               â–· rejection sampling from {âˆ’4, â€¦ , 4}\n 4:     else      return âŠ¥\n 5:     end if\n 6:    end if\n\nAlgorithms 16â€“19 efficiently translate an element ğ‘¤ âˆˆ    ğ‘… into a byte string and vice versa under the\nassumption that the coefficients of ğ‘¤ are in a restricted range. SimpleBitPack assumes that ğ‘¤ğ‘– âˆˆ [0, ğ‘]\nfor some positive integer ğ‘ and packs ğ‘¤ into a byte string of length 32 â‹… bitlen ğ‘. BitPack allows for the\nmore general restriction ğ‘¤ğ‘– âˆˆ [âˆ’ğ‘, ğ‘]. The BitPack algorithm works by merely subtracting ğ‘¤ from the\npolynomial âˆ‘255 ğ‘ğ‘‹ğ‘–.\n                  ğ‘–=0\n\nAlgorithm 16 SimpleBitPack(ğ‘¤, ğ‘)\nEncodes a polynomial ğ‘¤ into a byte string.\nInput: ğ‘ âˆˆ â„• and ğ‘¤ âˆˆ ğ‘… such that the coefficients of ğ‘¤ are all in [0, ğ‘].\nOutput: A byte string of length 32 â‹… bitlen ğ‘.\n 1:    ğ‘§ â† ()                                                â–· set ğ‘§ to the empty bit string\n 2:    for ğ‘– from 0 to 255 do\n 3:    endğ‘§ â† ğ‘§||IntegerToBits(ğ‘¤ğ‘– , bitlen ğ‘)\n 4:         for\n 5:    return BitsToBytes(ğ‘§)\n\nAlgorithm 17 BitPack(ğ‘¤, ğ‘, ğ‘)\nEncodes a polynomial ğ‘¤ into a byte string.\nInput: ğ‘, ğ‘ âˆˆ â„• and ğ‘¤ âˆˆ ğ‘… such that the coefficients of ğ‘¤ are all in [âˆ’ğ‘, ğ‘].\nOutput: A byte string of length 32 â‹… bitlen (ğ‘ + ğ‘).\n 1:    ğ‘§ â† ()                                                â–· set ğ‘§ to the empty bit string\n 2:    for ğ‘– from 0 to 255 do\n 3:    endğ‘§ â† ğ‘§||IntegerToBits(ğ‘ âˆ’ ğ‘¤ğ‘– , bitlen (ğ‘ + ğ‘))\n 4:         for\n 5:    return BitsToBytes(ğ‘§)\n\nSimpleBitUnpack and BitUnpack are used to decode the byte strings produced by the above functions.\nFor some choices of ğ‘ and ğ‘, there exist malformed byte strings that will cause SimpleBitUnpack and\nBitUnpack to output polynomials whose coefficients are not in the ranges [0, ğ‘] and [âˆ’ğ‘, ğ‘], respectively.\n        This can be a concern when running SimpleBitUnpack and BitUnpack on inputs that may come from an\nuntrusted source.\n                                                       30"}
{"doc_id": "NIST.FIPS.204", "source_path": "data/raw_pdfs/NIST.FIPS.204.pdf", "page_number": 41, "text": "FIPS 204                             MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n\nAlgorithm 18 SimpleBitUnpack(ğ‘£, ğ‘)\nReverses the procedure SimpleBitPack.\nInput: ğ‘ âˆˆ â„• and a byte string ğ‘£ of length 32 â‹… bitlen ğ‘.\nOutput: A polynomial ğ‘¤ âˆˆ ğ‘… with coefficients in [0, 2ğ‘ âˆ’ 1], where ğ‘ = bitlen ğ‘.\nWhen ğ‘ + 1 is a power of 2, the coefficients are in [0, ğ‘].\n 1:  ğ‘ â† bitlen ğ‘\n 2:  ğ‘§ â† BytesToBits(ğ‘£)\n 3:  for ğ‘– from 0 to 255 do\n 4:  endğ‘¤ğ‘– â† BitsToInteger((ğ‘§[ğ‘–ğ‘], ğ‘§[ğ‘–ğ‘ + 1], â€¦ ğ‘§[ğ‘–ğ‘ + ğ‘ âˆ’ 1]), ğ‘)\n 5:         for\n 6:  return ğ‘¤\n\nAlgorithm 19 BitUnpack(ğ‘£, ğ‘, ğ‘)\nReverses the procedure BitPack.\nInput: ğ‘, ğ‘ âˆˆ â„• and a byte string ğ‘£ of length 32 â‹… bitlen (ğ‘ + ğ‘).\nOutput: A polynomial ğ‘¤ âˆˆ ğ‘… with coefficients in [ğ‘ âˆ’ 2ğ‘ + 1, ğ‘], where ğ‘ = bitlen (ğ‘ + ğ‘).\nWhen ğ‘ + ğ‘ + 1 is a power of 2, the coefficients are in [âˆ’ğ‘, ğ‘].\n 1:  ğ‘ â† bitlen (ğ‘ + ğ‘)\n 2:  ğ‘§ â† BytesToBits(ğ‘£)\n 3:  for ğ‘– from 0 to 255 do\n 4:  endğ‘¤ğ‘– â† ğ‘ âˆ’ BitsToInteger((ğ‘§[ğ‘–ğ‘], ğ‘§[ğ‘–ğ‘ + 1], â€¦ ğ‘§[ğ‘–ğ‘ + ğ‘ âˆ’ 1]), ğ‘)\n 5:         for\n 6:  return ğ‘¤\n\nAlgorithms 20 and 21 carry out byte-string-to-polynomial conversions for polynomials with sparse binary\ncoefficients. In particular, the signing and verification algorithms (Sections 6.2 and 6.3) make use of a â€œhint,â€\nwhich is a vector of polynomials ğ¡ âˆˆ ğ‘…ğ‘˜ such that the total number of coefficients in ğ¡[0], ğ¡[1], â€¦ , ğ¡[ğ‘˜âˆ’1]\nthat are equal to  is no more than  . 2\n                   1                ğœ” This constraint enables encoding and decoding procedures that are\nmore efficient (although more complex) than BitPack and BitUnpack.\nHintBitPack (ğ¡) outputs a byte string ğ‘¦ of length ğœ” + ğ‘˜. The last ğ‘˜ bytes of ğ‘¦ contain information about\nhow many nonzero coefficients are present in each of the polynomials ğ¡[0], ğ¡[1], â€¦ , ğ¡[ğ‘˜ âˆ’ 1], and the\nfirst ğœ” bytes of ğ‘¦ contain information about exactly where those nonzero terms occur. HintBitUnpack\nreverses the procedure performed by HintBitPack and recovers the vector ğ¡.\n\n31"}
{"doc_id": "NIST.FIPS.204", "source_path": "data/raw_pdfs/NIST.FIPS.204.pdf", "page_number": 42, "text": "FIPS 204    MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n\nAlgorithm 20 HintBitPack(ğ¡)\nEncodes a polynomial vector ğ¡ with binary coefficients into a byte string.\nInput: A polynomial vector ğ¡         âˆˆ ğ‘…ğ‘˜ such that the polynomials ğ¡[0], ğ¡[1],...,ğ¡[ğ‘˜ âˆ’ 1] have\ncollectively at most ğœ” nonzero          2\n                                      coefficients.\nOutput: A byte string ğ‘¦ of length ğœ” + ğ‘˜ that encodes ğ¡ as described above.\n 1:    ğ‘¦ âˆˆ ğ”¹ğœ”+ğ‘˜ â† 0ğœ”+ğ‘˜\n 2:    Index â† 0                                   â–· Index for writing the first ğœ” bytes of ğ‘¦\n 3:    for ğ‘– from 0 to ğ‘˜ âˆ’ 1 do                                             â–· look at ğ¡[ğ‘–]\n 4:     for ğ‘— from 0 to 255 do\n 5:      if ğ¡[ğ‘–]ğ‘— â‰  0    then\n 6:                 ğ‘¦[Index] â† ğ‘—        â–· store the locations of the nonzero coefficients in ğ¡[ğ‘–]\n 7:                 Index â† Index + 1\n 8:      end if\n 9:     end for\n10:     ğ‘¦[ğœ” + ğ‘–] â† Index                        â–· after processing ğ¡[ğ‘–], store the value of Index\n11:    end for\n12:    return ğ‘¦\n\nAlgorithm 21 HintBitUnpack(ğ‘¦)\nReverses the procedure HintBitPack.\nInput: A byte string ğ‘¦ of length ğœ” + ğ‘˜ that encodes ğ¡ as described above.\nOutput: A polynomial vector ğ¡ âˆˆ ğ‘…ğ‘˜ or âŠ¥.\n                                         2\n 1:    ğ¡ âˆˆ ğ‘…ğ‘˜ â† 0ğ‘˜\n       Index 2\n 2:     â† 0                                        â–· Index for reading the first ğœ” bytes of ğ‘¦\n 3:    for ğ‘– from 0 to ğ‘˜ âˆ’ 1 do                                             â–· reconstruct ğ¡[ğ‘–]\n 4:     if ğ‘¦[ğœ” + ğ‘–] < Index or ğ‘¦[ğœ” + ğ‘–] > ğœ” then return âŠ¥             â–· malformed input\n 5:     end if\n 6:     First â† Index\n 7:     while Index < ğ‘¦[ğœ” + ğ‘–] do               â–· ğ‘¦[ğœ” + ğ‘–] says how far one can advance Index\n 8:      if Index > First      then\n 9:                 if ğ‘¦[Index âˆ’ 1] â‰¥ ğ‘¦[Index] then return âŠ¥               â–· malformed input\n10:                 end if\n11:      end if\n12:      ğ¡[ğ‘–]ğ‘¦[Index]  â† 1             â–· ğ‘¦[Index] says which coefficient in ğ¡[ğ‘–] should be 1\n13:      Index â† Index + 1\n14:     end while\n15:    end for\n16:    for ğ‘– from Index to ğœ” âˆ’ 1 do              â–· read any leftover bytes in the first ğœ” bytes of ğ‘¦\n17:     if ğ‘¦[ğ‘–] â‰  0 then return âŠ¥                                          â–· malformed input\n18:     end if\n19:    end for\n20:    return ğ¡\n\n                                                   32"}
{"doc_id": "NIST.FIPS.204", "source_path": "data/raw_pdfs/NIST.FIPS.204.pdf", "page_number": 43, "text": "FIPS 204                                              MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n\n7.2    Encodings of ML-DSA Keys and Signatures\nAlgorithms 22â€“27 translate keys and signatures for ML-DSA into byte strings. These procedures take\ncertain sequences of algebraic objects, encode them consecutively into byte strings, and perform the\nrespective decoding procedures.\nFirst, pkEncode and pkDecode translate ML-DSA public keys into byte strings and vice versa.   When\nverifying a signature, pkDecode might be run on an input that comes from an untrusted source. Thus,\ncare is required when using SimpleBitUnpack. As used here, SimpleBitUnpack always returns values in\nthe correct range.\n\nAlgorithm 22 pkEncode(ğœŒ, ğ­â‚)\nEncodes a public key for ML-DSA into a byte string.\nInput:ğœŒ âˆˆ ğ”¹Â³Â², ğ­â‚ âˆˆ ğ‘…ğ‘˜ with coefficients in [0, 2áµ‡â±áµ—Ë¡áµ‰â¿ (ğ‘âˆ’1)âˆ’ğ‘‘ âˆ’ 1].\nOutput: Public key ğ‘ğ‘˜ âˆˆ ğ”¹32+32ğ‘˜(bitlen (ğ‘âˆ’1)âˆ’ğ‘‘).\n 1:  ğ‘ğ‘˜ â† ğœŒ\n 2:  for ğ‘– from 0 to ğ‘˜ âˆ’ 1 do\n 3:  endğ‘ğ‘˜ â† ğ‘ğ‘˜ || SimpleBitPack (ğ­Â¹[ğ‘–], 2áµ‡â±áµ—Ë¡áµ‰â¿ (ğ‘âˆ’1)âˆ’ğ‘‘ âˆ’ 1)\n 4:         for\n 5:  return ğ‘ğ‘˜\n\nAlgorithm 23 pkDecode(ğ‘ğ‘˜)\nReverses the procedure pkEncode.\nInput: Public key ğ‘ğ‘˜ âˆˆ ğ”¹32+32ğ‘˜(bitlen (ğ‘âˆ’1)âˆ’ğ‘‘).\nOutput: ğœŒ âˆˆ ğ”¹Â³Â², ğ­â‚ âˆˆ ğ‘…ğ‘˜ with coefficients in [0, 2áµ‡â±áµ—Ë¡áµ‰â¿ (ğ‘âˆ’1)âˆ’ğ‘‘ âˆ’ 1].\n 1:  (ğœŒ, ğ‘§â‚€, â€¦ , ğ‘§ğ‘˜âˆ’1 ) âˆˆ ğ”¹Â³Â² Ã— (ğ”¹32(bitlen (ğ‘âˆ’1)âˆ’ğ‘‘))ğ‘˜ â† ğ‘ğ‘˜\n 2:  for ğ‘– from 0 to ğ‘˜ âˆ’ 1 do\n 3:  endğ­Â¹[ğ‘–] â† SimpleBitUnpack(ğ‘§ğ‘– , 2áµ‡â±áµ—Ë¡áµ‰â¿ (ğ‘âˆ’1)âˆ’ğ‘‘ âˆ’ 1)       â–· This is always in the correct range\n 4:  for\n 5:  return (ğœŒ, ğ­â‚)\n\nNext, skEncode and skDecode translate ML-DSA secret keys into byte strings and vice versa. Note that\nthere exist malformed inputs that can cause skDecode to return values that are not in the correct range.\nHence, skDecode should only be run on inputs that come from trusted sources.\n\n33"}
{"doc_id": "NIST.FIPS.204", "source_path": "data/raw_pdfs/NIST.FIPS.204.pdf", "page_number": 44, "text": "FIPS 204                                                  MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n\nAlgorithm 24 skEncode(ğœŒ, ğ¾, ğ‘¡ğ‘Ÿ, ğ¬â‚, ğ¬â‚‚, ğ­â‚€)\nEncodes a secret key for ML-DSA into a byte string.\nInput: ğœŒ   âˆˆ ğ”¹Â³Â², ğ¾    âˆˆ ğ”¹Â³Â², ğ‘¡ğ‘Ÿ     âˆˆ ğ”¹â¶â´, ğ¬â‚ âˆˆ ğ‘…â„“ with coefficients in [âˆ’ğœ‚, ğœ‚], ğ¬â‚‚ âˆˆ ğ‘…ğ‘˜ with\ncoefficients in [âˆ’ğœ‚, ğœ‚], ğ­â‚€ âˆˆ ğ‘…ğ‘˜ with coefficients in [âˆ’2ğ‘‘âˆ’1 + 1, 2ğ‘‘âˆ’1].\nOutput: Private key ğ‘ ğ‘˜ âˆˆ ğ”¹32+32+64+32â‹…((ğ‘˜+â„“)â‹…bitlen (2ğœ‚)+ğ‘‘ğ‘˜).\n 1:    ğ‘ ğ‘˜ â† ğœŒ||ğ¾||ğ‘¡ğ‘Ÿ\n 2:    for ğ‘– from 0 to â„“ âˆ’ 1 do\n 3:    endğ‘ ğ‘˜ â† ğ‘ ğ‘˜ || BitPack (ğ¬Â¹[ğ‘–], ğœ‚, ğœ‚)\n 4:         for\n 5:    for ğ‘– from 0 to ğ‘˜ âˆ’ 1 do\n 6:    endğ‘ ğ‘˜ â† ğ‘ ğ‘˜ || BitPack (ğ¬Â²[ğ‘–], ğœ‚, ğœ‚)\n 7:         for\n 8:    for ğ‘– from 0 to ğ‘˜ âˆ’ 1 do\n 9:    endğ‘ ğ‘˜ â† ğ‘ ğ‘˜ || BitPack (ğ­â°[ğ‘–], 2ğ‘‘âˆ’1 âˆ’ 1, 2ğ‘‘âˆ’1)\n10:         for\n11:    return ğ‘ ğ‘˜\n\nAlgorithm 25 skDecode(ğ‘ ğ‘˜)\nReverses the procedure skEncode.\nInput: Private key ğ‘ ğ‘˜ âˆˆ ğ”¹32+32+64+32â‹…((â„“+ğ‘˜)â‹…bitlen (2ğœ‚)+ğ‘‘ğ‘˜).\nOutput: ğœŒ âˆˆ ğ”¹Â³Â², ğ¾ âˆˆ ğ”¹Â³Â², ğ‘¡ğ‘Ÿ âˆˆ ğ”¹â¶â´,\nğ¬â‚ âˆˆ ğ‘…â„“, ğ¬â‚‚ âˆˆ ğ‘…ğ‘˜, ğ­â‚€ âˆˆ ğ‘…ğ‘˜ with coefficients in [âˆ’2ğ‘‘âˆ’1 + 1, 2ğ‘‘âˆ’1].\n 1:    (ğœŒ, ğ¾, ğ‘¡ğ‘Ÿ, ğ‘¦â‚€, â€¦ , ğ‘¦â„“âˆ’1, ğ‘§â‚€, â€¦ , ğ‘§ğ‘˜âˆ’1 , ğ‘¤â‚€, â€¦ , ğ‘¤ğ‘˜âˆ’1 ) âˆˆ ğ”¹Â³Â² Ã— ğ”¹Â³Â² Ã— ğ”¹â¶â´ Ã— (ğ”¹32â‹…bitlen (2ğœ‚))â„“ Ã—\n       (ğ”¹32â‹…bitlen (2ğœ‚))ğ‘˜ Ã— (ğ”¹32ğ‘‘)ğ‘˜ â† ğ‘ ğ‘˜\n 2:    for ğ‘– from 0 to â„“ âˆ’ 1 do\n 3:    endğ¬Â¹[ğ‘–] â† BitUnpack(ğ‘¦ğ‘– , ğœ‚, ğœ‚)           â–· this may lie outside [âˆ’ğœ‚, ğœ‚] if input is malformed\n 4:         for\n 5:    for ğ‘– from 0 to ğ‘˜ âˆ’ 1 do\n 6:    endğ¬Â²[ğ‘–] â† BitUnpack(ğ‘§ğ‘– , ğœ‚, ğœ‚)           â–· this may lie outside [âˆ’ğœ‚, ğœ‚] if input is malformed\n 7:         for\n 8:    for ğ‘– from 0 to ğ‘˜ âˆ’ 1 do\n 9:    endğ­â°[ğ‘–] â† BitUnpack(ğ‘¤ğ‘– , 2ğ‘‘âˆ’1 âˆ’ 1, 2ğ‘‘âˆ’1)              â–· this is always in the correct range\n10:         for\n11:    return (ğœŒ, ğ¾, ğ‘¡ğ‘Ÿ, ğ¬â‚, ğ¬â‚‚, ğ­â‚€)\n\nNext, sigEncode and sigDecode translate ML-DSA signatures into byte strings and vice versa.      When\nverifying a signature, sigDecode might take input that comes from an untrusted source. Thus, care is\nrequired when using BitUnpack. As used here, BitUnpack always returns values in the correct range.\n\n34"}
{"doc_id": "NIST.FIPS.204", "source_path": "data/raw_pdfs/NIST.FIPS.204.pdf", "page_number": 45, "text": "FIPS 204                                         MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n\nAlgorithm 26 sigEncode(ğ‘, ğ³, ğ¡)\nEncodes a signature into a byte string.\nInput: ğ‘ âˆˆ ğ”¹ğœ†/4, ğ³ âˆˆ ğ‘…â„“ with coefficients in [âˆ’ğ›¾â‚ + 1, ğ›¾â‚], ğ¡ âˆˆ ğ‘…ğ‘˜.\nOutput: Signature ğœ âˆˆ ğ”¹ğœ†/4+â„“â‹…32â‹…(1+bitlen (ğ›¾â‚âˆ’1))+ğœ”+ğ‘˜.       2\n 1:  ğœ â† ğ‘Ìƒ\n 2:  for ğ‘– from 0 to â„“ âˆ’ 1 do\n 3:  endğœ â† ğœ || BitPack (ğ³[ğ‘–], ğ›¾Â¹ âˆ’ 1, ğ›¾Â¹)\n 4:         for\n 5:  ğœ â† ğœ || HintBitPack (ğ¡)\n 6:  return ğœ\n\nAlgorithm 27 sigDecode(ğœ)\nReverses the procedure sigEncode.\nInput: Signature ğœ âˆˆ ğ”¹ğœ†/4+â„“â‹…32â‹…(1+bitlen (ğ›¾â‚âˆ’1))+ğœ”+ğ‘˜.\nOutput: ğ‘ âˆˆ ğ”¹ğœ†/4, ğ³ âˆˆ ğ‘…â„“ with coefficients in [âˆ’ğ›¾â‚ + 1, ğ›¾â‚], ğ¡ âˆˆ ğ‘…ğ‘˜, or âŠ¥.\n                                                                             2\n 1:  (ğ‘, ğ‘¥Ìƒâ‚€, â€¦ , ğ‘¥â„“âˆ’1, ğ‘¦) âˆˆ ğ”¹ğœ†/4 Ã— (ğ”¹32â‹…(1+áµ‡â±áµ—Ë¡áµ‰â¿ (ğ›¾â‚âˆ’1)))â„“ Ã— ğ”¹ğœ”+ğ‘˜ â† ğœ\n 2:  for ğ‘– from 0 to â„“ âˆ’ 1 do\n 3:  endğ³[ğ‘–] â† BitUnpack(ğ‘¥ğ‘– , ğ›¾Â¹ âˆ’ 1, ğ›¾Â¹)  â–· this is in the correct range, as ğ›¾â‚ is a power of 2\n 4:         for\n 5:  ğ¡ â† HintBitUnpack(ğ‘¦)\n 6:  return (ğ‘, ğ³, ğ¡)\n\nw1Encode is a specific subroutine used in ML-DSA.Sign. The procedure w1Encode encodes a polynomial\nvector ğ°1 into a string of bytes so that it can be processed by the function H.\n\nAlgorithm 28 w1Encode(ğ°â‚)\nEncodes a polynomial vector ğ°â‚ into a byte string.\nInput: ğ°â‚ âˆˆ ğ‘…ğ‘˜ whose polynomial coordinates have coefficients in [0, (ğ‘ âˆ’ 1)/(2ğ›¾â‚‚) âˆ’ 1].\nOutput: A byte string representation ğ°â‚ âˆˆ ğ”¹32ğ‘˜â‹…bitlen ((ğ‘âˆ’1)/(2ğ›¾â‚‚)âˆ’1).\n 1:  ğ°Ìƒâ‚ â† ()\n 2:  for ğ‘– from 0 to ğ‘˜ âˆ’ 1 do\n 3:  endğ°ÌƒÂ¹ â† ğ°ÌƒÂ¹ || SimpleBitPack (ğ°Â¹[ğ‘–], (ğ‘ âˆ’ 1)/(2ğ›¾Â²) âˆ’ 1)\n 4:         for\n 5:  return ğ°Ìƒâ‚\n\n35"}
{"doc_id": "NIST.FIPS.204", "source_path": "data/raw_pdfs/NIST.FIPS.204.pdf", "page_number": 46, "text": "    FIPS 204                                                   MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n\n    7.3       Pseudorandom Sampling\n               This section specifies various algorithms for generating algebraic objects pseudorandomly from a seed\n    ğœŒ, where ğœŒ is a byte string whose length varies depending on the algorithm. The first procedure to be\n    defined is SampleInBall. As in Section 2.3, ğµğœ denotes the set of all polynomials ğ‘ âˆˆ ğ‘… such that\n\n           â€¢  Each coefficient of ğ‘ is either âˆ’1, 0, or 1, and\n\n           â€¢  Exactly ğœ of the coefficients of ğ‘ are nonzero.\n\n    SampleInBall pseudorandomly generates an element of ğµğœ using the XOF of a seed ğœŒ. The procedure\n    is based on the Fisher-Yates shuffle. H is applied to ğœŒ, and the first 8 bytes of the output are used to\n    choose the signs of the nonzero entries of ğ‘.12 Subsequent bytes are used to choose the positions of\n    those nonzero entries.\n\n    Algorithm 29 SampleInBall(ğœŒ)\n    Samples a polynomial ğ‘ âˆˆ ğ‘… with coefficients from {âˆ’1, 0, 1} and Hamming weight ğœ â‰¤ 64.\n    Input: A seed ğœŒ âˆˆ ğ”¹ğœ†/4\n    Output: A polynomial ğ‘ in ğ‘….\n     1:     ğ‘ â† 0\n     2:     ctx â† H.Init()\n     3:     ctx â† H.Absorb(ctx, ğœŒ)\n     4:     (ctx, ğ‘ ) â† H.Squeeze(ctx, 8)\n     5:     â„ â† BytesToBits(ğ‘ )                                â–· â„ is a bit string of length 64\n     6:     for ğ‘– from 256 âˆ’ ğœ to 255 do\n     7:        (ctx, ğ‘—) â† H.Squeeze(ctx, 1)\n     8:        while ğ‘— > ğ‘– do                                â–· rejection sampling in {0, â€¦ , ğ‘–}\n     9:             (ctx, ğ‘—) â† H.Squeeze(ctx, 1)\n    10:        end while                                       â–· ğ‘— is a pseudorandom byte that is â‰¤ ğ‘–\n    11:        ğ‘ğ‘– â† ğ‘ğ‘—\n    12:     endğ‘ğ‘— â† (âˆ’1)â„[ğ‘–+ğœâˆ’256]\n    13:         for\n    14:     return ğ‘\n\n    Algorithms 30â€“34 are the pseudorandom procedures RejNTTPoly, RejBoundedPoly, ExpandA, ExpandS,\n    and ExpandMask.       Each generates elements of ğ‘… or ğ‘‡ğ‘ under different input and output conditions.\n    RejNTTPoly and ExpandA make use of the more efficient XOF G, whereas the other three procedures\n    use the XOF H.\n                  The procedure ExpandMask (Algorithm 34) generates a polynomial vector ğ² in ğ‘…ğ‘˜ that disguises the\n    secret key in the ML-DSA.Sign_internal procedure (Algorithm 7). In addition to the seed ğœŒ, ExpandMask\n    also accepts an integer input ğœ‡ that is incorporated into the pseudorandom procedure that generates ğ¬.\n\n12The parameter ğœ is always less than or equal to 64, and thus 8 bytes are sufficient to choose the signs for all ğœ\n    nonzero entries of ğœ.\n                                                         36"}
{"doc_id": "NIST.FIPS.204", "source_path": "data/raw_pdfs/NIST.FIPS.204.pdf", "page_number": 47, "text": "FIPS 204    MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n\nAlgorithm 30 RejNTTPoly(ğœŒ)\nSamples a polynomial âˆˆ ğ‘‡ğ‘ .\nInput: A seed ğœŒ âˆˆ ğ”¹Â³â´.\nOutput: An element ğ‘ âˆˆ ğ‘‡ğ‘ .\n 1:    ğ‘— â† 0\n 2:    ctx â† G.Init()\n 3:    ctx â† G.Absorb(ctx, ğœŒ)\n 4:    while ğ‘— < 256 do\n 5:     (ctx, ğ‘ ) â† G.Squeeze(ctx, 3)\n 6:     ğ‘[ğ‘—] â† CoeffFromThreeBytes(ğ‘ [0], ğ‘ [1], ğ‘ [2])\n 7:     if ğ‘[ğ‘—] â‰  âŠ¥ then\n 8:          ğ‘— â† ğ‘— + 1\n 9:     end if\n10:    end while\n11:    return ğ‘Ì‚\n\nAlgorithm 31 RejBoundedPoly(ğœŒ)\nSamples an element ğ‘ âˆˆ ğ‘… with coefficients in [âˆ’ğœ‚, ğœ‚] computed via rejection sampling from ğœŒ.\nInput: A seed ğœŒ âˆˆ ğ”¹â¶â¶.\nOutput: A polynomial ğ‘ âˆˆ ğ‘….\n 1:    ğ‘— â† 0\n 2:    ctx â† H.Init()\n 3:    ctx â† H.Absorb(ctx, ğœŒ)\n 4:    while ğ‘— < 256 do\n 5:     ğ‘§ â† H.Squeeze(ctx, 1)\n 6:     ğ‘§â‚€ â† CoeffFromHalfByte(ğ‘§ mod 16)\n 7:     ğ‘§â‚ â† CoeffFromHalfByte(âŒŠğ‘§/16âŒ‹)\n 8:     if ğ‘§â‚€ â‰  âŠ¥ then\n 9:          ğ‘ğ‘— â† ğ‘§â‚€\n10:          ğ‘— â† ğ‘— + 1\n11:     end if\n12:     if   ğ‘§â‚ â‰  âŠ¥ and ğ‘— < 256 then\n13:          ğ‘ğ‘— â† ğ‘§â‚\n14:          ğ‘— â† ğ‘— + 1\n15:     end if\n16:    end while\n17:    return ğ‘\n\n37"}
{"doc_id": "NIST.FIPS.204", "source_path": "data/raw_pdfs/NIST.FIPS.204.pdf", "page_number": 48, "text": "FIPS 204    MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n\nAlgorithm 32 ExpandA(ğœŒ)\nSamples a ğ‘˜ Ã— â„“ matrix ğ€ of elements of ğ‘‡ğ‘ .\nInput: A seed ğœŒ âˆˆ ğ”¹Â³Â².\nOutput: Matrix ğ€ âˆˆ (ğ‘‡ğ‘ )ğ‘˜Ã—â„“.\n 1:    for ğ‘Ÿ from 0 to ğ‘˜ âˆ’ 1 do\n 2:     for ğ‘  from 0 to â„“ âˆ’ 1 do\n 3:      ğœŒâ€² â† ğœŒ||IntegerToBytes(ğ‘ , 1)||IntegerToBytes(ğ‘Ÿ, 1)\n 4:      ğ€[ğ‘Ÿ, ğ‘ ] â† RejNTTPoly(ğœŒâ€² )                         â–· seed ğœŒâ€² depends on ğ‘  and ğ‘Ÿ\n 5:     end for\n 6:    end for\n 7:    return ğ€\n\nAlgorithm 33 ExpandS(ğœŒ)\nSamples vectors ğ¬â‚ âˆˆ ğ‘…â„“ and ğ¬â‚‚ âˆˆ ğ‘…ğ‘˜, each with polynomial coordinates whose coefficients are\nin the interval [âˆ’ğœ‚, ğœ‚].\nInput: A seed ğœŒ âˆˆ ğ”¹â¶â´.\nOutput: Vectors ğ¬â‚, ğ¬â‚‚ of polynomials in ğ‘….\n 1:  for ğ‘Ÿ from 0 to â„“ âˆ’ 1 do\n 2:  endğ¬ğŸ [ğ‘Ÿ] â† RejBoundedPoly(ğœŒ||IntegerToBytes(ğ‘Ÿ, 2))      â–· seed depends on ğ‘Ÿ\n 3:  for\n 4:  for ğ‘Ÿ from 0 to ğ‘˜ âˆ’ 1 do\n 5:  endğ¬ğŸ [ğ‘Ÿ] â† RejBoundedPoly(ğœŒ||IntegerToBytes(ğ‘Ÿ + â„“, 2))  â–· seed depends on ğ‘Ÿ + â„“\n 6:  for\n 7:  return (ğ¬ğŸ , ğ¬ğŸ )\n\nAlgorithm 34 ExpandMask(ğœŒ, ğœ‡)\nSamples a vector ğ² âˆˆ ğ‘…â„“ such that each polynomial ğ²[ğ‘Ÿ] has coefficients between âˆ’ğ›¾â‚ + 1 and\nğ›¾â‚.\nInput: A seed ğœŒ âˆˆ ğ”¹â¶â´ and a nonnegative integer ğœ‡.\nOutput: Vector ğ² âˆˆ ğ‘…â„“.\n 1:    ğ‘ â† 1 + bitlen (ğ›¾â‚ âˆ’ 1)                     â–· ğ›¾â‚ is always a power of 2\n 2:    for ğ‘Ÿ from 0 to â„“ âˆ’ 1 do\n 3:     ğœŒâ€² â† ğœŒ||IntegerToBytes(ğœ‡ + ğ‘Ÿ, 2)\n 4:     ğ‘£ â† H(ğœŒâ€² , 32ğ‘)                           â–· seed depends on ğœ‡ + ğ‘Ÿ\n 5:    endğ²[ğ‘Ÿ] â† BitUnpack(ğ‘£, ğ›¾Â¹ âˆ’ 1, ğ›¾Â¹)\n 6:     for\n 7:    return ğ²\n\n                                              38"}
{"doc_id": "NIST.FIPS.204", "source_path": "data/raw_pdfs/NIST.FIPS.204.pdf", "page_number": 49, "text": "FIPS 204                                                    MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n\n7.4      High-Order and Low-Order Bits and Hints\nThis specification uses the auxiliary functions Power2Round, Decompose, HighBits, LowBits, MakeHint,\nand UseHint and explicitly defines these functions, where ğ‘Ÿ âˆˆ â„¤ğ‘, ğ‘Ÿ1, ğ‘Ÿ0 âˆˆ â„¤, and â„ is a Boolean (or\nequivalently an element of â„¤2). However, this specification also uses these functions where ğ«, ğ³ âˆˆ ğ‘…ğ‘˜,\n                                                                                         ğ‘\nğ«1, ğ«0 âˆˆ ğ‘…ğ‘˜, and ğ¡ âˆˆ ğ‘…ğ‘˜. In this case, the functions are applied coefficientwise to the polynomials in the\nvectors. In particular:  2\n\n      â€¢  For ğ« âˆˆ ğ‘…ğ‘˜, define (ğ«     , ğ«   ) âˆˆ (ğ‘…ğ‘˜)2 = Power2Round(ğ«) so that:\n                   ğ‘             1          0\n                                              ((ğ«1[ğ‘–])ğ‘—, (ğ«0[ğ‘–])ğ‘—) = Power2Round((ğ«[ğ‘–])ğ‘—).\n\n      â€¢  For ğ« âˆˆ ğ‘…ğ‘˜, define (ğ«     , ğ«   ) âˆˆ (ğ‘…ğ‘˜)2 = Decompose(ğ«) so that:\n                   ğ‘             1          0\n                                              ((ğ«1[ğ‘–])ğ‘—, (ğ«0[ğ‘–])ğ‘—) = Decompose((ğ«[ğ‘–])ğ‘—).\n\n      â€¢  For ğ« âˆˆ ğ‘…ğ‘˜, define ğ«   = HighBits (ğ«) so that:\n                   ğ‘             1\n                                                (ğ«1[ğ‘–])ğ‘— = HighBits((ğ«[ğ‘–])ğ‘—).\n\n      â€¢  For ğ« âˆˆ ğ‘…ğ‘˜, define ğ«   = LowBits(ğ«) so that:\n                   ğ‘             0\n                                                (ğ«0[ğ‘–])ğ‘— = LowBits((ğ«[ğ‘–])ğ‘—).\n\n      â€¢  For ğ³, ğ« âˆˆ ğ‘…ğ‘˜, define ğ¡ âˆˆ ğ‘…ğ‘˜ = MakeHint(ğ³, ğ«) so that:\n                         ğ‘                   2\n                                               (ğ¡[ğ‘–])ğ‘— = MakeHint((ğ³[ğ‘–])ğ‘—, (ğ«[ğ‘–])ğ‘—).\n\n      â€¢  For ğ¡ âˆˆ ğ‘…ğ‘˜ and ğ« âˆˆ ğ‘…ğ‘˜, define ğ« âˆˆ ğ‘…ğ‘˜ = UseHint(ğ¡, ğ«) so that:\n                   2                   ğ‘      1\n                                               ğ«1[ğ‘–]ğ‘— = UseHint((ğ¡[ğ‘–])ğ‘—, (ğ«[ğ‘–])ğ‘—).\n\nThese algorithms are used to support the key compression optimization of ML-DSA. They involve dropping\nthe ğ‘‘ low-order bits of each coefficient of the polynomial vector ğ­ from the public key using the function\nPower2Round. However, in order to make this optimization work, additional information called a â€œhintâ€\nneeds to be provided in the signature to allow the verifier to reconstruct enough of the information in\nthe dropped public-key bits to verify the signature.        Hints are created during signing and used during\nverification by the functions MakeHint and UseHint, respectively. In the verification of a valid signature,\nthe hint allows the verifier to recover ğ°1 âˆˆ ğ‘…ğ‘˜, which represents ğ° âˆˆ ğ‘…ğ‘˜ rounded to a nearby multiple\nof          . The signer directly obtains       using the function                 ,       ğ‘\nis    ğ›¼ = 2ğ›¾2                                ğ°1                    HighBits        and the part rounded off (i.e., ğ«0)\n      obtained by LowBits. ğ«0 is used by the signer in the rejection sampling procedure.\nPower2Round decomposes an input ğ‘Ÿ âˆˆ â„¤ğ‘ into integers that represent the high- and low-order bits of\nğ‘Ÿ mod ğ‘ in the straightforward bitwise way, ğ‘Ÿ mod ğ‘ = ğ‘Ÿ1 â‹… 2ğ‘‘ + ğ‘Ÿ0, where ğ‘Ÿ0 = (ğ‘Ÿ mod ğ‘) modÂ±2ğ‘‘ and\nğ‘Ÿ1 = (ğ‘Ÿ mod ğ‘ âˆ’ ğ‘Ÿ0)/2ğ‘‘.\nHowever, for the purpose of computations related to hints, this method of decomposing ğ‘Ÿ has the\nundesirable property that when ğ‘Ÿ is close to ğ‘ âˆ’ 1 or 0, a small rounding error in ğ‘Ÿ can cause ğ‘Ÿ1 to change\nby more than 1, even accounting for wrap-around. In contrast to other unequal pairs of values of ğ‘Ÿ1 â‹… 2ğ‘‘\nand ğ‘Ÿâ€² â‹… 2ğ‘‘, the distance (modğ‘) between âŒŠğ‘/2ğ‘‘âŒ‹ â‹… 2ğ‘‘ and 0 may be very small.\n        1\n                                                          39"}
{"doc_id": "NIST.FIPS.204", "source_path": "data/raw_pdfs/NIST.FIPS.204.pdf", "page_number": 50, "text": "FIPS 204    MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n\nTo avoid this problem, this specification defines Decompose, which is similar to Power2Round except:\n\n    â€¢  ğ‘Ÿ is generally decomposed as ğ‘Ÿ mod ğ‘ = ğ‘Ÿ1 â‹… ğ›¼ + ğ‘Ÿ0, where ğ›¼ = 2ğ›¾2 is a divisor of ğ‘ âˆ’ 1.\n\n    â€¢  If the straightforward rounding procedure would return (ğ‘Ÿ1 = (ğ‘ âˆ’ 1)/ğ›¼, ğ‘Ÿ0 âˆˆ [âˆ’(ğ›¼/2) + 1, ğ›¼/2]),\n       Decompose instead returns (ğ‘Ÿ1 = 0, ğ‘Ÿ0 âˆ’ 1).\n\nThe functions HighBits and LowBits â€” which only return ğ‘Ÿ1 and ğ‘Ÿ0, respectively â€” and MakeHint and\nUseHint use Decompose. For additional discussion of the mathematical properties of these functions\nthat are relevant to the correctness and security of ML-DSA, see Section 2.4 in [6].\n\nAlgorithm 35 Power2Round(ğ‘Ÿ)\nDecomposes ğ‘Ÿ into (ğ‘Ÿâ‚, ğ‘Ÿâ‚€) such that ğ‘Ÿ â‰¡ ğ‘Ÿâ‚2ğ‘‘ + ğ‘Ÿâ‚€ mod ğ‘.\nInput: ğ‘Ÿ âˆˆ â„¤ğ‘ .\nOutput: Integers (ğ‘Ÿâ‚, ğ‘Ÿâ‚€).\n 1:  ğ‘Ÿâº â† ğ‘Ÿ mod ğ‘\n 2:  ğ‘Ÿâ‚€ â† ğ‘Ÿâº modÂ±2ğ‘‘\n 3:  return ((ğ‘Ÿâº âˆ’ ğ‘Ÿâ‚€)/2ğ‘‘, ğ‘Ÿâ‚€)\n\nAlgorithm 36 Decompose(ğ‘Ÿ)\nDecomposes ğ‘Ÿ into (ğ‘Ÿâ‚, ğ‘Ÿâ‚€) such that ğ‘Ÿ â‰¡ ğ‘Ÿâ‚(2ğ›¾â‚‚) + ğ‘Ÿâ‚€ mod ğ‘.\nInput: ğ‘Ÿ âˆˆ â„¤ğ‘ .\nOutput: Integers (ğ‘Ÿâ‚, ğ‘Ÿâ‚€).\n 1:    ğ‘Ÿâº â† ğ‘Ÿ mod ğ‘\n 2:    ğ‘Ÿâ‚€ â† ğ‘Ÿâº modÂ±(2ğ›¾â‚‚)\n 3:    if ğ‘Ÿâº âˆ’ ğ‘Ÿâ‚€ = ğ‘ âˆ’ 1 then\n 4:     ğ‘Ÿâ‚ â† 0\n 5:     ğ‘Ÿâ‚€ â† ğ‘Ÿâ‚€ âˆ’ 1\n 6:    else ğ‘Ÿâ‚ â† (ğ‘Ÿâº âˆ’ ğ‘Ÿâ‚€)/(2ğ›¾â‚‚)\n 7:    end if\n 8:    return (ğ‘Ÿâ‚, ğ‘Ÿâ‚€)\n\nAlgorithm 37 HighBits(ğ‘Ÿ)\nReturns ğ‘Ÿâ‚ from the output of Decompose (ğ‘Ÿ).\nInput: ğ‘Ÿ âˆˆ â„¤ğ‘ .\nOutput: Integer ğ‘Ÿâ‚.\n 1:  (ğ‘Ÿâ‚, ğ‘Ÿâ‚€) â† Decompose(ğ‘Ÿ)\n 2:  return ğ‘Ÿâ‚\n\n40"}
{"doc_id": "NIST.FIPS.204", "source_path": "data/raw_pdfs/NIST.FIPS.204.pdf", "page_number": 51, "text": "FIPS 204    MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n\nAlgorithm 38 LowBits(ğ‘Ÿ)\nReturns ğ‘Ÿâ‚€ from the output of Decompose (ğ‘Ÿ).\nInput: ğ‘Ÿ âˆˆ â„¤ğ‘ .\nOutput: Integer ğ‘Ÿâ‚€.\n 1:  (ğ‘Ÿâ‚, ğ‘Ÿâ‚€) â† Decompose(ğ‘Ÿ)\n 2:  return ğ‘Ÿâ‚€\n\nAlgorithm 39 MakeHint(ğ‘§, ğ‘Ÿ)\nComputes hint bit indicating whether adding ğ‘§ to ğ‘Ÿ alters the high bits of ğ‘Ÿ.\nInput: ğ‘§, ğ‘Ÿ âˆˆ â„¤ğ‘ .\nOutput: Boolean.\n 1:  ğ‘Ÿâ‚ â† HighBits(ğ‘Ÿ)\n 2:  ğ‘£â‚ â† HighBits(ğ‘Ÿ + ğ‘§)\n 3:  return [[ğ‘Ÿâ‚ â‰  ğ‘£â‚]]\n\nAlgorithm 40 UseHint(â„, ğ‘Ÿ)\nReturns the high bits of ğ‘Ÿ adjusted according to hint â„.\nInput: Boolean â„, ğ‘Ÿ âˆˆ â„¤ğ‘ .\nOutput: ğ‘Ÿâ‚ âˆˆ â„¤ with 0 â‰¤ ğ‘Ÿâ‚ â‰¤ ğ‘âˆ’1.\n                               2ğ›¾2\n 1:  ğ‘š â† (ğ‘ âˆ’ 1)/(2ğ›¾â‚‚)\n 2:  (ğ‘Ÿâ‚, ğ‘Ÿâ‚€) â† Decompose(ğ‘Ÿ)\n 3:  if â„ = 1 and ğ‘Ÿâ‚€ > 0 return (ğ‘Ÿâ‚ + 1) mod ğ‘š\n 4:  if â„ = 1 and ğ‘Ÿâ‚€ â‰¤ 0 return (ğ‘Ÿâ‚ âˆ’ 1) mod ğ‘š\n 5:  return ğ‘Ÿâ‚\n\n41"}
{"doc_id": "NIST.FIPS.204", "source_path": "data/raw_pdfs/NIST.FIPS.204.pdf", "page_number": 52, "text": "FIPS 204                                      MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n\n7.5  NTT and NTTâˆ’1\n\nThe following algorithms implement the NTT and its inverse (NTTâˆ’1), which is important for efficiency.\nThere are other optimizations that are not included in this standard. In particular, mod ğ‘ and modÂ±ğ‘ are\nexpensive operations whose use can be minimized by using Montgomery Multiplication (see Appendix A).\nAn element of ğ‘…ğ‘ is a polynomial in â„¤ğ‘[ğ‘‹]/(ğ‘‹256 + 1), and an element of ğ‘‡ğ‘ is a tuple in Î 255 â„¤ğ‘. The\n                                                                                                ğ‘—=0\nNTT algorithm takes a polynomial ğ‘¤ âˆˆ ğ‘…ğ‘ as input and returns ğ‘¤ âˆˆ ğ‘‡ğ‘. NTTâˆ’1 takes ğ‘¤ âˆˆ ğ‘‡ğ‘ as input\nand returns ğ‘¤ such that ğ‘¤Ì‚ = NTT(ğ‘¤).\nThis document always distinguishes between elements of ğ‘…ğ‘ and elements of ğ‘‡ğ‘. However, the natural\ndata structure for both of these sets is as an integer array of size 256. This would allow the NTT and\nNTTâˆ’1 algorithms to perform computation in place on an integer array passed by reference.           That\noptimization is not included in this document.\nIn Section 2.5, ğœ = 1753 âˆˆ â„¤ğ‘, which is a 512th root of unity modulo ğ‘. On input ğ‘¤ âˆˆ ğ‘…ğ‘, the algorithm\noutputs\n                  NTT(ğ‘¤) = (ğ‘¤(ğœ0), ğ‘¤(ğœ1), â€¦ , ğ‘¤(ğœ255)) âˆˆ ğ‘‡ğ‘,                               (7.1)\nwhere ğœğ‘– = ğ‘¤(ğœ2BitRevâ‚ˆ(ğ‘–)+1) mod ğ‘.\nThe values ğœBitRevâ‚ˆ(ğ‘˜) mod ğ‘ for ğ‘˜ = 1, â€¦ , 255 used in line 10 of Algorithms 41 and 42 are pre-computed\ninto an array zetas[1..255]. The table of zetas is given in Appendix B. If Montgomery Multiplication is used\n(see Appendix A), then the zetas array would typically be stored in Montgomery form.\nNTT and NTTâˆ’1 use BitRev8, which reverses the order of bits in an 8-bit integer.\n\n42"}
{"doc_id": "NIST.FIPS.204", "source_path": "data/raw_pdfs/NIST.FIPS.204.pdf", "page_number": 53, "text": "FIPS 204    MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n\nAlgorithm 41 NTT(ğ‘¤)\nComputes the NTT.\nInput: Polynomial ğ‘¤(ğ‘‹) = âˆ‘Â²âµâµ ğ‘¤ğ‘—ğ‘‹ğ‘— âˆˆ ğ‘…ğ‘ .\n                                 ğ‘—=0\nOutput: ğ‘¤ = (ğ‘¤[0], â€¦ , ğ‘¤[255]) âˆˆ ğ‘‡ğ‘ .\n 1:    for ğ‘— from 0 to 255 do\n 2:    endğ‘¤[ğ‘—] â† ğ‘¤ğ‘—\n 3:     for\n 4:    ğ‘š â† 0\n 5:    ğ‘™ğ‘’ğ‘› â† 128\n 6:    while ğ‘™ğ‘’ğ‘› â‰¥ 1 do\n 7:     ğ‘ ğ‘¡ğ‘ğ‘Ÿğ‘¡ â† 0\n 8:     while ğ‘ ğ‘¡ğ‘ğ‘Ÿğ‘¡ < 256 do\n 9:          ğ‘š â† ğ‘š + 1\n10:          ğ‘§ â† zetas[ğ‘š]                                      â–· ğ‘§ â† ğœá´®â±áµ—á´¿áµ‰áµ›â‚ˆ(ğ‘š) mod ğ‘\n11:          for ğ‘— from ğ‘ ğ‘¡ğ‘ğ‘Ÿğ‘¡ to ğ‘ ğ‘¡ğ‘ğ‘Ÿğ‘¡ + ğ‘™ğ‘’ğ‘› âˆ’ 1 do\n12:                ğ‘¡ â† (ğ‘§ â‹… ğ‘¤[ğ‘— + ğ‘™ğ‘’ğ‘›]) mod ğ‘\n13:                ğ‘¤[ğ‘— + ğ‘™ğ‘’ğ‘›] â† (ğ‘¤[ğ‘—] âˆ’ ğ‘¡) mod ğ‘\n14:                ğ‘¤[ğ‘—] â† (ğ‘¤[ğ‘—] + ğ‘¡) mod ğ‘\n15:          end for\n16:          ğ‘ ğ‘¡ğ‘ğ‘Ÿğ‘¡ â† ğ‘ ğ‘¡ğ‘ğ‘Ÿğ‘¡ + 2 â‹… ğ‘™ğ‘’ğ‘›\n17:     end while\n18:     ğ‘™ğ‘’ğ‘› â† âŒŠğ‘™ğ‘’ğ‘›/2âŒ‹\n19:    end while\n20:    return ğ‘¤Ì‚\n\n43"}
{"doc_id": "NIST.FIPS.204", "source_path": "data/raw_pdfs/NIST.FIPS.204.pdf", "page_number": 54, "text": "FIPS 204    MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n\nAlgorithm 42 NTTâˆ’1 (ğ‘¤)Ì‚\nComputes the inverse of the NTT.\nInput: ğ‘¤ = (ğ‘¤[0], â€¦ , ğ‘¤[255]) âˆˆ ğ‘‡ğ‘ .\nOutput: Polynomial ğ‘¤(ğ‘‹) = âˆ‘Â²âµâµ ğ‘¤ğ‘—ğ‘‹ğ‘— âˆˆ ğ‘…ğ‘ .\n                                     ğ‘—=0\n 1:    for ğ‘— from 0 to 255 do\n 2:    endğ‘¤ğ‘— â† ğ‘¤[ğ‘—]\n 3:     for\n 4:    ğ‘š â† 256\n 5:    ğ‘™ğ‘’ğ‘› â† 1\n 6:    while ğ‘™ğ‘’ğ‘› < 256 do\n 7:     ğ‘ ğ‘¡ğ‘ğ‘Ÿğ‘¡ â† 0\n 8:     while ğ‘ ğ‘¡ğ‘ğ‘Ÿğ‘¡ < 256 do\n 9:          ğ‘š â† ğ‘š âˆ’ 1\n10:          ğ‘§ â† âˆ’ğ‘§ğ‘’ğ‘¡ğ‘ğ‘ [ğ‘š]                                â–· ğ‘§ â† âˆ’ğœá´®â±áµ—á´¿áµ‰áµ›â‚ˆ(ğ‘š) mod ğ‘\n11:          for ğ‘— from ğ‘ ğ‘¡ğ‘ğ‘Ÿğ‘¡ to ğ‘ ğ‘¡ğ‘ğ‘Ÿğ‘¡ + ğ‘™ğ‘’ğ‘› âˆ’ 1 do\n12:              ğ‘¡ â† ğ‘¤ğ‘—\n13:              ğ‘¤ğ‘— â† (ğ‘¡ + ğ‘¤ğ‘—+ğ‘™ğ‘’ğ‘›) mod ğ‘\n14:              ğ‘¤ğ‘—+ğ‘™ğ‘’ğ‘› â† (ğ‘¡ âˆ’ ğ‘¤ğ‘—+ğ‘™ğ‘’ğ‘›) mod ğ‘\n15:          endğ‘¤ğ‘—+ğ‘™ğ‘’ğ‘› â† (ğ‘§ â‹… ğ‘¤ğ‘—+ğ‘™ğ‘’ğ‘›) mod ğ‘\n16:              for\n17:          ğ‘ ğ‘¡ğ‘ğ‘Ÿğ‘¡ â† ğ‘ ğ‘¡ğ‘ğ‘Ÿğ‘¡ + 2 â‹… ğ‘™ğ‘’ğ‘›\n18:     end while\n19:     ğ‘™ğ‘’ğ‘› â† 2 â‹… ğ‘™ğ‘’ğ‘›\n20:    end while\n21:    ğ‘“ â† 8347681                                              â–· ğ‘“ = 256âˆ’1 mod ğ‘\n22:    for ğ‘— from 0 to 255 do\n23:    endğ‘¤ğ‘— â† (ğ‘“ â‹… ğ‘¤ğ‘—) mod ğ‘\n24:     for\n25:    return ğ‘¤\n\nAlgorithm 43 BitRevâ‚ˆ (ğ‘š)\nTransforms a byte by reversing the order of bits in its 8-bit binary expansion.\nInput: A byte ğ‘š âˆˆ [0, 255].\nOutput: A byte ğ‘Ÿ âˆˆ [0, 255].\n 1:    ğ‘ â† IntegerToBits(ğ‘š, 8)\n 2:    ğ‘rev âˆˆ {0, 1}â¸ â† (0, â€¦ , 0)\n 3:    for ğ‘– from 0 to 7 do\n 4:    endğ‘Ê³áµ‰áµ› [ğ‘–] â† ğ‘ [7 âˆ’ ğ‘–]\n 5:     for\n 6:    ğ‘Ÿ â† BitsToInteger(ğ‘rev, 8)\n 7:    return r\n\n                                                        44"}
{"doc_id": "NIST.FIPS.204", "source_path": "data/raw_pdfs/NIST.FIPS.204.pdf", "page_number": 55, "text": "FIPS 204                           MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n\n7.6  Arithmetic Under NTT\nThe NTT converts elements of the ring ğ‘…ğ‘ (where addition and multiplication are denoted by + and â‹…,\nrespectively) into elements of the ring ğ‘‡ğ‘ (where addition and multiplication are denoted by + and âˆ˜,\nrespectively). This section gives explicit algorithms for linear algebra over the ring ğ‘‡ğ‘.\nThe ring ğ‘‡ğ‘ is defined to be the direct product ring Î 255â„¤ğ‘. Thus, an element ğ‘ âˆˆ ğ‘‡ğ‘ is an array of length\n256, and its elements are denoted by ğ‘[0], ğ‘[1], â€¦ , ğ‘–=0\n                                   ğ‘[255] âˆˆ â„¤ğ‘.\n\nAlgorithm 44 AddNTT(ğ‘,Ì‚ ğ‘)\nComputes the sum ğ‘ + ğ‘ of two elements ğ‘, ğ‘ âˆˆ ğ‘‡ğ‘ .\nInput: ğ‘,Ì‚ ğ‘ âˆˆ ğ‘‡ğ‘ .\nOutput: ğ‘ âˆˆ ğ‘‡ğ‘ .\n 1:  for ğ‘– from 0 to 255 do\n 2:         ğ‘[ğ‘–] â† ğ‘[ğ‘–] + ğ‘[ğ‘–]\n 3:  end for\n 4:  return ğ‘\n\nAlgorithm 45 MultiplyNTT(ğ‘,Ì‚ ğ‘)\nComputes the product ğ‘ âˆ˜Ì‚ ğ‘ of two elements ğ‘,Ì‚ ğ‘ âˆˆ ğ‘‡ğ‘ .\nInput: ğ‘,Ì‚ ğ‘ âˆˆ ğ‘‡ğ‘ .\nOutput: ğ‘ âˆˆ ğ‘‡ğ‘ .\n 1:  for ğ‘– from 0 to 255 do\n 2:         ğ‘[ğ‘–] â† ğ‘[ğ‘–] â‹… ğ‘[ğ‘–]\n 3:  end for\n 4:  return ğ‘\n\nAlgorithm 46 AddVectorNTT(ğ¯,Ì‚ ğ°)Ì‚\nComputes the sum ğ¯ + ğ° of two vectors ğ¯, ğ° over ğ‘‡ğ‘ .\nInput: â„“ âˆˆ â„•, ğ¯ âˆˆ ğ‘‡ â„“, ğ° âˆˆ ğ‘‡ â„“.\n                       ğ‘           ğ‘\nOutput: ğ® âˆˆ ğ‘‡ â„“.\n               ğ‘\n 1:  for ğ‘– from 0 to â„“ âˆ’ 1 do\n 2:         ğ®[ğ‘–] â† AddNTT(ğ¯[ğ‘–], ğ°[ğ‘–])\n 3:  end for\n 4:  return ğ®Ì‚\n\n45"}
{"doc_id": "NIST.FIPS.204", "source_path": "data/raw_pdfs/NIST.FIPS.204.pdf", "page_number": 56, "text": "FIPS 204    MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n\nAlgorithm 47 ScalarVectorNTT(ğ‘,Ì‚ ğ¯)Ì‚\nComputes the product ğ‘ âˆ˜Ì‚ ğ¯Ì‚ of a scalar ğ‘ and a vector ğ¯Ì‚ over ğ‘‡ğ‘ .\nInput: ğ‘ âˆˆ ğ‘‡ğ‘ , â„“ âˆˆ â„•, ğ¯ âˆˆ ğ‘‡ â„“.\n                  ğ‘\nOutput: ğ° âˆˆ ğ‘‡ â„“.\n               ğ‘\n 1:  for ğ‘– from 0 to â„“ âˆ’ 1 do\n 2:  ğ°[ğ‘–] â† MultiplyNTT(ğ‘, ğ¯[ğ‘–])\n 3:  end for\n 4:  return ğ°Ì‚\n\nAlgorithm 48 MatrixVectorNTT(ğŒ, ğ¯)Ì‚\nComputes the product ğŒ âˆ˜ ğ¯Ì‚ of a matrix ğŒ and a vector ğ¯Ì‚ over ğ‘‡ğ‘ .\nInput: ğ‘˜, â„“ âˆˆ â„•, ğŒ âˆˆ ğ‘‡ ğ‘˜Ã—â„“, ğ¯ âˆˆ ğ‘‡ â„“.\n                   ğ‘            ğ‘\nOutput: ğ° âˆˆ ğ‘‡ ğ‘˜.\n                 ğ‘\n 1:    ğ° â† 0ğ‘˜\n 2:    for ğ‘– from 0 to ğ‘˜ âˆ’ 1 do\n 3:     for ğ‘— from 0 to â„“ âˆ’ 1 do\n 4:           ğ°[ğ‘–] â† AddNTT(ğ°[ğ‘–], MultiplyNTT(ğŒ[ğ‘–, ğ‘—], ğ¯[ğ‘—]))\n 5:     end for\n 6:    end for\n 7:    return ğ°Ì‚\n\n46"}
{"doc_id": "NIST.FIPS.204", "source_path": "data/raw_pdfs/NIST.FIPS.204.pdf", "page_number": 57, "text": "FIPS 204                                      MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n\nReferences\n\n [1]  National Institute of Standards and Technology (2023) Digital signature standard (DSS), (U.S. Depart-\n      ment of Commerce, Washington, DC), Federal Information Processing Standards Publication (FIPS)\n      186-5. https://doi.org/10.6028/NIST.FIPS.186-5.\n\n [2]  Barker E (2020) Guideline for using cryptographic standards in the federal government: Cryptographic\n      mechanisms, (National Institute of Standards and Technology, Gaithersburg, MD), NIST Special\n      Publication (SP) 800-175B, Rev. 1 [or as amended]. https://doi.org/10.6028/NIST.SP.800-175Br1.\n\n [3]  Barker E (2006) Recommendation for obtaining assurances for digital signature applications, National\n      Institute of Standards and Technology, Gaithersburg, MD. NIST Special Publication (SP) 800-89 [or as\n      amended]. https://doi.org/10.6028/NIST.SP.800-89.\n\n [4]  Langlois A, StehlÃ© D (2015) Worst-case to average-case reductions for module lattices. Designs, Codes\n      and Cryptography 75(3):565â€“599. https://doi.org/10.1007/s10623-014-9938-4.\n\n [5]  Bai S, Ducas L, Kiltz E, Lepoint T, Lyubashevsky V, Schwabe P, Seiler G, StehlÃ© D (2020) CRYSTALS-\n      Dilithium: Algorithm specifications and supporting documentation, Submission to the NISTâ€™s post-\n      quantum cryptography standardization process. Available at https://csrc.nist.gov/Projects/post-qua\n      ntum-cryptography/post-quantum-cryptography-standardization/round-3-submissions.\n\n [6]  Bai S, Ducas L, Kiltz E, Lepoint T, Lyubashevsky V, Schwabe P, Seiler G, StehlÃ© D (2021) CRYSTALS-\n      Dilithium: Algorithm specifications and supporting documentation (Version 3.1). Available at https:\n      //pq-crystals.org/dilithium/data/dilithium-specification-round3-20210208.pdf.\n\n [7]  National Institute of Standards and Technology (2015) SHA-3 standard: Permutation-based hash and\n      extendable-output functions, (U.S. Department of Commerce, Washington, DC), Federal Information\n      Processing Standards Publication (FIPS) 202. https://doi.org/10.6028/NIST.FIPS.202.\n\n [8]  National Institute of Standards and Technology (2015) Secure hash standard (SHS), (U.S. Department\n      of Commerce, Washington, DC), Federal Information Processing Standards Publication (FIPS) 180-4.\n      https://doi.org/10.6028/NIST.FIPS.180-4.\n\n [9]  Barker E (2020) Recommendation for key management: Part 1 - general, (National Institute of\n      Standards and Technology, Gaithersburg, MD), NIST Special Publication (SP) 800-57 Part 1, Rev. 5 [or\n      as amended]. https://doi.org/10.6028/NIST.SP.800-57pt1r5.\n\n[10]  Lyubashevsky V (2009) Fiat-Shamir with aborts: Applications to lattice and factoring-based signa-\n      tures. Advances in Cryptology â€“ ASIACRYPT 2009, ed Matsui M (Springer Berlin Heidelberg, Berlin,\n      Heidelberg), pp 598â€“616. https://doi.org/10.1007/978-3-642-10366-7_35.\n\n[11]  Lyubashevsky V (2012) Lattice signatures without trapdoors. EUROCRYPT (Springer), Lecture Notes\n      in Computer Science, Vol. 7237, pp 738â€“755. https://doi.org/10.1007/978-3-642-29011-4_43.\n\n[12]  GÃ¼neysu T, Lyubashevsky V, PÃ¶ppelmann T (2012) Practical lattice-based cryptography: A signature\n      scheme for embedded systems. CHES (Springer), Vol. 7428, pp 530â€“547. https://doi.org/10.1007/97\n      8-3-642-33027-8_31.\n\n[13]  Bai S, Galbraith SD (2014) An improved compression technique for signatures based on learning with\n      errors. Topics in Cryptology â€“ CT-RSA 2014, ed Benaloh J (Springer International Publishing, Cham),\n      pp 28â€“47. https://doi.org/10.1007/978-3-319-04852-9_2.\n\n                                              47"}
{"doc_id": "NIST.FIPS.204", "source_path": "data/raw_pdfs/NIST.FIPS.204.pdf", "page_number": 58, "text": "FIPS 204    MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n\n[14]  Cremers C, DÃ¼zlÃ¼ S, Fiedler R, Janson C, Fischlin M (2021) BUFFing signature schemes beyond\n      unforgeability and the case of post-quantum signatures. 2021 IEEE Symposium on Security and\n      Privacy (SP) (IEEE Computer Society, Los Alamitos, CA, USA), pp 1696â€“1714. https://doi.org/10.110\n      9/SP40001.2021.00093.\n\n[15]  Regev O (2005) On lattices, learning with errors, random linear codes, and cryptography. Proceedings\n      of the Thirty-Seventh Annual ACM Symposium on Theory of Computing STOC â€™05 (Association for\n      Computing Machinery, New York, NY, USA), p 84â€“93. https://doi.org/10.1145/1060590.1060603.\n\n[16]  Kiltz E, Lyubashevsky V, Schaffner C (2018) A concrete treatment of Fiat-Shamir signatures in the\n      quantum random-oracle model. Advances in Cryptology â€“ EUROCRYPT 2018, eds Nielsen JB, Rijmen\n     V (Springer International Publishing, Cham), pp 552â€“586. https://doi.org/10.1007/978-3-319-78372\n     -7_18.\n\n[17]  Barker E, Barker W (2019) Recommendation for key management: Part 2 - best practices for key\n      management organizations, National Institute of Standards and Technology, Gaithersburg, MD. NIST\n      Special Publication (SP) 800-57 Part 2, Rev. 1. https://doi.org/10.6028/NIST.SP.800-57pt2r1.\n\n[18]  Barker E, Dang Q (2019) Recommendation for key management: Part 3 - application-specific key\n      management guidance, National Institute of Standards and Technology, Gaithersburg, MD. NIST\n      Special Publication (SP) 800-57 Part 3, Rev. 1. http://doi.org/10.6028/NIST.SP.800-57pt3r1.\n\n[19]  Barker E, Kelsey J (2015) Recommendation for random number generation using deterministic\n      random bit generators, (National Institute of Standards and Technology, Gaithersburg, MD), NIST\n      Special Publication (SP) 800-90A, Rev. 1. https://doi.org/10.6028/NIST.SP.800-90Ar1.\n\n[20]  SÃ¶nmez Turan M, Barker E, Kelsey J, McKay K, Baish M, Boyle M (2018) Recommendation for the\n      entropy sources used for random bit generation, (National Institute of Standards and Technology,\n      Gaithersburg, MD), NIST Special Publication (SP) 800-90B. https://doi.org/10.6028/NIST.SP.800-90B.\n\n[21]  Barker E, Kelsey J, McKay K, Roginsky A, Turan MS (2024) Recommendation for random bit generator\n     (RBG) constructions, (National Institute of Standards and Technology, Gaithersburg, MD), NIST Special\n      Publication (SP) 800-90C 4pd. https://doi.org/10.6028/NIST.SP.800-90C.4pd.\n\n[22]  Bruinderink LG, Pessl P (2018) Differential fault attacks on deterministic lattice signatures. IACR\n     Transactions on Cryptographic Hardware and Embedded Systems (3):21â€“43. https://doi.org/10.131\n      54/tches.v2018.i3.21-43.\n\n[23]  Poddebniak D, Somorovsky J, Schinzel S, Lochter M, RÃ¶sler P (2018) Attacking deterministic signature\n      schemes using fault attacks. 2018 IEEE European Symposium on Security and Privacy (EuroS&P)\n     (IEEE), pp 338â€“352. https://doi.org/10.1109/EuroSP.2018.00031.\n\n[24]  Samwel N, Batina L, Bertoni G, Daemen J, Susella R (2018) Breaking ed25519 in wolfssl. Topics in\n      Cryptologyâ€“CT-RSA 2018: The Cryptographersâ€™ Track at the RSA Conference 2018, San Francisco, CA,\n      USA, April 16-20, 2018, Proceedings (Springer), pp 1â€“20. https://doi.org/10.1007/978-3-319-76953\n      -0_1.\n\n[25]  Kelsey J, Chang S, Perlner R (2016) SHA-3 Derived Functions: cSHAKE, KMAC, TupleHash and Parallel-\n      Hash, (National Institute of Standards and Technology, Gaithersburg, MD), NIST Special Publication\n     (SP) 800-185 [or as amended]. https://doi.org/10.6028/NIST.SP.800-185.\n\n[26]  National Institute of Standards and Technology (2016) Submission requirements and evaluation\n      criteria for the post-quantum cryptography standardization process. Available at https://csrc.nist.go\n                              48"}
{"doc_id": "NIST.FIPS.204", "source_path": "data/raw_pdfs/NIST.FIPS.204.pdf", "page_number": 59, "text": "FIPS 204    MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n\n     v/CSRC/media/Projects/Post-Quantum-Cryptography/documents/call-for-proposals-final-dec-201\n      6.pdf.\n\n[27]  Alagic G, Apon D, Cooper D, Dang Q, Dang T, Kelsey J, Lichtinger J, Liu YK, Miller C, Moody D, Peralta R,\n      Perlner R, Robinson A, Smith-Tone D (2022) Status report on the third round of the NIST post-quantum\n      cryptography standardization process (National Institute of Standards and Technology, Gaithersburg,\n      MD), NIST Interagency or Internal Report (IR) 8413. https://doi.org/10.6028/NIST.IR.8413-upd1.\n\n[28]  Avanzi R, Bos J, Ducas L, Kiltz E, Lepoint T, Lyubashevsky V, Schanck JM, Schwabe P, Seiler G,\n      StehlÃ© D (2020) CRYSTALS-Kyber algorithm specifications and supporting documentation, 3rd\n      Round submission to the NISTâ€™s post-quantum cryptography standardization process. Available\n      at https://csrc.nist.gov/Projects/post-quantum-cryptography/post-quantum-cryptography-standar\n      dization/round-3-submissions.\n\n[29]  Housley R (2009) Cryptographic Message Syntax (CMS), Internet Engineering Task Force (IETF) request\n      for comments (RFC) 5652, https://doi.org/10.17487/RFC5652.\n\n[30]  Schnorr C (1990) Efficient identification and signatures for smart cards. Advances in Cryptology â€”\n      CRYPTOâ€™ 89 Proceedings, ed Brassard G (Springer New York, New York, NY), pp 239â€“252. https:\n     //doi.org/10.1007/0-387-34805-0_22.\n\n[31]  Josefsson S, Liusvaara I (2017) Edwards-Curve Digital Signature Algorithm (EdDSA), RFC 8032. https:\n     //doi.org/10.17487/RFC8032.\n\n[32]  Lyubashevsky V (2021) Round 3 Official Comment: CRYSTALS-DILITHIUM. Available at https://groups\n      .google.com/a/list.nist.gov/g/pqc-forum/c/BjfjRMIdnhM/m/W7kkVOFDBAAJ.\n\n[33]  Hamburg M (2024) Dilithium hint unpacking. Available at https://groups.google.com/a/list.nist.gov/\n      g/pqc-forum/c/TQo-qFbBO1A/m/YcYKjMblAAAJ.\n\n[34]  Mattsson (on behalf of SÃ¶nke Jendral) JP (2024) Dilithium hint unpacking. Available at https://grou\n      ps.google.com/a/list.nist.gov/g/pqc-forum/c/TQo-qFbBO1A/m/sLjseYlSAwAJ.\n\n[35]  Lee S (2024) Updates for FIPS 203. Available at https://groups.google.com/a/list.nist.gov/g/pqc-for\n      um/c/Rb0nFvfFTEQ/m/lw-k7tVdBQAJ.\n\n49"}
{"doc_id": "NIST.FIPS.204", "source_path": "data/raw_pdfs/NIST.FIPS.204.pdf", "page_number": 60, "text": "FIPS 204                                                MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n\nAppendix A â€” Montgomery Multiplication\n\n  This document uses modular multiplications of the form ğ‘ â‹… ğ‘ modulo ğ‘. This is an expensive operation\nthat is often sped up in practice through the use of Montgomery Multiplication.\nIf ğ‘ is an integer modulo ğ‘, then its Montgomery form with multiplier 232 is ğ‘Ÿ â‰¡ ğ‘ â‹… 232 mod ğ‘. 13\nSuppose that two integers ğ‘¢ and ğ‘£ modulo ğ‘ are in Montgomery form.         Their product modulo ğ‘ is\nğ‘ = ğ‘¢ â‹… ğ‘£ â‹… 2âˆ’32, which is also in Montgomery form. If the integer product of ğ‘¢ and ğ‘£ does not overflow a\n64-bit signed integer, then one can compute ğ‘ by first performing the integer multiplication ğ‘¢ â‹… ğ‘£ and then\nâ€œreducingâ€ the product by multiplying by 2âˆ’32 modulo ğ‘. This last operation can be done efficiently as\nfollows.\n The MontgomeryReduce function takes an integer ğ‘ with absolute value at most 231ğ‘ as input. It returns\nan integer ğ‘Ÿ such that ğ‘Ÿ = ğ‘ â‹… 2âˆ’32 mod ğ‘. The output is in Montgomery form with multiplier 232 mod ğ‘.\nAn implementation would typically input a 64-bit input and return a 32-bit output. The â€œmodulo 232â€\noperation simply extracts the 32 least significant bits of a 64-bit value. The value (ğ‘ âˆ’ ğ‘¡ â‹… ğ‘) on line 3 is an\ninteger divisible by 232. Therefore, the division consists of simply taking the most significant 32 bits of a\n64-bit value. Extracting the four low- or high-order bytes is often done using typecasting.\n\nAlgorithm 49 MontgomeryReduce(ğ‘)\nComputes ğ‘ â‹… 2âˆ’32 mod ğ‘.\nInput: Integer ğ‘ with âˆ’2Â³Â¹ğ‘ â‰¤ ğ‘ â‰¤ 2Â³Â¹ğ‘.\nOutput: ğ‘Ÿ â‰¡ ğ‘ â‹… 2âˆ’32 mod ğ‘.\n 1:  QINV â† 58728449                       â–· the inverse of ğ‘ modulo 2Â³Â²\n 2:  ğ‘¡ â† ((ğ‘ mod 2Â³Â²) â‹… QINV) mod 2Â³Â²\n 3:  ğ‘Ÿ â† (ğ‘ âˆ’ ğ‘¡ â‹… ğ‘)/2Â³Â²\n 4:  return ğ‘Ÿ\n\n  With this algorithm, the modular product of ğ‘ and ğ‘ is ğ‘ = MontgomeryReduce(ğ‘ â‹… ğ‘), where ğ‘, ğ‘, and ğ‘\nare in Montgomery form. The return value of the algorithm is not necessarily less than ğ‘ in absolute value,\nbut it is less than 2ğ‘ in absolute value. This is not a concern in practice since the objective of Montgomery\nMultiplication is to efficiently work with modular values that fit in a 32-bit register. If necessary, the result\ncan be normalized to an integer in (âˆ’ğ‘, ğ‘) using a comparison and an integer addition.\nConverting an integer modulo ğ‘ to Montgomery form by multiplying by 232 modulo ğ‘ is an expensive\noperation. When a sequence of modular operations is to be performed, the operands are converted once\nto Montgomery form. The operations are then performed, and the factor 232 is extracted from the final\nresult.\n\n13This section does not distinguish between different versions of the â€œ mod â€ operator. There are three such versions\nof â€œğ‘¥ = ğ‘ modulo ğ‘â€: i) ğ‘¥ âˆˆ [0, ğ‘ âˆ’ 1]; ii) ğ‘¥ âˆˆ [âˆ’âŒˆğ‘/2âŒ‰, âŒŠğ‘/2âŒ‹] ; iii) ğ‘¥ âˆˆ [âˆ’ğ‘ + 1, ğ‘ âˆ’ 1]. The last version\ncorresponds to the â€¶%â€³ operator in most programming languages.\n                                                    50"}
{"doc_id": "NIST.FIPS.204", "source_path": "data/raw_pdfs/NIST.FIPS.204.pdf", "page_number": 61, "text": "FIPS 204                MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n\nAppendix B â€” Zetas Array\n\nThe values ğœBitRevâ‚ˆ(ğ‘˜) mod ğ‘ for ğ‘˜ = 1, â€¦ , 255 used in the NTT Algorithms 41 and 42 may be pre-computed\nand stored in an array zetas[1..255]. This table of zetas is given below.\nzetas[0..255] = {\n   0,       4808194,    3765607,    3761513,    5178923,     5496691,    5234739,     5178987,\n7778734,    3542485,    2682288,    2129892,    3764867,     7375178,    557458,      7159240,\n5010068,    4317364,    2663378,    6705802,    4855975,     7946292,    676590,      7044481,\n5152541,    1714295,    2453983,    1460718,    7737789,     4795319,    2815639,     2283733,\n3602218,    3182878,    2740543,    4793971,    5269599,     2101410,    3704823,     1159875,\n394148,     928749,     1095468,    4874037,    2071829,     4361428,    3241972,     2156050,\n3415069,    1759347,    7562881,    4805951,    3756790,     6444618,    6663429,     4430364,\n5483103,    3192354,    556856,     3870317,    2917338,     1853806,    3345963,     1858416,\n3073009,    1277625,    5744944,    3852015,    4183372,     5157610,    5258977,     8106357,\n2508980,    2028118,    1937570,    4564692,    2811291,     5396636,    7270901,     4158088,\n1528066,    482649,     1148858,    5418153,    7814814,     169688,     2462444,     5046034,\n4213992,    4892034,    1987814,    5183169,    1736313,     235407,     5130263,     3258457,\n5801164,    1787943,    5989328,    6125690,    3482206,     4197502,    7080401,     6018354,\n7062739,    2461387,    3035980,    621164,     3901472,     7153756,    2925816,     3374250,\n1356448,    5604662,    2683270,    5601629,    4912752,     2312838,    7727142,     7921254,\n348812,     8052569,    1011223,    6026202,    4561790,     6458164,    6143691,     1744507,\n 1753,      6444997,    5720892,    6924527,    2660408,     6600190,    8321269,     2772600,\n1182243,     87208,     636927,     4415111,    4423672,     6084020,    5095502,     4663471,\n8352605,    822541,     1009365,    5926272,    6400920,     1596822,    4423473,     4620952,\n6695264,    4969849,    2678278,    4611469,    4829411,     635956,     8129971,     5925040,\n4234153,    6607829,    2192938,    6653329,    2387513,     4768667,    8111961,     5199961,\n3747250,    2296099,    1239911,    4541938,    3195676,     2642980,    1254190,     8368000,\n2998219,    141835,     8291116,    2513018,    7025525,     613238,     7070156,     6161950,\n7921677,    6458423,    4040196,    4908348,    2039144,     6500539,    7561656,     6201452,\n6757063,    2105286,    6006015,    6346610,    586241,      7200804,    527981,      5637006,\n6903432,    1994046,    2491325,    6987258,    507927,      7192532,    7655613,     6545891,\n5346675,    8041997,    2647994,    3009748,    5767564,     4148469,    749577,      4357667,\n3980599,    2569011,    6764887,    1723229,    1665318,     2028038,    1163598,     5011144,\n3994671,    8368538,    7009900,    3020393,    3363542,     214880,     545376,      7609976,\n3105558,    7277073,    508145,     7826699,    860144,      3430436,    140244,      6866265,\n6195333,    3123762,    2358373,    6187330,    5365997,     6663603,    2926054,     7987710,\n8077412,    3531229,    4405932,    4606686,    1900052,     7598542,    1054478,    7648983 }\n\n51"}
{"doc_id": "NIST.FIPS.204", "source_path": "data/raw_pdfs/NIST.FIPS.204.pdf", "page_number": 62, "text": "FIPS 204                                                   MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n\nAppendix C â€” Loop Bounds\n\nThere are four algorithms in this standard with loops that iterate an indeterminate number of times,\nthough the expected number of iterations is a small constant in each case. Three of the four algorithms\ninvolve sampling from the output of an XOF, where the amount of output required from the XOF is\nproportional to the number of iterations that are performed.\nImplementations should not bound the number of iterations in these loops or the amount of output that\nis extracted from the XOFs when executing these functions.14 If an implementation bounds the number of\niterations or the number of bytes that may be extracted from the XOF, it shall not use a limit lower than\nthose presented in Table 3. The limits yield a probability of approximately 2âˆ’256 (or less) of being reached\nin a correct implementation of this standard. The probability is calculated under standard assumptions\nabout the output distributions of XOFs and hash functions.\n\nTable 3. While loop and XOF output limits for a 2âˆ’256 or less probability of failure\n\n     Algorithm    Minimum allowable limit                               Minimum allowable limit\n                     (Loop iterations)                                     (XOF output bytes)\nML-DSA.Sign_internal        814                                                   N/A\n   RejBoundedPoly           481                                         481\n     RejNTTPoly             298                                         894\n    SampleInBall            121                                         221\n\nImplementations may limit the number of iterations of a while loop or the number of bytes drawn from\nthe XOF to not exceed the maximum values in Table 3. If this option is used and the maximum number of\niterations or XOF output bytes is exceeded, the algorithm shall destroy all intermediate results. If a return\nvalue or exception is produced, it shall be the same for any execution in which the maximum number of\niterations or output bytes is exceeded.\nThere is essentially no performance penalty for using a larger than necessary limit, as the limit will only\nbe reached on a faulty execution of the loop. Because of this, limits were chosen that lower-bound the\nprobability of reaching them to 2âˆ’256.\nML-DSA.Sign_internal\nTable 1 contains the expected repetitions in the rejection sampling loop of ML-DSA.Sign_internal. These\nare 4.25, 5.1, and 3.85 for Categories 2, 3, and 5, respectively. Therefore, the probability that the number\nof repetitions exceeds ğ‘› is less than or equal to ( 5.1âˆ’1)ğ‘› for all categories. Solving ( 5.1âˆ’1)ğ‘› â‰¤ 2âˆ’256\nyields ğ‘› = 814.                                           5.1             5.1\nRejBoundedPoly\nLet ğ‘‹ be the number of coefficients generated in ğ‘› iterations of the while loop of RejBoundedPoly15.\nThen ğ‘‹ is ğµğ‘–ğ‘›ğ‘œğ‘šğ‘–ğ‘ğ‘™(2ğ‘›, ğœƒ), where ğœƒ is either 9 or 15 , depending on the parameter ğœ‚. For ğœƒ = 9 ,\n                                   256 coefficient16              16                                       16\nthe probability that fewer than                          s are generated in 481 iterations of the main loop in\nRejBoundedPoly is less than 2âˆ’256. Each iteration consumes one byte of output from H.\n\n14RejBoundedPoly, RejNTTPoly, and SampleInBall use the incremental APIs described in Section 3.7 in order to\nextract the amount of output needed from the XOFs, given that the amount needed is not known in advance.\n15Note that 0, 1, or 2 coefficients are generated in each iteration.\n                                                           52"}
{"doc_id": "NIST.FIPS.204", "source_path": "data/raw_pdfs/NIST.FIPS.204.pdf", "page_number": 63, "text": "FIPS 204                                   MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n\nRejNTTPoly\nThe number of valid coefficients generated in ğ‘› calls to G.Squeeze in RejNTTPoly is ğµğ‘–ğ‘›ğ‘œğ‘šğ‘–ğ‘ğ‘™(ğ‘›, 2âˆ’23ğ‘).\nIt follows that after 298 calls, the probability of failure is less than 2âˆ’256. Each iteration consumes three\nbytes of output from G.\nSampleInBall\nStep 9 in SampleInBall is executed every time a pseudorandom byte is greater than a value ğ‘– in the range\n[256 âˆ’ ğœ , 255]. The parameter ğœ is 39, 49, and 60 for categories 2, 3, and 5, respectively. Therefore, the\nprobability that this step is executed more than ğ‘› times in a single iteration of the for loop is less than or\nequal to ( 59 )ğ‘› â‰¤ ( ğœ       )ğ‘›. Solving ( 59 )ğ‘› â‰¤ 2âˆ’256 yields a bound of ğ‘› = 121 for the while loop on step\n8 of        256       256      256\n      SampleInBall. Each iteration consumes one byte of output from H.\nEach call to SampleInBall extracts eight bytes from H and then performs ğœ iterations of the for loop, each\nof which extracts an indeterminate amount of data from H. The probability that more than ğ‘› bytes of\noutput will be required from H during an execution of SampleInBall for a given value of ğœ is\n\n                      â§               1                                              if ğ‘› â‰¤ 8\n            ğ‘ƒ (ğ‘›, ğœ) = {           0                                              if ğœ  = 1 and ğ‘› > 8 .\n                      â¨\n                      { ( 257âˆ’ğœ ) ğ‘ƒ (ğ‘› âˆ’ 1, ğœ âˆ’ 1) + ( ğœâˆ’1) ğ‘ƒ (ğ‘› âˆ’ 1, ğœ)     if ğœ  > 1 and ğ‘› > 8\n                      â©        256                        256\n\nğ‘ƒ (ğ‘›, 60) is less than 2âˆ’256 when ğ‘› is 221 or greater. Implementations may limit the number of bytes\nextracted from H to ğ‘› â‰¥ 221. Such implementations must stop the execution of SampleInBall, return a\nconstant that represents an error and no other output, and destroy all intermediate results after ğ‘› bytes\nof output have been consumed.\n\n53"}
{"doc_id": "NIST.FIPS.204", "source_path": "data/raw_pdfs/NIST.FIPS.204.pdf", "page_number": 64, "text": "FIPS 204                                   MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n\nAppendix D â€” Differences from the CRYSTALS-DILITHIUM Submission\n\nML-DSA is derived from Version 3.1 of CRYSTALS-DILITHIUM [6]. Version 3.1 differs slightly from the most\nrecent version that appears on the NIST website (i.e., Version 3 CRYSTALS-DILITHIUM [5]). Appendices D.1,\nD.2, and D.3 document the differences between Versions 3 and 3.1, the differences between Version 3.1\nand the initial public draft of the ML-DSA, and the differences between the initial public draft and the\nML-DSA standard as published in this document, respectively.\n\nD.1  Differences Between Version 3.1 and the Round 3 Version of CRYSTALS-\nDILITHIUM\n  The lengths of the variables ğœŒâ€² (private random seed) and ğœ‡ (message representative) in the signing\nalgorithm were increased from 384 to 512 bits. The increase in the length of ğœ‡ corrects a security flaw\nthat appeared in the third-round submission, where a collision attack against SHAKE256 with a 384-bit\noutput would make it so that parameters targeting NIST security strength category 5 could only meet\ncategory 4 [32].\nAdditionally, the length of the variable ğ‘¡ğ‘Ÿ (the hash of the public key) was reduced from 384 to 256 bits.\nIn key generation, the variable ğœ was relabeled as ğœŒâ€² and increased in size from 256 bits to 512 bits.\n\nD.2  Differences Between Version 3.1 of CRYSTALS-DILITHIUM and FIPS 204\nInitial Public Draft\nIn order to ensure the properties noted in [14], ML-DSA increases the length of ğ‘¡ğ‘Ÿ to 512 bits and increases\nthe length of ğ‘ to 384 and 512 bits for the parameter sets ML-DSA-65 and ML-DSA-87, respectively. In\ndraft ML-DSA, only the first 256 bits of ğ‘ are used in the generation of ğ‘.\nIn Version 3.1 of the CRYSTALS-DILITHIUM submission, the default version of the signing algorithm is\ndeterministic with ğœŒâ€² being generated pseudorandomly from the signerâ€™s private key and the message,\nand an optional version of the signing algorithm has ğœŒâ€² sampled instead as a 512-bit random string. In\nML-DSA, ğœŒâ€² is generated by a â€œhedgedâ€ procedure in which ğœŒâ€² is pseudorandomly derived from the signerâ€™s\nprivate key, the message, and a 256-bit string ğ‘Ÿğ‘›ğ‘‘, which should be generated by an Approved RBG by\ndefault. The ML-DSA standard also allows for an optional deterministic version in which ğ‘Ÿğ‘›ğ‘‘ is a 256-bit\nconstant string.\n The draft ML-DSA standard also included pseudocode that unintentionally omitted a check for malformed\ninput while unpacking the hint [33]. Failure to perform this check results in a signature scheme that is not\nstrongly existentially unforgeable [34].\n\nD.3  Changes From FIPS 204 Initial Public Draft\nIn the final version of the ML-DSA standard, the omitted malformed input check was restored to the hint\nunpacking algorithm (Algorithm 21). Additionally, in the final version of ML-DSA, all of the bits of ğ‘ are\nused in the generation of ğ‘ (Algorithm 29), and ExpandMask (Algorithm 34) is modified to take output\nbits from the beginning of the output of H.\nBased on comments that were submitted on the draft version, more details were provided for the pre-hash\nversion HashML-DSA in Section 5.4. These modifications include domain separation for the cases in which\nthe message is signed directly and cases in which a digest of the message is signed. The changes were\nmade by explicitly defining external functions for both versions of the signing and verification functions\n\n                                                   54"}
{"doc_id": "NIST.FIPS.204", "source_path": "data/raw_pdfs/NIST.FIPS.204.pdf", "page_number": 65, "text": "FIPS 204    MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n\nthat call an internal function corresponding to the signing or verification functions from the draft FIPS.\nDomain separation is included in the input to the internal function (see Algorithms 2, 3, 4, 5, 7, and 8).\nTo simplify APIs and for testing purposes, this document also introduced a similar external/internal split\nfor key generation (see Algorithms 1 and 6), but this is a purely editorial change, as the external key\ngeneration algorithm is functionally equivalent to the key-generation algorithm from the draft FIPS.\nFinally, to offer misuse resistance against the possibility that keys for different parameter sets might be\nexpanded from the same seed [35], domain separation was added to line 1 of Algorithm 6.\n\n55"}
{"doc_id": "NIST.FIPS.205", "source_path": "data/raw_pdfs/NIST.FIPS.205.pdf", "page_number": 1, "text": "  FIPS 205\n\n  Federal Information Processing Standards Publication\n\n  Stateless Hash-Based Digital Signature\n  Standard\n\n  Category: Computer Security    Subcategory: Cryptography\n\n  Information Technology Laboratory\n  National Institute of Standards and Technology\n  Gaithersburg, MD 20899-8900\n\n  This publication is available free of charge from:\n  https://doi.org/10.6028/NIST.FIPS.205\n\n  Published: August 13, 2024\n\n  U.S. Department of Commerce\n  Gina M. Raimondo, Secretary\n\n 0 National Institute of Standards and Technology\n  Laurie E. Locascio, NIST Director and Under Secretary of Commerce for Standards and Technology\n\nCheck\n   for\nupdates"}
{"doc_id": "NIST.FIPS.205", "source_path": "data/raw_pdfs/NIST.FIPS.205.pdf", "page_number": 2, "text": "                                                   Foreword\n\nThe Federal Information Processing Standards Publication (FIPS) series of the National Institute of Standards\nand Technology (NIST) is the official series of publications relating to standards and guidelines developed\nunder 15 U.S.C. 278g-3, and issued by the Secretary of Commerce under 40 U.S.C. 11331.\nComments concerning this Federal Information Processing Standard publication are welcomed and should\nbe submitted using the contact information in the â€œInquiries and commentsâ€ clause of the announcement\nsection.\n\n        Kevin M. Stine, Director\n        Information Technology Laboratory"}
{"doc_id": "NIST.FIPS.205", "source_path": "data/raw_pdfs/NIST.FIPS.205.pdf", "page_number": 3, "text": "FIPS 205    STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n\n                                            Abstract\nThis standard specifies the stateless hash-based digital signature algorithm (SLH-DSA). Digital\nsignatures are used to detect unauthorized modifications to data and to authenticate the identity\nof the signatory. In addition, the recipient of signed data can use a digital signature as evidence in\ndemonstrating to a third party that the signature was, in fact, generated by the claimed signatory.\nThis is known as non-repudiation since the signatory cannot easily repudiate the signature at a\nlater time. SLH-DSA is based on SPHINCSâº, which was selected for standardization as part of the\nNIST Post-Quantum Cryptography Standardization process.\n\nKeywords: computer security; cryptography; digital signatures; Federal Information Processing\nStandards; hash-based signatures; post-quantum; public-key cryptography."}
{"doc_id": "NIST.FIPS.205", "source_path": "data/raw_pdfs/NIST.FIPS.205.pdf", "page_number": 4, "text": "FIPS 205                              STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n\n    Federal Information Processing Standards Publication 205\n\n    Published:                       August 13, 2024\n    Effective:                       August 13, 2024\n\n                     Announcing the\n    Stateless Hash-Based Digital Signature Standard\n\nFederal Information Processing Standards (FIPS) publications are developed by the National\nInstitute of Standards and Technology (NIST) under 15 U.S.C. 278g-3 and issued by the Secretary\nof Commerce under 40 U.S.C. 11331.\n1.  Name of Standard. Stateless Hash-Based Digital Signature Standard (FIPS 205).\n2.  Category of Standard. Computer Security. Subcategory. Cryptography.\n3.  Explanation. This standard specifies a stateless hash-based digital signature scheme (SLH-\n    DSA) for applications that require a digital signature rather than a written signature. Additional\n    digital signature schemes are specified and approved in other NIST Special Publications and\n    FIPS publications (e.g., FIPS 186-5 [1]). A digital signature is represented in a computer as a\n    string of bits and computed using a set of rules and parameters that allow the identity of the\n    signatory and the integrity of the data to be verified. Digital signatures may be generated on\n    both stored and transmitted data.\n    Signature generation uses a private key to generate a digital signature. Signature verification\n    uses a public key that corresponds to but is not the same as the private key. Each signatory\n    possesses a private and public key pair. Public keys may be known by the public, but private\n    keys must be kept secret. Anyone can verify the signature by employing the signatoryâ€™s public\n    key. Only the user who possesses the private key can perform signature generation.\n    The digital signature is provided to the intended verifier along with the signed data. The\n    verifying entity verifies the signature by using the claimed signatoryâ€™s public key. Similar\n    procedures may be used to generate and verify signatures for both stored and transmitted\n    data.\n    This standard specifies several parameter sets for SLH-DSA that are approved for use. Addi-\n    tional parameter sets may be specified and approved in future NIST Special Publications.\n4.  Approving Authority. Secretary of Commerce.\n5.  Maintenance Agency. Department of Commerce, National Institute of Standards and Tech-\n    nology, Information Technology Laboratory (ITL).\n6.  Applicability. This standard is applicable to all federal departments and agencies for the\n    protection of sensitive unclassified information that is not subject to section 2315 of Title 10,\n    United States Code, or section 3502 (2) of Title 44, United States Code. Either this standard,\n    FIPS 204, FIPS 186-5, or NIST Special Publication 800-208 shall be used in designing and\n    implementing public-key-based signature systems that federal departments and agencies op-\n    erate or that are operated for them under contract. In the future, additional digital signature\n\n                                     i"}
{"doc_id": "NIST.FIPS.205", "source_path": "data/raw_pdfs/NIST.FIPS.205.pdf", "page_number": 5, "text": "FIPS 205                                 STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n\n    schemes may be specified and approved in FIPS publications or NIST Special Publications.\n    The adoption and use of this standard are available to private and commercial organizations.\n7.  Applications. A digital signature algorithm allows an entity to authenticate the integrity of\n    signed data and the identity of the signatory. The recipient of a signed message can use a\n    digital signature as evidence in demonstrating to a third party that the signature was, in fact,\n    generated by the claimed signatory. This is known as non-repudiation since the signatory\n    cannot easily repudiate the signature at a later time. A digital signature algorithm is intended\n    for use in electronic mail, electronic funds transfer, electronic data interchange, software\n    distribution, data storage, and other applications that require data integrity assurance and\n    data origin authentication.\n8.  Implementations. A digital signature algorithm may be implemented in software, firmware,\n    hardware, or any combination thereof. NIST will develop a validation program to test imple-\n    mentations for conformance to the algorithms in this standard. For every computational\n    procedure that is specified in this standard, a conforming implementation may replace the\n    given set of steps with any mathematically equivalent process. In other words, different\n    procedures that produce the correct output for every input are permitted. Information about\n    validation programs is available at https://csrc.nist.gov/projects/cmvp. Examples for digital\n    signature algorithms are available at https://csrc.nist.gov/projects/cryptographic-standards-\n    and-guidelines/example-values.\n    Agencies are advised that digital signature key pairs shall not be used for other purposes.\n9.  Other Approved Security Functions. Digital signature implementations that comply with this\n    standard shall employ cryptographic algorithms that have been approved for protecting Fed-\n    eral Government-sensitive information. Approved cryptographic algorithms and techniques\n    include those that are either:\n    a.     Specified in a Federal Information Processing Standard (FIPS) publication,\n    b.     Adopted in a FIPS or NIST recommendation, or\n    c.     Specified in the list of approved security functions in SP 800-140C.\n10. Export Control. Certain cryptographic devices and technical data regarding them are subject\n    to federal export controls. Exports of cryptographic modules that implement this standard\n    and technical data regarding them must comply with these federal regulations and be licensed\n    by the Bureau of Industry and Security of the U.S. Department of Commerce. Information\n    about export regulations is available at https://www.bis.doc.gov.\n11. Patents. The algorithm in this standard may be covered by U.S. or foreign patents.\n12. Implementation Schedule. This standard becomes effective immediately upon final publica-\n    tion.\n13. Specifications. Federal Information Processing Standard (FIPS) 205, Stateless Hash-Based\n    Digital Signature Standard (affixed).\n\nii"}
{"doc_id": "NIST.FIPS.205", "source_path": "data/raw_pdfs/NIST.FIPS.205.pdf", "page_number": 6, "text": "FIPS 205                                   STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n\n14. Qualifications. The security of a digital signature system depends on the secrecy of the\n signatoryâ€™s private keys. Signatories shall, therefore, guard against the disclosure of their\n private keys. While it is the intent of this standard to specify general security requirements for\n generating digital signatures, conformance to this standard does not ensure that a particular\n implementation is secure. It is the responsibility of an implementer to ensure that any module\n that implements a digital signature capability is designed and built in a secure manner.\n Similarly, the use of a product containing an implementation that conforms to this standard\n does not guarantee the security of the overall system in which the product is used. The re-\n sponsible authority in each agency or department shall ensure that an overall implementation\n provides an acceptable level of security.\n Since a standard of this nature must be flexible enough to adapt to advancements and\n innovations in science and technology, this standard will be reviewed every five years in order\n to assess its adequacy.\n15. Waiver Procedure. The Federal Information Security Management Act (FISMA) does not\n allow for waivers to Federal Information Processing Standards (FIPS) that are made mandatory\n by the Secretary of Commerce.\n16. Where to Obtain Copies of the Standard. This publication is available by accessing https:\n//csrc.nist.gov/publications. Other computer security publications are available at the same\nwebsite.\n17. How to Cite This Publication. NIST has assigned NIST FIPS 205 as the publication identifier\n for this FIPS, per the NIST Technical Series Publication Identifier Syntax. NIST recommends\n that it be cited as follows:\n            National Institute of Standards and Technology (2024) Stateless Hash-Based Dig-\n            ital Signature Standard. (Department of Commerce, Washington, D.C.), Fed-\n            eral Information Processing Standards Publication (FIPS) NIST FIPS 205. https:\n            //doi.org/10.6028/NIST.FIPS.205\n18. Inquiries and Comments. Inquiries and comments about this FIPS may be submitted to\n fips-205-comments@nist.gov.\n\niii"}
{"doc_id": "NIST.FIPS.205", "source_path": "data/raw_pdfs/NIST.FIPS.205.pdf", "page_number": 7, "text": "FIPS 205    STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n\nFederal Information Processing Standards Publication 205\n\nStateless  Specification for the\n           Hash-Based Digital Signature Standard\n\n                                    Table of Contents\n\n1  Introduction                                                                                      1\n   1.1     Purpose and Scope     . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     1\n   1.2     Context   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     1\n\n2  Glossary of Terms, Acronyms, and Symbols                                                          2\n   2.1     Terms and Definitions     . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     2\n   2.2     Acronyms    . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     4\n   2.3     Mathematical Symbols      . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     5\n\n3  Overview of the SLH-DSA Signature Scheme                                                          7\n   3.1     Additional Requirements     . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     9\n   3.2     Implementation Considerations       . . . . . . . . . . . . . . . . . . . . . . . . .    10\n\n4  Functions and Addressing                                                                         11\n   4.1     Hash Functions and Pseudorandom Functions           . . . . . . . . . . . . . . . . .    11\n   4.2     Addresses   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .    11\n   4.3     Member Functions      . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .    14\n   4.4     Arrays, Byte Strings, and Integers    . . . . . . . . . . . . . . . . . . . . . . . .    15\n\n5  Winternitz One-Time Signature Plus Scheme                                                        17\n   5.1     WOTSâº Public-Key Generation       . . . . . . . . . . . . . . . . . . . . . . . . . .    18\n   5.2     WOTSâº Signature Generation        . . . . . . . . . . . . . . . . . . . . . . . . . .    19\n   5.3     Computing a WOTSâº Public Key From a Signature           . . . . . . . . . . . . . . .    21\n\n6  eXtended Merkle Signature Scheme (XMSS)                                                          22\n   6.1     Generating a Merkle Hash Tree       . . . . . . . . . . . . . . . . . . . . . . . . .    22\n   6.2          Generating an XMSS Signature . . . . . . . . . . . . . . . . . . . . . . . . . .    23\n   6.3             Computing an XMSS Public Key From a Signature . . . . . . . . . . . . . . . .    25\n\n7 The SLH-DSA Hypertree                                                                             26\n                                                 iv"}
{"doc_id": "NIST.FIPS.205", "source_path": "data/raw_pdfs/NIST.FIPS.205.pdf", "page_number": 8, "text": "FIPS 205                                     STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n\n   7.1      Hypertree Signature Generation             . . . . . . . . . . . . . . . . . . . . . . . . .    26\n   7.2      Hypertree Signature Verification . . . . . . . . . . . . . . . . . . . . . . . . .              28\n\n8  Forest of Random Subsets (FORS)                                                                          29\n   8.1      Generating FORS Secret Values . . . . . . . . . . . . . . . . . . . . . . . . . .               29\n   8.2      Generating a Merkle Hash Tree              . . . . . . . . . . . . . . . . . . . . . . . . .    30\n   8.3      Generating a FORS Signature . . . . . . . . . . . . . . . . . . . . . . . . . . .               30\n   8.4      Computing a FORS Public Key From a Signature . . . . . . . . . . . . . . . . .                  31\n\n9  SLH-DSA Internal Functions                                                                               33\n   9.1      SLH-DSA Key Generation             . . . . . . . . . . . . . . . . . . . . . . . . . . . . .    33\n   9.2      SLH-DSA Signature Generation . . . . . . . . . . . . . . . . . . . . . . . . . .                34\n   9.3      SLH-DSA Signature Verification . . . . . . . . . . . . . . . . . . . . . . . . . .              36\n\n10 SLH-DSA External Functions                                                                               37\n   10.1     SLH-DSA Key Generation             . . . . . . . . . . . . . . . . . . . . . . . . . . . . .    37\n   10.2     SLH-DSA Signature Generation . . . . . . . . . . . . . . . . . . . . . . . . . .                37\n            10.2.1  Pure SLH-DSA Signature Generation  .  .  .  . .  .  .  .  .  .  .  .  .  . . . . . .    38\n            10.2.2  HashSLH-DSA Signature Generation   .  .  .  . .  .  .  .  .  .  .  .  .  . . . . . .    39\n   10.3     SLH-DSA Signature Verification . . . . . . . . . . . . . . . . . . . . . . . . . .              41\n\n11 Parameter Sets                                                                                           43\n   11.1     SLH-DSA Using SHAKE              . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .    44\n   11.2     SLH-DSA Using SHA2             . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .    44\n            11.2.1  SLH-DSA Using SHA2 for Security Category 1 .     .  .  .  .  .  .  .  .  . . . . . .    45\n            11.2.2  SLH-DSA Using SHA2 for Security Categories 3 and 5           .  .  .  .  . . . . . .    46\n\nReferences                                                                                                  47\n\nAppendix A â€” Differences From the SPHINCS+ Submission                                                       51\n   A.1      Changes From FIPS 205 Initial Public Draft . . . . . . . . . . . . . . . . . . . .              51\n\nv"}
{"doc_id": "NIST.FIPS.205", "source_path": "data/raw_pdfs/NIST.FIPS.205.pdf", "page_number": 9, "text": "FIPS 205                                                                     STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n\n                                       List of Tables\n\nTable 1      Member functions for addresses                 . . . . . . . . . . . . . . . . . . . . . .                   14\nTable 2      SLH-DSA parameter sets                 . . . . . . . . . . . . . . . . . . . . . . . . . .                     43\nTable 3      Member functions for compressed addresses .    . . .                  . . . . . . . . . . .                    45\n\n                                       List of Figures\n\nFigure 1       An SLH-DSA signature               . . . . . . . . . . . . . . . . . . . . . . . . . . .                     8\nFigure 2       Address (ADRS)                 . . . . . . . . . . . . . . . . . . . . . . . . . . . . .                     12\nFigure 3       WOTSâº hash address                 . . . . . . . . . . . . . . . . . . . . . . . . . . .                     12\nFigure 4       WOTSâº public-key compression address   . .   . . . .                . . . . . . . . . . .                    12\nFigure 5       Hash tree address              . . . . . . . . . . . . . . . . . . . . . . . . . . . . .                     13\nFigure 6       FORS tree address              . . . . . . . . . . . . . . . . . . . . . . . . . . . . .                     13\nFigure 7       FORS tree roots compression address .  . . . . . . .                . . . . . . . . . . .                    13\nFigure 8       WOTSâº key generation address                 . . . . . . . . . . . . . . . . . . . . . .                     14\nFigure 9       FORS key generation address                . . . . . . . . . . . . . . . . . . . . . . .                     14\nFigure 10                     WOTSâº signature data format . . . . . . . . . . . . . . . . . . . . . . .                     19\nFigure 11      XMSS signature data format               . . . . . . . . . . . . . . . . . . . . . . . .                     22\nFigure 12                  Merkle hash tree . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .                   24\nFigure 13      HT signature data format               . . . . . . . . . . . . . . . . . . . . . . . . .                     26\nFigure 14      FORS signature data format               . . . . . . . . . . . . . . . . . . . . . . . .                     29\nFigure 15      SLH-DSA private key              . . . . . . . . . . . . . . . . . . . . . . . . . . . .                     33\nFigure 16                  SLH-DSA public key . . . . . . . . . . . . . . . . . . . . . . . . . . . . .                     33\nFigure 17      SLH-DSA signature data format                . . . . . . . . . . . . . . . . . . . . . .                   34\nFigure 18                        Compressed address (ADRSğ‘) . . . . . . . . . . . . . . . . . . . . . .                    45\n\n                                       List of Algorithms\nAlgorithm 1      gen_lenâ‚‚ (ğ‘›, ğ‘™ğ‘”ğ‘¤)          . . . . . . . . . . . . . . . . . . . . . . . . . . . .                     10\nAlgorithm 2      toInt(ğ‘‹, ğ‘›)            . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .                     15\nAlgorithm 3      toByte(ğ‘¥, ğ‘›)             . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .                     15\nAlgorithm 4      base_2áµ‡(ğ‘‹, ğ‘, ğ‘œğ‘¢ğ‘¡_ğ‘™ğ‘’ğ‘›)         . . . . . . . . . . . . . . . . . . . . . . . .                     16\nAlgorithm 5      chain(ğ‘‹, ğ‘–, ğ‘ , PK.seed, ADRS)                 . . . . . . . . . . . . . . . . . . .                     18\nAlgorithm 6      wots_pkGen(SK.seed, PK.seed, ADRS)                         . . . . . . . . . . . . . .                     18\nAlgorithm 7      wots_sign(ğ‘€, SK.seed, PK.seed, ADRS)                        . . . . . . . . . . . . .                     20\nAlgorithm 8                             wots_pkFromSig(ğ‘ ğ‘–ğ‘”, ğ‘€, PK.seed, ADRS) . . . . . . . . . . . . .                 21\nAlgorithm 9      xmss_node(SK.seed, ğ‘–, ğ‘§, PK.seed, ADRS)                      . . . . . . . . . . . .                     23\nAlgorithm 10                            xmss_sign(ğ‘€, SK.seed, ğ‘–ğ‘‘ğ‘¥, PK.seed, ADRS) . . . . . . . . . . .                 24\nAlgorithm 11                               xmss_pkFromSig(ğ‘–ğ‘‘ğ‘¥, SIGğ‘‹ğ‘€ğ‘†ğ‘†, ğ‘€, PK.seed, ADRS) . . . . . . .             25\nAlgorithm 12     ht_sign(ğ‘€, SK.seed, PK.seed, ğ‘–ğ‘‘ğ‘¥ğ‘¡ğ‘Ÿğ‘’ğ‘’, ğ‘–ğ‘‘ğ‘¥ğ‘™ğ‘’ğ‘ğ‘“ )     . . . . . . . . . .                     27\nAlgorithm 13                       ht_verify(ğ‘€, SIGğ»ğ‘‡, PK.seed, ğ‘–ğ‘‘ğ‘¥ğ‘¡ğ‘Ÿğ‘’ğ‘’, ğ‘–ğ‘‘ğ‘¥ğ‘™ğ‘’ğ‘ğ‘“ , PK.root) . . . . . .    28\nAlgorithm 14     fors_skGen(SK.seed, PK.seed, ADRS, ğ‘–ğ‘‘ğ‘¥)                     . . . . . . . . . . . .                     29\n\n                                                   vi"}
{"doc_id": "NIST.FIPS.205", "source_path": "data/raw_pdfs/NIST.FIPS.205.pdf", "page_number": 10, "text": "FIPS 205                                         STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n\nAlgorithm 15     fors_node(SK.seed, ğ‘–, ğ‘§, PK.seed, ADRS)           . . . . . . . . . . . . .     30\nAlgorithm 16     fors_sign(ğ‘šğ‘‘, SK.seed, PK.seed, ADRS)             . . . . . . . . . . . . .     31\nAlgorithm 17     fors_pkFromSig(SIGğ¹ ğ‘‚ğ‘…ğ‘† , ğ‘šğ‘‘, PK.seed, ADRS) . . . . . . . . . .            32\nAlgorithm 18     slh_keygen_internal(SK.seed, SK.prf, PK.seed)             . . . . . . . . . .     34\nAlgorithm 19     slh_sign_internal(ğ‘€, SK, ğ‘ğ‘‘ğ‘‘ğ‘Ÿğ‘›ğ‘‘) . . . . . . . . . . . . . . . . . . .     35\nAlgorithm 20     slh_verify_internal(ğ‘€, SIG, PK)      . . . . . . . . . . . . . . . . . . . .     36\nAlgorithm 21     slh_keygen()      . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     37\nAlgorithm 22     slh_sign(ğ‘€, ğ‘ğ‘¡ğ‘¥, SK)  . . . . . . . . . . . . . . . . . . . . . . . . . .     39\nAlgorithm 23     hash_slh_sign(ğ‘€, ğ‘ğ‘¡ğ‘¥, PH, SK)   . . . . . . . . . . . . . . . . . . . . .     40\nAlgorithm 24     slh_verify(ğ‘€, SIG, ğ‘ğ‘¡ğ‘¥, PK) . . . . . . . . . . . . . . . . . . . . . . .     41\nAlgorithm 25     hash_slh_verify(ğ‘€, SIG, ğ‘ğ‘¡ğ‘¥, PH, PK)    . . . . . . . . . . . . . . . . .     42\n\nvii"}
{"doc_id": "NIST.FIPS.205", "source_path": "data/raw_pdfs/NIST.FIPS.205.pdf", "page_number": 11, "text": "FIPS 205              STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n\n1.   Introduction\n\n1.1  Purpose and Scope\nThis standard defines a method for digital signature generation that can be used for the protection\nof binary data (commonly called a message) and for the verification and validation of those digital\nsignatures.Â¹ The security of the stateless hash-based digital signature algorithm (SLH-DSA) relies\non the presumed difficulty of finding preimages for hash functions as well as several related\nproperties of the same hash functions. Unlike the algorithms specified in FIPS 186-5 [1], SLH-DSA\nis designed to provide resistance against attacks from a large-scale quantum computer.\nThis standard specifies the mathematical steps that need to be performed for key generation,\nsignature generation, and signature verification. Additional assurances are required for digital\nsignatures to be valid (e.g., the assurance of identity and private key possession). SP 800-89,\nRecommendation for Obtaining Assurances for Digital Signature Applications [3], specifies the\nrequired assurances and the methods for obtaining these assurances.\n\n1.2  Context\nOver the past several years, there has been steady progress toward building quantum computers.\nThe security of many commonly used public-key cryptosystems will be at risk if large-scale\nquantum computers are ever realized. This would include key-establishment schemes and digital\nsignatures that are based on integer factorization and discrete logarithms (both over finite fields\nand elliptic curves). As a result, in 2016, NIST initiated a public Post-Quantum Cryptography\n(PQC) Standardization process to select quantum-resistant public-key cryptographic algorithms\nfor standardization. A total of 82 candidate algorithms were submitted to NIST for consideration.\nAfter three rounds of evaluation and analysis, NIST selected the first four algorithms for stan-\ndardization. These algorithms are intended to protect sensitive U.S. Government information\nwell into the foreseeable future, including after the advent of cryptographically relevant quan-\ntum computers. This standard includes the specification for one of the algorithms selected:\nSPHINCSâº, a stateless hash-based digital signature scheme. This standard contains several minor\nmodifications compared to Version 3 [4], which was submitted at the beginning of round three\nof the NIST PQC Standardization process. The changes are described in Appendix A. Throughout\nthis standard, SPHINCSâº will be referred to as SLH-DSA for stateless hash-based digital signature\nalgorithm.\n\n1NIST Special Publication (SP) 800-175B [2], Guideline for Using Cryptographic Standards in the Federal Government:\nCryptographic Mechanisms, includes a general discussion of digital signatures.\n1"}
{"doc_id": "NIST.FIPS.205", "source_path": "data/raw_pdfs/NIST.FIPS.205.pdf", "page_number": 12, "text": "FIPS 205                                     STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n\n2.   Glossary of Terms, Acronyms, and Symbols\n\n2.1  Terms and Definitions\n approved               FIPS-approved and/or NIST-recommended.        An algorithm or tech-\n                        nique that is either 1) specified in a FIPS or NIST recommendation, 2)\n                        adopted in a FIPS or NIST recommendation, or 3) specified in a list of\n                        NIST-approved security functions. [1]\n big-endian             The property of a byte string having its bytes positioned in order of\n                        decreasing significance. In particular, the leftmost (first) byte is the\n                        most significant, and the rightmost (last) byte is the least significant.\n                        The term â€œbig-endianâ€ may also be applied in the same manner to bit\n                        strings. [5, adapted]\n byte string            An array of integers in which each integer is in the set {0, â€¦ , 255}.\n claimed signatory      From the verifierâ€™s perspective, the claimed signatory is the entity that\n                        purportedly generated a digital signature. [1]\n destroy                An action applied to a key or a piece of secret data. After a key or a\n                        piece of secret data is destroyed, no information about its value can\n                        be recovered. [1]\n digital signature      The result of a cryptographic transformation of data that, when prop-\n                        erly implemented, provides a mechanism for verifying origin authenti-\n                        cation, data integrity, and signatory non-repudiation. [1]\n entity                 An individual (person), organization, device, or process. Used inter-\n                        changeably with party. [1]\n equivalent process     Two processes are equivalent if the same output is produced when\n                        the same values are input to each process (either as input parameters,\n                        as values made available during the process, or both). [1]\n extendable-output      A function on bit strings in which the output can be extended to any\n function               desired length. Approved XOFs (such as those specified in FIPS 202 [6])\n                        are designed to satisfy the following properties as long as the specified\n                        output length is sufficiently long to prevent trivial attacks:\n                         1.  (One-way) It is computationally infeasible to find any input that\n                             maps to any new pre-specified output.\n                         2.  (Collision-resistant) It is computationally infeasible to find any\n                             two distinct inputs that map to the same output. [7, adapted]\n fresh random value     A previously unused output of a random bit generator.\n hash function          A function on bit strings in which the length of the output is fixed.\n                        Approved hash functions (such as those specified in FIPS 180 [8] and\n                        FIPS 202 [6]) are designed to satisfy the following properties:\n\n2"}
{"doc_id": "NIST.FIPS.205", "source_path": "data/raw_pdfs/NIST.FIPS.205.pdf", "page_number": 13, "text": "FIPS 205                                   STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n\n                     1.  (One-way) It is computationally infeasible to find any input that\n                         maps to any new pre-specified output\n                     2.  (Collision-resistant) It is computationally infeasible to find any\n                         two distinct inputs that map to the same output. [1]\nhash value          See message digest.\nkey                 A parameter used in conjunction with a cryptographic algorithm that\n                    determines its operation. Examples applicable to this standard include:\n                     1.   The computation of a digital signature from data, and\n                     2.   The verification of a digital signature. [1]\nkey pair            A public key and its corresponding private key. [1]\nmessage             The data that is signed. Also known as signed data during the signature\n                    verification and validation process. [1]\nmessage digest      The result of applying a hash function to a message. Also known as a\n                    hash value. [1]\nnon-repudiation     A service that is used to provide assurance of the integrity and origin\n                    of data in such a way that the integrity and origin can be verified and\n                    validated by a third party as having originated from a specific entity in\n                    possession of the private key (i.e., the signatory). [1]\nowner               A key pair owner is the entity authorized to use the private key of a\n                    key pair. [1]\nparty               An individual (person), organization, device, or process. Used inter-\n                    changeably with entity. [1]\nprivate key         A cryptographic key that is used with an asymmetric (public-key) cryp-\n                    tographic algorithm. The private key is uniquely associated with the\n                    owner and is not made public. The private key is used to compute a\n                    digital signature that may be verified using the corresponding public\n                    key. [1]\npseudorandom        A process or data produced by a process is said to be pseudorandom\n                    when the outcome is deterministic yet also effectively random as long\n                    as the internal action of the process is hidden from observation. For\n                    cryptographic purposes, â€œeffectively randomâ€ means â€œcomputation-\n                    ally indistinguishable from random within the limits of the intended\n                    security strength.â€ [1]\npublic key          A cryptographic key that is used with an asymmetric (public-key) cryp-\n                    tographic algorithm and is associated with a private key. The public\n                    key is associated with an owner and may be made public. In the case\n                    of digital signatures, the public key is used to verify a digital signature\n                    that was generated using the corresponding private key. [1]\n\n3"}
{"doc_id": "NIST.FIPS.205", "source_path": "data/raw_pdfs/NIST.FIPS.205.pdf", "page_number": 14, "text": "FIPS 205                                       STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n\nsecurity category        A number associated with the security strength of a post-quantum\n                         cryptographic algorithm, as specified by NIST (see [9, Sect. 5.6]).\nsecurity strength        A number associated with the amount of work (i.e., the number of\n                         operations) that is required to break a cryptographic algorithm or\n                         system. [1]\nshall                    Used to indicate a requirement of this standard. [1]\nshould                   Used to indicate a strong recommendation but not a requirement of\n                         this standard. Ignoring the recommendation could result in undesir-\n                         able results. [1]\nsignatory                The entity that generates a digital signature on data using a private\n                         key. [1]\nsignature generation     The process of using a digital signature algorithm and a private key to\n                         generate a digital signature on data. [1]\nsignature validation     The (mathematical) verification of the digital signature and obtain-\n                         ing the appropriate assurances (e.g., public-key validity, private-key\n                         possession, etc.). [1]\nsignature verification   The process of using a digital signature algorithm and a public key to\n                         verify a digital signature on data. [1]\nsigned data              The data or message upon which a digital signature has been computed.\n                         Also see message. [1]\nverifier                 The entity that verifies the authenticity of a digital signature using the\n                         public key. [1]\n\n2.2    Acronyms\nADRS                     Address\nADRSá¶œ                    Compressed Address\nAES                      Advanced Encryption Standard\nDER                      Distinguished Encoding Rules\nFIPS                     Federal Information Processing Standard\nFORS                     Forest of Random Subsets\nITL                      Information Technology Laboratory\nMGF                      Mask Generation Function\nNIST                     National Institute of Standards and Technology\nOID                      Object Identifier\nPQC                      Post-Quantum Cryptography\nPRF                      Pseudorandom Function\n\n                                               4"}
{"doc_id": "NIST.FIPS.205", "source_path": "data/raw_pdfs/NIST.FIPS.205.pdf", "page_number": 15, "text": "FIPS 205                              STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n\nSHA            Secure Hash Algorithm\nSHAKE          Secure Hash Algorithm KECCAK\nSP             Special Publication\nRFC            Request for Comments\nWOTSâº          Winternitz One-Time Signature Plus\nXMSS           eXtended Merkle Signature Scheme\nXOF            eXtendable-Output Function\n\n2.3     Mathematical Symbols\nğ‘‹ âˆ¥ ğ‘Œ        The concatenation of two arrays ğ‘‹ and ğ‘Œ. If ğ‘‹ is an array of length â„“ğ‘¥ ,\n               and ğ‘Œ is an array of length â„“ğ‘¦, then ğ‘ = ğ‘‹ âˆ¥ ğ‘Œ is an array of length\n               â„“ğ‘¥ + â„“ğ‘¦ such that\n\n                            ğ‘[ğ‘–] = { ğ‘‹[ğ‘–]          if  0 â‰¤ ğ‘– < â„“ğ‘¥\n                                    ğ‘Œ [ğ‘– âˆ’ â„“ğ‘¥ ]     if  â„“ğ‘¥ â‰¤ ğ‘– < â„“ğ‘¥ + â„“ğ‘¦.\n\nğ‘‹[ğ‘– âˆ¶ ğ‘—]     A subarray of ğ‘‹. If ğ‘‹ is an array of length â„“ğ‘¥ , 0 â‰¤ ğ‘– < ğ‘— â‰¤ â„“ğ‘¥ , and\n               ğ‘Œ   = ğ‘‹[ğ‘– âˆ¶ ğ‘—], then ğ‘Œ is an array of length ğ‘— âˆ’ ğ‘– such that ğ‘Œ [ğ‘˜] =\n               ğ‘‹[ğ‘– + ğ‘˜] for 0 â‰¤ ğ‘˜ < ğ‘— âˆ’ ğ‘–.\nTruncâ„“(ğ‘‹)     A truncation function that outputs the leftmost â„“ bytes of the input\n               byte string ğ‘‹. If ğ‘Œ = Truncâ„“(ğ‘‹), then ğ‘Œ is a byte string (array) of\n               length â„“ such that ğ‘Œ [ğ‘–] = ğ‘‹[ğ‘–] for 0 â‰¤ ğ‘– < â„“ (i.e., ğ‘Œ = ğ‘‹[0 âˆ¶ â„“]).\n|ğ‘‹|           The length (in bytes) of byte string ğ‘‹.\nâŒˆğ‘âŒ‰           The ceiling of ğ‘; the smallest integer that is greater than or equal to ğ‘.\n               For example, âŒˆ5âŒ‰ = 5, âŒˆ5.3âŒ‰ = 6, and âŒˆâˆ’2.1âŒ‰ = âˆ’2. [1]\nâŒŠğ‘âŒ‹           The floor of ğ‘; the largest integer that is less than or equal to ğ‘. For\n               example, âŒŠ5âŒ‹ = 5, âŒŠ5.3âŒ‹ = 5, and âŒŠâˆ’2.1âŒ‹ = âˆ’3. [1]\nğ‘ mod ğ‘›      The unique remainder ğ‘Ÿ, 0 â‰¤ ğ‘Ÿ â‰¤ (ğ‘› âˆ’ 1), when integer ğ‘ is divided\n               by the positive integer ğ‘›. For example, 23 mod 7 = 2. [1]\nğ‘ â‹… ğ‘        The product of ğ‘ and ğ‘. For example, 3 â‹… 5 = 15.\nğ‘ğ‘           ğ‘ raised to the power ğ‘. For example, 2âµ = 32.\nlogâ‚‚ ğ‘¥        The base 2 logarithm of ğ‘¥. For example, logâ‚‚(16) = 4.\n0b             The prefix to a number that is represented in binary.\n0x             The prefix to a number that is represented in hexadecimal. [1, adapted]\nğ‘ â‰« ğ‘        The logical right shift of ğ‘ by ğ‘ positions (i.e., ğ‘ â‰« ğ‘ =   ğ‘\n                                                                                âŒŠğ‘/2 âŒ‹). For\n               example, 0x73 â‰« 4 = 7. [10, adapted]\n\n                                     5"}
{"doc_id": "NIST.FIPS.205", "source_path": "data/raw_pdfs/NIST.FIPS.205.pdf", "page_number": 16, "text": "FIPS 205      STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n\nğ‘ â‰ª ğ‘       The logical left shift of ğ‘ by ğ‘ positions (i.e., ğ‘ â‰ª ğ‘ = ğ‘ â‹… 2ğ‘). For\n              example, 0x73 â‰ª 4 = 0x730. [10, adapted]\nğ‘ âŠ• ğ‘       The bitwise exclusive-or of ğ‘ and ğ‘. For example, 115 âŠ• 1 = 114\n              (115 âŠ• 1 = 0b01110011 âŠ• 0b00000001 = 0b01110010 = 114).\nğ‘  â† ğ‘¥       In pseudocode, this notation means that the variable ğ‘  is set to the\n              value of the expression ğ‘¥.\nğ‘    $      ğ‘›\n   â†\n     âˆ’ ğ”¹     In pseudocode, this notation means that the variable ğ‘  is set to a\n              byte string of length ğ‘› chosen at random. A fresh random value is\n              generated for each time this step is performed.\nâŠ¥             A symbol indicating failure or the lack of output from an algorithm.\n\n6"}
{"doc_id": "NIST.FIPS.205", "source_path": "data/raw_pdfs/NIST.FIPS.205.pdf", "page_number": 17, "text": "FIPS 205                                STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n\n3.  Overview of the SLH-DSA Signature Scheme\n\nSLH-DSA is a stateless hash-based signature scheme that is constructed using other hash-based\nsignature schemes as components: (1) a few-time signature scheme, forest of random subsets\n(FORS), and (2) a multi-time signature scheme, the eXtended Merkle Signature Scheme (XMSS).\n                              XMSS is constructed using the hash-based one-time signature scheme Winternitz One-Time\nSignature Plus (WOTSâº) as a component.Â²\nConceptually, an SLH-DSA key pair consists of a very large set of FORS key pairs.Â³ The few-time\nsignature scheme FORS allows each key pair to safely sign a small number of messages. An\nSLH-DSA signature is created by computing a randomized hash of the message, using part of the\nresulting message digest to pseudorandomly select a FORS key, and signing the remaining part of\nthe message digest with that key. An SLH-DSA signature consists of the FORS signature and the\ninformation that authenticates the FORS public key. The authentication information is created\nusing XMSS signatures.\n                         XMSS is a multi-time signature scheme that is created using a combination of WOTSâº one-time\nsignatures and Merkle hash trees [13]. An XMSS key consists of 2â„â€² WOTSâº keys and can sign\n2â„â€² messages. The WOTSâº public keys are formed into a Merkle hash tree, and the root of the\ntree is the XMSS public key. (The Merkle hash tree formed from the WOTSâº keys is also referred\nto as an XMSS tree.) An XMSS signature consists of a WOTSâº signature and an authentication\npath within the Merkle hash tree for the WOTSâº public key.                          In Figure 1, triangles represent\n                       XMSS trees, squares represent the WOTSâº public keys, and circles represent the interior nodes\nof the hash tree.                       Within an XMSS tree, the square and circles that are filled in represent the\nauthentication path for the WOTSâº public key needed to verify the signature.\n                     The authentication information for a FORS public key is a hypertree signature. A hypertree is a\ntree of XMSS trees, as depicted in Figure 1. The tree consists of ğ‘‘ layersâ´ in which the top layer\n(layer ğ‘‘ âˆ’ 1) consists of a single XMSS tree, the next layer down (layer ğ‘‘ âˆ’ 2) consists of 2â„â€²\n                  XMSS trees, and the lowest layer (layer 0) consists of 2(ğ‘‘âˆ’1)â„â€² XMSS trees. The public key of each\nXMSS key at layers 0 through ğ‘‘ âˆ’ 2 is signed by an XMSS key at the next higher layer. The XMSS\nkeys at layer 0 collectively have 2ğ‘‘â„â€²                          = 2â„ WOTSâº keys, which are used to sign the 2â„ FORS\npublic keys in the SLH-DSA key pair. The sequence of ğ‘‘ XMSS signatures needed to authenticate\na FORS public key when starting with the public key of the XMSS key at layer ğ‘‘ âˆ’ 1 is a hypertree\nsignature. An SLH-DSA signature consists of a FORS signature along with a hypertree signature.\n                         An SLH-DSA public key (Figure 16) contains two ğ‘›-byte components: (1) PK.root, which is the\npublic key of the XMSS key at layer ğ‘‘ âˆ’ 1, and (2) PK.seed, which is used to provide domain\nseparation between different SLH-DSA key pairs. An SLH-DSA private key (Figure 15) consists of\nan ğ‘›-byte seed SK.seed that is used to pseudorandomly generate all of the secret values for the\n                       WOTSâº and FORS keys and an ğ‘›-byte key SK.prf that is used in the generation of the randomized\nhash of the message. An SLH-DSA private key also includes copies of PK.root and PK.seed, as\nthese values are needed during both signature generation and signature verification.\n\n2The WOTS+ and XMSS schemes that are used as components of SLH-DSA are not the same as the WOTS+ and\nXMSS schemes in RFC 8391 [11] and SP 800-208 [12].\n3For the parameter sets in this standard, an SLH-DSA key pair contains 263 , 264 , 266 , or 268 FORS keys, which are\npseudorandomly generated from a single seed.\n4For the parameter sets in this standard, ğ‘‘ is 7, 8, 17, or 22.\n                                                  7"}
{"doc_id": "NIST.FIPS.205", "source_path": "data/raw_pdfs/NIST.FIPS.205.pdf", "page_number": 18, "text": "    FIPS 205    STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n\n                PK.root\n\n                layer ğ‘‘ âˆ’ 1 = 2\n\n    WOTSâº signature\n\n    layer 1\n\n                   Merkle tree node\nWOTSâº signature    WOTSâº public key\n\n        layer 0    FORS public key\n\n    WOTSâº signature\n\n    FORS signature\n    Message\n\n                          Figure 1. An SLH-DSA signature\n\n    The WOTSâº one-time signature scheme is specified in Section 5, and the XMSS multi-time sig-\n    nature scheme is specified in Section 6. Section 7 specifies the generation and verification of\n    hypertree signatures. The FORS few-time signature scheme is specified in Section 8.   Finally,\n    Section 9 specifies the SLH-DSA key generation, signature, and verification functions. As the\n     WOTSâº, XMSS, hypertree, and FORS schemes described in this standard are not intended for\n    use as stand-alone signature schemes, only the components of the schemes necessary to imple-\n    ment SLH-DSA are described. In particular, these sections do not include functions for key pair\n    generation, and a signature verification function is only specified for hypertree signatures.\n    When used in this standard, WOTSâº, XMSS, and FORS signatures are implicitly verified using\n    functions to generate public keys from messages and signatures (see Sections 5.3, 6.3, and\n    8.4). When verifying an SLH-DSA signature, the randomized hash of the message and the FORS\n    signature are used to compute a candidate FORS public key. The candidate FORS public key and\n    the WOTSâº signature from the layer 0 XMSS key are used to compute a candidate WOTSâº public\n    key, which is then used in conjunction with the corresponding authentication path to compute a\n    candidate XMSS public key. The candidate layer 0 XMSS public key is used along with the layer 1\n\n                                                8"}
{"doc_id": "NIST.FIPS.205", "source_path": "data/raw_pdfs/NIST.FIPS.205.pdf", "page_number": 19, "text": "FIPS 205                             STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n\nXMSS signature to compute a candidate layer 1 XMSS public key. This process is repeated until a\ncandidate layer ğ‘‘ âˆ’ 1 public key has been computed. SLH-DSA signature verification succeeds if\nthe computed candidate layer ğ‘‘ âˆ’ 1 XMSS public key is the same as the SLH-DSA public key root\nPK.root.\n\n3.1  Additional Requirements\nThis section specifies requirements for cryptographic modules that implement SLH-DSA. Sec-\ntion 3.2 discusses issues that implementers of cryptographic modules should take into considera-\ntion but that are not requirements. SP 800-89, Recommendation for Obtaining Assurances for\nDigital Signature Applications [3], specifies requirements that apply to the use of digital signature\nschemes.\n\nRandomness generation. SLH-DSA key generation (Algorithm 21) requires the generation of three\nrandom ğ‘›-byte values: PK.seed, SK.seed, and SK.prf, where ğ‘› is 16, 24, or 32, depending on\nthe parameter set. For each invocation of key generation, each of these values shall be a fresh\n(i.e., not previously used) random value generated using an approved random bit generator\n(RBG), as prescribed in SP 800-90A, SP 800-90B, and SP 800-90C [14, 15, 16]. Moreover, the RBG\nused shall have a security strength of at least 8ğ‘› bits. See Table 2 for the value of ğ‘› for each\nparameter set.\n\nDestruction of sensitive data. Data used internally by key generation and signing algorithms in\nintermediate computation steps could be used by an adversary to gain information about the\nprivate key and thereby compromise security. The data used internally by verification algorithms\nis similarly sensitive for some applications, including the verification of signatures that are used as\nbearer tokens (i.e., authentication secrets) or signatures on plaintext messages that are intended\nto be confidential. Intermediate values of the verification algorithm may reveal information\nabout its inputs (i.e., the message, signature, and public key), and in some applications, security\nor privacy requires one or more of these inputs to be confidential. Therefore, implementations of\nSLH-DSA shall ensure that any local copies of the inputs and any potentially sensitive intermediate\ndata are destroyed as soon as they are no longer needed.\n\nKey checks. SP 800-89 imposes requirements for the assurance of public-key validity and private-\nkey possession. In the case of SLH-DSA, where public-key validation is required, implementations\nshall verify that the public key is 2ğ‘› bytes in length. When the assurance of private key possession\nis obtained via regeneration, the owner of the private key shall check that the private key is 4ğ‘›\nbytes in length and shall use SK.seed and PK.seed to recompute PK.root and compare the\nnewly generated value with the value in the private key currently held.\n\nFloating-point arithmetic. Implementations of SLH-DSA shall not use floating-point arithmetic,\nas rounding errors in floating point operations may lead to incorrect results in some cases. In all\npseudocode in this standard in which division is performed (e.g., ğ‘¥/ğ‘¦) and ğ‘¦ may not divide ğ‘¥,\neither âŒŠğ‘¥/ğ‘¦âŒ‹ or âŒˆğ‘¥/ğ‘¦âŒ‰ is used. Both of these can be computed without floating-point arithmetic,\nas ordinary integer division ğ‘¥/ğ‘¦ computes âŒŠğ‘¥/ğ‘¦âŒ‹, and âŒˆğ‘¥/ğ‘¦âŒ‰ = âŒŠ(ğ‘¥ + ğ‘¦ âˆ’ 1)/ğ‘¦âŒ‹ for non-negative\nintegers ğ‘¥ and positive integers ğ‘¦.\n\n9"}
{"doc_id": "NIST.FIPS.205", "source_path": "data/raw_pdfs/NIST.FIPS.205.pdf", "page_number": 20, "text": "FIPS 205                                                 STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n\nWhile the value of ğ‘™ğ‘’ğ‘›â‚‚ (see Equation 5.3) may be computed without using floating-point arith-\nmetic (see Algorithm 1), it is recommended that this value be precomputed. For all parameter\nsets in this standard, ğ‘™ğ‘’ğ‘›â‚‚ is 3.\n\nAlgorithm 1 gen_lenâ‚‚ (ğ‘›, ğ‘™ğ‘”ğ‘¤)\nComputes ğ‘™ğ‘’ğ‘›â‚‚ (Equation 5.3).\nInput: Security parameter ğ‘›, bits per hash chain ğ‘™ğ‘”ğ‘¤.\nOutput: ğ‘™ğ‘’ğ‘›â‚‚.\n 1:    ğ‘¤ â† 2ğ‘™ğ‘”ğ‘¤                                                   â–· Equation 5.1\n 2:    ğ‘™ğ‘’ğ‘›â‚ â† âŒŠ 8â‹…ğ‘›+ğ‘™ğ‘”ğ‘¤âˆ’1 âŒ‹                                    â–· Equation 5.2\n                       ğ‘™ğ‘”ğ‘¤\n 3:    ğ‘šğ‘ğ‘¥_ğ‘â„ğ‘’ğ‘ğ‘˜ğ‘ ğ‘¢ğ‘š = ğ‘™ğ‘’ğ‘›â‚ â‹… (ğ‘¤ âˆ’ 1)       â–· maximum possible checksum value\n 4:    ğ‘™ğ‘’ğ‘›â‚‚ â† 1                                       â–· maximum value that may be signed using\n 5:    ğ‘ğ‘ğ‘ğ‘ğ‘ğ‘–ğ‘¡ğ‘¦ â† ğ‘¤                             â–· ğ‘™ğ‘’ğ‘›â‚‚ hash chains is ğ‘¤ğ‘™ğ‘’ğ‘›â‚‚ âˆ’ 1 = ğ‘ğ‘ğ‘ğ‘ğ‘ğ‘–ğ‘¡ğ‘¦ âˆ’ 1\n 6:    while ğ‘ğ‘ğ‘ğ‘ğ‘ğ‘–ğ‘¡ğ‘¦ â‰¤ ğ‘šğ‘ğ‘¥_ğ‘â„ğ‘’ğ‘ğ‘˜ğ‘ ğ‘¢ğ‘š do\n 7:     ğ‘™ğ‘’ğ‘›â‚‚ â† ğ‘™ğ‘’ğ‘›â‚‚ + 1\n 8:     ğ‘ğ‘ğ‘ğ‘ğ‘ğ‘–ğ‘¡ğ‘¦ â† ğ‘ğ‘ğ‘ğ‘ğ‘ğ‘–ğ‘¡ğ‘¦ â‹… ğ‘¤\n 9:    end while\n10:    return ğ‘™ğ‘’ğ‘›â‚‚\n\n3.2    Implementation Considerations\nThis section discusses some implementation considerations for SLH-DSA.\n\nDo not support component use. As WOTSâº, XMSS, FORS, and hypertree signature schemes are\nnot approved for use as stand-alone signature schemes, cryptographic modules should not make\ninterfaces to these components available to applications. SP 800-208 [12] specifies approved\nstateful hash-based signature schemes.\n\nSide-channel and fault attacks. For signature schemes, the secrecy of the private key is critical.\nCare must be taken to protect implementations against attacks, such as side-channel attacks\nor fault attacks [17, 18, 19, 20, 21]. A cryptographic device may leak critical information with\nside-channel analysis or attacks that allow internal data or keying material to be extracted without\nbreaking the cryptographic primitives.\n\n10"}
{"doc_id": "NIST.FIPS.205", "source_path": "data/raw_pdfs/NIST.FIPS.205.pdf", "page_number": 21, "text": "FIPS 205                                      STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n\n4.   Functions and Addressing\n\n4.1  Hash Functions and Pseudorandom Functions\nThe specification of SLH-DSA makes use of six functions â€” PRFğ‘šğ‘ ğ‘”, Hğ‘šğ‘ ğ‘”, PRF, Tâ„“, H, and\nF â€” that are all implemented using hash functions or XOFs with fixed output lengths. The inputs\nand output of each function are byte strings. In the following definitions, ğ”¹ = {0, â€¦ , 255}\ndenotes the set of all bytes, ğ”¹ğ‘› denotes the set of byte strings of length ğ‘› bytes, and ğ”¹âˆ— denotes\nthe set of all byte strings. The ADRS input is described in Section 4.2.\n    â€¢ PRFğ‘šğ‘ ğ‘”(SK.prf, ğ‘œğ‘ğ‘¡_ğ‘Ÿğ‘ğ‘›ğ‘‘, ğ‘€ ) (ğ”¹ğ‘› Ã— ğ”¹ğ‘› Ã— ğ”¹âˆ— â†’ ğ”¹ğ‘›) is a pseudorandom function\n     (PRF) that generates the randomizer (ğ‘…) for the randomized hashing of the message to be\n     signed.\n    â€¢ Hğ‘šğ‘ ğ‘”(ğ‘…, PK.seed, PK.root, ğ‘€ ) (ğ”¹ğ‘› Ã— ğ”¹ğ‘› Ã— ğ”¹ğ‘› Ã— ğ”¹âˆ— â†’ ğ”¹ğ‘š ) is used to generate the\n     digest of the message to be signed.\n    â€¢ PRF(PK.seed, SK.seed, ADRS) (ğ”¹ğ‘› Ã— ğ”¹ğ‘› Ã— ğ”¹Â³Â²            â†’ ğ”¹ğ‘›) is a PRF that is used to\n     generate the secret values in WOTSâº and FORS private keys.\n    â€¢ Tâ„“(PK.seed, ADRS, ğ‘€â„“) (ğ”¹ğ‘› Ã— ğ”¹Â³Â² Ã— ğ”¹â„“ğ‘› â†’ ğ”¹ğ‘›) is a hash function that maps an\n     â„“ğ‘›-byte message to an ğ‘›-byte message.\n    â€¢ H(PK.seed, ADRS, ğ‘€â‚‚) (ğ”¹ğ‘› Ã— ğ”¹Â³Â² Ã— ğ”¹2ğ‘› â†’ ğ”¹ğ‘›) is a special case of Tâ„“ that takes a\n     2ğ‘›-byte message as input.\n    â€¢ F(PK.seed, ADRS, ğ‘€â‚) (ğ”¹ğ‘› Ã— ğ”¹Â³Â² Ã— ğ”¹ğ‘› â†’ ğ”¹ğ‘›) is a hash function that takes an ğ‘›-byte\n     message as input and produces an ğ‘›-byte output.\nThe specific instantiations for these functions differ for different parameter sets and are specified\nin Section 11.\n\n4.2  Addresses\nFour of the functions described in Section 4.1 take a 32-byte address (i.e., ADRS) as input. An\nADRS consists of public values that indicate the position of the value being computed by the\nfunction. A different ADRS value is used for each call to each function. In the case of PRF,\nthis is used to generate a large number of different secret values from a single seed. In the case\nof Tâ„“, H, and F, it is used to mitigate multi-target attacks. In the pseudocode, where addresses\nare passed as parameters, they may be passed either by reference or by value.\nThe structure of an ADRS conforms to word boundaries, with each word being 4 bytes long\nand values encoded as unsigned integers in big-endian byte order (see Figure 2). The first word\nof ADRS specifies the layer address, which is the height of an XMSS tree within the hypertree.\nTrees on the bottom layer have a height of zero, and the single XMSS tree at the top has a height\nof ğ‘‘ âˆ’ 1 (see Figure 1). The next three words of ADRS specify the tree address, which is the\nposition of an XMSS tree within a layer of the hypertree. The leftmost XMSS tree in a layer has a\ntree address of zero, and the rightmost XMSS tree in layer ğ¿ has a tree address of 2(ğ‘‘âˆ’1âˆ’ğ¿)â„â€² âˆ’ 1.\nThe next word is used to specify the type of the address, which differs depending on the use case.\n\n                                            11"}
{"doc_id": "NIST.FIPS.205", "source_path": "data/raw_pdfs/NIST.FIPS.205.pdf", "page_number": 22, "text": "FIPS 205    STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n\nThere are seven different types of address used in SLH-DSA, as described below.âµ The address\ntype determines how the final 12 bytes of the address are to be interpreted. The algorithms\nin this standard are written based on the assumption that whenever the type in an ADRS is\nchanged, the final 12 bytes of the address are initialized to zero.\n\n                            layer address            4 bytes\n\n                             tree address           12 bytes\n\n                                       ğ‘¡ğ‘¦ğ‘ğ‘’      4 bytes\n\n                                                    12 bytes\n\n                                                                Figure 2. Address (ADRS)\n\n                            The type is set to WOTS_HASH (i.e., ğ‘¡ğ‘¦ğ‘ğ‘’ = 0) for a WOTSâº hash address (see Figure 3), which is\nused when computing hash chains in WOTSâº. When type is WOTS_HASH, the next word encodes\nthe key pair address, which is the index of the WOTSâº key pair within the XMSS tree specified\nby the layer and tree addresses, with the leftmost WOTSâº key having an index of zero and the\nrightmost WOTSâº key having an index of 2â„â€² âˆ’ 1. Next is the chain address, which encodes the\nindex of the chain within WOTSâº, followed by the hash address, which encodes the address of\nthe hash function within the chain.\n layer address                                                layer address\n\n tree address                                                  tree address\n\n ğ‘¡ğ‘¦ğ‘ğ‘’ = 0 (WOTS_HASH)                                   ğ‘¡ğ‘¦ğ‘ğ‘’ = 1 (WOTS_PK)\n   key pair address         4 bytes                          key pair address  4 bytes\n    chain address           4 bytes                            ğ‘ğ‘ğ‘‘ğ‘‘ğ‘–ğ‘›ğ‘” = 0  8 bytes\n     hash address           4 bytes\n\n Figure 3. WOTSâº hash address          Figure 4. WOTSâº public-key compression address\n\nThe type is set to WOTS_PK (i.e., ğ‘¡ğ‘¦ğ‘ğ‘’ = 1) when compressing WOTSâº public keys (see Figure 4).\n                              As when the type is WOTS_HASH, the next word encodes the index of the WOTSâº key pair within\nthe XMSS tree specified by the layer and tree addresses. The remaining two words of ADRS\nare not needed and are set to zero.\n                              The type is set to TREE (i.e., ğ‘¡ğ‘¦ğ‘ğ‘’ = 2) when computing the hashes within the XMSS tree (see\nFigure 5). For this type of address, the next word is always set to zero. The following word\n5The type word will have a value of 0, 1, 2, 3, 4, 5, or 6. In order to improve readability, these values will be\n referred to in this standard by the constants WOTS_HASH, WOTS_PK, TREE, FORS_TREE, FORS_ROOTS, WOTS_PRF,\n and FORS_PRF, respectively.\n                                                 12"}
{"doc_id": "NIST.FIPS.205", "source_path": "data/raw_pdfs/NIST.FIPS.205.pdf", "page_number": 23, "text": "FIPS 205                                     STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n\nencodes the height of the node within the tree that is being computed, and the final word\nencodes the index of the node at that height.\n\n                            layer address\n\n                             tree address\n\n                           ğ‘¡ğ‘¦ğ‘ğ‘’ = 2 (TREE)\n                             ğ‘ğ‘ğ‘‘ğ‘‘ğ‘–ğ‘›ğ‘” = 0     4 bytes\n                             tree height            4 bytes\n                              tree index            4 bytes\n\n                                                             Figure 5. Hash tree address\n\n                            The type is set to FORS_TREE (i.e., ğ‘¡ğ‘¦ğ‘ğ‘’ = 3) when computing hashes within the FORS tree (see\n                            Figure 6). The next word is the key pair address, which encodes the FORS key that is used. The\n                              value is the same as the key pair address for the WOTSâº key used to sign the FORS key (see\n                            Figure 3 and Figure 4). The next two words â€” the tree height and tree index â€” encode the node\nwithin the FORS tree that is being computed. The tree height starts with zero for the leaf nodes.\n                            The tree index is counted continuously across the ğ‘˜ different FORS trees. The leftmost node in\n                           the leftmost tree has an index of zero, and the rightmost node in the rightmost tree at level ğ‘—\nhas an index of ğ‘˜ â‹… 2(ğ‘âˆ’ğ‘—) âˆ’ 1, where ğ‘ is the height of the tree.\n\n layer address = 0                                    layer address = 0\n\n    tree address                                         tree address\n\nğ‘¡ğ‘¦ğ‘ğ‘’ = 3 (FORS_TREE)                            ğ‘¡ğ‘¦ğ‘ğ‘’ = 4 (FORS_ROOTS)\n  key pair address         4 bytes                     key pair address  4 bytes\n    tree height            4 bytes                       ğ‘ğ‘ğ‘‘ğ‘‘ğ‘–ğ‘›ğ‘” = 0  8 bytes\n            tree index     4 bytes\n\n            Figure 6. FORS tree address      Figure 7. FORS tree roots compression address\n\n                              The type is set to FORS_ROOTS (i.e., ğ‘¡ğ‘¦ğ‘ğ‘’ = 4) when compressing the ğ‘˜ FORS tree roots (see\n                            Figure 7). The next word is the key pair address, which has the same meaning as it does in the\nFORS_TREE address. The remaining two words of ADRS are not needed and are set to zero.\n                            The type is set to WOTS_PRF (i.e., ğ‘¡ğ‘¦ğ‘ğ‘’ = 5) when generating secret values for WOTSâº keys (see\n                            Figure 8). The values for the other words in the address are set to the same values as for the\nWOTS_HASH address (Figure 3) used for the chain. The hash address is always set to zero.\n\n13"}
{"doc_id": "NIST.FIPS.205", "source_path": "data/raw_pdfs/NIST.FIPS.205.pdf", "page_number": 24, "text": "    FIPS 205                                    STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n\n                layer address                  layer address = 0\n\n                tree address                      tree address\n\n     ğ‘¡ğ‘¦ğ‘ğ‘’ = 5 (WOTS_PRF)                  ğ‘¡ğ‘¦ğ‘ğ‘’ = 6 (FORS_PRF)\n       key pair address              4 bytes    key pair address          4 bytes\n        chain address                4 bytes    tree height = 0           4 bytes\n                hash address = 0     4 bytes       tree index             4 bytes\n\n     Figure 8. WOTSâº key generation address     Figure 9. FORS key generation address\n\n    The type is set to FORS_PRF (i.e., ğ‘¡ğ‘¦ğ‘ğ‘’ = 6) when generating secret values for FORS keys (see\n    Figure 9). The values for the other words in the address are set to the same values as for the\n    FORS_TREE address (Figure 6) used for the same leaf node.\n\n    4.3  Member Functions\n    The algorithms in this standard make use of member functions. If a complex data structure\n    (e.g., an ADRS) contains a component ğ‘‹, then ADRS.getX() returns the value of ğ‘‹, and\n    ADRS.setX(ğ‘Œ) sets the component ğ‘‹ in ADRS to the value held by ğ‘Œ. If a data structure ğ‘ \n    contains multiple instances of ğ‘‹, then ğ‘ .getX(ğ‘–) returns the value of the ğ‘–áµ—Ê° instance of ğ‘‹ in ğ‘ .\n    For example, if ğ‘  is a FORS signature (Figure 14), then ğ‘ .getAUTH(ğ‘–) returns the authentication\n    path for the ğ‘–áµ—Ê° tree.\n    Whenever the type in an address changes, the final 12 bytes of the address are initialized to zero.\n    The member function ADRS.setTypeAndClear(ğ‘Œ) for addresses sets the ğ‘¡ğ‘¦ğ‘ğ‘’ of the ADRS to\n    ğ‘Œ and sets the final 12 bytes of the ADRS to zero.â¶\n    Table 1 shows alternative notation for each of the member functions that operates on addresses.\n\n                                 Table 1. Member functions for addresses\n\nMember function\nADRS.setLayerAddress(ğ‘™)\nADRS.setTreeAddress(ğ‘¡)\nADRS.setTypeAndClear(ğ‘Œ)\nADRS.setKeyPairAddress(ğ‘–)\nADRS.setChainAddress(ğ‘–)\nADRS.setTreeHeight(ğ‘–)\nADRS.setHashAddress(ğ‘–)\nADRS.setTreeIndex(ğ‘–)\nğ‘– â† ADRS.getKeyPairAddress()\nğ‘– â† ADRS.getTreeIndex()\n Expanded notation\nADRS â† toByte(ğ‘™, 4) âˆ¥ ADRS[4 âˆ¶ 32]\nADRS â† ADRS[0 âˆ¶ 4] âˆ¥ toByte(ğ‘¡, 12) âˆ¥ ADRS[16 âˆ¶ 32]\nADRS â† ADRS[0 âˆ¶ 16] âˆ¥ toByte(ğ‘Œ , 4) âˆ¥ toByte(0, 12)\nADRS â† ADRS[0 âˆ¶ 20] âˆ¥ toByte(ğ‘–, 4) âˆ¥ ADRS[24 âˆ¶ 32]\nADRS â† ADRS[0 âˆ¶ 24] âˆ¥ toByte(ğ‘–, 4) âˆ¥ ADRS[28 âˆ¶ 32]\n\nADRS â† ADRS[0 âˆ¶ 28] âˆ¥ toByte(ğ‘–, 4)\n\nğ‘– â† toInt(ADRS[20 âˆ¶ 24], 4)\nğ‘– â† toInt(ADRS[28 âˆ¶ 32], 4)\n\n                                       6As noted in Section 4.2, the type (ğ‘Œ) is an integer. However, in the pseudocode, the constants WOTS_HASH, WOTS_PK,\n    TREE, FORS_TREE, FORS_ROOTS, WOTS_PRF, and FORS_PRF are used in order to improve readability.\n                                                                                                14"}
{"doc_id": "NIST.FIPS.205", "source_path": "data/raw_pdfs/NIST.FIPS.205.pdf", "page_number": 25, "text": "FIPS 205                                           STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n\n4.4    Arrays, Byte Strings, and Integers\nIf ğ‘‹ is a byte string of length ğ‘›, then ğ‘‹[ğ‘–] for ğ‘– âˆˆ {0, â€¦ , ğ‘› âˆ’ 1} will refer to the ğ‘–áµ—Ê° element in\nthe string ğ‘‹. If ğ‘‹ is an array of ğ‘š ğ‘›-byte strings, then ğ‘‹[ğ‘–] for ğ‘– âˆˆ {0, â€¦ , ğ‘š âˆ’ 1} will refer to\nthe ğ‘–áµ—Ê° ğ‘›-byte string in ğ‘‹, and ğ‘‹ will refer to the ğ‘š â‹… ğ‘›-byte string ğ‘‹[0] âˆ¥ ğ‘‹[1] âˆ¥ â€¦ ğ‘‹[ğ‘š âˆ’ 1].\n        A byte string may be interpreted as the big-endian representation of an integer. In such cases, a\nbyte string ğ‘‹ of length ğ‘› is converted to the integer\n\n                           ğ‘‹[0] â‹… 256ğ‘›âˆ’1 + ğ‘‹[1] â‹… 256ğ‘›âˆ’2 + â€¦ ğ‘‹[ğ‘› âˆ’ 2] â‹… 256 + ğ‘‹[ğ‘› âˆ’ 1].\n\nSimilarly, an integer ğ‘¥ may be converted to a byte string of length ğ‘› by finding coefficients\nğ‘¥â‚€, ğ‘¥â‚, â€¦ ğ‘¥ğ‘›âˆ’2, ğ‘¥ğ‘›âˆ’1 âˆˆ {0, â€¦ , 255} such that\n\n                        ğ‘¥ = ğ‘¥â‚€ â‹… 256ğ‘›âˆ’1 + ğ‘¥â‚ â‹… 256ğ‘›âˆ’2 + â€¦ ğ‘¥ğ‘›âˆ’2 â‹… 256 + ğ‘¥ğ‘›âˆ’1\n\nand then setting the byte string to be ğ‘¥â‚€ğ‘¥â‚ â€¦ ğ‘¥ğ‘›âˆ’2ğ‘¥ğ‘›âˆ’1.\nAlgorithm 2 is a function that converts a byte string ğ‘‹ of length ğ‘› to an integer, and Algorithm 3\nis a function that converts an integer ğ‘¥ to a byte string of length ğ‘›.\n\nAlgorithm 2 toInt(ğ‘‹, ğ‘›)\nConverts a byte string to an integer.\nInput: ğ‘›-byte string ğ‘‹.\nOutput: Integer value of ğ‘‹.\n 1:    ğ‘¡ğ‘œğ‘¡ğ‘ğ‘™ â† 0\n 2:    for ğ‘– from 0 to ğ‘› âˆ’ 1 do\n 3:         ğ‘¡ğ‘œğ‘¡ğ‘ğ‘™ â† 256 â‹… ğ‘¡ğ‘œğ‘¡ğ‘ğ‘™ + ğ‘‹[ğ‘–]\n 4:    end for\n 5:    return ğ‘¡ğ‘œğ‘¡ğ‘ğ‘™\n\nAlgorithm 3 toByte(ğ‘¥, ğ‘›)\nConverts an integer to a byte string.\nInput: Integer ğ‘¥, string length ğ‘›.\nOutput: Byte string of length ğ‘› containing binary representation of ğ‘¥ in big-endian byte-order.\n 1:    ğ‘¡ğ‘œğ‘¡ğ‘ğ‘™ â† ğ‘¥\n 2:    for ğ‘– from 0 to ğ‘› âˆ’ 1 do\n 3:     ğ‘†[ğ‘› âˆ’ 1 âˆ’ ğ‘–] â† ğ‘¡ğ‘œğ‘¡ğ‘ğ‘™ mod 256                 â–· least significant 8 bits of ğ‘¡ğ‘œğ‘¡ğ‘ğ‘™\n 4:     ğ‘¡ğ‘œğ‘¡ğ‘ğ‘™ â† ğ‘¡ğ‘œğ‘¡ğ‘ğ‘™ â‰« 8\n 5:    end for\n 6:    return ğ‘†\n\n15"}
{"doc_id": "NIST.FIPS.205", "source_path": "data/raw_pdfs/NIST.FIPS.205.pdf", "page_number": 26, "text": "FIPS 205                                                    STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n\nFor the WOTSâº and FORS schemes, the messages to be signed need to be split into a sequence\nof ğ‘-bit strings, where each ğ‘-bit string is interpreted as an integer between 0 and 2ğ‘ âˆ’ 1.â· This\nis the equivalent of creating the base-2ğ‘ representation of the message. The base_2áµ‡ function\n(Algorithm 4) takes a byte string ğ‘‹, a bit string length ğ‘, and an output length ğ‘œğ‘¢ğ‘¡_ğ‘™ğ‘’ğ‘› as input\nand returns an array of base-2ğ‘ integers that represent the first ğ‘œğ‘¢ğ‘¡_ğ‘™ğ‘’ğ‘› â‹… ğ‘ bits of ğ‘‹ if the\nindividual bytes in ğ‘‹ are encoded as 8-bit strings in big-endian bit order. ğ‘‹ must be at least\nâŒˆğ‘œğ‘¢ğ‘¡_ğ‘™ğ‘’ğ‘› â‹… ğ‘/8âŒ‰ bytes in length. As the value of ğ‘ğ‘–ğ‘¡ğ‘  will never exceed ğ‘ + 7, a ğ‘ + 7-bit unsigned\ninteger is sufficient to store ğ‘¡ğ‘œğ‘¡ğ‘ğ‘™ (i.e., ğ‘¡ğ‘œğ‘¡ğ‘ğ‘™ may be stored as a 32-bit unsigned integer).\n\nAlgorithm 4 base_2áµ‡(ğ‘‹, ğ‘, ğ‘œğ‘¢ğ‘¡_ğ‘™ğ‘’ğ‘›)\nComputes the base 2ğ‘ representation of ğ‘‹.\nInput: Byte string ğ‘‹ of length at least âŒˆ ğ‘œğ‘¢ğ‘¡_ğ‘™ğ‘’ğ‘›â‹…ğ‘ âŒ‰, integer ğ‘, output length ğ‘œğ‘¢ğ‘¡_ğ‘™ğ‘’ğ‘›.\n                                                    8\nOutput: Array of ğ‘œğ‘¢ğ‘¡_ğ‘™ğ‘’ğ‘› integers in the range [0, â€¦ , 2ğ‘ âˆ’ 1].\n 1:    ğ‘–ğ‘› â† 0\n 2:    ğ‘ğ‘–ğ‘¡ğ‘  â† 0\n 3:    ğ‘¡ğ‘œğ‘¡ğ‘ğ‘™ â† 0\n 4:    for ğ‘œğ‘¢ğ‘¡ from 0 to ğ‘œğ‘¢ğ‘¡_ğ‘™ğ‘’ğ‘› âˆ’ 1 do\n 5:     while ğ‘ğ‘–ğ‘¡ğ‘  < ğ‘ do\n 6:         ğ‘¡ğ‘œğ‘¡ğ‘ğ‘™ â† (ğ‘¡ğ‘œğ‘¡ğ‘ğ‘™ â‰ª 8) + ğ‘‹[ğ‘–ğ‘›]\n 7:         ğ‘–ğ‘› â† ğ‘–ğ‘› + 1\n 8:         ğ‘ğ‘–ğ‘¡ğ‘  â† ğ‘ğ‘–ğ‘¡ğ‘  + 8\n 9:     end while\n10:     ğ‘ğ‘–ğ‘¡ğ‘  â† ğ‘ğ‘–ğ‘¡ğ‘  âˆ’ ğ‘\n11:     ğ‘ğ‘ğ‘ ğ‘’ğ‘[ğ‘œğ‘¢ğ‘¡] â† (ğ‘¡ğ‘œğ‘¡ğ‘ğ‘™ â‰« ğ‘ğ‘–ğ‘¡ğ‘ ) mod 2ğ‘\n12:    end for\n13:    return ğ‘ğ‘ğ‘ ğ‘’ğ‘\n\n7ğ‘ will be the value of ğ‘™ğ‘”ğ‘¤ when the base_2b function is used in WOTS+, and ğ‘ will be the value of ğ‘ when the\nbase_2b function is used in FORS. For the parameter sets in this standard, ğ‘™ğ‘”ğ‘¤ is 4, and ğ‘ is 6, 8, 9, 12, or 14.\n16"}
{"doc_id": "NIST.FIPS.205", "source_path": "data/raw_pdfs/NIST.FIPS.205.pdf", "page_number": 27, "text": "FIPS 205                               STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n\n5.   Winternitz One-Time Signature Plus Scheme\n\n     This section describes the WOTSâº one-time signature scheme that is a component of SLH-DSA.\n     WOTSâº uses two parameters. The security parameter ğ‘› is the length in bytes of the messages\n   that may be signed as well as the length of the private key elements, public key elements, and\n   signature elements. For the parameter sets specified in this standard, ğ‘› may be 16, 24, or 32\n   (see Table 2). The second parameter ğ‘™ğ‘”ğ‘¤ indicates the number of bits that are encoded by each\n  hash chain that is used.â¸ ğ‘™ğ‘”ğ‘¤ is 4 for all parameter sets in this standard. These parameters are\nused to compute four additional values:\n\n                                       ğ‘¤ = 2ğ‘™ğ‘”ğ‘¤                              (5.1)\n\n                                           ğ‘™ğ‘’ğ‘›â‚ = âŒˆ 8ğ‘› âŒ‰                     (5.2)\n                                       ğ‘™ğ‘”ğ‘¤\n\n                                ğ‘™ğ‘’ğ‘›â‚‚ = âŒŠ logÂ²(ğ‘™ğ‘’ğ‘›Â¹ â‹… (ğ‘¤ âˆ’ 1)) âŒ‹ + 1       (5.3)\n                                       ğ‘™ğ‘”ğ‘¤\n                                         ğ‘™ğ‘’ğ‘› = ğ‘™ğ‘’ğ‘›â‚ + ğ‘™ğ‘’ğ‘›â‚‚              (5.4)\n\nWhen ğ‘™ğ‘”ğ‘¤ = 4, ğ‘¤ = 16, ğ‘™ğ‘’ğ‘›â‚ = 2ğ‘›, ğ‘™ğ‘’ğ‘›â‚‚ = 3, and ğ‘™ğ‘’ğ‘› = 2ğ‘› + 3.\n A WOTSâº private key consists of ğ‘™ğ‘’ğ‘› secret values of length ğ‘›. In SLH-DSA, these are all generated\n    from an ğ‘›-byte seed SK.seed using a PRF. Chains of length ğ‘¤ are then created from the secret\nvalues using a chaining function, and the end values from each of the chains are public values. The\n  WOTSâº public key is computed as the hash of these public values. In order to create a signature,\n  the 8ğ‘›-bit message is first converted into an array of ğ‘™ğ‘’ğ‘›â‚ base-ğ‘¤ integers. A checksum is then\ncomputed for this string, and the checksum is converted into an array of ğ‘™ğ‘’ğ‘›â‚‚ base-ğ‘¤ integers.\n The signature consists of the appropriate entries from the chains for each of the integers in the\nmessage and checksum arrays.\n   The WOTSâº functions make use of two helper functions: base_2áµ‡ and chain. The base_2áµ‡ function\n   (Section 4.4) is used to break the message to be signed and the checksum value into arrays of\nbase-ğ‘¤ integers. The chain function (Algorithm 5) is used to compute the hash chains.\n  The chain function takes an ğ‘›-byte string ğ‘‹ and integers ğ‘  and ğ‘– (where ğ‘– + ğ‘  < ğ‘¤) as input and\n returns the result of iterating a hash function F on the input ğ‘  times, starting from an index of\nğ‘–.â¹ The chain function also requires as input PK.seed, which is part of the SLH-DSA public key,\nand an address ADRS. The type in ADRS must be set to WOTS_HASH, and the layer address,\n  tree address, key pair address, and chain address must be set to the address of the chain being\n    computed. The chain function updates the hash address in ADRS with each iteration to specify\nthe current position in the chain prior to ADRSâ€™s use in F.\n\n8In [10], the Winternitz parameter ğ‘¤ is used as the second WOTS+ parameter, where ğ‘¤ indicates the length of the\n\n9hash chains that are used. This standard uses the parameter ğ‘™ğ‘”ğ‘¤ = log2(ğ‘¤) to simplify notation.\nA start index of 0 indicates the beginning of the chain.\n                                                        17"}
{"doc_id": "NIST.FIPS.205", "source_path": "data/raw_pdfs/NIST.FIPS.205.pdf", "page_number": 28, "text": "FIPS 205                                               STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n\nAlgorithm 5 chain(ğ‘‹, ğ‘–, ğ‘ , PK.seed, ADRS)\nChaining function used in WOTSâº.\nInput: Input string ğ‘‹, start index ğ‘–, number of steps ğ‘ , public seed PK.seed, address ADRS.\nOutput: Value of F iterated ğ‘  times on ğ‘‹.\n 1:    ğ‘¡ğ‘šğ‘ â† ğ‘‹\n 2:    for ğ‘— from ğ‘– to ğ‘– + ğ‘  âˆ’ 1 do\n 3:     ADRS.setHashAddress(ğ‘—)\n 4:     ğ‘¡ğ‘šğ‘ â† F(PK.seed, ADRS, ğ‘¡ğ‘šğ‘)\n 5:    end for\n 6:    return ğ‘¡ğ‘šğ‘\n\n5.1    WOTS+ Public-Key Generation\nThe wots_pkGen function (Algorithm 6) generates WOTSâº public keys. It takes SK.seed and\nPK.seed from the SLH-DSA private key and an address as input. The type in the address ADRS\nmust be set to WOTS_HASH, and the layer address, tree address, and key pair address must encode\nthe address of the WOTSâº public key to be generated.\nLines 4 through 9 in Algorithm 6 generate the public values, as described in Section 5. For each\nof the ğ‘™ğ‘’ğ‘› public values, the corresponding secret value is generated in lines 5 and 6, and the\nchain function is called to compute the end value of the chain of length ğ‘¤. Once the ğ‘™ğ‘’ğ‘› public\nvalues are computed, they are compressed into a single ğ‘›-byte value in lines 10 through 13.\n\nAlgorithm 6 wots_pkGen(SK.seed, PK.seed, ADRS)\nGenerates a WOTSâº public key.\nInput: Secret seed SK.seed, public seed PK.seed, address ADRS.\nOutput: WOTSâº public key ğ‘ğ‘˜.\n 1:    skADRS â† ADRS                   â–· copy address to create key generation key address\n 2:    skADRS.setTypeAndClear(WOTS_PRF)\n 3:    skADRS.setKeyPairAddress(ADRS.getKeyPairAddress())\n 4:    for ğ‘– from 0 to ğ‘™ğ‘’ğ‘› âˆ’ 1 do\n 5:     skADRS.setChainAddress(ğ‘–)\n 6:     ğ‘ ğ‘˜ â† PRF(PK.seed, SK.seed, skADRS)                â–· compute secret value for chain ğ‘–\n 7:     ADRS.setChainAddress(ğ‘–)\n 8:     ğ‘¡ğ‘šğ‘[ğ‘–] â† chain(ğ‘ ğ‘˜, 0, ğ‘¤ âˆ’ 1, PK.seed, ADRS)  â–· compute public value for chain ğ‘–\n 9:    end for\n10:    wotspkADRS â† ADRS                   â–· copy address to create WOTSâºpublic key address\n11:    wotspkADRS.setTypeAndClear(WOTS_PK)\n12:    wotspkADRS.setKeyPairAddress(ADRS.getKeyPairAddress())\n13:    ğ‘ğ‘˜ â† Tğ‘™ğ‘’ğ‘› (PK.seed, wotspkADRS, ğ‘¡ğ‘šğ‘)           â–· compress public key\n14:    return ğ‘ğ‘˜\n\n18"}
{"doc_id": "NIST.FIPS.205", "source_path": "data/raw_pdfs/NIST.FIPS.205.pdf", "page_number": 29, "text": "FIPS 205                                        STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n\n5.2  WOTS+ Signature Generation\nA WOTSâº signature is an array of ğ‘™ğ‘’ğ‘› byte strings of length ğ‘›, as shown in Figure 10. The wots_sign\nfunction (Algorithm 7) generates the signature by converting the ğ‘›-byte message ğ‘€Â¹â° into an\narray of ğ‘™ğ‘’ğ‘›â‚ base-ğ‘¤ integers (line 2). A checksum is computed over ğ‘€ (lines 3 through 5). The\nchecksum is converted to a byte string, which is then converted into an array of ğ‘™ğ‘’ğ‘›â‚‚ base-ğ‘¤\nintegers (lines 6 and 7). The ğ‘™ğ‘’ğ‘›â‚‚ integers that represent the checksum are appended to the ğ‘™ğ‘’ğ‘›â‚\nintegers that represent the message (line 7).Â¹Â¹ For each of the ğ‘™ğ‘’ğ‘› base-ğ‘¤ integers, the signature\nconsists of the corresponding node in one of the hash chains. For each of these integers, lines\n   12 and 13 compute the secret value for the hash chain, and lines 14 and 15 compute the node in\nthe hash chain that corresponds to the integer. The selected nodes are concatenated to form\nthe WOTSâº signature.\n\n   sigâ‚’â‚œâ‚› [0]                                     ğ‘› bytes\n       â‹¯\nsigâ‚’â‚œâ‚› [ğ‘™ğ‘’ğ‘› âˆ’ 1]                               ğ‘› bytes\n\n                               Figure 10. WOTSâº signature data format\n\nIn addition to the ğ‘›-byte message to be signed, wots_sign takes SK.seed and PK.seed from\nthe SLH-DSA private key and an address as input. The type in the address ADRS must be set to\n    WOTS_HASH, and the layer address, tree address, and key pair address must encode the address\nof the WOTSâº key that is used to sign the message.\n\n10In SLH-DSA, the message ğ‘€ that is signed using WOTS+ is either an XMSS public key or a FORS public key.\n11In the case that ğ‘™ğ‘”ğ‘¤ = 4, the ğ‘›-byte message is converted into an array of 2ğ‘› base-16 integers (i.e., hexadecimal\n digits). The checksum is encoded as two bytes with the least significant four bits being zeros, and the most\n significant 12 bits are appended to the message as an array of three base-16 integers.\n          19"}
{"doc_id": "NIST.FIPS.205", "source_path": "data/raw_pdfs/NIST.FIPS.205.pdf", "page_number": 30, "text": "FIPS 205    STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n\nAlgorithm 7 wots_sign(ğ‘€, SK.seed, PK.seed, ADRS)\nGenerates a WOTSâº signature on an ğ‘›-byte message.\nInput: Message ğ‘€, secret seed SK.seed, public seed PK.seed, address ADRS.\nOutput: WOTSâº signature ğ‘ ğ‘–ğ‘”.\n 1:    ğ‘ğ‘ ğ‘¢ğ‘š â† 0\n 2:    ğ‘šğ‘ ğ‘” â† base_2áµ‡(ğ‘€, ğ‘™ğ‘”ğ‘¤, ğ‘™ğ‘’ğ‘›â‚)                           â–· convert message to base ğ‘¤\n 3:    for ğ‘– from 0 to ğ‘™ğ‘’ğ‘›â‚ âˆ’ 1 do                                                      â–· compute checksum\n 4:     ğ‘ğ‘ ğ‘¢ğ‘š â† ğ‘ğ‘ ğ‘¢ğ‘š + ğ‘¤ âˆ’ 1 âˆ’ ğ‘šğ‘ ğ‘”[ğ‘–]\n 5:    end for\n 6:    ğ‘ğ‘ ğ‘¢ğ‘š â† ğ‘ğ‘ ğ‘¢ğ‘š â‰ª ((8 âˆ’ ((ğ‘™ğ‘’ğ‘›â‚‚ â‹… ğ‘™ğ‘”ğ‘¤) mod 8)) mod 8)  â–· for ğ‘™ğ‘”ğ‘¤ = 4, left shift by 4\n 7:    ğ‘šğ‘ ğ‘” â† ğ‘šğ‘ ğ‘” âˆ¥ base_2áµ‡ (toByte (ğ‘ğ‘ ğ‘¢ğ‘š, âŒˆ ğ‘™ğ‘’ğ‘›Â²â‹…ğ‘™ğ‘”ğ‘¤ âŒ‰) , ğ‘™ğ‘”ğ‘¤, ğ‘™ğ‘’ğ‘›â‚‚)  â–· convert to base ğ‘¤\n                                                 8\n 8:    skADRS â† ADRS                            â–· copy address to create key generation key address\n 9:    skADRS.setTypeAndClear(WOTS_PRF)\n10:    skADRS.setKeyPairAddress(ADRS.getKeyPairAddress())\n11:    for ğ‘– from 0 to ğ‘™ğ‘’ğ‘› âˆ’ 1 do\n12:     skADRS.setChainAddress(ğ‘–)\n13:     ğ‘ ğ‘˜ â† PRF(PK.seed, SK.seed, skADRS)                           â–· compute chain ğ‘– secret value\n14:     ADRS.setChainAddress(ğ‘–)\n15:     ğ‘ ğ‘–ğ‘”[ğ‘–] â† chain(ğ‘ ğ‘˜, 0, ğ‘šğ‘ ğ‘”[ğ‘–], PK.seed, ADRS)  â–· compute chain ğ‘– signature value\n16:    end for\n17:    return ğ‘ ğ‘–ğ‘”\n\n20"}
{"doc_id": "NIST.FIPS.205", "source_path": "data/raw_pdfs/NIST.FIPS.205.pdf", "page_number": 31, "text": "FIPS 205                                         STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n\n5.3    Computing a WOTS+ Public Key From a Signature\n        Verifying a WOTSâº signature involves computing a public-key value from a message and signature\n        value. Verification succeeds if the correct public-key value is computed, which is determined\nby using the computed public-key value along with other information to compute a candidate\nPK.root value and then comparing that value to the known value of PK.root from the SLH-DSA\npublic key. This section describes wots_pkFromSig (Algorithm 8), a function that computes a\ncandidate WOTSâº public key from a WOTSâº signature and corresponding message.\nIn addition to an ğ‘›-byte message ğ‘€ and a ğ‘™ğ‘’ğ‘› â‹… ğ‘›-byte signature ğ‘ ğ‘–ğ‘”, which is interpreted as\nan array of ğ‘™ğ‘’ğ‘› ğ‘›-byte strings, the wots_pkFromSig function takes PK.seed from the SLH-DSA\npublic key and an address as input. The type of the address ADRS must be set to WOTS_HASH,\nand the layer address, tree address, and key pair address must encode the address of the WOTSâº\nkey that was used to sign the message.\nLines 1 through 7 of wots_pkFromSig are the same as lines 1 through 7 of wots_sign (Algorithm 7).\nLines 8 through 11 of wots_pkFromSig compute the end nodes for each of the chains using\nthe signature value as the starting point and the message value to determine the number of\niterations that need to be performed to get to the end node. Finally, as with lines 10 through 13\nof Algorithm 6, the computed public-key values are compressed in lines 12 through 15.\n\nAlgorithm 8 wots_pkFromSig(ğ‘ ğ‘–ğ‘”, ğ‘€, PK.seed, ADRS)\nComputes a WOTSâº public key from a message and its signature.\nInput: WOTSâº signature ğ‘ ğ‘–ğ‘”, message ğ‘€, public seed PK.seed, address ADRS.\nOutput: WOTSâº public key ğ‘ğ‘˜ğ‘ ğ‘–ğ‘” derived from ğ‘ ğ‘–ğ‘”.\n 1:    ğ‘ğ‘ ğ‘¢ğ‘š â† 0\n 2:    ğ‘šğ‘ ğ‘” â† base_2áµ‡(ğ‘€, ğ‘™ğ‘”ğ‘¤, ğ‘™ğ‘’ğ‘›â‚)                           â–· convert message to base ğ‘¤\n 3:    for ğ‘– from 0 to ğ‘™ğ‘’ğ‘›â‚ âˆ’ 1 do                                                      â–· compute checksum\n 4:     ğ‘ğ‘ ğ‘¢ğ‘š â† ğ‘ğ‘ ğ‘¢ğ‘š + ğ‘¤ âˆ’ 1 âˆ’ ğ‘šğ‘ ğ‘”[ğ‘–]\n 5:    end for\n 6:    ğ‘ğ‘ ğ‘¢ğ‘š â† ğ‘ğ‘ ğ‘¢ğ‘š â‰ª ((8 âˆ’ ((ğ‘™ğ‘’ğ‘›â‚‚ â‹… ğ‘™ğ‘”ğ‘¤) mod 8)) mod 8)  â–· for ğ‘™ğ‘”ğ‘¤ = 4, left shift by 4\n 7:    ğ‘šğ‘ ğ‘” â† ğ‘šğ‘ ğ‘” âˆ¥ base_2áµ‡ (toByte (ğ‘ğ‘ ğ‘¢ğ‘š, âŒˆ ğ‘™ğ‘’ğ‘›Â²â‹…ğ‘™ğ‘”ğ‘¤ âŒ‰) , ğ‘™ğ‘”ğ‘¤, ğ‘™ğ‘’ğ‘›â‚‚)  â–· convert to base ğ‘¤\n                                                         8\n 8:    for ğ‘– from 0 to ğ‘™ğ‘’ğ‘› âˆ’ 1 do\n 9:     ADRS.setChainAddress(ğ‘–)\n10:     ğ‘¡ğ‘šğ‘[ğ‘–] â† chain(ğ‘ ğ‘–ğ‘”[ğ‘–], ğ‘šğ‘ ğ‘”[ğ‘–], ğ‘¤ âˆ’ 1 âˆ’ ğ‘šğ‘ ğ‘”[ğ‘–], PK.seed, ADRS)\n11:    end for\n12:    wotspkADRS â† ADRS                        â–· copy address to create WOTSâº public key address\n13:    wotspkADRS.setTypeAndClear(WOTS_PK)\n14:    wotspkADRS.setKeyPairAddress(ADRS.getKeyPairAddress())\n15:    ğ‘ğ‘˜ğ‘ ğ‘–ğ‘” â† Tğ‘™ğ‘’ğ‘› (PK.seed, wotspkADRS, ğ‘¡ğ‘šğ‘)\n16:    return ğ‘ğ‘˜ğ‘ ğ‘–ğ‘”\n\n21"}
{"doc_id": "NIST.FIPS.205", "source_path": "data/raw_pdfs/NIST.FIPS.205.pdf", "page_number": 32, "text": "    FIPS 205                 STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n\n    6.   eXtended Merkle Signature Scheme (XMSS)\n\n    XMSS extends the WOTSâº signature scheme into one that can sign multiple messages. A Merkle\n    tree [13] of height â„â€² is used to allow 2â„â€² WOTSâº public keys to be authenticated using a single\n    ğ‘›-byte XMSS public key, which is the root of the Merkle tree.Â¹Â² As each WOTSâº key may be used\n    to sign one message, the XMSS key may be used to sign 2â„â€² messages.\n    An XMSS signature is (â„â€² + ğ‘™ğ‘’ğ‘›) â‹… ğ‘› bytes in length and consists of a WOTSâº signature and an\n    authentication path (see Figure 11). The authentication path is an array of nodes from the Merkle\n    tree â€” one from each level of the tree, except for the root â€” that allows the verifier to compute\n    the root of the tree when used in conjunction with the WOTSâº public key that can be computed\n    from the WOTSâº signature.\n\n      SIGWOTSâ‚Š               ğ‘™ğ‘’ğ‘› â‹… ğ‘›\n                             bytes\n      AUTH[0]                ğ‘› bytes\n         â‹¯\n    AUTH[â„â€² âˆ’ 1]             ğ‘› bytes\n\n                             Figure 11. XMSS signature data format\n\n    6.1  Generating a Merkle Hash Tree\n    The xmss_node function (Algorithm 9) computes the nodes of an XMSS tree. The xmss_node\n    function takes as input SK.seed and PK.seed from the SLH-DSA private key; a target node index\n    ğ‘–, which is the index of the node being computed; a target node height ğ‘§, which is the height\n    within the Merkle tree of the node being computed; and an address. The address ADRS must\n    have the layer address and tree address set to the XMSS tree within which the node is being\n    computed. The target node height and index must satisfy ğ‘§ â‰¤ â„â€² and ğ‘– < 2(â„â€²âˆ’ğ‘§) .\n    Each node in an XMSS tree is the root of a subtree, and Algorithm 9 computes the root of the\n    subtree recursively. If the subtree consists of a single leaf node, then the function simply returns\n    the value of the nodeâ€™s WOTSâº public key (lines 2 through 4). Otherwise, the function computes\n    the roots of the left subtree (line 6) and right subtree (line 7) and hashes them together (lines 8\n    through 11).\n\n12The Merkle tree formed from the 2â„â€² WOTS+ keys of an XMSS key is referred to in this standard as an XMSS tree.\n                                                       22"}
{"doc_id": "NIST.FIPS.205", "source_path": "data/raw_pdfs/NIST.FIPS.205.pdf", "page_number": 33, "text": "FIPS 205                               STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n\nAlgorithm 9 xmss_node(SK.seed, ğ‘–, ğ‘§, PK.seed, ADRS)\nComputes the root of a Merkle subtree of WOTSâº public keys.\nInput: Secret seed SK.seed, target node index ğ‘–, target node height ğ‘§, public seed PK.seed,\n       address ADRS.\nOutput: ğ‘›-byte root ğ‘›ğ‘œğ‘‘ğ‘’.\n 1:    if ğ‘§ = 0 then\n 2:     ADRS.setTypeAndClear(WOTS_HASH)\n 3:     ADRS.setKeyPairAddress(ğ‘–)\n 4:     ğ‘›ğ‘œğ‘‘ğ‘’ â† wots_pkGen(SK.seed, PK.seed, ADRS)\n 5:    else\n 6:     ğ‘™ğ‘›ğ‘œğ‘‘ğ‘’ â† xmss_node(SK.seed, 2ğ‘–, ğ‘§ âˆ’ 1, PK.seed, ADRS)\n 7:     ğ‘Ÿğ‘›ğ‘œğ‘‘ğ‘’ â† xmss_node(SK.seed, 2ğ‘– + 1, ğ‘§ âˆ’ 1, PK.seed, ADRS)\n 8:     ADRS.setTypeAndClear(TREE)\n 9:     ADRS.setTreeHeight(ğ‘§)\n10:     ADRS.setTreeIndex(ğ‘–)\n11:     ğ‘›ğ‘œğ‘‘ğ‘’ â† H(PK.seed, ADRS, ğ‘™ğ‘›ğ‘œğ‘‘ğ‘’ âˆ¥ ğ‘Ÿğ‘›ğ‘œğ‘‘ğ‘’)\n12:    end if\n13:    return ğ‘›ğ‘œğ‘‘ğ‘’\n\n6.2    Generating an XMSS Signature\nThe xmss_sign function (Algorithm 10) creates an XMSS signature on an ğ‘›-byte message ğ‘€Â¹Â³ by\ncreating an authentication path (lines 1 through 4) and signing ğ‘€ with the appropriate WOTSâº\nkey (lines 5 through 7). In addition to ğ‘€, xmss_sign takes SK.seed and PK.seed from the\nSLH-DSA private key, an address, and an index as input. The address ADRS must have the layer\naddress and tree address set to the XMSS key that is being used to sign the message, and the\nindex ğ‘–ğ‘‘ğ‘¥ must be the index of the WOTSâº key within the XMSS tree that will be used to sign the\nmessage.\nThe authentication path consists of the sibling nodes of each node that is on the path from\nthe WOTSâº key used to the root. For example, in Figure 12, if the message is signed with ğ¾â‚‚,\nthen ğ¾â‚‚, ğ‘›1,1 , and ğ‘›2,0 are the on path nodes, and the authentication path consists of ğ¾â‚ƒ,\nğ‘›1,0 , and ğ‘›2,1 . In line 2 of Algorithm 10, âŒŠğ‘–ğ‘‘ğ‘¥/2ğ‘—âŒ‹ is the on path node, and âŒŠğ‘–ğ‘‘ğ‘¥/2ğ‘—âŒ‹ âŠ• 1 is the\nauthentication path node. Line 3 computes the value of the authentication path node.\n\n13In SLH-DSA, the message ğ‘€ that is signed using XMSS is either an XMSS public key or a FORS public key.\n23"}
{"doc_id": "NIST.FIPS.205", "source_path": "data/raw_pdfs/NIST.FIPS.205.pdf", "page_number": 34, "text": "FIPS 205    STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n\nAlgorithm 10 xmss_sign(ğ‘€, SK.seed, ğ‘–ğ‘‘ğ‘¥, PK.seed, ADRS)\nGenerates an XMSS signature.\nInput: ğ‘›-byte message ğ‘€, secret seed SK.seed, index ğ‘–ğ‘‘ğ‘¥, public seed PK.seed,\n       address ADRS.\nOutput: XMSS signature SIGğ‘‹ğ‘€ğ‘†ğ‘† = (ğ‘ ğ‘–ğ‘” âˆ¥ AUTH).\n 1:    for ğ‘— from 0 to â„â€² âˆ’ 1 do                           â–· build authentication path\n 2:     ğ‘˜ â† âŒŠğ‘–ğ‘‘ğ‘¥/2ğ‘—âŒ‹ âŠ• 1\n 3:     AUTH[ğ‘—] â† xmss_node(SK.seed, ğ‘˜, ğ‘—, PK.seed, ADRS)\n 4:    end for\n 5:    ADRS.setTypeAndClear(WOTS_HASH)\n 6:    ADRS.setKeyPairAddress(ğ‘–ğ‘‘ğ‘¥)\n 7:    ğ‘ ğ‘–ğ‘” â† wots_sign(ğ‘€, SK.seed, PK.seed, ADRS)\n 8:    SIGğ‘‹ğ‘€ğ‘†ğ‘† â† ğ‘ ğ‘–ğ‘” âˆ¥ AUTH\n 9:    return SIGğ‘‹ğ‘€ğ‘†ğ‘†\n\nğ‘›3,0 = H(ğ‘›2,0 âˆ¥ ğ‘›2,1 )\nPPPPP\n                         P\nğ‘›2,0 = H(ğ‘›1,0 âˆ¥ ğ‘›1,1 )    ğ‘›2,1 = H(ğ‘›1,2 âˆ¥ ğ‘›1,3 )\n\nï¿½ï¿½  @@                       ï¿½ï¿½  @@\nğ‘›1,0 = H(ğ¾â‚€ âˆ¥ ğ¾â‚) ğ‘›1,1 = H(ğ¾â‚‚ âˆ¥ ğ¾â‚ƒ) ğ‘›1,2 = H(ğ¾â‚„ âˆ¥ ğ¾â‚…) ğ‘›1,3 = H(ğ¾â‚† âˆ¥ ğ¾â‚‡)\n\nï¿½ï¿½ @@                ï¿½ï¿½  @@               ï¿½ï¿½ @@                ï¿½ï¿½  @@\nğ¾â‚€  ğ¾â‚             ğ¾â‚‚     ğ¾â‚ƒ          ğ¾â‚„  ğ¾â‚…             ğ¾â‚†   ğ¾â‚‡\n                          Figure 12. Merkle hash tree\n\n24"}
{"doc_id": "NIST.FIPS.205", "source_path": "data/raw_pdfs/NIST.FIPS.205.pdf", "page_number": 35, "text": "FIPS 205                                      STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n\n6.3    Computing an XMSS Public Key From a Signature\nVerifying an XMSS signature involves computing a public-key value from a message and a signature\nvalue. Verification succeeds if the correct public-key value is computed, which is determined\nby using the computed public-key value along with other information to compute a candidate\nPK.root value and then comparing that value to the known value of PK.root from the SLH-DSA\npublic key. This section describes xmss_pkFromSig (Algorithm 11), a function that computes a\ncandidate XMSS public key from an XMSS signature and corresponding message.\nIn addition to an ğ‘›-byte message ğ‘€ and an (ğ‘™ğ‘’ğ‘›+â„â€² )â‹…ğ‘›-byte signature SIGğ‘‹ğ‘€ğ‘†ğ‘†, xmss_pkFromSig\ntakes PK.seed from the SLH-DSA public key, an address, and an index as input. The address\nADRS must be set to the layer address and tree address of the XMSS key that was used to sign\nthe message, and the index ğ‘–ğ‘‘ğ‘¥ must be the index of the WOTSâº key within the XMSS tree that\nwas used to sign the message.\nAlgorithm 11 begins by computing the WOTSâº public key in lines 1 through 5. The root is then\ncomputed in lines 6 through 18.     Starting with the leaf node (i.e., the WOTSâº public key), a\nnode at each level of the tree is computed by hashing together the node computed in the\nprevious iteration with the corresponding authentication path node. In lines 12 and 15, AUTH is\ninterpreted as an array of â„â€² ğ‘›-byte strings.\n\nAlgorithm 11 xmss_pkFromSig(ğ‘–ğ‘‘ğ‘¥, SIGğ‘‹ğ‘€ğ‘†ğ‘†, ğ‘€, PK.seed, ADRS)\nComputes an XMSS public key from an XMSS signature.\nInput: Index ğ‘–ğ‘‘ğ‘¥, XMSS signature SIGğ‘‹ğ‘€ğ‘†ğ‘† = (ğ‘ ğ‘–ğ‘” âˆ¥ AUTH), ğ‘›-byte message ğ‘€,\n       public seed PK.seed, address ADRS.\nOutput: ğ‘›-byte root value ğ‘›ğ‘œğ‘‘ğ‘’[0].\n 1:    ADRS.setTypeAndClear(WOTS_HASH)        â–· compute WOTSâº pk from WOTSâº ğ‘ ğ‘–ğ‘”\n 2:    ADRS.setKeyPairAddress(ğ‘–ğ‘‘ğ‘¥)\n 3:    ğ‘ ğ‘–ğ‘” â† SIGğ‘‹ğ‘€ğ‘†ğ‘†.getWOTSSig()                           â–· SIGğ‘‹ğ‘€ğ‘†ğ‘†[0 âˆ¶ ğ‘™ğ‘’ğ‘› â‹… ğ‘›]\n 4:    AUTH â† SIGğ‘‹ğ‘€ğ‘†ğ‘†.getXMSSAUTH()            â–· SIGğ‘‹ğ‘€ğ‘†ğ‘†[ğ‘™ğ‘’ğ‘› â‹… ğ‘› âˆ¶ (ğ‘™ğ‘’ğ‘› + â„â€² ) â‹… ğ‘›]\n 5:    ğ‘›ğ‘œğ‘‘ğ‘’[0] â† wots_pkFromSig(ğ‘ ğ‘–ğ‘”, ğ‘€ , PK.seed, ADRS)\n 6:    ADRS.setTypeAndClear(TREE)             â–· compute root from WOTSâº pk and AUTH\n 7:    ADRS.setTreeIndex(ğ‘–ğ‘‘ğ‘¥)\n 8:    for ğ‘˜ from 0 to â„â€² âˆ’ 1 do\n 9:     ADRS.setTreeHeight(ğ‘˜ + 1)\n10:     if âŒŠğ‘–ğ‘‘ğ‘¥/2ğ‘˜âŒ‹ is even then\n11:         ADRS.setTreeIndex(ADRS.getTreeIndex()/2)\n12:         ğ‘›ğ‘œğ‘‘ğ‘’[1] â† H(PK.seed, ADRS, ğ‘›ğ‘œğ‘‘ğ‘’[0] âˆ¥ AUTH[ğ‘˜])\n13:     else\n14:         ADRS.setTreeIndex((ADRS.getTreeIndex() âˆ’ 1)/2)\n15:         ğ‘›ğ‘œğ‘‘ğ‘’[1] â† H(PK.seed, ADRS, AUTH[ğ‘˜] âˆ¥ ğ‘›ğ‘œğ‘‘ğ‘’[0])\n16:     end if\n17:     ğ‘›ğ‘œğ‘‘ğ‘’[0] â† ğ‘›ğ‘œğ‘‘ğ‘’[1]\n18:    end for\n19:    return ğ‘›ğ‘œğ‘‘ğ‘’[0]\n\n                                              25"}
{"doc_id": "NIST.FIPS.205", "source_path": "data/raw_pdfs/NIST.FIPS.205.pdf", "page_number": 36, "text": "FIPS 205                                   STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n\n7.   The SLH-DSA Hypertree\n\nSLH-DSA requires a very large number of WOTSâº keys to sign FORS public keys.              As it would\nnot be feasible for the parameter sets in this standard to have a single XMSS key with so many\nWOTSâº keys, SLH-DSA uses a hypertree to sign the FORS keys. As depicted in Figure 1, a hypertree\nis a tree of XMSS trees.          The XMSS keys at the lowest layer are used to sign FORS public keys\n     (Section 8), and the XMSS keys at every other layer are used to sign the XMSS public keys at the\nlayer below.\nThe hypertree has ğ‘‘ layers of XMSS trees with each XMSS tree being a Merkle tree of height â„â€² ,\nso the total height of the hypertree is â„ = ğ‘‘ â‹… â„â€² (see Table 2). The top layer (layer ğ‘‘ âˆ’ 1) is a\nsingle XMSS tree, and the public key of this XMSS key pair (i.e., the root of the Merkle tree) is the\npublic key of the hypertree (PK.root). The next layer down has 2â„â€² XMSS trees, and the public\nkey of each of these XMSS keys is signed by one of the 2â„â€² WOTSâº keys that is part of the top\nlayerâ€™s XMSS key. The lowest layer has 2â„âˆ’â„â€² XMSS trees, providing 2â„ WOTSâº keys to sign FORS\nkeys.\n\n7.1  Hypertree Signature Generation\n      A hypertree signature is (â„ + ğ‘‘ â‹… ğ‘™ğ‘’ğ‘›) â‹… ğ‘› bytes in length and consists of a sequence of ğ‘‘ XMSS\nsignatures, starting with a signature generated using an XMSS key at the lowest layer and ending\nwith a signature generated using the XMSS key at the top layer (see Figure 13).\n\n  XMSS signature SIGXMSS (layer 0)         (â„â€² + ğ‘™ğ‘’ğ‘›) â‹… ğ‘› bytes\n  XMSS signature SIGXMSS (layer 1)         (â„â€² + ğ‘™ğ‘’ğ‘›) â‹… ğ‘› bytes\n                 â‹¯\nXMSS signature SIGXMSS (layer ğ‘‘ âˆ’ 1)      (â„â€² + ğ‘™ğ‘’ğ‘›) â‹… ğ‘› bytes\n\n                         Figure 13. HT signature data format\n\nIn addition to the ğ‘›-byte message ğ‘€,Â¹â´           the ht_sign function (Algorithm 12) takes as input\nSK.seed and PK.seed from the SLH-DSA private key, the index of the XMSS tree at the lowest\nlayer that will sign the message ğ‘–ğ‘‘ğ‘¥ğ‘¡ğ‘Ÿğ‘’ğ‘’, and the index of the WOTSâº key within the XMSS tree\nthat will sign the message ğ‘–ğ‘‘ğ‘¥ğ‘™ğ‘’ğ‘ğ‘“ .\n          Algorithm 12 begins in lines 1 through 3 by signing ğ‘€ with the specified XMSS key using the\n     WOTSâº key within that XMSS key specified by ğ‘–ğ‘‘ğ‘¥ğ‘™ğ‘’ğ‘ğ‘“ . The XMSS public key is obtained (line 5 or\n    14) for each successive layer and signed by the appropriate key at the next higher level (lines 7\nthrough 11).\n\n14In SLH-DSA, the message ğ‘€ that is provided to ht_sign is a FORS public key.\n26"}
{"doc_id": "NIST.FIPS.205", "source_path": "data/raw_pdfs/NIST.FIPS.205.pdf", "page_number": 37, "text": "FIPS 205    STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n\nAlgorithm 12 ht_sign(ğ‘€, SK.seed, PK.seed, ğ‘–ğ‘‘ğ‘¥ğ‘¡ğ‘Ÿğ‘’ğ‘’, ğ‘–ğ‘‘ğ‘¥ğ‘™ğ‘’ğ‘ğ‘“ )\nGenerates a hypertree signature.\nInput: Message ğ‘€, private seed SK.seed, public seed PK.seed, tree index ğ‘–ğ‘‘ğ‘¥ğ‘¡ğ‘Ÿğ‘’ğ‘’,\n       leaf index ğ‘–ğ‘‘ğ‘¥ğ‘™ğ‘’ğ‘ğ‘“ .\nOutput: HT signature SIGğ»ğ‘‡.\n 1:    ADRS â† toByte(0, 32)\n 2:    ADRS.setTreeAddress(ğ‘–ğ‘‘ğ‘¥ğ‘¡ğ‘Ÿğ‘’ğ‘’)\n 3:    SIGğ‘¡ğ‘šğ‘ â† xmss_sign(ğ‘€, SK.seed, ğ‘–ğ‘‘ğ‘¥ğ‘™ğ‘’ğ‘ğ‘“ , PK.seed, ADRS)\n 4:    SIGğ»ğ‘‡ â† SIGğ‘¡ğ‘šğ‘\n 5:    ğ‘Ÿğ‘œğ‘œğ‘¡ â† xmss_pkFromSig(ğ‘–ğ‘‘ğ‘¥ğ‘™ğ‘’ğ‘ğ‘“ , SIGğ‘¡ğ‘šğ‘, ğ‘€ , PK.seed, ADRS)\n 6:    for ğ‘— from 1 to ğ‘‘ âˆ’ 1 do\n 7:     ğ‘–ğ‘‘ğ‘¥ğ‘™ğ‘’ğ‘ğ‘“ â† ğ‘–ğ‘‘ğ‘¥ğ‘¡ğ‘Ÿğ‘’ğ‘’ modâ€²2â„â€²    â–· â„â€² least significant bits of ğ‘–ğ‘‘ğ‘¥ğ‘¡ğ‘Ÿğ‘’ğ‘’\n 8:     ğ‘–ğ‘‘ğ‘¥ğ‘¡ğ‘Ÿğ‘’ğ‘’ â† ğ‘–ğ‘‘ğ‘¥ğ‘¡ğ‘Ÿğ‘’ğ‘’ â‰« â„        â–· remove least significant â„â€² bits from ğ‘–ğ‘‘ğ‘¥ğ‘¡ğ‘Ÿğ‘’ğ‘’\n 9:     ADRS.setLayerAddress(ğ‘—)\n10:     ADRS.setTreeAddress(ğ‘–ğ‘‘ğ‘¥ğ‘¡ğ‘Ÿğ‘’ğ‘’)\n11:     SIGğ‘¡ğ‘šğ‘ â† xmss_sign(ğ‘Ÿğ‘œğ‘œğ‘¡, SK.seed, ğ‘–ğ‘‘ğ‘¥ğ‘™ğ‘’ğ‘ğ‘“ , PK.seed, ADRS)\n12:     SIGğ»ğ‘‡ â† SIGğ»ğ‘‡ âˆ¥ SIGğ‘¡ğ‘šğ‘\n13:     if ğ‘— < ğ‘‘ âˆ’ 1 then\n14:     endğ‘Ÿğ‘œğ‘œğ‘¡ â† xmss_pkFromSig(ğ‘–ğ‘‘ğ‘¥ğ‘™ğ‘’ğ‘ğ‘“ , SIGğ‘¡ğ‘šğ‘, ğ‘Ÿğ‘œğ‘œğ‘¡, PK.seed, ADRS)\n15:           if\n16:    end for\n17:    return SIGğ»ğ‘‡\n\n27"}
{"doc_id": "NIST.FIPS.205", "source_path": "data/raw_pdfs/NIST.FIPS.205.pdf", "page_number": 38, "text": "FIPS 205                                           STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n\n7.2    Hypertree Signature Verification\nHypertree signature verification works by making ğ‘‘ calls to xmss_pkFromSig (Algorithm 11) and\ncomparing the result to the public key of the hypertree.\nIn addition to the ğ‘›-byte message ğ‘€ and the (â„ + ğ‘‘ â‹… ğ‘™ğ‘’ğ‘›) â‹… ğ‘›-byte signature SIGğ»ğ‘‡, ht_verify\n(Algorithm 13) takes as input PK.seed and PK.root from the SLH-DSA public key, the index of\nthe XMSS tree at the lowest layer that signed the message ğ‘–ğ‘‘ğ‘¥ğ‘¡ğ‘Ÿğ‘’ğ‘’, and the index of the WOTSâº\nkey within the XMSS tree that signed the message ğ‘–ğ‘‘ğ‘¥ğ‘™ğ‘’ğ‘ğ‘“ .\nAt each layer, either the message ğ‘€ or the computed public key of the XMSS key at the lower\nlayer is provided along with the appropriate XMSS signature to xmss_pkFromSig in order to\nobtain the layerâ€™s computed XMSS public key. If the computed XMSS public key of the top layer\ntree is the same as the known hypertree public key, PK.root, then verification succeeds.\n\nAlgorithm 13 ht_verify(ğ‘€, SIGğ»ğ‘‡, PK.seed, ğ‘–ğ‘‘ğ‘¥ğ‘¡ğ‘Ÿğ‘’ğ‘’, ğ‘–ğ‘‘ğ‘¥ğ‘™ğ‘’ğ‘ğ‘“ , PK.root)\nVerifies a hypertree signature.\nInput: Message ğ‘€, signature SIGğ»ğ‘‡, public seed PK.seed, tree index ğ‘–ğ‘‘ğ‘¥ğ‘¡ğ‘Ÿğ‘’ğ‘’, leaf index ğ‘–ğ‘‘ğ‘¥ğ‘™ğ‘’ğ‘ğ‘“ ,\n       HT public key PK.root.\nOutput: Boolean.\n 1:    ADRS â† toByte(0, 32)\n 2:    ADRS.setTreeAddress(ğ‘–ğ‘‘ğ‘¥ğ‘¡ğ‘Ÿğ‘’ğ‘’)                                              â€²\n 3:    SIGğ‘¡ğ‘šğ‘ â† SIGğ»ğ‘‡.getXMSSSignature(0)                   â–· SIGğ»ğ‘‡[0 âˆ¶ (â„        + ğ‘™ğ‘’ğ‘›) â‹… ğ‘›]\n 4:    ğ‘›ğ‘œğ‘‘ğ‘’ â† xmss_pkFromSig(ğ‘–ğ‘‘ğ‘¥ğ‘™ğ‘’ğ‘ğ‘“ , SIGğ‘¡ğ‘šğ‘, ğ‘€ , PK.seed, ADRS)\n 5:    for ğ‘— from 1 to ğ‘‘ âˆ’ 1 do\n 6:     ğ‘–ğ‘‘ğ‘¥ğ‘™ğ‘’ğ‘ğ‘“ â† ğ‘–ğ‘‘ğ‘¥ğ‘¡ğ‘Ÿğ‘’ğ‘’ modâ€²2â„â€²                  â–· â„â€² least significant bits of ğ‘–ğ‘‘ğ‘¥ğ‘¡ğ‘Ÿğ‘’ğ‘’\n 7:     ğ‘–ğ‘‘ğ‘¥ğ‘¡ğ‘Ÿğ‘’ğ‘’ â† ğ‘–ğ‘‘ğ‘¥ğ‘¡ğ‘Ÿğ‘’ğ‘’ â‰« â„        â–· remove least significant â„â€² bits from ğ‘–ğ‘‘ğ‘¥ğ‘¡ğ‘Ÿğ‘’ğ‘’\n 8:     ADRS.setLayerAddress(ğ‘—)\n 9:     ADRS.setTreeAddress(ğ‘–ğ‘‘ğ‘¥ğ‘¡ğ‘Ÿğ‘’ğ‘’)\n10:     SIGğ‘¡ğ‘šğ‘ â† SIGğ»ğ‘‡.getXMSSSignature(ğ‘—)   â–· SIGğ»ğ‘‡[ğ‘— â‹… (â„â€² + ğ‘™ğ‘’ğ‘›) â‹… ğ‘› âˆ¶ (ğ‘— + 1)(â„â€² + ğ‘™ğ‘’ğ‘›) â‹… ğ‘›]\n11:    endğ‘›ğ‘œğ‘‘ğ‘’ â† xmss_pkFromSig(ğ‘–ğ‘‘ğ‘¥ğ‘™ğ‘’ğ‘ğ‘“ , SIGğ‘¡ğ‘šğ‘, ğ‘›ğ‘œğ‘‘ğ‘’, PK.seed, ADRS)\n12:         for\n13:    if ğ‘›ğ‘œğ‘‘ğ‘’ = PK.root then\n14:     return true\n15:    else\n16:     return false\n17:    end if\n\n28"}
{"doc_id": "NIST.FIPS.205", "source_path": "data/raw_pdfs/NIST.FIPS.205.pdf", "page_number": 39, "text": "FIPS 205                                         STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n\n8.   Forest of Random Subsets (FORS)\n\nFORS is a few-time signature scheme that is used to sign the digests of the actual messages.\nUnlike WOTSâº, for which forgeries become feasible if a key is used twice [22], the security of a\nFORS key degrades gradually as the number of signatures increases.\nFORS uses two parameters: ğ‘˜ and ğ‘¡ = 2ğ‘ (see Table 2). A FORS private key consists of ğ‘˜ sets of ğ‘¡\nğ‘›-byte strings, all of which are pseudorandomly generated from the seed SK.seed. Each of the\nğ‘˜ sets is formed into a Merkle tree, and the roots of the trees are hashed together to form the\nFORS public key. A signature on a ğ‘˜ â‹… ğ‘-bit message digest consists of ğ‘˜ elements from the private\nkey, one from each set selected using ğ‘ bits of the message digest, along with the authentication\npaths for each of these elements (see Figure 14).\n\n                      private key value (tree 0)     ğ‘› bytes\n                                AUTH (tree 0)        ğ‘ â‹… ğ‘› bytes\n                   â‹¯\n     private key value (tree ğ‘˜ âˆ’ 1)                 ğ‘› bytes\n                      AUTH (tree ğ‘˜ âˆ’ 1)             ğ‘ â‹… ğ‘› bytes\n\n                      Figure 14. FORS signature data format\n\n8.1  Generating FORS Secret Values\nThe fors_skGen function (Algorithm 14) generates the ğ‘›-byte strings of the FORS private key. The\nfunction takes SK.seed and PK.seed from the SLH-DSA private key, an address, and an index\nas input. The ğ‘¡ğ‘¦ğ‘ğ‘’ in the address ADRS must be set to FORS_TREE, and the tree address and\nkey pair address must be set to the index of the WOTSâº key within the XMSS tree that signs the\nFORS key. The layer address must be set to zero. The index ğ‘–ğ‘‘ğ‘¥ is the index of the FORS secret\nvalue within the sets of FORS trees.\n\nAlgorithm 14 fors_skGen(SK.seed, PK.seed, ADRS, ğ‘–ğ‘‘ğ‘¥)\nGenerates a FORS private-key value.\nInput: Secret seed SK.seed, public seed PK.seed, address ADRS, secret key index ğ‘–ğ‘‘ğ‘¥.\nOutput: ğ‘›-byte FORS private-key value.\n 1:  skADRS â† ADRS                               â–· copy address to create key generation address\n 2:  skADRS.setTypeAndClear(FORS_PRF)\n 3:  skADRS.setKeyPairAddress(ADRS.getKeyPairAddress())\n 4:  skADRS.setTreeIndex(ğ‘–ğ‘‘ğ‘¥)\n 5:  return PRF(PK.seed, SK.seed, skADRS)\n\n29"}
{"doc_id": "NIST.FIPS.205", "source_path": "data/raw_pdfs/NIST.FIPS.205.pdf", "page_number": 40, "text": "FIPS 205                                 STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n\n8.2    Generating a Merkle Hash Tree\nThe fors_node function (Algorithm 15) computes the nodes of a Merkle tree. It is the same as\nxmss_node, except that the leaf nodes are the hashes of the FORS secret values instead of WOTSâº\npublic keys.\nThe fors_node function takes as input SK.seed and PK.seed from the SLH-DSA private key; a\ntarget node index ğ‘–, which is the index of the node being computed; a target node height ğ‘§, which\nis the height within the Merkle tree of the node being computed; and an address. The address\nADRS must have the layer address set to zero (since the XMSS tree that signs a FORS key is\nalways at layer 0), the tree address set to the XMSS tree that signs the FORS key, the ğ‘¡ğ‘¦ğ‘ğ‘’ set to\nFORS_TREE, and the key pair address set to the index of the WOTSâº key within the XMSS tree\nthat signs the FORS key. The target node height and index must satisfy ğ‘§ â‰¤ ğ‘ and ğ‘– < ğ‘˜ â‹… 2(ğ‘âˆ’ğ‘§).\nEach node in the Merkle tree is the root of a subtree, and Algorithm 15 computes the root of a\nsubtree recursively. If the subtree consists of a single leaf node, then the function simply returns\na hash of the nodeâ€™s private ğ‘›-byte string (lines 2 through 5). Otherwise, the function computes\nthe roots of the left subtree (line 7) and right subtree (line 8) and hashes them together (lines 9\nthrough 11).\n\nAlgorithm 15 fors_node(SK.seed, ğ‘–, ğ‘§, PK.seed, ADRS)\nComputes the root of a Merkle subtree of FORS public values.\nInput: Secret seed SK.seed, target node index ğ‘–, target node height ğ‘§, public seed PK.seed,\n       address ADRS.\nOutput: ğ‘›-byte root ğ‘›ğ‘œğ‘‘ğ‘’.\n 1:    if ğ‘§ = 0 then\n 2:     ğ‘ ğ‘˜ â† fors_skGen(SK.seed, PK.seed, ADRS, ğ‘–)\n 3:     ADRS.setTreeHeight(0)\n 4:     ADRS.setTreeIndex(ğ‘–)\n 5:     ğ‘›ğ‘œğ‘‘ğ‘’ â† F(PK.seed, ADRS, ğ‘ ğ‘˜)\n 6:    else\n 7:     ğ‘™ğ‘›ğ‘œğ‘‘ğ‘’ â† fors_node(SK.seed, 2ğ‘–, ğ‘§ âˆ’ 1, PK.seed, ADRS)\n 8:     ğ‘Ÿğ‘›ğ‘œğ‘‘ğ‘’ â† fors_node(SK.seed, 2ğ‘– + 1, ğ‘§ âˆ’ 1, PK.seed, ADRS)\n 9:     ADRS.setTreeHeight(ğ‘§)\n10:     ADRS.setTreeIndex(ğ‘–)\n11:     ğ‘›ğ‘œğ‘‘ğ‘’ â† H(PK.seed, ADRS, ğ‘™ğ‘›ğ‘œğ‘‘ğ‘’ âˆ¥ ğ‘Ÿğ‘›ğ‘œğ‘‘ğ‘’)\n12:    end if\n13:    return ğ‘›ğ‘œğ‘‘ğ‘’\n\n8.3    Generating a FORS Signature\nThe fors_sign function (Algorithm 16) signs a ğ‘˜ â‹… ğ‘-bit message digest ğ‘šğ‘‘.Â¹âµ In addition to the\nmessage digest, fors_sign takes SK.seed and PK.seed from the SLH-DSA private key and an\naddress as input. The address ADRS must have the layer address set to zero (since the XMSS\n\n15For convenience, fors_sign takes a âŒˆğ‘˜â‹…ğ‘âŒ‰ byte message digest as input and extracts ğ‘˜ â‹… ğ‘ bits to sign.\n                              8\n                                         30"}
{"doc_id": "NIST.FIPS.205", "source_path": "data/raw_pdfs/NIST.FIPS.205.pdf", "page_number": 41, "text": "FIPS 205                                       STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n\ntree that signs a FORS key is always at layer 0), the tree address set to the XMSS tree that signs\nthe FORS key, the ğ‘¡ğ‘¦ğ‘ğ‘’ set to FORS_TREE, and the key pair address set to the index of the WOTSâº\nkey within the XMSS tree that signs the FORS key.\nThe fors_sign function splits ğ‘˜â‹…ğ‘ bits of ğ‘šğ‘‘ into ğ‘˜ ğ‘-bit strings (line 2), each of which is interpreted\nas an integer between 0 and ğ‘¡ âˆ’ 1. Each of these integers is used to select a secret value from\none of the ğ‘˜ sets (line 4). For each secret value selected, an authentication path is computed\nand added to the signature (lines 5 through 9).\n\nAlgorithm 16 fors_sign(ğ‘šğ‘‘, SK.seed, PK.seed, ADRS)\nGenerates a FORS signature.\nInput: Message digest ğ‘šğ‘‘, secret seed SK.seed, address ADRS, public seed PK.seed.\nOutput: FORS signature SIGğ¹ ğ‘‚ğ‘…ğ‘† .\n 1:    SIGğ¹ ğ‘‚ğ‘…ğ‘† = NULL b                 â–· initialize SIGğ¹ ğ‘‚ğ‘…ğ‘† as a zero-length byte string\n 2:    ğ‘–ğ‘›ğ‘‘ğ‘–ğ‘ğ‘’ğ‘  â† base_2 (ğ‘šğ‘‘, ğ‘, ğ‘˜)\n 3:    for ğ‘– from 0 to ğ‘˜ âˆ’ 1 do                   â–· compute signature elements\n 4:     SIGğ¹ ğ‘‚ğ‘…ğ‘† â† SIGğ¹ ğ‘‚ğ‘…ğ‘† âˆ¥ fors_skGen(SK.seed, PK.seed, ADRS, ğ‘– â‹… 2ğ‘ + ğ‘–ğ‘›ğ‘‘ğ‘–ğ‘ğ‘’ğ‘ [ğ‘–])\n 5:     for ğ‘— from 0 to ğ‘ âˆ’ 1 do                  â–· compute auth path\n 6:         ğ‘  â† âŒŠğ‘–ğ‘›ğ‘‘ğ‘–ğ‘ğ‘’ğ‘ [ğ‘–]/2ğ‘—âŒ‹ âŠ• 1\n 7:         AUTH[ğ‘—] â† fors_node(SK.seed, ğ‘– â‹… 2ğ‘âˆ’ğ‘— + ğ‘ , ğ‘—, PK.seed, ADRS)\n 8:     end for\n 9:    endSIGğ¹ ğ‘‚ğ‘…ğ‘† â† SIGğ¹ ğ‘‚ğ‘…ğ‘† âˆ¥ AUTH\n10:         for\n11:    return SIGğ¹ ğ‘‚ğ‘…ğ‘†\n\n8.4  Computing a FORS Public Key From a Signature\n  Verifying a FORS signature involves computing a public-key value from a message digest and\na signature value. Verification succeeds if the correct public-key value is computed, which is\ndetermined by verifying the hypertree signature on the computed public-key value using the SLH-\nDSA public key. This section describes fors_pkFromSig (Algorithm 17), a function that computes\na candidate FORS public key from a FORS signature and corresponding message digest.\nIn addition to a message digest ğ‘šğ‘‘ and a ğ‘˜ â‹… (ğ‘ + 1) â‹… ğ‘›-byte signature SIGğ¹ ğ‘‚ğ‘…ğ‘† , fors_pkFromSig\ntakes PK.seed from the SLH-DSA public key and an address as input.Â¹â¶ The address ADRS\nmust have the layer address set to zero (since the XMSS tree that signs a FORS key is always at\nlayer 0), the tree address set to the XMSS tree that signs the FORS key, the ğ‘¡ğ‘¦ğ‘ğ‘’ set to FORS_TREE,\nand the key pair address set to the index of the WOTSâº key within the XMSS tree that signs the\nFORS key.\nThe fors_pkFromSig function begins by computing the roots of each of the ğ‘˜ Merkle trees (lines\n2 through 20). As in fors_sign, ğ‘˜ â‹… ğ‘ bits of the message digest are split into ğ‘˜ ğ‘-bit strings (line\n 1), each of which is interpreted as an integer between 0 and ğ‘¡ âˆ’ 1. The integers are used to\ndetermine the locations in the Merkle trees of the secret values from the signature (lines 3\n16As with fors_sign, fors_pkFromSig takes a âŒˆğ‘˜â‹…ğ‘âŒ‰ byte message digest as input and extracts ğ‘˜ â‹… ğ‘ bits.\n         8\n          31"}
{"doc_id": "NIST.FIPS.205", "source_path": "data/raw_pdfs/NIST.FIPS.205.pdf", "page_number": 42, "text": "FIPS 205                                            STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n\nthrough 5). The hashes of the secret values are computed (line 6), and the hash values are used\nalong with the corresponding authentication paths from the signature to compute the Merkle\ntree roots (lines 7 through 19). Once all of the Merkle tree roots have been computed, they are\nhashed together to compute the FORS public key (lines 21 through 24).\n\nAlgorithm 17 fors_pkFromSig(SIGğ¹ ğ‘‚ğ‘…ğ‘† , ğ‘šğ‘‘, PK.seed, ADRS)\nComputes a FORS public key from a FORS signature.\nInput: FORS signature SIGğ¹ ğ‘‚ğ‘…ğ‘† , message digest ğ‘šğ‘‘, public seed PK.seed, address ADRS.\nOutput: FORS public key.\n 1:    ğ‘–ğ‘›ğ‘‘ğ‘–ğ‘ğ‘’ğ‘  â† base_2áµ‡(ğ‘šğ‘‘, ğ‘, ğ‘˜)\n 2:    for ğ‘– from 0 to ğ‘˜ âˆ’ 1 do\n 3:     ğ‘ ğ‘˜ â† SIGğ¹ ğ‘‚ğ‘…ğ‘† .getSK(ğ‘–)              â–· SIGğ¹ ğ‘‚ğ‘…ğ‘† [ğ‘– â‹… (ğ‘ + 1) â‹… ğ‘› âˆ¶ (ğ‘– â‹… (ğ‘ + 1) + 1) â‹… ğ‘›]\n 4:     ADRS.setTreeHeight(0)                                              â–· compute leaf\n 5:     ADRS.setTreeIndex(ğ‘– â‹… 2ğ‘ + ğ‘–ğ‘›ğ‘‘ğ‘–ğ‘ğ‘’ğ‘ [ğ‘–])\n 6:     ğ‘›ğ‘œğ‘‘ğ‘’[0] â† F(PK.seed, ADRS, ğ‘ ğ‘˜)\n 7:     ğ‘ğ‘¢ğ‘¡â„ â† SIGğ¹ ğ‘‚ğ‘…ğ‘† .getAUTH(ğ‘–)  â–· SIGğ¹ ğ‘‚ğ‘…ğ‘† [(ğ‘– â‹… (ğ‘ + 1) + 1) â‹… ğ‘› âˆ¶ (ğ‘– + 1) â‹… (ğ‘ + 1) â‹… ğ‘›]\n 8:     for ğ‘— from 0 to ğ‘ âˆ’ 1 do                      â–· compute root from leaf and AUTH\n 9:         ADRS.setTreeHeight(ğ‘— + 1)\n10:         if âŒŠğ‘–ğ‘›ğ‘‘ğ‘–ğ‘ğ‘’ğ‘ [ğ‘–]/2ğ‘—âŒ‹ is even then\n11:               ADRS.setTreeIndex(ADRS.getTreeIndex()/2)\n12:               ğ‘›ğ‘œğ‘‘ğ‘’[1] â† H(PK.seed, ADRS, ğ‘›ğ‘œğ‘‘ğ‘’[0] âˆ¥ ğ‘ğ‘¢ğ‘¡â„[ğ‘—])\n13:         else\n14:               ADRS.setTreeIndex((ADRS.getTreeIndex() âˆ’ 1)/2)\n15:               ğ‘›ğ‘œğ‘‘ğ‘’[1] â† H(PK.seed, ADRS, ğ‘ğ‘¢ğ‘¡â„[ğ‘—] âˆ¥ ğ‘›ğ‘œğ‘‘ğ‘’[0])\n16:         end if\n17:         ğ‘›ğ‘œğ‘‘ğ‘’[0] â† ğ‘›ğ‘œğ‘‘ğ‘’[1]\n18:     end for\n19:     ğ‘Ÿğ‘œğ‘œğ‘¡[ğ‘–] â† ğ‘›ğ‘œğ‘‘ğ‘’[0]\n20:    end for\n21:    forspkADRS â† ADRS                            â–· copy address to create a FORS public-key address\n22:    forspkADRS.setTypeAndClear(FORS_ROOTS)\n23:    forspkADRS.setKeyPairAddress(ADRS.getKeyPairAddress())\n24:    ğ‘ğ‘˜ â† Tğ‘˜(PK.seed, forspkADRS, ğ‘Ÿğ‘œğ‘œğ‘¡)        â–· compute the FORS public key\n25:    return ğ‘ğ‘˜\n\n32"}
{"doc_id": "NIST.FIPS.205", "source_path": "data/raw_pdfs/NIST.FIPS.205.pdf", "page_number": 43, "text": "FIPS 205                                         STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n\n9.   SLH-DSA Internal Functions\n\nSLH-DSA uses the hypertree and the FORS keys to create a stateless hash-based signature scheme.\n                         The SLH-DSA private key contains a secret seed value and a secret PRF key. The public key consists\nof a key identifier PK.seed and the root of the hypertree. A signature is created by hashing\nthe message, using part of the message digest to select a FORS key, signing other bits from the\nmessage digest with the FORS key, and generating a hypertree signature for the FORS key. The\nparameters for SLH-DSA are those specified previously for WOTSâº, XMSS, the SLH-DSA hypertree,\nand FORS (see Table 2).\nSLH-DSA uses one additional parameter ğ‘š, which is the length in bytes of the message digest. It\nis computed as:\n\n                                                          ğ‘š = âŒˆâ„ âˆ’ â„â€² âŒ‰ + âŒˆâ„â€² âŒ‰ + âŒˆğ‘˜ â‹… ğ‘ âŒ‰\n                                              8    8   8\n\nSLH-DSA uses â„ bits of the message digest to select a FORS key: â„ âˆ’ â„â€² bits to select an XMSS\ntree at the lowest layer and â„â€² bits to select a WOTSâº key and corresponding FORS key from that\ntree. ğ‘˜ â‹… ğ‘ bits of the digest are signed by the selected FORS key. While only â„ + ğ‘˜ â‹… ğ‘ bits of the\nmessage digest are used, implementation is simplified by extracting the necessary bits from a\nslightly larger digest.\n                             This section describes the functions for SLH-DSA key generation, signature generation, and\nsignature verification. In the functions in this section, where randomness is required, the random\n                       values are provided as inputs to the functions. The interfaces specified in this section will be used\n                              when testing of SLH-DSA implementations is performed through the Cryptographic Algorithm\n                         Validation Program (CAVP). The key generation function in this section may also be used to obtain\nthe assurance of private key possession via regeneration, as described in Section 3.1.\nOther than for testing purposes, the interfaces for key generation and signature generation\nspecified in this section should not be made available to applications, as any random values\nrequired for key generation and signature generation shall be generated by the cryptographic\nmodule. Section 10 provides guidance on the interfaces to be made available to applications.\n\n9.1  SLH-DSA Key Generation\nSLH-DSA public keys contain two elements (see Figure 16). The first is an ğ‘›-byte public seed\nPK.seed, which is used in many hash function calls to provide domain separation between\ndifferent SLH-DSA key pairs. The second value is the hypertree public key (i.e., the root of the\ntop layer XMSS tree). PK.seed shall be generated using an approved random bit generator (see\n\nSK.seed                ğ‘› bytes\n SK.prf                ğ‘› bytes                        PK.seed      ğ‘› bytes\nPK.seed                ğ‘› bytes                         PK.root     ğ‘› bytes\nPK.root                ğ‘› bytes\n\n            Figure 15. SLH-DSA private key             Figure 16. SLH-DSA public key\n                                                 33"}
{"doc_id": "NIST.FIPS.205", "source_path": "data/raw_pdfs/NIST.FIPS.205.pdf", "page_number": 44, "text": "FIPS 205                                         STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n\n[14, 15, 16]), where the instantiation of the random bit generator supports at least 8ğ‘› bits of\nsecurity strength.\n       The SLH-DSA private key contains two random, secret ğ‘›-byte values (see Figure 15). SK.seed is\nused to generate all of the WOTSâº and FORS private key elements. SK.prf is used to generate a\nrandomization value for the randomized hashing of the message in SLH-DSA. The private key\nalso includes a copy of the public key. Both SK.seed and SK.prf shall be generated using an\napproved random bit generator, where the instantiation of the random bit generator supports\nat least 8ğ‘› bits of security strength.\n      Algorithm 18 generates an SLH-DSA key pair. Lines 1 through 3 compute the root of the top layer\n          XMSS tree. Line 4 bundles the three inputs and the computed PK.seed into the private and\npublic keys.\nSLH-DSA signing has two variants â€” â€œhedgedâ€ and deterministic (see Section 9.2) â€” whose keys\nshould only be used for the generation and verification of hedged and deterministic SLH-DSA\ndigital signatures, respectively.\n\nAlgorithm 18 slh_keygen_internal(SK.seed, SK.prf, PK.seed)\nGenerates an SLH-DSA key pair.\nInput: Secret seed SK.seed, PRF key SK.prf, public seed PK.seed\nOutput: SLH-DSA key pair (SK, PK).\n 1:  ADRS â† toByte(0, 32)              â–· generate the public key for the top-level XMSS tree\n 2:  ADRS.setLayerAddress(ğ‘‘ âˆ’ 1)\n 3:  PK.root â† xmss_node(SK.seed, 0, â„â€² , PK.seed, ADRS)\n 4:  return ( (SK.seed, SK.prf, PK.seed, PK.root), (PK.seed, PK.root) )\n\n9.2  SLH-DSA Signature Generation\n         An SLH-DSA signature consists of a randomization string, a FORS signature, and a hypertree\nsignature, as shown in Figure 17.\nGenerating an SLH-DSA signature (Algorithm 19) begins by creating an ğ‘š-byte message digest\n     (lines 2 through 5). A PRF is used to create a message randomizer (line 3), and it is hashed along\n     with the message to create the digest (line 5). Bits are then extracted from the message digest to\nbe signed by the FORS key (line 6), to select an XMSS tree (lines 7 and 9), and to select a WOTSâº\nkey and corresponding FORS key within that XMSS tree (lines 8 and 10). Next, the FORS signature\nis computed (lines 11 through 14), and the corresponding FORS public key is obtained (line 16).\nFinally, the FORS public key is signed (line 17).\n\n                  Randomness R                   ğ‘› bytes\n     FORS signature SIGFORS                      ğ‘˜(1 + ğ‘) â‹… ğ‘› bytes\n       HT signature SIGHT                        (â„ + ğ‘‘ â‹… ğ‘™ğ‘’ğ‘›) â‹… ğ‘› bytes\n\n                                  Figure 17. SLH-DSA signature data format\n\n                                                     34"}
{"doc_id": "NIST.FIPS.205", "source_path": "data/raw_pdfs/NIST.FIPS.205.pdf", "page_number": 45, "text": "FIPS 205    STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n\nAlgorithm 19 slh_sign_internal(ğ‘€, SK, ğ‘ğ‘‘ğ‘‘ğ‘Ÿğ‘›ğ‘‘)\nGenerates an SLH-DSA signature.\nInput: Message ğ‘€, private key SK = (SK.seed, SK.prf, PK.seed, PK.root),\n     (optional) additional randomness ğ‘ğ‘‘ğ‘‘ğ‘Ÿğ‘›ğ‘‘.\nOutput: SLH-DSA signature SIG.\n 1:  ADRS â† toByte(0, 32)\n 2:  ğ‘œğ‘ğ‘¡_ğ‘Ÿğ‘ğ‘›ğ‘‘ â† ğ‘ğ‘‘ğ‘‘ğ‘Ÿğ‘›ğ‘‘       â–· substitute ğ‘œğ‘ğ‘¡_ğ‘Ÿğ‘ğ‘›ğ‘‘ â† PK.seed for the deterministic variant\n 3:  ğ‘… â† PRFğ‘šğ‘ ğ‘”(SK.prf, ğ‘œğ‘ğ‘¡_ğ‘Ÿğ‘ğ‘›ğ‘‘, ğ‘€ )                                      â–· generate randomizer\n 4:  SIG â† ğ‘…\n 5:  ğ‘‘ğ‘–ğ‘”ğ‘’ğ‘ ğ‘¡ â† Hğ‘šğ‘ ğ‘”(ğ‘…, PK.seed, PK.root, ğ‘€ )                     â–· compute message digest\n 6:  ğ‘šğ‘‘ â† ğ‘‘ğ‘–ğ‘”ğ‘’ğ‘ ğ‘¡ [0 âˆ¶ âŒˆğ‘˜â‹…ğ‘âŒ‰]                                                           â–· first âŒˆğ‘˜â‹…ğ‘âŒ‰ bytes\n                        8                                          â„âˆ’â„/ğ‘‘                        8\n 7:  ğ‘¡ğ‘šğ‘_ğ‘–ğ‘‘ğ‘¥ğ‘¡ğ‘Ÿğ‘’ğ‘’ â† ğ‘‘ğ‘–ğ‘”ğ‘’ğ‘ ğ‘¡ [âŒˆ ğ‘˜â‹…ğ‘âŒ‰ âˆ¶ âŒˆğ‘˜â‹…ğ‘âŒ‰ + âŒˆ            âŒ‰]        â–· next âŒˆ â„âˆ’â„/ğ‘‘ âŒ‰ bytes\n                                          8  8                     8                             8\n 8:  ğ‘¡ğ‘šğ‘_ğ‘–ğ‘‘ğ‘¥ğ‘™ğ‘’ğ‘ğ‘“ â† ğ‘‘ğ‘–ğ‘”ğ‘’ğ‘ ğ‘¡ [âŒˆ ğ‘˜â‹…ğ‘âŒ‰ + âŒˆ â„âˆ’â„/ğ‘‘ âŒ‰ âˆ¶ âŒˆğ‘˜â‹…ğ‘âŒ‰ + âŒˆ â„âˆ’â„/ğ‘‘ âŒ‰ + âŒˆ â„ âŒ‰] â–· next âŒˆ â„ âŒ‰ bytes\n                                          8       8                     8          8  8ğ‘‘        8ğ‘‘\n 9:  ğ‘–ğ‘‘ğ‘¥ğ‘¡ğ‘Ÿğ‘’ğ‘’ â† toInt (ğ‘¡ğ‘šğ‘_ğ‘–ğ‘‘ğ‘¥ğ‘¡ğ‘Ÿğ‘’ğ‘’, âŒˆ â„âˆ’â„/ğ‘‘ âŒ‰) mod 2â„âˆ’â„/ğ‘‘\n                                               8\n10:  ğ‘–ğ‘‘ğ‘¥ğ‘™ğ‘’ğ‘ğ‘“ â† toInt (ğ‘¡ğ‘šğ‘_ğ‘–ğ‘‘ğ‘¥ğ‘™ğ‘’ğ‘ğ‘“ , âŒˆ â„ âŒ‰) mod 2â„/ğ‘‘\n                                               8ğ‘‘\n11:  ADRS.setTreeAddress(ğ‘–ğ‘‘ğ‘¥ğ‘¡ğ‘Ÿğ‘’ğ‘’)\n12:  ADRS.setTypeAndClear(FORS_TREE)\n13:  ADRS.setKeyPairAddress(ğ‘–ğ‘‘ğ‘¥ğ‘™ğ‘’ğ‘ğ‘“ )\n14:  SIGğ¹ ğ‘‚ğ‘…ğ‘† â† fors_sign(ğ‘šğ‘‘, SK.seed, PK.seed, ADRS)\n15:  SIG â† SIG âˆ¥ SIGğ¹ ğ‘‚ğ‘…ğ‘†\n16:  PKğ¹ ğ‘‚ğ‘…ğ‘† â† fors_pkFromSig(SIGğ¹ ğ‘‚ğ‘…ğ‘† , ğ‘šğ‘‘, PK.seed, ADRS)                            â–· get FORS key\n17:  SIGğ»ğ‘‡ â† ht_sign(PKğ¹ ğ‘‚ğ‘…ğ‘† , SK.seed, PK.seed, ğ‘–ğ‘‘ğ‘¥ğ‘¡ğ‘Ÿğ‘’ğ‘’, ğ‘–ğ‘‘ğ‘¥ğ‘™ğ‘’ğ‘ğ‘“ )\n18:  SIG â† SIG âˆ¥ SIGğ»ğ‘‡\n19:  return SIG\n\n35"}
{"doc_id": "NIST.FIPS.205", "source_path": "data/raw_pdfs/NIST.FIPS.205.pdf", "page_number": 46, "text": "FIPS 205                                                             STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n\nThe message randomizer may be set in either a non-deterministic or deterministic way, depending\non whether ğ‘ğ‘‘ğ‘‘ğ‘Ÿğ‘›ğ‘‘ is provided as an input. For the â€œhedgedâ€ variant, ğ‘ğ‘‘ğ‘‘ğ‘Ÿğ‘›ğ‘‘ is provided as an\ninput, and ğ‘œğ‘ğ‘¡_ğ‘Ÿğ‘ğ‘›ğ‘‘ is set to ğ‘ğ‘‘ğ‘‘ğ‘Ÿğ‘›ğ‘‘. The hedged variant is the default and should be used on\nplatforms where side-channel attacks are a concern. When using the hedged version, ğ‘ğ‘‘ğ‘‘ğ‘Ÿğ‘›ğ‘‘\nshall be an ğ‘›-byte random value. While ğ‘ğ‘‘ğ‘‘ğ‘Ÿğ‘›ğ‘‘ should ideally be generated by an approved\nrandom bit generator, other methods for generating fresh random values may be used. For\nthe deterministic variant, ğ‘ğ‘‘ğ‘‘ğ‘Ÿğ‘›ğ‘‘ is not provided as an input, and ğ‘œğ‘ğ‘¡_ğ‘Ÿğ‘ğ‘›ğ‘‘ is set to PK.seed,\nwhich results in signing being deterministic (i.e., signing the same message twice will result in\nthe same signature). The deterministic variant is available for platforms where a random bit\ngenerator is not available.\n\n9.3    SLH-DSA Signature Verification\nAs with signature generation, SLH-DSA signature verification (Algorithm 20) begins by computing\na message digest (line 8) and then extracting ğ‘šğ‘‘ (line 9), ğ‘–ğ‘‘ğ‘¥ğ‘¡ğ‘Ÿğ‘’ğ‘’ (lines 10 and 12), and ğ‘–ğ‘‘ğ‘¥ğ‘™ğ‘’ğ‘ğ‘“\n(lines 11 and 13) from the digest. A candidate FORS public key is then computed (line 17), and\nthe signature on the FORS key is verified (line 18). If this signature verification succeeds, then\nthe correct FORS public key was computed, and the signature SIG on message ğ‘€ is valid.\n\nAlgorithm 20 slh_verify_internal(ğ‘€, SIG, PK)\nVerifies an SLH-DSA signature.\nInput: Message ğ‘€, signature SIG, public key PK = (PK.seed, PK.root).\nOutput: Boolean.\n 1:    if |SIG| â‰  (1 + ğ‘˜(1 + ğ‘) + â„ + ğ‘‘ â‹… ğ‘™ğ‘’ğ‘›) â‹… ğ‘› then\n 2:         return false\n 3:    end if\n 4:    ADRS â† toByte(0, 32)\n 5:    ğ‘… â† SIG.getR()                                                                             â–· SIG[0 âˆ¶ ğ‘›]\n 6:    SIGğ¹ ğ‘‚ğ‘…ğ‘† â† SIG.getSIG_FORS()                                      â–· SIG[ğ‘› âˆ¶ (1 + ğ‘˜(1 + ğ‘)) â‹… ğ‘›]\n 7:    SIGğ»ğ‘‡ â† SIG.getSIG_HT()            â–· SIG[(1 + ğ‘˜(1 + ğ‘)) â‹… ğ‘› âˆ¶ (1 + ğ‘˜(1 + ğ‘) + â„ + ğ‘‘ â‹… ğ‘™ğ‘’ğ‘›) â‹… ğ‘›]\n 8:    ğ‘‘ğ‘–ğ‘”ğ‘’ğ‘ ğ‘¡ â† Hğ‘šğ‘ ğ‘”(ğ‘…, PK.seed, PK.root, ğ‘€ )                     â–· compute message digest\n 9:    ğ‘šğ‘‘ â† ğ‘‘ğ‘–ğ‘”ğ‘’ğ‘ ğ‘¡ [0 âˆ¶ âŒˆğ‘˜â‹…ğ‘âŒ‰]                                                           â–· first âŒˆğ‘˜â‹…ğ‘âŒ‰ bytes\n                          8                                          â„âˆ’â„/ğ‘‘                        8\n10:    ğ‘¡ğ‘šğ‘_ğ‘–ğ‘‘ğ‘¥ğ‘¡ğ‘Ÿğ‘’ğ‘’ â† ğ‘‘ğ‘–ğ‘”ğ‘’ğ‘ ğ‘¡ [âŒˆ ğ‘˜â‹…ğ‘âŒ‰ âˆ¶ âŒˆğ‘˜â‹…ğ‘âŒ‰ + âŒˆ            âŒ‰]    â–· next âŒˆ â„âˆ’â„/ğ‘‘ âŒ‰ bytes\n                                            8  8                     8                             8\n11:    ğ‘¡ğ‘šğ‘_ğ‘–ğ‘‘ğ‘¥ğ‘™ğ‘’ğ‘ğ‘“ â† ğ‘‘ğ‘–ğ‘”ğ‘’ğ‘ ğ‘¡ [âŒˆ ğ‘˜â‹…ğ‘âŒ‰ + âŒˆ â„âˆ’â„/ğ‘‘ âŒ‰ âˆ¶ âŒˆğ‘˜â‹…ğ‘âŒ‰ + âŒˆ â„âˆ’â„/ğ‘‘ âŒ‰ + âŒˆ â„ âŒ‰] â–· next âŒˆ â„ âŒ‰ bytes\n                                            8       8                     8          8  8ğ‘‘        8ğ‘‘\n12:    ğ‘–ğ‘‘ğ‘¥ğ‘¡ğ‘Ÿğ‘’ğ‘’ â† toInt (ğ‘¡ğ‘šğ‘_ğ‘–ğ‘‘ğ‘¥ğ‘¡ğ‘Ÿğ‘’ğ‘’, âŒˆ â„âˆ’â„/ğ‘‘ âŒ‰) mod 2â„âˆ’â„/ğ‘‘\n                                                 8\n13:    ğ‘–ğ‘‘ğ‘¥ğ‘™ğ‘’ğ‘ğ‘“ â† toInt (ğ‘¡ğ‘šğ‘_ğ‘–ğ‘‘ğ‘¥ğ‘™ğ‘’ğ‘ğ‘“ , âŒˆ â„ âŒ‰) mod 2â„/ğ‘‘\n                                                 8ğ‘‘\n14:    ADRS.setTreeAddress(ğ‘–ğ‘‘ğ‘¥ğ‘¡ğ‘Ÿğ‘’ğ‘’)                                              â–· compute FORS public key\n15:    ADRS.setTypeAndClear(FORS_TREE)\n16:    ADRS.setKeyPairAddress(ğ‘–ğ‘‘ğ‘¥ğ‘™ğ‘’ğ‘ğ‘“ )\n17:    PKğ¹ ğ‘‚ğ‘…ğ‘† â† fors_pkFromSig(SIGğ¹ ğ‘‚ğ‘…ğ‘† , ğ‘šğ‘‘, PK.seed, ADRS)\n18:    return ht_verify(PKğ¹ ğ‘‚ğ‘…ğ‘† , SIGğ»ğ‘‡, PK.seed, ğ‘–ğ‘‘ğ‘¥ğ‘¡ğ‘Ÿğ‘’ğ‘’, ğ‘–ğ‘‘ğ‘¥ğ‘™ğ‘’ğ‘ğ‘“ , PK.root)\n\n                                                       36"}
{"doc_id": "NIST.FIPS.205", "source_path": "data/raw_pdfs/NIST.FIPS.205.pdf", "page_number": 47, "text": "FIPS 205                                    STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n\n10.         SLH-DSA External Functions\n\nThis section provides guidance on the key generation, signature generation, and signature\nverification functions that should be provided for use by applications. The functions in this\nsection use the functions in Section 9 to implement the underlying SLH-DSA scheme.\n\n10.1        SLH-DSA Key Generation\nAlgorithm 21 generates an SLH-DSA key pair.      Lines 1 through 3 generate the random values\nfor the private and public keys, and line 7 calls slh_keygen_internal to compute PK.root and\nreturn the private and public key. PK.seed, SK.seed, and SK.prf shall be generated using an\napproved random bit generator (see [14, 15, 16]), where the instantiation of the random bit\ngenerator supports at least 8ğ‘› bits of security strength.\n\nAlgorithm 21 slh_keygen()\nGenerates an SLH-DSA key pair.\nInput: (none)\nOutput: SLH-DSA key pair (SK, PK).\n       SK.seed    $     ğ‘›\n               â†\n 1:               âˆ’ ğ”¹            â–· set SK.seed, SK.prf, and PK.seed to random ğ‘›-byte\n       SK.prf  $        ğ‘›\n              â†\n 2:            âˆ’ ğ”¹                     â–· strings using an approved random bit generator\n       PK.seed     $      ğ‘›\n                  â†\n 3:                âˆ’ ğ”¹\n 4:    if SK.seed = NULL or SK.prf = NULL or PK.seed = NULL then\n 5:         return âŠ¥              â–· return an error indication if random bit generation failed\n 6:    end if\n 7:    return slh_keygen_internal(SK.seed, SK.prf, PK.seed)\n\n10.2        SLH-DSA Signature Generation\nThis section presents two versions of SLH-DSA signature generation: a â€œpureâ€ version (slh_sign)\nand a â€œpre-hashâ€ version (hash_slh_sign). Both versions use slh_sign_internal, but they differ\nin how the message input to slh_sign_internal is created from the content to be signed. In the\npure version, the content is signed by slh_sign_internal along with some domain separation\ninformation. In the pre-hash version, a hash of the content is signed by slh_sign_internal along\nwith some domain separation information.\nBoth versions take the content to be signed, the private key, and a context as input. The pre-hash\n                   version also takes as input a hash function or XOF that is to be used to pre-hash the content to\nbe signed. The context string has a maximum length of 255 bytes. By default, the context is the\nempty string. However, applications may specify the use of a non-empty context string.\nThe identifier for a signature (e.g., the object identifier [OID]) should indicate whether the\nsignature is a pure signature or a pre-hash signature. In the case of pre-hash signatures, the\nidentifier should also indicate the hash function or XOF used to compute the pre-hash.Â¹â· While\n17In the case of a XOF, this would also include the length of the output from the XOF.\n                                                                  37"}
{"doc_id": "NIST.FIPS.205", "source_path": "data/raw_pdfs/NIST.FIPS.205.pdf", "page_number": 48, "text": "FIPS 205                        STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n\na single key pair may be used for both pure and pre-hash signatures, it is recommended that\neach key pair only be used for one version or the other. If a non-empty context string is to be\nused, this should either be indicated by the signatureâ€™s identifier or the application with which\nthe signature is being used.\nIf the default hedged variant of slh_sign_internal is used, the ğ‘›-byte random value ğ‘ğ‘‘ğ‘‘ğ‘Ÿğ‘›ğ‘‘\nshall be generated by the cryptographic module that runs slh_sign_internal. However, ğ‘€â€² in\nAlgorithms 22 and 23 may be constructed outside of the crytographic module. In the case of\nhash_slh_sign, the hash or XOF of the content to be signed must be computed within a FIPS\n140-validated cryptographic module, but it may be a different cryptographic module than the\none that runs slh_sign_internal.\nIn general, the pure version is preferred. However, for some cryptographic modules that generate\nSLH-DSA signatures, performing lines 3 and 5 of Algorithm 19 may be infeasible if the message ğ‘€\nis large. This may, for example, be the result of the module having limited memory to store the\nmessage to be signed. Similarly, for some cryptographic modules that verify SLH-DSA signatures,\nperforming line 8 of Algorithm 20 may be infeasible if the message ğ‘€ is large. For some use\ncases, these issues may be addressed by signing a digest of the content rather than signing the\ncontent directly.\nIn many cases where the content to be signed is large, hashing of the content is performed at\nthe application level. For example, in the Cryptographic Message Syntax [23], a digest of the\ncontent may be computed, and that digest is signed along with other attributes.   In cases in\nwhich the content is not hashed at the application level, the pre-hash version of SLH-DSA signing\n(Section 10.2.2) may be used.\nTo maintain the same level of security strength when the content is hashed at the application\nlevel or when using the pre-hash version of SLH-DSA, the digest that is signed needs to be\ngenerated using an approved hash function or XOF (e.g., from FIPS 180-4 [8] or FIPS 202 [6]) that\nprovides at least 8ğ‘› bits of classical security strength against both collision and second preimage\nattacks [6, Table 4].Â¹â¸              Verification of a signature created in this way will require the verify function\nto generate a digest from the message in the same way for input to the verification function.\nEven if it is feasible to compute collisions on the hash functions or XOF used to instantiate Hğ‘šğ‘ ğ‘”,\nPRF, PRFğ‘šğ‘ ğ‘”, F, H, and Tğ‘™, there is believed to be no adverse effect on the security of\nSLH-DSA.Â¹â¹ However, if the input to the signing function is a digest of the content, then collisions\non the function used to compute the digest can result in forged messages.\n\n10.2.1      Pure SLH-DSA Signature Generation\nIn the pure version, the content to be signed is prepended with a one-byte domain separator,\none byte that indicates the length of the context string, and the context string.                          The domain\nseparator, which has a value of zero for pure signing, is included to prevent pre-hash signatures\nfrom verifying as pure signatures and vice versa. In the default case in which the context string\n\n18Obtaining at least 8ğ‘› bits of classical security strength against collision attacks requires that the digest to be\n   signed is at least 2ğ‘› bytes in length.\n19As noted in Section 11, applications that require message-bound signatures may be adversely affected if it is\n   feasible to compute collisions on Hğ‘šğ‘ ğ‘”.\n                                             38"}
{"doc_id": "NIST.FIPS.205", "source_path": "data/raw_pdfs/NIST.FIPS.205.pdf", "page_number": 49, "text": "FIPS 205                                               STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n\nis empty, pure signing simply involves prepending two zero bytes to the content to be signed\nand passing the result to slh_sign_internal along with the private key and, in the case of hedged\nsigning, an ğ‘›-byte random value.\n\nAlgorithm 22 slh_sign(ğ‘€, ğ‘ğ‘¡ğ‘¥, SK)\nGenerates a pure SLH-DSA signature.\nInput: Message ğ‘€, context string ğ‘ğ‘¡ğ‘¥, private key SK.\nOutput: SLH-DSA signature SIG.\n 1:    if |ğ‘ğ‘¡ğ‘¥| > 255 then\n 2:         return âŠ¥                    â–· return an error indication if the context string is too long\n 3:    end if\n       ğ‘ğ‘‘ğ‘‘ğ‘Ÿğ‘›ğ‘‘  $  ğ‘›\n                    â†\n 4:                  âˆ’ ğ”¹                       â–· skip lines 4 through 7 for the deterministic variant\n 5:    if ğ‘ğ‘‘ğ‘‘ğ‘Ÿğ‘›ğ‘‘ = NULL then\n 6:         return âŠ¥                      â–· return an error indication if random bit generation failed\n 7:    end if\n 8:    ğ‘€â€² â† toByte(0, 1) âˆ¥ toByte(|ğ‘ğ‘¡ğ‘¥|, 1) âˆ¥ ğ‘ğ‘¡ğ‘¥ âˆ¥ ğ‘€\n 9:    SIG â† slh_sign_internal(ğ‘€ â€² , SK, ğ‘ğ‘‘ğ‘‘ğ‘Ÿğ‘›ğ‘‘)    â–· omit ğ‘ğ‘‘ğ‘‘ğ‘Ÿğ‘›ğ‘‘ for the deterministic variant\n10:    return SIG\n\n10.2.2      HashSLH-DSA Signature Generation\nIn the pre-hash version, the message input to slh_sign_internal is the result of applying either a\nhash function or a XOF to the content to be signed. The output of the hash function or XOF is\nprepended by a one-byte domain separator, one byte that indicates the length of the context\nstring, the context string, and the distinguished encoding rules (DER) encoding of the hash\nfunction or XOFâ€™s OID. The domain separator has a value of one for pre-hash signing. The DER\nencoding of the OID includes the tag and length.\nAlgorithm 23 shows the DER encodings of the OIDs for SHA-256, SHA-512, SHAKE128, and\nSHAKE256. However, hash_slh_sign may be used with other hash functions or XOFs. SHA-256\nand SHAKE128 are only appropriate for use with SLH-DSA parameter sets that are claimed to be\nin security category 1 (see Section 11).\n\n39"}
{"doc_id": "NIST.FIPS.205", "source_path": "data/raw_pdfs/NIST.FIPS.205.pdf", "page_number": 50, "text": "FIPS 205    STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n\nAlgorithm 23 hash_slh_sign(ğ‘€, ğ‘ğ‘¡ğ‘¥, PH, SK)\nGenerates a pre-hash SLH-DSA signature.\nInput: Message ğ‘€, context string ğ‘ğ‘¡ğ‘¥, pre-hash function PH, private key SK.\nOutput: SLH-DSA signature SIG.\n 1:    if |ğ‘ğ‘¡ğ‘¥| > 255 then\n 2:     return âŠ¥                  â–· return an error indication if the context string is too long\n 3:    end if\n       ğ‘ğ‘‘ğ‘‘ğ‘Ÿğ‘›ğ‘‘  $  ğ‘›\n                    â†\n 4:                  âˆ’ ğ”¹              â–· skip lines 4 through 7 for the deterministic variant\n 5:    if ğ‘ğ‘‘ğ‘‘ğ‘Ÿğ‘›ğ‘‘ = NULL then\n 6:     return âŠ¥                  â–· return an error indication if random bit generation failed\n 7:    end if\n 8:    switch PH do\n 9:     case SHA-256:\n10:          OID â† toByte(0x0609608648016503040201, 11)              â–· 2.16.840.1.101.3.4.2.1\n11:          PHğ‘€ â† SHA-256(ğ‘€)\n12:     case SHA-512:\n13:          OID â† toByte(0x0609608648016503040203, 11)              â–· 2.16.840.1.101.3.4.2.3\n14:          PHğ‘€ â† SHA-512(ğ‘€)\n15:     case SHAKE128:\n16:          OID â† toByte(0x060960864801650304020B, 11)              â–· 2.16.840.1.101.3.4.2.11\n17:          PHğ‘€ â† SHAKE128(ğ‘€, 256)\n18:     case SHAKE256:\n19:          OID â† toByte(0x060960864801650304020C, 11)              â–· 2.16.840.1.101.3.4.2.12\n20:          PHğ‘€ â† SHAKE256(ğ‘€, 512)\n21:     case â€¦                                           â–· other approved hash functions or XOFs\n22:          â€¦\n23:    end switch\n24:    ğ‘€â€² â† toByte(1, 1) âˆ¥ toByte(|ğ‘ğ‘¡ğ‘¥|, 1) âˆ¥ ğ‘ğ‘¡ğ‘¥ âˆ¥ OID âˆ¥ PHğ‘€\n25:    SIG â† slh_sign_internal(ğ‘€ â€² , SK, ğ‘ğ‘‘ğ‘‘ğ‘Ÿğ‘›ğ‘‘)  â–· omit ğ‘ğ‘‘ğ‘‘ğ‘Ÿğ‘›ğ‘‘ for the deterministic variant\n26:    return SIG\n\n40"}
{"doc_id": "NIST.FIPS.205", "source_path": "data/raw_pdfs/NIST.FIPS.205.pdf", "page_number": 51, "text": "FIPS 205                                       STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n\n10.3        SLH-DSA Signature Verification\nAlgorithms 24 and 25 present the pure and pre-hash versions of SLH-DSA signature verification\nthat correspond to the pure and pre-hash versions of SLH-DSA signature generation in Sec-\ntion 10.2. These functions construct ğ‘€â€² in the same way as Algorithms 22 and 23, respectively,\nand pass the resulting ğ‘€â€² to slh_verify_internal for verification. As with signature generation,\nğ‘€â€² may be constructed outside of the cryptographic module that performs slh_verify_internal.\nHowever, in the case of hash_slh_verify, the hash or XOF of the content must be computed within\na FIPS 140-validated cryptographic module, which may be a different cryptographic module than\nthe one that performs slh_verify_internal.\nThe identifier associated with the signature should indicate whether the pure or pre-hash version\nof signature verification should be used, and in the pre-hash case, the hash function or XOF to\nuse to compute the pre-hash. A non-empty context string should be used in verification if one is\nspecified in the signatureâ€™s identifier or by the application with which the signature is being used.\n\nAlgorithm 24 slh_verify(ğ‘€, SIG, ğ‘ğ‘¡ğ‘¥, PK)\nVerifies a pure SLH-DSA signature.\nInput: Message ğ‘€, signature SIG, context string ğ‘ğ‘¡ğ‘¥, public key PK.\nOutput: Boolean.\n 1:  if |ğ‘ğ‘¡ğ‘¥| > 255 then\n 2:         return false\n 3:  end if\n 4:  ğ‘€â€² â† toByte(0, 1) âˆ¥ toByte(|ğ‘ğ‘¡ğ‘¥|, 1) âˆ¥ ğ‘ğ‘¡ğ‘¥ âˆ¥ ğ‘€\n 5:  return slh_verify_internal(ğ‘€ â€² , SIG, PK)\n\n41"}
{"doc_id": "NIST.FIPS.205", "source_path": "data/raw_pdfs/NIST.FIPS.205.pdf", "page_number": 52, "text": "FIPS 205    STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n\nAlgorithm 25 hash_slh_verify(ğ‘€, SIG, ğ‘ğ‘¡ğ‘¥, PH, PK)\nVerifies a pre-hash SLH-DSA signature.\nInput: Message ğ‘€, signature SIG, context string ğ‘ğ‘¡ğ‘¥, pre-hash function PH, public key PK.\nOutput: Boolean.\n 1:    if |ğ‘ğ‘¡ğ‘¥| > 255 then\n 2:     return false\n 3:    end if\n 4:    switch PH do\n 5:     case SHA-256:\n 6:          OID â† toByte(0x0609608648016503040201, 11)              â–· 2.16.840.1.101.3.4.2.1\n 7:          PHğ‘€ â† SHA-256(ğ‘€)\n 8:     case SHA-512:\n 9:          OID â† toByte(0x0609608648016503040203, 11)              â–· 2.16.840.1.101.3.4.2.3\n10:          PHğ‘€ â† SHA-512(ğ‘€)\n11:     case SHAKE128:\n12:          OID â† toByte(0x060960864801650304020B, 11)              â–· 2.16.840.1.101.3.4.2.11\n13:          PHğ‘€ â† SHAKE128(ğ‘€, 256)\n14:     case SHAKE256:\n15:          OID â† toByte(0x060960864801650304020C, 11)              â–· 2.16.840.1.101.3.4.2.12\n16:          PHğ‘€ â† SHAKE256(ğ‘€, 512)\n17:     case â€¦                                       â–· other approved hash functions or XOFs\n18:          â€¦\n19:    end switch\n20:    ğ‘€â€² â† toByte(1, 1) âˆ¥ toByte(|ğ‘ğ‘¡ğ‘¥|, 1) âˆ¥ ğ‘ğ‘¡ğ‘¥ âˆ¥ OID âˆ¥ PHğ‘€\n21:    return slh_verify_internal(ğ‘€ â€² , SIG, PK)\n\n42"}
{"doc_id": "NIST.FIPS.205", "source_path": "data/raw_pdfs/NIST.FIPS.205.pdf", "page_number": 53, "text": "FIPS 205                                         STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n\n11.         Parameter Sets\n\n                                                 This standard approves 12 parameter sets for use with SLH-DSA. A parameter set consists of\nparameters for WOTSâº (ğ‘› and ğ‘™ğ‘”ğ‘¤), XMSS and the SLH-DSA hypertree (â„ and ğ‘‘), and FORS (ğ‘˜\nand ğ‘), as well as instantiations for the functions Hğ‘šğ‘ ğ‘”, PRF, PRFğ‘šğ‘ ğ‘”, F, H, and Tâ„“.\nTable 2 lists the parameter sets that are approved for use.Â²â°         Each parameter set name indicates\nthe hash function family (SHA2 or SHAKE) that is used to instantiate the hash functions, the\nlength in bits of the security parameter ğ‘›, and whether the parameter set was designed to create\nrelatively small signatures (â€˜sâ€™) or to have relatively fast signature generation (â€˜fâ€™). There are six\nsets of values for ğ‘›, ğ‘™ğ‘”ğ‘¤, â„, ğ‘‘, ğ‘˜, and ğ‘ that are approved for use.Â²Â¹     For each of the six sets of\n                                                   values, the functions Hğ‘šğ‘ ğ‘”, PRF, PRFğ‘šğ‘ ğ‘”, F, H, and Tâ„“ may be instantiated using either\nSHAKE [6] or SHA-2 [8]. For the SHAKE parameter sets, the functions shall be instantiated as\nspecified in Section 11.1. For the SHA2 parameter sets, the functions shall be instantiated as\nspecified in Section 11.2.1 if ğ‘› = 16 and shall be instantiated as specified in Section 11.2.2 if\nğ‘› = 24 or ğ‘› = 32.\n\n                                                                              Table 2. SLH-DSA parameter sets\n\n                                                                                  security     pk    sig\n                       ğ‘›     â„      ğ‘‘    â„â€²    ğ‘        ğ‘˜    ğ‘™ğ‘”ğ‘¤     ğ‘š    category    bytes  bytes\n SLH-DSA-SHA2-128s     16     63     7     9     12        14    4          30     1           32     7 856\n SLH-DSA-SHAKE-128s\n SLH-DSA-SHA2-128f     16     66     22    3     6         33    4          34     1           32    17 088\n SLH-DSA-SHAKE-128f\n SLH-DSA-SHA2-192s     24     63     7     9     14        17    4          39     3           48    16 224\n SLH-DSA-SHAKE-192s\n SLH-DSA-SHA2-192f     24     66     22    3     8         33    4          42     3           48    35 664\n SLH-DSA-SHAKE-192f\n SLH-DSA-SHA2-256s     32     64     8     8     14        22    4          47     5           64    29 792\n SLH-DSA-SHAKE-256s\n SLH-DSA-SHA2-256f     32     68     17    4     9         35    4          49     5           64    49 856\n SLH-DSA-SHAKE-256f\n\n                                                 The 12 parameter sets included in Table 2 were designed to meet certain security strength\ncategories defined by NIST in its original Call for Proposals [25] with respect to existential un-\nforgeability under chosen message attack (EUF-CMA) when each key pair is used to sign at most\n2â¶â´ messages.Â²Â² These security strength categories are explained further in SP 800-57, Part 1 [9].\n\n20SP 800-230 [24] specifies additional parameter sets that are approved for use. While key pairs generated for the\n parameter sets specified in this standard may be used to sign up to 264 messages, key pairs generated for the\n parameter sets in SP 800-230 are more limited in the number of signatures that may be generated.\n21In addition to ğ‘›, ğ‘™ğ‘”ğ‘¤, â„, ğ‘‘, ğ‘˜, and ğ‘, Table 2 also lists values for parameters that may be computed from these\n values (â„â€², ğ‘š, public-key size(pk bytes), and signature size(sig bytes)). The security category is the security\n category in which the parameter set is claimed to be [10].\n22If a key pair were used to sign 10 billion (1010 ) messages per second, it would take over 58 years to sign 264\n messages.\n                                                                                             43"}
{"doc_id": "NIST.FIPS.205", "source_path": "data/raw_pdfs/NIST.FIPS.205.pdf", "page_number": 54, "text": "    FIPS 205                                      STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n\n    Using this approach, security strength is not described by a single number, such as â€œ128 bits of\n    security.â€ Instead, each parameter set is claimed to be at least as secure as a generic block cipher\nwith a prescribed key size. More precisely, it is claimed that the computational resources needed\n    to break SLH-DSA are greater than or equal to the computational resources needed to break the\n    block cipher when these computational resources are estimated using any realistic model of\n    computation. Different models of computation can be more or less realistic and, accordingly,\n    lead to more or less accurate estimates of security strength. Some commonly studied models\n    are discussed in [26].\n    Concretely, the parameter sets with ğ‘› = 16 are claimed to be in security category 1, the\n    parameter sets with ğ‘› = 24 are claimed to be in security category 3, and the parameter sets with\n    ğ‘› = 32 are claimed to be in security category 5 [10]. For additional discussion of the security\n    strength of SLH-DSA, see [10, 27].\n    Some applications require a property known as message-bound signatures [28, 29], which\n    intuitively requires that it be infeasible for anyone to create a public key and a signature that\n    are valid for two different messages. Signature schemes are not required to have this property\n    under the EUF-CMA security definition used in assigning security categories.          In the case of\n    SLH-DSA, the key pair owner could create two messages with the same signature by finding\n    a collision on Hğ‘šğ‘ ğ‘”. Due to the length of the output of Hğ‘šğ‘ ğ‘”, finding such a collision would\n    be expected to require fewer computational resources than specified for the parameter setsâ€™\n    claimed security categories in all cases except SLH-DSA-SHA2-128f and SLH-DSA-SHAKE-128f.Â²Â³\n    Therefore, applications that require message-bound signatures should either take the expected\n    cost of finding collisions on Hğ‘šğ‘ ğ‘” into account when choosing an appropriate parameter set or\n    apply a technique (e.g., the BUFF transformation [29]) to obtain the message-bound signatures\n    property.\n\n    11.1        SLH-DSA Using SHAKE\n    Hğ‘šğ‘ ğ‘”, PRF, PRFğ‘šğ‘ ğ‘”, F, H, and Tâ„“ shall be instantiated as follows for the SLH-DSA-SHAKE-\n    128s, SLH-DSA-SHAKE-128f, SLH-DSA-SHAKE-192s, SLH-DSA-SHAKE-192f, SLH-DSA-SHAKE-256s,\n    and SLH-DSA-SHAKE-256f parameter sets:\n    Hğ‘šğ‘ ğ‘”(ğ‘…, PK.seed, PK.root, ğ‘€) = SHAKE256(ğ‘… âˆ¥ PK.seed âˆ¥ PK.root âˆ¥ ğ‘€ , 8ğ‘š)\n    PRF(PK.seed, SK.seed, ADRS) = SHAKE256(PK.seed âˆ¥ ADRS âˆ¥ SK.seed, 8ğ‘›)\n    PRFğ‘šğ‘ ğ‘”(SK.prf, ğ‘œğ‘ğ‘¡_ğ‘Ÿğ‘ğ‘›ğ‘‘, ğ‘€) = SHAKE256(SK.prf âˆ¥ ğ‘œğ‘ğ‘¡_ğ‘Ÿğ‘ğ‘›ğ‘‘ âˆ¥ ğ‘€ , 8ğ‘›)\n    F(PK.seed, ADRS, ğ‘€â‚) = SHAKE256(PK.seed âˆ¥ ADRS âˆ¥ ğ‘€â‚, 8ğ‘›)\n    H(PK.seed, ADRS, ğ‘€â‚‚) = SHAKE256(PK.seed âˆ¥ ADRS âˆ¥ ğ‘€â‚‚, 8ğ‘›)\n    Tâ„“(PK.seed, ADRS, ğ‘€â„“) = SHAKE256(PK.seed âˆ¥ ADRS âˆ¥ ğ‘€â„“, 8ğ‘›)\n\n    11.2        SLH-DSA Using SHA2\n    In Sections 11.2.1 and 11.2.2, the functions MGF1-SHA-256 and MGF1-SHA-512 are MGF1 from\n    Appendix B.2.1 of RFC 8017 [30], where Hash is SHA-256 or SHA-512, respectively. The functions\n\n    23Finding a collision would be expected to require computing Hğ‘šğ‘ ğ‘” for approximately 2(â„+ğ‘˜â‹…ğ‘)/2 different mes-\n    sages.\n          44"}
{"doc_id": "NIST.FIPS.205", "source_path": "data/raw_pdfs/NIST.FIPS.205.pdf", "page_number": 55, "text": "    FIPS 205                                    STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n\n    HMAC-SHA-256 and HMAC-SHA-512 are the HMAC function from FIPS 198-1 [31, 32], where ğ»\n    is SHA-256 or SHA-512, respectively.\n    The functions in Sections 11.2.1 and 11.2.2 make use of a compressed version of ADRS (see\n    Figure 18). A compressed address (ADRSğ‘) is a 22-byte string that is the same as an ADRS\n    with the exceptions that the encodings of the layer address and type are reduced to one byte\n    each and the encoding of the tree address is reduced to eight bytes (i.e., ADRSğ‘ = ADRS[3] âˆ¥\n    ADRS[8 âˆ¶ 16] âˆ¥ ADRS[19] âˆ¥ ADRS[20 âˆ¶ 32]). For implementations of the SHA2 parameter\n    sets that store addresses in compressed form (i.e., 22 bytes), the member functions (Section 4.3)\n    are as shown in Table 3 rather than Table 1.\n\n    layer address    1 byte\ntree address       8 bytes\n    ğ‘¡ğ‘¦ğ‘ğ‘’         1 byte\n\n                   12 bytes\n\n    Figure 18. Compressed address (ADRSğ‘)\n\n                       Table 3. Member functions for compressed addresses\n\nMember function\nADRS.setLayerAddress(ğ‘™)\nADRS.setTreeAddress(ğ‘¡)\nADRS.setTypeAndClear(ğ‘Œ)\nADRS.setKeyPairAddress(ğ‘–)\nADRS.setChainAddress(ğ‘–)\nADRS.setTreeHeight(ğ‘–)\nADRS.setHashAddress(ğ‘–)\nADRS.setTreeIndex(ğ‘–)\nğ‘– â† ADRS.getKeyPairAddress()\nğ‘– â† ADRS.getTreeIndex()\n Expanded notation\nADRS â† toByte(ğ‘™, 1) âˆ¥ ADRS[1 âˆ¶ 22]\nADRS â† ADRS[0 âˆ¶ 1] âˆ¥ toByte(ğ‘¡, 8) âˆ¥ ADRS[9 âˆ¶ 22]\nADRS â† ADRS[0 âˆ¶ 9] âˆ¥ toByte(ğ‘Œ , 1) âˆ¥ toByte(0, 12)\nADRS â† ADRS[0 âˆ¶ 10] âˆ¥ toByte(ğ‘–, 4) âˆ¥ ADRS[14 âˆ¶ 22]\nADRS â† ADRS[0 âˆ¶ 14] âˆ¥ toByte(ğ‘–, 4) âˆ¥ ADRS[18 âˆ¶ 22]\n\nADRS â† ADRS[0 âˆ¶ 18] âˆ¥ toByte(ğ‘–, 4)\n\nğ‘– â† toInt(ADRS[10 âˆ¶ 14], 4)\nğ‘– â† toInt(ADRS[18 âˆ¶ 22], 4)\n\n    11.2.1  SLH-DSA Using SHA2 for Security Category 1\n    Hğ‘šğ‘ ğ‘”, PRF, PRFğ‘šğ‘ ğ‘”, F, H, and Tâ„“ shall be instantiated as follows for the SLH-DSA-SHA2-128s\n    and SLH-DSA-SHA2-128f parameter sets:\n    Hğ‘šğ‘ ğ‘”(ğ‘…, PK.seed, PK.root, ğ‘€) =\n            MGF1-SHA-256(ğ‘… âˆ¥ PK.seed âˆ¥ SHA-256(ğ‘… âˆ¥ PK.seed âˆ¥ PK.root âˆ¥ ğ‘€ ), ğ‘š)\n\n                                         45"}
{"doc_id": "NIST.FIPS.205", "source_path": "data/raw_pdfs/NIST.FIPS.205.pdf", "page_number": 56, "text": "FIPS 205                           STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n\nPRF(PK.seed, SK.seed, ADRS) =\n\nPRF         Truncğ‘›(SHA-256(PK.seed âˆ¥ toByte(0, 64 âˆ’ ğ‘›) âˆ¥ ADRSğ‘ âˆ¥ SK.seed))\nğ‘šğ‘ ğ‘”(SK.prf, ğ‘œğ‘ğ‘¡_ğ‘Ÿğ‘ğ‘›ğ‘‘, ğ‘€) =\n\nF(PK.seed,  Truncğ‘›(HMAC-SHA-256(SK.prf, ğ‘œğ‘ğ‘¡_ğ‘Ÿğ‘ğ‘›ğ‘‘ âˆ¥ ğ‘€ ))\n            ADRS, ğ‘€â‚) =                                        ğ‘\n\nH(PK.seed,  Truncğ‘›(SHA-256(PK.seed âˆ¥ toByte(0, 64 âˆ’ ğ‘›) âˆ¥ ADRS   âˆ¥ ğ‘€â‚))\n            ADRS, ğ‘€â‚‚) =                                        ğ‘\n\nT (PK.seed, Truncğ‘›(SHA-256(PK.seed âˆ¥ toByte(0, 64 âˆ’ ğ‘›) âˆ¥ ADRS   âˆ¥ ğ‘€â‚‚))\nâ„“           ADRS, ğ‘€â„“) =                                        ğ‘\n            Truncğ‘›(SHA-256(PK.seed âˆ¥ toByte(0, 64 âˆ’ ğ‘›) âˆ¥ ADRS   âˆ¥ ğ‘€â„“))\n\n11.2.2      SLH-DSA Using SHA2 for Security Categories 3 and 5\nHğ‘šğ‘ ğ‘”, PRF, PRFğ‘šğ‘ ğ‘”, F, H, and Tâ„“ shall be instantiated as follows for the SLH-DSA-SHA2-192s,\nSLH-DSA-SHA2-192f, SLH-DSA-SHA2-256s, and SLH-DSA-SHA2-256f parameter sets:\nHğ‘šğ‘ ğ‘”(ğ‘…, PK.seed, PK.root, ğ‘€) =\n            MGF1-SHA-512(ğ‘… âˆ¥ PK.seed âˆ¥ SHA-512(ğ‘… âˆ¥ PK.seed âˆ¥ PK.root âˆ¥ ğ‘€ ), ğ‘š)\nPRF(PK.seed, SK.seed, ADRS) =\n\nPRF         Truncğ‘›(SHA-256(PK.seed âˆ¥ toByte(0, 64 âˆ’ ğ‘›) âˆ¥ ADRSğ‘ âˆ¥ SK.seed))\n     ğ‘šğ‘ ğ‘”(SK.prf, ğ‘œğ‘ğ‘¡_ğ‘Ÿğ‘ğ‘›ğ‘‘, ğ‘€) =\n\nF(PK.seed,  Truncğ‘›(HMAC-SHA-512(SK.prf, ğ‘œğ‘ğ‘¡_ğ‘Ÿğ‘ğ‘›ğ‘‘ âˆ¥ ğ‘€ ))\n            ADRS, ğ‘€â‚) =                                        ğ‘\n\nH(PK.seed,  Truncğ‘›(SHA-256(PK.seed âˆ¥ toByte(0, 64 âˆ’ ğ‘›) âˆ¥ ADRS   âˆ¥ ğ‘€â‚))\n            ADRS, ğ‘€â‚‚) =                                          ğ‘\n\nT (PK.seed, Truncğ‘›(SHA-512(PK.seed âˆ¥ toByte(0, 128 âˆ’ ğ‘›) âˆ¥ ADRS    âˆ¥ ğ‘€â‚‚))\nâ„“           ADRS, ğ‘€â„“) =                                          ğ‘\n            Truncğ‘›(SHA-512(PK.seed âˆ¥ toByte(0, 128 âˆ’ ğ‘›) âˆ¥ ADRS    âˆ¥ ğ‘€â„“))\n\n46"}
{"doc_id": "NIST.FIPS.205", "source_path": "data/raw_pdfs/NIST.FIPS.205.pdf", "page_number": 57, "text": "FIPS 205                                  STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n\nReferences\n\n [1]  National Institute of Standards and Technology (2023) Digital Signature Standard (DSS).\n      (Department of Commerce, Washington, D.C.), Federal Information Processing Standards\n      Publications (FIPS) NIST FIPS 186-5. https://doi.org/10.6028/NIST.FIPS.186-5.\n [2]  National Institute of Standards and Technology (2024) Guideline for Using Cryptographic\n      Standards in the Federal Government: Cryptographic Mechanisms. (National Institute of\n      Standards and Technology, Gaithersburg, MD), NIST Special Publication (SP) 800-175B, Rev.\n      2. [Forthcoming: will be available at https://csrc.nist.gov/publications].\n [3]  National Institute of Standards and Technology (2024) Recommendation for Obtaining\n      Assurances for Digital Signature Applications. (National Institute of Standards and Technol-\n      ogy, Gaithersburg, MD), NIST Special Publication (SP) 800-89, Rev. 1. [Forthcoming: will be\n      available at https://csrc.nist.gov/publications].\n [4]  Aumasson JP, Bernstein DJ, Beullens W, Dobraunig C, Eichlseder M, Fluhrer S, Gazdag\n      SL, HÃ¼lsing A, Kampanakis P, KÃ¶lbl S, Lange T, Lauridsen MM, Mendel F, Niederhagen R,\n      Rechberger C, Rijneveld J, Schwabe P, Westerbaan B (2020) SPHINCSâº â€“ Submission to the\n      NIST post-quantum project, v.3.\n [5]  Barker EB, Chen L, Roginsky AL, Vassilev A, Davis R, Simon S (2019) Recommendation for\n      Pair-Wise Key-Establishment Using Integer Factorization Cryptography. (National Institute\n      of Standards and Technology, Gaithersburg, MD), NIST Special Publication (SP) 800-56B,\n      Rev. 2. https://doi.org/10.6028/NIST.SP.800-56Br2.\n [6]  National Institute of Standards and Technology (2015) SHA-3 Standard: Permutation-Based\n      Hash and Extendable-Output Functions. (Department of Commerce, Washington, DC),\n      Federal Information Processing Standards Publication (FIPS) NIST FIPS 202. https://doi.org/\n      10.6028/NIST.FIPS.202.\n [7]  Kelsey JM, Chang SjH, Perlner RA (2016) SHA-3 Derived Functions: cSHAKE, KMAC, Tuple-\n      Hash and ParallelHash. (National Institute of Standards and Technology, Gaithersburg, MD),\n      NIST Special Publication (SP) 800-185. https://doi.org/10.6028/NIST.SP.800-185.\n [8]  National Institute of Standards and Technology (2015) Secure Hash Standard (SHS). (De-\n      partment of Commerce, Washington, D.C.), Federal Information Processing Standards\n      Publication (FIPS) NIST FIPS 180-4. https://doi.org/10.6028/NIST.FIPS.180-4.\n [9]  National Institute of Standards and Technology (2024) Recommendation for Key Manage-\n      ment: Part 1 â€“ General. (National Institute of Standards and Technology, Gaithersburg,\n      MD), NIST Special Publication (SP) 800-57 Part 1, Rev 6. [Forthcoming: will be available at\n      https://csrc.nist.gov/publications].\n[10]  Aumasson JP, Bernstein DJ, Beullens W, Dobraunig C, Eichlseder M, Fluhrer S, Gazdag\n      SL, HÃ¼lsing A, Kampanakis P, KÃ¶lbl S, Lange T, Lauridsen MM, Mendel F, Niederhagen R,\n      Rechberger C, Rijneveld J, Schwabe P, Westerbaan B (2022) SPHINCSâº â€“ Submission to\n      the NIST post-quantum project, v.3.1. Available at https://sphincs.org/data/sphincs+-r3.1-\n      specification.pdf.\n\n47"}
{"doc_id": "NIST.FIPS.205", "source_path": "data/raw_pdfs/NIST.FIPS.205.pdf", "page_number": 58, "text": "FIPS 205                                      STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n\n[11]  HÃ¼lsing A, Butin D, Gazdag SL, Rijneveld J, Mohaisen A (2018) XMSS: eXtended Merkle\n      Signature Scheme. (Internet Research Task Force (IRTF)), IRTF Request for Comments (RFC)\n      8391. https://doi.org/10.17487/RFC8391.\n[12]  Cooper DA, Apon D, Dang QH, Davidson MS, Dworkin MJ, Miller CA (2020) Recommendation\n      for Stateful Hash-Based Signature Schemes. (National Institute of Standards and Technology,\n      Gaithersburg, MD), NIST Special Publication (SP) 800-208. https://doi.org/10.6028/NIST.SP.\n      800-208.\n[13]  Merkle RC (1979) Secrecy, Authentication, and Public Key Systems. Ph.D. thesis. Stanford\n      university, .\n[14]  Barker EB, Kelsey JM (2015) Recommendation for Random Number Generation Using\n      Deterministic Random Bit Generators. (National Institute of Standards and Technology,\n      Gaithersburg, MD), NIST Special Publication (SP) 800-90A, Rev. 1. https://doi.org/10.6028/\n      NIST.SP.800-90Ar1.\n[15]  SÃ¶nmez Turan M, Barker EB, Kelsey JM, McKay KA, Baish ML, Boyle M (2018) Recom-\n      mendation for the Entropy Sources Used for Random Bit Generation. (National Institute\n      of Standards and Technology, Gaithersburg, MD), NIST Special Publication (SP) 800-90B.\n      https://doi.org/10.6028/NIST.SP.800-90B.\n[16]  Barker EB, Kelsey JM, McKay KA, Roginsky AL, SÃ¶nmez Turan M (2022) Recommendation for\n      Random Bit Generator (RBG) Constructions. (National Institute of Standards and Technology,\n      Gaithersburg, MD), NIST Special Publication (SP) 800-90C 4pd. https://doi.org/10.6028/\n      NIST.SP.800-90C.4pd.\n[17]  Kannwischer MJ, GenÃªt A, Butin D, KrÃ¤mer J, Buchmann J (2018) Differential Power Analysis\n      of XMSS and SPHINCS. Constructive Side-Channel Analysis and Secure Design, eds Fan J,\n      Gierlichs B (Springer International Publishing, Cham), pp 168â€“188. https://doi.org/10.1007/\n      978-3-319-89641-0_10.\n[18]  Castelnovi L, Martinelli A, Prest T (2018) Grafting Trees: A Fault Attack Against the SPHINCS\n      Framework. Post-Quantum Cryptography, eds Lange T, Steinwandt R (Springer International\n      Publishing, Cham), pp 165â€“184. https://doi.org/10.1007/978-3-319-79063-3_8.\n[19]  GenÃªt A, Kannwischer MJ, Pelletier H, McLauchlan A (2018) Practical Fault Injection Attacks\n      on SPHINCS, Cryptology ePrint Archive preprint. https://ia.cr/2018/674.\n[20]  Amiet D, Leuenberger L, Curiger A, Zbinden P (2020) FPGA-based SPHINCS+ Implementa-\n      tions: Mind the Glitch. 2020 23rd Euromicro Conference on Digital System Design (DSD), pp\n      229â€“237. https://doi.org/10.1109/DSD51259.2020.00046.\n[21]  GenÃªt A (2023) On Protecting SPHINCS+ Against Fault Attacks. IACR Transactions on Cryp-\n      tographic Hardware and Embedded Systems 2023(2):80â€“114. https://doi.org/10.46586/\n      tches.v2023.i2.80-114.\n[22]  Groot Bruinderink L, HÃ¼lsing A (2018) â€œOops, I Did It Againâ€ â€“ Security of One-Time Signatures\n      Under Two-Message Attacks. Selected Areas in Cryptography â€“ SAC 2017, eds Adams C,\n      Camenisch J (Springer International Publishing, Cham), pp 299â€“322. https://doi.org/10.\n      1007/978-3-319-72565-9_15.\n\n                                48"}
{"doc_id": "NIST.FIPS.205", "source_path": "data/raw_pdfs/NIST.FIPS.205.pdf", "page_number": 59, "text": "FIPS 205                                    STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n\n[23]  Housley R (2009) Cryptographic Message Syntax (CMS). (Internet Engineering Task Force\n      (IETF)), IETF Request for Comments (RFC) 5652. https://doi.org/10.17487/RFC5652.\n[24]  National Institute of Standards and Technology (2024) Recommendation for Additional\n      Stateless Hash-Based Digital Signature Parameter Sets. (National Institute of Standards and\n      Technology, Gaithersburg, MD), NIST Special Publication (SP) 800-230. [Forthcoming: will\n      be available at https://csrc.nist.gov/publications].\n[25]  National Institute of Standards and Technology (2016) Submission Requirements and Eval-\n      uation Criteria for the Post-Quantum Cryptography Standardization Process. Available\n      at https://csrc.nist.gov/CSRC/media/Projects/Post-Quantum-Cryptography/documents/\n      call-for-proposals-final-dec-2016.pdf.\n[26]  Alagic G, Apon D, Cooper DA, Dang QH, Dang T, Kelsey JM, Lichtinger J, Liu YK, Miller CA,\n      Moody D, Peralta R, Perlner RA, Robinson A, Smith-Tone D (2022) Status Report on the\n      Third Round of the NIST Post-Quantum Cryptography Standardization Process. (National\n      Institute of Standards and Technology, Gaithersburg, MD), NIST Interagency or Internal\n      Report (IR) NIST IR 8413-upd1, includes updates as of September 26, 2022. https://doi.org/\n      10.6028/NIST.IR.8413-upd1.\n[27]  HÃ¼lsing A, Kudinov M (2022) Recovering the Tight Security Proof of SPHINCSâº. Advances in\n      Cryptology â€“ ASIACRYPT 2022, eds Agrawal S, Lin D (Springer Nature Switzerland, Cham),\n      pp 3â€“33. https://doi.org/10.1007/978-3-031-22972-5_1.\n[28]  Stern J, Pointcheval D, Malone-Lee J, Smart NP (2002) Flaws in Applying Proof Methodologies\n      to Signature Schemes. Advances in Cryptology â€” CRYPTO 2002, ed Yung M (Springer Berlin\n      Heidelberg, Berlin, Heidelberg), pp 93â€“110. https://doi.org/10.1007/3-540-45708-9_7.\n[29]  Cremers C, DÃ¼zlÃ¼ S, Fiedler R, Janson C, Fischlin M (2021) BUFFing Signature Schemes\n      Beyond Unforgeability and the Case of Post-Quantum Signatures. 2021 IEEE Symposium on\n      Security and Privacy (SP) (IEEE Computer Society, Los Alamitos, CA, USA), pp 1696â€“1714.\n      https://doi.org/10.1109/SP40001.2021.00093.\n[30]  Moriarty K, Kaliski B, Jonsson J, Rusch A (2016) PKCS #1: RSA Cryptography Specifications\n      Version 2.2. (Internet Engineering Task Force (IETF)), IETF request for comments (RFC) 8017.\n      https://doi.org/10.17487/RFC8017.\n[31]  National Institute of Standards and Technology (2008) The Keyed-Hash Message Authentica-\n      tion Code (HMAC). (Department of Commerce, Washington, DC), Federal Information Pro-\n      cessing Standards Publication (FIPS) NIST FIPS 198-1. https://doi.org/10.6028/NIST.FIPS.198-\n      1.\n[32]  Krawczyk H, Bellare M, Canetti R (1997) HMAC: Keyed-Hashing for Message Authentication.\n      (Internet Engineering Task Force (IETF)), IETF request for comments (RFC) 2104. https:\n      //doi.org/10.17487/RFC2104.\n[33]  Stern M (2021) Re: Diversity of signature schemes. Available at https://groups.google.com/\n      a/list.nist.gov/g/pqc-forum/c/2LEoSpskELs/m/LkUdQ5mKAwAJ.\n[34]  Antonov S (2022) ROUND 3 OFFICIAL COMMENT: SPHINCS+. Available at https://groups.\n      google.com/a/list.nist.gov/g/pqc-forum/c/FVItvyRea28/m/mGaRi5iZBwAJ.\n\n                                            49"}
{"doc_id": "NIST.FIPS.205", "source_path": "data/raw_pdfs/NIST.FIPS.205.pdf", "page_number": 60, "text": "FIPS 205    STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n\n[35]  Perlner R, Kelsey J, Cooper D (2022) Breaking Category Five SPHINCSâº with SHA-256. Post-\n      Quantum Cryptography, eds Cheon JH, Johansson T (Springer International Publishing,\n      Cham), pp 501â€“522. https://doi.org/10.1007/978-3-031-17234-2_23.\n\n50"}
{"doc_id": "NIST.FIPS.205", "source_path": "data/raw_pdfs/NIST.FIPS.205.pdf", "page_number": 61, "text": "FIPS 205                                      STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n\nAppendix A â€” Differences From the SPHINCS+ Submission\n\n       This standard is based on Version 3.1 of the SPHINCSâº specification [10] and contains several\nminor modifications compared to Version 3 [4], which was submitted at the beginning of round\nthree of the NIST PQC Standardization process:\n  â€¢ Two new address types â€” WOTS_PRF and FORS_PRF â€” were defined for WOTSâº and FORS\n    secret key value generation.\n  â€¢ PK.seed was added as an input to PRF in order to mitigate multi-key attacks.\n  â€¢ For the category 3 and 5 SHA2 parameter sets, SHA-256 was replaced by SHA-512 in Hğ‘šğ‘ ğ‘”,\n    PRFğ‘šğ‘ ğ‘”, H, and Tâ„“ based on weaknesses that were discovered when using SHA-256 to\n    obtain category 5 security [33, 34, 35].\n  â€¢ ğ‘… and PK.seed were added as inputs to MGF1 when computing Hğ‘šğ‘ ğ‘” for the SHA2\n    parameter sets in order to mitigate multi-target long-message second preimage attacks.\n     This standard also differs from the Version 3 specification in its method for extracting bits from\nthe message digest to select a FORS key. This change was made in order to align with the\nreference implementation that was submitted along with the round three specification. The\ndescription of the method for extracting indices for FORS signature generation and verification\nfrom the message digest was also changed due to ambiguity in the submitted specification. The\nmethod described in this standard is not compatible with the method used in the reference\nimplementation that was submitted along with the round three specification. Additionally, line 6\nin both wots_sign and wots_pkFromSig were changed to match the reference implementation,\nas the pseudocode in [10, 4] will sometimes shift ğ‘ğ‘ ğ‘¢ğ‘š by the incorrect amount when ğ‘™ğ‘”ğ‘¤ is not\n4.\n    This standard approves the use of only 12 of the 36 parameter sets defined in [10, 4]. As specified\nin Section 11, only the â€˜simpleâ€™ instances of the SHA2 and SHAKE parameter sets are approved.\n\nA.1 Changes From FIPS 205 Initial Public Draft\n         The differences from Version 3 of the SPHINCSâº specification described in Appendix A were\nincluded in the draft version of this standard (FIPS 205 ipd) that was posted on August 24, 2023.\nBased on comments that were submitted on FIPS 205 ipd, the SLH-DSA signature generation and\n        verification functions were modified to include domain separation cases in which the message\nis signed directly and in which a digest of the message is signed. The changes were made by\nmodifying the inputs to the signing and verification functions (see Algorithms 22, 23, 24, and\n25).\n\n51"}
{"doc_id": "NIST.IR.8545", "source_path": "data/raw_pdfs/NIST.IR.8545.pdf", "page_number": 1, "text": "    NIST Internal Report\n    NIST IR 8545\n    Status Report on the Fourth Round of the\n                    NIST Post-Quantum Cryptography\n                           Standardization Process\n\n    Gorjan Alagic\n                                       Maxime Bros\n                                    Pierre Ciadoux\n    David Cooper\n                                        Quynh Dang\n                                        Thinh Dang\n                                       John Kelsey\n                                  Jacob Lichtinger\n                                        Yi-Kai Liu\n                                       Carl Miller\n    Dustin Moody\n                                      Rene Peralta\n                                       Ray Perlner\n                                   Angela Robinson\n    Hamilton Silberg\n                                 Daniel Smith-Tone\n                                       Noah Waller\n\nThis publication is available free of charge from:\n              https://doi.org/10.6028/NIST.IR.8545\n\n  0\n    NST NATIONAL INSTITUTE OF\n    STANDARDS AND TECHNOLOGY\n  Check for    U.S. DEPARTMENT OF COMMERCE\n  updates"}
{"doc_id": "NIST.IR.8545", "source_path": "data/raw_pdfs/NIST.IR.8545.pdf", "page_number": 2, "text": "                    NIST Internal Report\n                    NIST IR 8545\n\nStatus Report on the Fourth Round of the\n                          NIST Post-Quantum Cryptography\n                                 Standardization Process\n\nGorjan Alagic           Carl Miller\n     Maxime Bros    Dustin Moody\n  Pierre Ciadoux    Rene Peralta\nDavid Cooper            Ray Perlner\n      Quynh Dang    Angela Robinson\n      Thinh Dang    Hamilton Silberg\n     John Kelsey    Daniel Smith-Tone\nJacob Lichtinger                             Noah Waller\n                              Computer Security Division\n                    Information Technology Laboratory\n\n                                              Yi-Kai Liu\n          Applied and Computational Mathematics Division\n                    Information Technology Laboratory\n\n      This publication is available free of charge from:\n                    https://doi.org/10.6028/NIST.IR.8545\n                    March 2025\n\n                                                                              U.S. Department of Commerce\n                                                                                Howard Lutnick, Secretary\nNational Institute of Standards and Technology\nCraig Burkhardt, Acting Under Secretary of Commerce for Standards and Technology and Acting NIST Director"}
{"doc_id": "NIST.IR.8545", "source_path": "data/raw_pdfs/NIST.IR.8545.pdf", "page_number": 3, "text": "Certain equipment, instruments, software, or materials, commercial or non-commercial, are identified in\nthis paper in order to specify the experimental procedure adequately. Such identification does not imply\nrecommendation or endorsement of any product or service by NIST, nor does it imply that the materials or\nequipment identified are necessarily the best available for the purpose.\nThere may be references in this publication to other publications currently under development by NIST in\naccordance with its assigned statutory responsibilities. The information in this publication, including\nconcepts and methodologies, may be used by federal agencies even before the completion of such\ncompanion publications. Thus, until each publication is completed, current requirements, guidelines, and\nprocedures, where they exist, remain operative. For planning and transition purposes, federal agencies\nmay wish to closely follow the development of these new publications by NIST.\nOrganizations are encouraged to review all draft publications during public comment periods and provide\nfeedback to NIST. Many NIST cybersecurity publications, other than the ones noted above, are available at\nhttps://csrc.nist.gov/publications.\n\nNIST Technical Series Policies\nCopyright, Use, and Licensing Statements\nNIST Technical Series Publication Identifier Syntax\n\nPublication History\nApproved by the NIST Editorial Review Board on 2025-03-05\nHow to cite this NIST Technical Series Publication:\nAlagic G, Bros M, Ciadoux P, Cooper D, Dang Q, Dang T, Kelsey J, Lichtinger J, Liu YK, Miller C, Moody D,\nPeralta R, Perlner R, Robinson A, Silberg H, Smith-Tone D, Waller N (2025) Status Report on the Fourth\nRound of the NIST Post-Quantum Cryptography Standardization Process. (National Institute of Standards\nand Technology, Gaithersburg, MD), NIST Internal Report (IR) NIST IR 8545.\nhttps://doi.org/10.6028/NIST.IR.8545"}
{"doc_id": "NIST.IR.8545", "source_path": "data/raw_pdfs/NIST.IR.8545.pdf", "page_number": 4, "text": "Author ORCID iDs\nGorjan Alagic: 0000-0002-0107-6037\nMaxime Bros: 0000-0001-7838-2529\nPierre Ciadoux: 0009-0001-2272-681X\nDavid Cooper: 0009-0001-2410-5830\nQuynh Dang: 0009-0005-9801-6805\nThinh Dang: 0000-0001-9705-0925\nJohn Kelsey: 0000-0002-3427-1744\nJacob Lichtinger: 0000-0003-2407-5309\nYi-Kai Liu: 0000-0001-7458-4721\nCarl Miller: 0000-0003-1917-1531\nDustin Moody: 0000-0002-4868-6684\nRene Peralta: 0000-0002-2318-7563\nRay Perlner: 0000-0001-8793-2238\nAngela Robinson: 0000-0002-1209-0379\nHamilton Silberg: 0009-0004-4178-8954\nDaniel Smith-Tone: 0000-0002-7995-8734\nNoah Waller: 0000-0002-6979-9725\nContact Information\npqc-comments@nist.gov\nAdditional Information\nAdditional information about this publication is available at https://csrc.nist.gov/pubs/ir/8545/final,\nincluding related content, potential updates, and document history.\nAll comments are subject to release under the Freedom of Information Act (FOIA)."}
{"doc_id": "NIST.IR.8545", "source_path": "data/raw_pdfs/NIST.IR.8545.pdf", "page_number": 5, "text": "NIST IR 8545    Fourth Round Status Report\nMarch 2025\n\nAbstract\n\nNIST is selecting public-key cryptographic algorithms through a public, competition-like\nprocess to specify additional digital signature, public-key encryption, and key-establishment\nalgorithms to supplement FIPS 186-5, SP 800-56Ar3, and SP 800-56Br2. These algorithms\nare intended to protect sensitive information well into the foreseeable future, including\nafter the advent of quantum computers. In the fourth round of the Post-Quantum Cryp-\ntography Standardization Process, NIST selected four candidate algorithms for key estab-\nlishment to be studied:  BIKE, Classic McEliece, HQC, and SIKE. This report describes the\nevaluation and selection process of these fourth-round candidates based on public feed-\nback and internal review.      The report summarizes each of the candidate algorithms and\nidentifies those selected for standardization.  The only key-establishment algorithm that\nwill be standardized is HQC, and NIST will develop a standard based on HQC to augment\nits key-establishment portfolio.\n\nKeywords\n\ncryptography; key-encapsulation mechanism (KEM); key establishment; post-quantum cryp-\ntography; quantum-resistant; quantum-safe.\n\nReports on Computer Systems Technology\n\nThe Information Technology Laboratory (ITL) at the National Institute of Standards and\nTechnology (NIST) promotes the U.S. economy and public welfare by providing technical\nleadership for the Nationâ€™s measurement and standards infrastructure. ITL develops tests,\ntest methods, reference data, proof of concept implementations, and technical analyses\nto advance the development and productive use of information technology. ITLâ€™s respon-\nsibilities include the development of management, administrative, technical, and physical\nstandards and guidelines for the cost-effective security and privacy of other than national\nsecurity-related information in federal information systems.\n\ni"}
{"doc_id": "NIST.IR.8545", "source_path": "data/raw_pdfs/NIST.IR.8545.pdf", "page_number": 6, "text": "NIST IR 8545    Fourth Round Status Report\nMarch 2025\n\n                                          Contents\n\n 1. Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     1\n 1.1.     Purpose and Organization of This Document            . . . . . . . . . . . . . . . . . .     3\n2. Evaluation Criteria and Selection Process       . . . . . . . . . . . . . . . . . . . . . . . .     4\n 2.1.     Acceptance of the Fourth-Round Candidates            . . . . . . . . . . . . . . . . . .     4\n 2.2.      Evaluation Criteria . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     4\n           2.2.1. Security . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     4\n           2.2.2. Cost and Performance       . . . . . . . . . . . . . . . . . . . . . . . . . . .     5\n           2.2.3. Algorithm and Implementation Characteristics           . . . . . . . . . . . . .     8\n 2.3.            Selection of the Candidates for Standardization . . . . . . . . . . . . . . . . .     8\n3. Summary of the Fourth-Round Candidates            . . . . . . . . . . . . . . . . . . . . . . .    10\n 3.1.      HQC . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .    10\n 3.2.     BIKE . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .    12\n 3.3.     Classic McEliece   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .    14\n 3.4.     SIKE . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .    16\n 4. Conclusion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .    18\nReferences   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .    19\nAppendix A. List of Symbols, Abbreviations, and Acronyms             . . . . . . . . . . . . . . .    26\n\n                           List of Tables\n\nTable 1. Timeline of the NIST Post-Quantum Cryptography Standardization Process                  .     2\nTable 2. Fourth-round KEM candidates organized by category, with the candidate se-\n         lected for standardization bolded and in blue         . . . . . . . . . . . . . . . . . .     4\nTable 3. Performance of BIKE in thousands of cycles on x86_64 [1]            . . . . . . . . . . .     6\n            Table 4. Performance of HQC in thousands of cycles on x86_64 [1] . . . . . . . . . . .     6\nTable 5. Performance of Classic McEliece in thousands of cycles on x86_64 [1]              . . . .     6\nTable 6. BIKE keys and ciphertext sizes in bytes       . . . . . . . . . . . . . . . . . . . . . .     7\nTable 7. HQC keys and ciphertext sizes in bytes        . . . . . . . . . . . . . . . . . . . . . .     7\nTable 8. Classic McEliece keys and ciphertext sizes in bytes         . . . . . . . . . . . . . . .     7\n\nii"}
{"doc_id": "NIST.IR.8545", "source_path": "data/raw_pdfs/NIST.IR.8545.pdf", "page_number": 7, "text": "NIST IR 8545    Fourth Round Status Report\nMarch 2025\n\nSupplemental Content\n\nThe NIST Post-Quantum Cryptography Standardization Process web page is available at https://cs\nrc.nist.gov/Projects/post-quantum-cryptography/post-quantum-cryptography-standardization.\n\nAcknowledgments\n\nNIST would like to thank all of the candidate submission teams who developed, designed, and an-\nalyzed the post-quantum candidate algorithms and prepared detailed submission packages.\nNIST is also grateful for the efforts of those in the cryptographic community who provided security,\nimplementation, and performance analyses of the candidate algorithms during the four rounds of\nthe process. NIST would not be able to select post-quantum digital algorithms for standardization\nwithout the combined efforts of these individuals and the algorithm submitters.\nThe authors of this report also appreciate the efforts by other members of NISTâ€™s PQC team who\nreviewed candidate algorithms, analyses, and public comments; performed testing; provided tech-\nnical and administrative support; and participated in numerous meetings to discuss the selection of\nthe candidate to be standardized. They are Zuzana Bajcsy, Lily Chen, Morris Dworkin, Sara Kerman,\nand Andrew Regenscheid.\n\niii"}
{"doc_id": "NIST.IR.8545", "source_path": "data/raw_pdfs/NIST.IR.8545.pdf", "page_number": 8, "text": "NIST IR 8545    Fourth Round Status Report\nMarch 2025\n\n1. Introduction\n\nThe National Institute of Standards and Technology (NIST) initiated the Post-Quantum Cryp-\ntography (PQC) Standardization Process in December 2016 to select quantum-resistant\npublic-key cryptographic algorithms for standardization in response to the substantial de-\nvelopment and advancement of quantum computing. After three rounds of evaluation\nand analysis, NIST announced the selection of the first algorithms to be standardized [2].\nThe key encapsulation mechanism (KEM) selected for standardization was CRYSTALS-Kyber\n(ML-KEM [3]). The digital signatures selected were CRYSTALS-Dilithium (ML-DSA [4]), Fal-\ncon (FN-DSA), and SPHINCS+ (SLH-DSA [5]). For a detailed explanation of NISTâ€™s choices,\nas well as a summary of the third round, see NIST IR 8413 [2].\nIn addition to those initial selections, NIST advanced four KEM candidates to the fourth\nround for continued evaluation: BIKE [6], Classic McEliece [7], HQC [8], and SIKE [9]. These\nalgorithms were all based on different security assumptions than ML-KEM. NIST indicated\nthat it would select one or two of the algorithms for standardization at the conclusion of\nthe fourth round.\nThe fourth round began in July 2022 and involved a thorough analysis of the theoretical\nand empirical evidence used to justify the security of the candidates. During this time, the\nsubmitters of SIKE acknowledged its insecurity and recommended against its further use.\nThe submission teams of the unbroken fourth-round candidates were invited to present\nupdates for their candidate algorithms at the Fifth NIST PQC Standardization Conference in\nRockville, Maryland, on April 10-12, 2024. The submitters participated in a joint panel to\ndiscuss the candidatesâ€™ merits, and several researchers presented work that was relevant\nto the PQC standardization process.\nThroughout the fourth round, NIST received valuable feedback from the cryptographic\ncommunity. Based on this feedback and internal reviews of the fourth-round candidates,\nNIST announced the selection of HQC in March 2025 for standardization.\nTable 1 shows a timeline of major events with respect to the NIST PQC Standardization\nProcess to date.\n\n1"}
{"doc_id": "NIST.IR.8545", "source_path": "data/raw_pdfs/NIST.IR.8545.pdf", "page_number": 9, "text": "   NIST IR 8545    Fourth Round Status Report\n   March 2025\n\n   Table 1. Timeline of the NIST Post-Quantum Cryptography Standardization Process\n\n   Date               Event\n   April 2015         Workshop on Cybersecurity  in    a Post-Quantum World,    NIST,\n                      Gaithersburg, MD\n    February 2016     PQC Standardization: Announcement and outline of NISTâ€™s Call\n                      for Submissions presentation given at PQCrypto 2016\n       April 2016     Release of IR 8105, Report on Post-Quantum Cryptography [10]\n    December 2016     Federal Register Notice â€“ Announcing Request for Nominations\n                      for Public-Key Post-Quantum Cryptographic Algorithms [11]\nNovember 30, 2017     Submission Deadline for NIST PQC Standardization Process\n    December 2017     Announcement of first-round candidates and beginning of first-\n                      round public comment period\n       April 2018     First NIST PQC Standardization Conference, Ft. Lauderdale, FL\n     January 2019     Announcement of second-round candidates; release of IR 8240,\n                      Status Report on the First Round of the NIST Post-Quantum Cryp-\n                      tography Standardization Process [12]; and beginning of second-\n                      round public comment period\n      August 2019     Second NIST PQC Standardization Conference, Santa Barbara, CA\n       April 2020     Call for feedback on the selection of third-round candidates\n        July 2020     Announcement of third-round finalists and alternate candidates;\n                      release of IR 8309, Status Report on the Second Round of the\n                      NIST Post-Quantum Cryptography Standardization Process [13];\n                      and beginning of third-round public comment period\n        June 2021     Third NIST PQC Standardization Conference, held virtually\n        July 2022     Announcement of candidate algorithms to be standardized and\n                      alternate candidates advancing to the fourth round; release of IR\n                      8413, Status Report on the Third Round of the NIST Post-Quantum\n                      Cryptography Standardization Process; and beginning of fourth-\n                      round public comment period\n     October 2022     Fourth round specifications published on NISTâ€™s PQC website\n    November 2022     Fourth NIST PQC Standardization Conference, held virtually\n      August 2023     Draft versions of FIPS 203 [14], FIPS 204 [4], and FIPS 205 [5]\n                      posted for public comment\n       April 2024     Fifth NIST PQC Standardization Conference, Gaithersburg, MD\n      August 2024     Final versions of FIPS 203 [14], FIPS 204 [4], and FIPS 205 [5] pub-\n                      lished\n     January 2025     Draft for KEM guidance SP 800-227 posted for public comment\n       March 2025     Announcement of fourth-round candidate algorithm to be stan-\n                      dardized and release of IR 8545, Status Report on the Fourth\n                      Round of the NIST Post-Quantum Cryptography Standardization\n                      Process\n\n   2"}
{"doc_id": "NIST.IR.8545", "source_path": "data/raw_pdfs/NIST.IR.8545.pdf", "page_number": 10, "text": "NIST IR 8545    Fourth Round Status Report\nMarch 2025\n\n1.1. Purpose and Organization of This Document\nThis report summarizes the fourth round of the NIST PQC Standardization Process.\nSection 2 enumerates the candidates that were included in the fourth round. It also de-\nscribes the evaluation criteria and selection process used to ultimately select HQC for stan-\ndardization.\nSection 3 summarizes each of the fourth-round candidates, including a brief description\nof the algorithm and its characteristics with regard to security, performance, and imple-\nmentation. This section also presents the rationale for standardizing some candidate algo-\nrithms and not others.\nSection 4 concludes and describes the next steps in the standardization process.\n\n3"}
{"doc_id": "NIST.IR.8545", "source_path": "data/raw_pdfs/NIST.IR.8545.pdf", "page_number": 11, "text": "NIST IR 8545    Fourth Round Status Report\nMarch 2025\n\n2. Evaluation Criteria and Selection Process\n\n2.1. Acceptance of the Fourth-Round Candidates\nNIST selected four candidate algorithms for the fourth round, all of which were KEMs. Clas-\nsic McEliece was a third-round finalist, and the other three algorithms were alternates [13].\nThe set of finalists included the algorithms that NIST considered to be the most promising\nto fit the majority of use cases and be ready for standardization soon after the third round.\nThe alternate candidates were regarded as potential candidates for future standardization,\nmost likely after another round of evaluation.\nThe submission teams were allowed to make minor modifications and resubmit their pack-\nages, which had to meet the same requirements as the original submissions. The complete\nupdated specifications were posted on NISTâ€™s PQC website [15] for public review on Oc-\ntober 27, 2022.   Most of the changes focused on fixing minor issues that were identified\nduring the third round and clarifying or simplifying the submission specification. One mod-\nification of note that occurred during the fourth round is BIKEâ€™s decoder. The thresholds\nfor the decoder were altered to reduce the risk of decryption failure. No major redesigns\nor changes were allowed.\n\nTable 2. Fourth-round KEM candidates organized by category, with the candidate\nselected for standardization bolded and in blue\n\n                        Code-Based  Isogeny-Based\n                        BIKE             SIKE\n                        HQC\n                        Classic McEliece\n\n2.2. Evaluation Criteria\nNISTâ€™s Call for Proposals [16] identified three broad aspects of the evaluation criteria that\nwould be used to compare candidate algorithms throughout the NIST PQC Standardiza-\ntion Process: 1) security, 2) cost and performance, and 3) algorithm and implementation\ncharacteristics. These criteria are described below, along with a discussion of how they\nimpacted the fourth-round candidate evaluations.\n\n2.2.1. Security\nAs with the previous phases of the PQC Standardization Process, security was the most im-\nportant factor that NIST considered when evaluating the fourth-round candidate schemes.\nIn the third round of the PQC Standardization Process, NIST selected one KEM â€” Kyber â€”\nthat was then standardized as ML-KEM in FIPS 203 [14]. The security of ML-KEM is based\nprimarily on the presumed hardness of certain computational problems in lattices. As dis-\ncussed in the third-round report, NIST values having a variety of computational hardness\n\n                                    4"}
{"doc_id": "NIST.IR.8545", "source_path": "data/raw_pdfs/NIST.IR.8545.pdf", "page_number": 12, "text": "NIST IR 8545    Fourth Round Status Report\nMarch 2025\n\nassumptions and aims to reduce the risk that a single cryptanalytic breakthrough will leave\nno viable standard for key establishment. In pursuit of that goal, NIST selected fourth-\nround candidates whose security was based on computational assumptions that differ sig-\nnificantly from that of ML-KEM. Specifically, the candidates consisted of the isogeny-based\nKEM SIKE and the code-based KEMs BIKE, HQC, and Classic McEliece. See Table 2.\nNISTâ€™s key-establishment standards are currently utilized in a wide variety of applications.\nThe specific properties required for a key-establishment scheme to provide security in a\ngiven application can vary. However, in terms of formal security definitions, a single no-\ntion suffices for key-establishment schemes that are intended for general use:      semantic\nsecurity with respect to adaptive chosen ciphertext attacks (equivalently, IND-CCA2 se-\ncurity).       ML-KEM is believed to satisfy IND-CCA2 security and is expected to serve as a\ngeneral-purpose scheme in any application that calls for NIST-approved post-quantum key-\nestablishment.\nThe formal security statuses of the fourth-round KEM candidates vary significantly. SIKE,\nthe sole isogeny-based candidate, was broken and thus does not satisfy IND-CCA2 secu-\nrity [17]. The code-based candidates BIKE, HQC, and Classic McEliece are believed to satisfy\nIND-CCA2 security. However, NISTâ€™s level of confidence in the IND-CCA2 security of these\nschemes is not equal. Notably, NIST has a higher level of confidence in the IND-CCA2 se-\ncurity of HQC than BIKE (see Sec. 3 for further details).\nSubmitters to the fourth round were encouraged but not required to provide proofs of IND-\nCCA2 security (from clearly stated computational assumptions) in relevant models. NIST\ndefined five security categories to compare the security strengths provided by the submis-\nsions. Submitters were asked to provide a classification of the security of the parameter\nsets of their schemes following the definitions provided in [16].\nNIST also listed other desirable security properties, such as resistance to side-channel and\nmulti-key attacks and resistance to misuse. Submissions were encouraged to note any ad-\nditional desirable security properties that they provided. Finally, NIST required submission\npackages to summarize known cryptanalytic attacks on the scheme and complexity esti-\nmates for those attacks.\n\n2.2.2. Cost and Performance\nThe second-most important criterion when evaluating candidate algorithms was their per-\nformance characteristics:\n â€¢ Sizes of encapsulation keys and ciphertexts\n â€¢ Computational efficiencies of encapsulations, decapsulations, and key generations\n       (i.e., the speeds of the algorithms)\nTables 3 through 5 show representative benchmarks for key generations, encapsulations,\nand decapsulations of BIKE, HQC, and Classic McEliece, respectively. Each row is a specific\n\n                                           5"}
{"doc_id": "NIST.IR.8545", "source_path": "data/raw_pdfs/NIST.IR.8545.pdf", "page_number": 13, "text": "NIST IR 8545    Fourth Round Status Report\nMarch 2025\n\nparameter set from the corresponding submission.     The â€œLevelâ€ columns indicate the se-\ncurity categories that the submission parameter sets claim to meet. BIKE and HQC each\nhad one parameter set per security category, while Classic McEliece had two. The Classic\nMcEliece f versions have faster key generation, while the non-f versions have simpler key\ngeneration.\nIn these benchmarks, BIKE is 6-10 times slower than HQC in key generation, 5-7 times\nslower than HQC in decapsulation, and about twice as fast as HQC in encapsulation. Key\ngeneration in Classic McEliece is an outlier, being three orders of magnitude more costly\nthan HQC.\n\n                  Parameter Set    Level  keygen     encaps   decaps\n                  BIKE Level 1       I       637       111     1 428\n                  BIKE Level 3      III     1 892      251     4 313\n                  BIKE Level 5       V      4 535      505    10 382\n\n         Table 3. Performance of BIKE in thousands of cycles on x86_64 [1]\n\n                  Parameter Set    Level  keygen     encaps   decaps\n                  hqc-128            I       105       197       360\n                  hqc-192           III      244       460       746\n                  hqc-256            V       447       844     1 410\n\n         Table 4. Performance of HQC in thousands of cycles on x86_64 [1]\n\n           Parameter Set           Level    keygen     encaps     decaps\n           mceliece348864          I        137 345         49     120\n           mceliece348864f                  114 189         45     120\n           mceliece460896          III      430 364         91     232\n           mceliece460896f                  313 600         92     231\n           mceliece6688128         V        674 012        196     273\n           mceliece6688128f                 493 758        176     274\n           mceliece6960119         V        602 164        167     252\n           mceliece6960119f                 404 166        169     253\n           mceliece8192128         V        686 110        203     269\n           mceliece8192128f                 453 985        206     269\n\nTable 5.   Performance of Classic McEliece in thousands of cycles on x86_64 [1]\n\n6"}
{"doc_id": "NIST.IR.8545", "source_path": "data/raw_pdfs/NIST.IR.8545.pdf", "page_number": 14, "text": "NIST IR 8545    Fourth Round Status Report\nMarch 2025\n\nTables 6 through 8 show the sizes of keys and ciphertexts for BIKE, HQC, and Classic McEliece.\nThe encapsulation keys of HQC are about 41-47 % larger than those of BIKE. The ciphertexts\nof HQC are about three times larger than the ciphertexts of BIKE.\n\n  Parameter Set    Level    Encapsulation Key    Decapsulation Key        Ciphertext\n  BIKE Level 1       I          1 541                            281       1 573\n  BIKE Level 3      III         3 083                            419       3 115\n  BIKE Level 5       V          5 122                            580       5 154\n\n                   Table 6.  BIKE keys and ciphertext sizes in bytes\n\n  Parameter Set    Level    Encapsulation Key    Decapsulation Key        Ciphertext\n  hqc-128            I          2 249          40                          4 497\n  hqc-192           III         4 522          40                          9 042\n  hqc-256            V          7 245          40                         14 485\n\n                   Table 7.  HQC keys and ciphertext sizes in bytes\n\n Parameter Set        Level  Encapsulation Key   Decapsulation Key        Ciphertext\n mceliece348864       I       261 120                            6 492        96\n mceliece348864f\n mceliece460896       III     524 160        13 608                           156\n mceliece460896f\n mceliece6688128      V       1 044 992      13 932                           208\n mceliece6688128f\n mceliece6960119      V       1 047 319      13 948                           194\n mceliece6960119f\n mceliece8192128      V       1 357 824      14 120                           208\n mceliece8192128f\n\n             Table 8. Classic McEliece keys and ciphertext sizes in bytes\n\nThere are a few studies comparing the performances of the KEMs in various protocols\n[18â€“21]. The study on the performance of post-quantum XML encryption and SAML SSO\n[21] contains data that compare BIKE and Classic McEliece in those protocols. For hybrid\nXML encryption, Classic McEliece slightly outperforms BIKE in decryption time and total\ntime but results in much larger data sizes. When used for SAML SSO, BIKE generally out-\nperforms Classic McEliece in time and produces much smaller bandwidths.   Experiments\non the performance of post-quantum KEMs in TLS 1.3 and QUIC [18â€“20] produce data that\ncompare BIKE and HQC. Generally, when network conditions (e.g., transmission rates and\npacket loss) are ignored or sufficiently good, HQC results in faster handshakes. In contrast,\n\n                              7"}
{"doc_id": "NIST.IR.8545", "source_path": "data/raw_pdfs/NIST.IR.8545.pdf", "page_number": 15, "text": "NIST IR 8545    Fourth Round Status Report\nMarch 2025\n\nwhen network conditions are sufficiently bad, BIKE outperforms HQC. Packet delay seems\nto affect both HQC and BIKE equally.\nThese results align with a prior expectation about the performances of BIKE and HQC based\non their differences in speeds and sizes. When the size differences between HQC and BIKE\ndo not affect the protocol execution time, the protocol runs faster with HQC. When the\ndifferences affect the protocol execution time noticeably, BIKE is more attractive than HQC.\nFor TLS, BIKE would likely be more attractive than HQC over the web. The cited studies do\nnot provide data for Classic McEliece, which is likely not a desirable choice for TLS 1.3 and\nQUIC due to its generally large encapsulation keys.\n\n2.2.3. Algorithm and Implementation Characteristics\nThe Call for Proposals [22] also requested various desirable algorithm and implementation\ncharacteristics for consideration, particularly flexibility, simplicity, and ease of adoption.\nAn important characteristic of candidates is their potential performance impact on existing\nwidely used protocols (e.g., TLS, IPSec, and SSH) and certificates. The third round included\nreal-world experiments to identify potential performance problems with the algorithms.\nThese experiments continued into the fourth round with a greater focus on HQC and BIKE\n(see Sec. 2.2.2).\nNIST believes it is important to select cryptographic standards that will be capable of pro-\ntecting sensitive government information as well as being widely adopted for use in in-\ndustry. In selecting a cryptographic algorithm for standardization, an evaluation factor\nis whether a patent might hinder the adoption of a cryptographic standard. All submis-\nsion teams were required to submit statements regarding knowledge of patents involving\ntheir algorithms and implementations, which are available on the NIST PQC fourth round\nsubmissions website [23]. The submitters of HQC indicated two patents that could po-\ntentially be relevant to an implementation of HQC. However, the patent owner committed\nand agreed to grant to any interested party on a worldwide basis a non-exclusive license for\nthe purpose of implementing the standard without compensation and under reasonable\nterms and conditions that are demonstrably free of any unfair discrimination.1\n\n2.3. Selection of the Candidates for Standardization\nIn relative order of importance, NIST considered the security, cost and performance, and\nalgorithm and implementation characteristics of the candidates in selecting what to stan-\ndardize. Early in the fourth round, published cryptanalytic results demonstrated that SIKE\nwas insecure [17, 24, 25], resulting in its removal from consideration [9].\n\n1See the Statement by Patent Owner included with the HQC submission at https://csrc.nist.gov/csrc/media\n/Projects/post-quantum-cryptography/documents/round-4/final-ip-statements/HQC-Statements-Round\n4.pdf\n\n                                    8"}
{"doc_id": "NIST.IR.8545", "source_path": "data/raw_pdfs/NIST.IR.8545.pdf", "page_number": 16, "text": "NIST IR 8545    Fourth Round Status Report\nMarch 2025\n\nIn IR 8413 [2], NIST requested feedback on specific use cases for which Classic McEliece\nwould be a good solution. Responses noted that Classic McEliece may provide better per-\nformance than BIKE or HQC for applications in which a public key can be transferred once\nand then used for several encapsulations (e.g., file encryption and virtual private networks\n[VPNs]) due to its small ciphertext size and fast encapsulation and decapsulation. There\nwas also some interest in Classic McEliece based on the perception that it is a conservative\nchoice. However, the interest expressed in Classic McEliece was limited, and having more\nstandards to implement adds complexity to protocols and PQC migration.\nClassic McEliece is currently under consideration for standardization by the International\nOrganization for Standardization (ISO). Concurrent standardization of Classic McEliece by\nNIST and ISO risks the creation of incompatible standards. After the ISO standardization\nprocess has been completed, NIST may consider developing a standard for Classic McEliece\nbased on the ISO standard. However, Classic McEliece is no longer under consideration for\nstandardization as part of the current NIST PQC Standardization Process.\nAt the end of the third round, NIST indicated its intent to standardize at most one of BIKE\nor HQC for use as a general-purpose KEM [2]. As specified in the Call for Proposals [22],\nsubmitted KEMs were evaluated based on how well they appear to provide IND-CCA2 se-\ncurity, particularly for KEMs intended for general use. While NIST has confidence in the in-\ndistinguishability under chosen-plaintext attack (IND-CPA) security of BIKE and HQC, both\nschemes require a sufficiently low decryption failure rate (DFR) in order to be IND-CCA2-\nsecure. There is evidence that HQC has a sufficiently low DFR and recent work indicates\nthat with minor modifications, BIKE achieves the same [26]. However, NIST does not con-\nsider the DFR analysis for BIKE to be as mature as that for HQC. Additionally, HQC is not\nbelieved to require additional modifications to achieve the desired security properties.\nGiven the critical need for strong IND-CCA2 security in a general-purpose KEM, HQC was\nselected for standardization.\nIn summary, NIST has only selected HQC for standardization. The algorithms that were\nnot selected are not under consideration for standardization by NIST as part of the current\nNIST PQC Standardization Process.\n\n9"}
{"doc_id": "NIST.IR.8545", "source_path": "data/raw_pdfs/NIST.IR.8545.pdf", "page_number": 17, "text": "NIST IR 8545    Fourth Round Status Report\nMarch 2025\n\n3. Summary of the Fourth-Round Candidates\n\nThis section describes each of the fourth-round candidates, including their advantages and\ndisadvantages and why a scheme was selected for standardization or not.\nSection 3 of IR 8413[2] introduces some computational and security concepts and history\nthat might be referenced throughout the subsequent subsections. The provided informa-\ntion reduced redundancy, as some of the candidatesâ€™ security analyses have properties\nin common. The information was not intended to be an exhaustive security or literature\nreview.\n\n3.1. HQC\nHQC (Hamming Quasi-Cyclic) is a KEM based on quasi-cyclic codes, where no trapdoor is\nhidden in the code [27]. It was designed to leverage the structural advantages of quasi-\ncyclic codes while maintaining a more direct security reduction to the problem of decod-\ning a random linear code. Unlike the other code-based candidates, the only coding-theory\nhardness assumptions required by HQCâ€™s security proof are parameterizations of the de-\ncisional Quasi-Cyclic Syndrome Decoding (QCSD) assumption. BIKE additionally assumes\nthe hardness of Quasi-Cyclic Codeword Finding (QCCF), and Classic McEliece requires as-\nsumptions concerning binary Goppa codes [27, 28].\n\nDesign. HQC is similar in structure to Learning with Errors (LWE)-based cryptosystems, like\nRegev [29], LPR (Lyubashevsky, Peikert, Regev) [30], and ML-KEM [14]. The IND-CPA-secure\npublic-key encryption (PKE) can be described as follows.\nLet R = F2[x]/(xn âˆ’ 1) for n prime such that xn âˆ’ 1 has only two irreducible factors modulo\n2. The secret key is a randomly sampled pair (x, y) âˆˆ R2, and the public key is the pair\n(h, s = x + h Â· y), where h is randomly sampled from R. Because the secret key is generated\nindependently of the underlying quasi-cyclic code, there is no hidden structure in the HQC\npublic parity-check matrix.  This enables the security reduction to be independent of the\ndecoding algorithm used for decryption [27]. In addition to h, the public key includes a\npublic generator matrix G âˆˆ FkÃ—n for a concatenated Reed-Muller Reed-Solomon (RMRS)\ncode. The structure of this  2\n                             code is assumed to be visible to all parties.\nTo encrypt a message m âˆˆ Fk, the sender randomly samples three polynomials e, r1, r2 âˆˆ R\nof appropriate low weights 2\n                             and responds with the ciphertext\n\n                         c = (u, v) := (r1 + h Â· r2, mG + s Â· r2 + e).    (1)\n\nTo decrypt, the receiver uses the decoding algorithm for an RMRS code to decode (v âˆ’ u Â· y).\n\nSecurity. The IND-CPA security of HQC relies on the difficulty of the QCSD with parity prob-\nlem. Applying the Fujisaki Okamoto (FO) transform [31] to the CPA-secure PKE achieves an\nIND-CCA2 KEM.\n\n                              10"}
{"doc_id": "NIST.IR.8545", "source_path": "data/raw_pdfs/NIST.IR.8545.pdf", "page_number": 18, "text": "NIST IR 8545    Fourth Round Status Report\nMarch 2025\n\nThe decoder used in HQC has a well-defined minimum distance d and, consequently, a de-\nterminable error-correction capability Î´ = b dâˆ’1 c. The probability that an HQC ciphertext\n                                    Î´ is captured 2\nincludes error e such that |e| >              in a closed-form analysis and used to produce\na heuristic2 upper bound on the DFR. A sufficiently low DFR is required for the IND-CCA2\nsecurity proof of the relevant FOâŠ¥ transform [31] to be valid and to prevent key-recovery\nattacks in a key-pair-reuse setting [32].\nAs with the other code-based schemes, the best known attacks are based on information\nset decoding.\n\nPerformance.      The quasi-cyclic structure of HQC enables small public-key and ciphertext\nsizes, although they are noticeably larger than the structured lattice KEMs.                  HQC cipher-\ntexts and public keys are roughly 2.9 and 1.5 times the size of BIKE ciphertexts and public\nkeys, respectively (see Tables 6 and 7).\nAlthough the bandwidth of HQC exceeds that of BIKE, HQCâ€™s key generation and decap-\nsulation are significantly faster than those of BIKE (see Tables 3 and 4). As a result, the\nperformances of HQC and BIKE in applications are difficult to compare.                     Experiments on\nTLS 1.3 handshake performance under varying network conditions have revealed that HQC\noutperforms BIKE under ideal network conditions [33].                     However, in the case of nonzero\npacket loss rates, BIKE outperforms HQC. In addition to the benchmarks included in the\nHQC submission for a hardware implementation, there have been several hardware im-\nplementation results published in the literature [34â€“36].\nSignificant events since Round 3. To address security and performance, HQC added a salt\nto mitigate multi-ciphertext attacks and switched to using implicit rejection for their FO\ntransform. Additionally, several changes to the implementation were made to avoid timing\nattacks.\n\nOverall assessment. NIST determined that HQC would provide a good complement to ML-\nKEM, since it is based on a different underlying security problem and still retains reasonable\nperformance characteristics for general applications.                  The only other fourth-round candi-\ndate that could potentially serve this purpose was BIKE, which relies on similar code-based\nassumptions to HQC. Compared to BIKE, HQC has larger public key and ciphertext sizes but\ncheaper key generation and decryption. NIST was unable to make a definitive assessment\nas to which performance profile is better but found it likely that either performance profile\nwould be acceptable for most general applications.\nThe decisive factor in favor of HQC relative to BIKE is HQCâ€™s stable DFR analysis. A suffi-\nciently low DFR is required to achieve IND-CCA2 security, and there have been persistent\nuncertainties regarding BIKEâ€™s DFR. While DFR estimation techniques for BIKE have recently\n\n2HQCâ€™s DFR analysis makes the simplifying assumption that the coordinates of eâ€² = x Â· r2 âˆ’ r1 Â· y + e are\nindependent variables. The HQC submission document [8] gives theoretical and experimental justifications\nfor this assumption.\n\n                                         11"}
{"doc_id": "NIST.IR.8545", "source_path": "data/raw_pdfs/NIST.IR.8545.pdf", "page_number": 19, "text": "NIST IR 8545    Fourth Round Status Report\nMarch 2025\n\nimproved, previous inaccurate DFR estimates have resulted in BIKE being attacked as late\nas the fourth round, and BIKE would likely require post-selection tweaks to achieve IND-\nCCA2 security. In contrast, DFR estimates for all HQC parameter sets have remained stable\nthroughout the NIST PQC Standardization Process. The IND-CCA2 security of HQC has not\nbeen successfully attacked since May 2020 when HQC discarded parameter sets target-\ning a higher DFR than 2âˆ’Î» for Î» bits of security. NIST is confident that HQC as submitted\nprovides a low enough DFR to achieve IND-CCA2 security.\n\n3.2. BIKE\n\nBIKE (Bit-Flipping Key Encapsulation) is a KEM based on binary linear quasi-cyclic moderate\ndensity parity check (QC-MDPC) codes [37]. The BIKE cryptosystem was initially designed\nfor ephemeral key use but now claims to also support static key use.\n\nDesign.   The binary linear QC-MDPC code C(n, k) used in BIKE is constructed as follows.\nThe secret key is a parity check matrix HrÃ—2r for a quasi-cyclic moderate density parity\ncheck code composed of two circulant blocks, where r is prime and chosen so that xrâˆ’1\nhas only two irreducible factors modulo 2. Each row of H has Hamming weight w â‰ˆ âˆšn,\nwhere w â‰¡ 2 mod 4 . All matrix operations in BIKE can be viewed as polynomial operations\ndue to the isomorphism between the ring of v Ã— v circulant matrices and the polynomial\nring F2[x]/(xv + 1) for any v âˆˆ N. The secret key may then be thought of as a 1 Ã— 2 module\n(h0, h1). The public key Hpub = (1, hâˆ’1h1) is the secret key in systematic form, which is\ncomputed by multiplying H by hâˆ’1.         0\n             0\nThe underlying BIKE PKE follows Niederreiter-style encryption. At a high level, a message\nis encoded as an error vector e of weight t , and the corresponding ciphertext is computed\nas HpubeT . Decryption is accomplished by multiplying the ciphertext by h0 to produce the\nsyndrome HeT and then using the recommended Black-Grey-Flip bit-flipping decoder [38]\nto recover e.\n\nSecurity. The proof of IND-CPA security of the underlying PKE in the random oracle model\n(ROM) depends on the difficulty of solving the decisional QCSD and QCCF problems. The\nFO transform, as described in [31], is applied to the CPA-secure PKE to achieve a claimed\nIND-CCA2 KEM. The PKE must be Î´ -correct3 for Î´ â‰¤ 2âˆ’Î» to apply this transformation.\nIterative bit-flipping decoders for QC-MDPC codes are difficult to analyze in closed form,\nand the anticipated DFR is too low to compute directly. Moreover, the DFR of MDPC and\nLDPC codes under iterative decoding follows two regimes: a waterfall region in which de-\ncoding failures decrease rapidly followed by an error floor region in which decoding failures\ndecrease at a much slower pace as the signal-to-noise ratio increases. Understanding the\n3A KEM is Î´ -correct if the decapsulation fails (i.e., disagrees with encapsulation) with probability at most Î´\non average over all keys and messages. Similarly, a decoder will be Î´ -correct if its failure rate is at most Î´ on\naverage when the input is drawn uniformly.\n\n                                           12"}
{"doc_id": "NIST.IR.8545", "source_path": "data/raw_pdfs/NIST.IR.8545.pdf", "page_number": 20, "text": "NIST IR 8545    Fourth Round Status Report\nMarch 2025\n\nDFR of BIKE has remained an open problem during the fourth round. Analyzing the BIKE\nDFR has involved studying the impacts of weak keys and near codewords on decoding per-\nformance.\nThe first classification of weak keys for QC-MDPC codes was given in [39] and generalized\nin [40, 41]. Since these classes of weak keys have small cardinality, they were determined\nto have minimal impact on the overall BIKE DFR. A new class of weak keys was discovered\n[42] based on the gathering property. These weak keys were shown to cause an average\nDFR of a least 2âˆ’117 for BIKE level 1 parameters, defeating the IND-CCA2 security of BIKE.\nThe BIKE team studied the weak keys with the gathering property and found that the de-\ncoding failures were largely caused by incorrect flips happening early in the decoding pro-\ncess. Namely, bits not in error were incorrectly flipped during the first iterations of the de-\ncoder. To mitigate the effect of the gathering keys, the BIKE team introduced a new decoder\nknown as BIKE-flip that sets a high bit-flipping threshold at the first decoding iteration and\nthen gradually lowers the threshold throughout decoding [6]. Results indicated that the\nBIKE-flip decoder significantly reduced the impact of gathering keys, although this analysis\nwas limited to classes of weak keys with a high enough DFR to be directly measured. Sub-\nsequently, a model introduced by [26] was able to predict variations in DFR based on the\nstructure of a key. This would allow a modification of the BIKE key-generation algorithm in\nwhich keys that are not expected to have a typical value for the DFR are rejected.\nNear codewords are error vectors of low weight (u) that map to syndromes of low weight (v)\nand are well-studied in the LDPC literature as impediments to the iterative decoding pro-\ncess. Moreover, these vectors are known to significantly contribute to error floor behavior.\nA particular class of near codewords, where u = v = w , was defined in [41] and shown to\nexist for BIKE. The impact of these near codewords  2\n                                                    on the decoding performance for BIKE\nwas initially analyzed in [41] and further studied in [26]. In [26], a Markov model that\ntracked proximity to near codewords was used to predict the error floors for QC-MDPC\ncodes under a generic iterative decoder. Results indicated that the error floor behavior\nin the BIKE DFR curves was dominated by convergence to these near codewords during\nfailed decoding instances [26]. Furthermore, the model predicted that increasing BIKE se-\ncurity level 1 block lengths from r = 12323 to r = 13477 would result in a conservative DFR\nestimate of 2âˆ’129.5 for typical keys.\n\nPerformance. The sizes of BIKEâ€™s public keys and ciphertexts were roughly 70% and 30%\nof HQCâ€™s, respectively. However, BIKEâ€™s decapsulation and key-generation algorithms were\nroughly 5-6 times slower than HQCâ€™s, respectively.  The performance of BIKE and HQC in\napplications was difficult to compare. Experiments on TLS 1.3 handshake performance\nunder varying network conditions have revealed that HQC outperforms BIKE under ideal\nnetwork conditions [33]. However, BIKE outperforms HQC when non-zero packet loss rates\nare introduced.\n\n13"}
{"doc_id": "NIST.IR.8545", "source_path": "data/raw_pdfs/NIST.IR.8545.pdf", "page_number": 21, "text": "NIST IR 8545    Fourth Round Status Report\nMarch 2025\n\nSignificant events since Round 3.                The BIKE specification was updated at the beginning of\nthe fourth round and included a change from the previous approach of sampling fixed-\nweight vectors to a data-oblivious technique.                  This modification had no noticeable per-\nformance impacts but eliminated certain side-channel attacks.                  To offer more resistance\nagainst multi-target key attacks, BIKEâ€™s FO transform to attain IND-CCA2 security now in-\ncludes a hash of part of the public key.                  As noted in the Security section above, a new\ndecoder (BIKE-Flips) was used, which has better resilience to decryption failure for weak\nkeys.\n\nOverall assessment. NIST found that BIKE is a KEM that would complement ML-KEM well\nwith respect to having a different underlying security problem and balanced performance\ncharacteristics. BIKE also offers smaller keys and ciphertexts than HQC. NIST reviewed sev-\neral DFR analyses of BIKE, including recent results indicating that an approximate 9% in-\ncrease in block size leads to a sufficiently low DFR for security level 1 parameters. Despite\nthese promising results, NIST found the security analysis of HQC to be more mature and\nstable than that of BIKE. As such, NIST has not selected BIKE for standardization.\n\n3.3. Classic McEliece\nDesign. Classic McEliece is a code-based KEM that uses binary Goppa codes in the Nieder-\nreiter variant of the McEliece cryptosystem combined with standard techniques to achieve\nIND-CCA2 security. Due to the use of Goppa codes, the KEM has perfect correctness.4 It\nis a merger of the second-round submissions Classic McEliece and NTS-KEM. The original\nMcEliece cryptosystem was published in [43] and was also based on binary Goppa codes.\n\nSecurity. The Classic McEliece submission cites [44] and other results as giving a tight proof\nof the submitted KEMâ€™s IND-CCA2 security in the quantum random oracle model based on\nthe assumption that the 1978 McEliece scheme provides one-way under chosen-plaintext\nattacks (OW-CPA) security. Confidence in the security of the 1978 scheme was mostly es-\ntablished based on the schemeâ€™s long history of surviving cryptanalysis with only minor\nchanges in the complexity of the best-known attack.                  Alternatively, the security of the\nscheme could be established under the assumptions that row-reduced parity check ma-\ntrices for the binary Goppa codes used by Classic McEliece are indistinguishable from row-\nreduced parity check matrices for random linear codes of the same dimensions and that\nthe syndrome decoding problem is hard for random linear codes with those dimensions.\nThe state of the art in cryptanalysis does not contradict these assumptions, although binary\nGoppa codes with very different dimensions from those used by the Classic McEliece sub-\nmission have been shown to be distinguishable from random codes [45]. More recent work\n[46] has proposed a distinguisher that claims to asymptotically break the indistinguishabil-\n\n4A perfectly correct KEM or PKE is one for which every ciphertext generated using the encapsulation/encryp-\ntion function may be correctly decrypted using the decapsulation/decryption function. In contrast, some\nKEMs and PKEs have a very small decryption failure rate.\n\n                                         14"}
{"doc_id": "NIST.IR.8545", "source_path": "data/raw_pdfs/NIST.IR.8545.pdf", "page_number": 22, "text": "NIST IR 8545    Fourth Round Status Report\nMarch 2025\n\nity of Goppa codes with parameters that are similar to those used by Classic McEliece but\nthat target a much higher security level.\nA number of approaches to the cryptanalysis of Classic McEliece have been studied. The\nmost effective known attacks and those used to set the parameters of Classic McEliece are\ninformation set decoding attacks, which are similar to the best-known attacks against BIKE\nand HQC. Unlike the other two schemes, information set decoding is only applicable to\nmessage recovery, not key recovery. These attacks ignore the structure of the binary code\nand seek to recover the error vector based on its low Hamming weight. These techniques\noriginated with Prangeâ€™s algorithm in 1962 [47] and have undergone a series of improve-\nments [48â€“56]. However, the net effect of these improvements has been fairly modest,\nand most of the change in concrete security is due to improvements that were discovered\nmore than 30 years ago. Quantum versions of information set decoding (ISD) algorithms\nhave also been studied [57]. These results represent a generic Grover-based speedup of\nclassical ISD algorithms and indicate that ISD algorithms can be sped up nearly as much\nas brute force search problems. In a multi-ciphertext setting, a further improvement [58]\ncan reduce the cost of decoding a single ciphertext by a factor equal to approximately the\nsquare root of the number of ciphertexts.\nKey-recovery attacks have also been studied, which attempt to find the private key by al-\ngebraic techniques or brute-force searches. Algebraic techniques have been used to break\nvariants of McEliece based on other algebraic codes [59â€“63] or Goppa codes with addi-\ntional structure imposed [64], but they appear to be significantly more costly than ISD for\nattacking the parameters submitted for Classic McEliece. Nonetheless, algebraic attacks\nthat target the structure of Goppa codes and achieve either key recovery or a distinguisher\nfrom a random linear code have remained an active area of research [46, 65â€“69].\n\nPerformance. Classic McEliece has a very large public-key size and fairly slow key gener-\nation, which will likely make it undesirable in many common settings. However, its pro-\nfile could have some advantages in settings where a public key is reused many times and\ndoes not need to be retransmitted for each new communication [70]. In particular, Classic\nMcEliece has the smallest ciphertext sizes of any of the NIST PQC candidates.\n\nSignificant events since Round 3. At the beginning of the fourth round, the submission team\nintroduced a modification to the FO transform to incorporate implicit rejection without\nplaintext confirmation. This tweak aimed to reduce the potential for patent concerns and\nsimplify the specification and software code.\nDuring the fourth round, there has been significant progress in cryptanalysis techniques\nthat are applicable to key recovery and the related problem of distinguishing a Goppa code\nfrom a random linear code [46, 66â€“69]. While these techniques are still far from concretely\naffecting the security of the submitted parameter sets of Classic McEliece, they somewhat\nweaken the argument that the long-term security of Classic McEliece is guaranteed by its\nlong history of cryptanalysis.\n\n                                         15"}
{"doc_id": "NIST.IR.8545", "source_path": "data/raw_pdfs/NIST.IR.8545.pdf", "page_number": 23, "text": "NIST IR 8545    Fourth Round Status Report\nMarch 2025\n\nAdditionally, during the third round, Classic McEliece was proposed to be added to the\nISO/International Electrotechnical Commission (IEC) standard ISO/IEC 18033-2. This con-\ncurrent standardization effort remains active and ongoing.\n\nOverall assessment. NIST remains confident in the security of Classic McEliece,5 although\nrecent progress in cryptanalysis somewhat undermines the case for treating it as an espe-\ncially conservative choice. Its large public-key size makes Classic McEliece an unattractive\nchoice for most common applications, but it offers an excellent performance profile for\napplications that are sensitive to ciphertext size, where public keys are rarely transmitted.\nNIST does not find the case for standardizing Classic McEliece compelling, due to skepticism\nthat it will see widespread use.                       In the event that Classic McEliece does become widely\nused through other standards, and that NIST remains confident in its security while also\ndetermining that there is sufficient need, NIST may develop a NIST standard based on the\nwidely used version.\n\n3.4. SIKE\nCryptographic schemes that are based on the hardness of the discrete logarithm problem\non elliptic curves are known to be quantum-insecure because of Shorâ€™s algorithm.                        How-\never, elliptic curves can be used in a different way to construct PKE and KEM protocols. An\nisogeny from one elliptic curve to another elliptic curve (over the same field) is a rational\nmap that is also a group homomorphism. Given two isogenous curves E and E â€², efficiently\nconstructing an isogeny from E to E â€² is generally unknown. The assumed hardness of find-\ning an isogeny between two elliptic curves combined with the Diffieâ€“Hellman model for\nkey exchange enables the construction of a family of isogeny-based KEMs.\nSIKE is a KEM based on isogenies of supersingular elliptic curves that follows and improves\nupon the construction known as Supersingular Isogeny Diffieâ€“Hellman (SIDH) [72]. In SIKE,\none party prepares a secret isogeny Ï† from a publicly known elliptic curve E0 to a new curve\nE and computes the images of the generators of a known torsion subgroup (under Ï† ) as\nthe public key. This public key is then used to carry out a Diffieâ€“Hellman procedure. The\nsecurity of SIKE depends crucially on the assumption that it is infeasible for an adversary\nto compute the secret isogeny Ï† from public information.\nHowever, in mid-2022, researchers showed that the secret isogeny Ï† can be efficiently\nrecovered from the public key [17]. Attacks on SIKE were further improved and general-\nized by other researchers [25, 73], and the authors of SIKE have acknowledged the break\n[9]. Attempts to patch the vulnerabilities were ineffective or had weaknesses in some in-\nstances [74].                       While these attacks were devastating for SIKE, they do not apply to many\n\n5Independent estimates [56, 71] of the cost of information set decoding algorithms have long suggested that\nClassic McElieceâ€™s parameter sets (i.e., mceliece460896 and mceliece460896f) that claim Category 3 security\nfall short of their security target. However, NIST remains confident that these parameter sets at least meet\nthe criteria for Category 2 security.\n\n                                     16"}
{"doc_id": "NIST.IR.8545", "source_path": "data/raw_pdfs/NIST.IR.8545.pdf", "page_number": 24, "text": "NIST IR 8545    Fourth Round Status Report\nMarch 2025\n\nother isogeny-based cryptographic schemes. The attacks relied on the information pro-\nvided by the image of a torsion subgroup in the SIKE public key, while other isogeny-based\nschemes do not utilize these auxiliary torsion points.\nSIKE is an insecure KEM, and it has been eliminated from the NIST PQC project.\n\n17"}
{"doc_id": "NIST.IR.8545", "source_path": "data/raw_pdfs/NIST.IR.8545.pdf", "page_number": 25, "text": "NIST IR 8545    Fourth Round Status Report\nMarch 2025\n\n4. Conclusion\n\nThis report summarizes the evaluation criteria for selecting the fourth-round candidate\nalgorithms, their basic designs, and their advantages and disadvantages. NIST greatly ap-\npreciates the participation in the NIST PQC Standardization Process. The announcement\nof the standardization of HQC marks the end of the fourth round, and also marks an end to\nthe standardization process which began with the NIST Call for Proposals in 2016 [22]. We\nnote that not all NIST PQC standardization is concluded, as NIST is also currently evaluating\nadditional digital signatures [75].\nNIST will create a draft standard based on HQC and post it for public comment. After the\ncomments are adjudicated, NIST will publish a final version in approximately two years.\nThe standardization of HQC will be the second PQC KEM after ML-KEM. NIST recently pub-\nlished draft SP 800-227, Recommendations for Key-Encapsulation Mechanisms [76], which\ndescribes the basic definitions, properties, and applications of KEMs. It also provides rec-\nommendations for implementing and using KEMs in a secure manner.\nNIST plans to host another NIST PQC Standardization Conference in September 2025, with\nmore details to be provided.\n\n18"}
{"doc_id": "NIST.IR.8545", "source_path": "data/raw_pdfs/NIST.IR.8545.pdf", "page_number": 26, "text": "NIST IR 8545    Fourth Round Status Report\nMarch 2025\n\nReferences\n\n[1]  Open quantum safe (OQS) algorithm performance visualizations. Available at https:\n     //openquantumsafe.org/benchmarking.\n[2]  Alagic G, Apon D, Cooper DA, Dang QH, Dang T, Kelsey JM, Lichtinger J, Liu YK, Miller\n     CA, Moody D, Peralta R, Perlner RA, Robinson A, Smith-Tone D (2022) Status Report\n     on the Third Round of the NIST Post-Quantum Cryptography Standardization Process.\n     (National Institute of Standards and Technology, Gaithersburg, MD), NIST Interagency\n     or Internal Report (IR) NIST IR 8413-upd1, Includes updates as of September 26, 2022.\n     https://doi.org/10.6028/NIST.IR.8413-upd1\n[3]  National Institute of Standards and Technology (2015) SHA-3 Standard: Permutation-\n     Based Hash and Extendable-Output Functions. (Department of Commerce, Washing-\n     ton, DC), Federal Information Processing Standards Publication (FIPS) NIST FIPS 202.\n     https://doi.org/10.6028/NIST.FIPS.202\n[4]  National Institute of Standards and Technology (2024) Module-Lattic-Based Digi-\n     tal          Signature Standard. (Department of Commerce, Washington, DC), Federal In-\n     formation Processing Standards Publication (FIPS) NIST FIPS 204. https://doi.org/\n     10.6028/NIST.FIPS.204\n[5]  National Institute of Standards and Technology (2024) Stateless Hash-Based Digi-\n     tal          Signature Standard. (Department of Commerce, Washington, DC), Federal In-\n     formation Processing Standards Publication (FIPS) NIST FIPS 205. https://doi.org/\n     10.6028/NIST.FIPS.205\n[6]  Aragon N, Barreto PSLM, Bettaieb S, Bidoux L, Blazy O, Deneuville JC, Gaborit P, Ghosh\n     S, Gueron S, GÃ¼neysu T, Melchor CA, Misoczk R, Persichetti E, Richter-Brockmann J,\n     Sendrier N, Tillich JP, Vasseur V, ZÃ©mor G (2022) BIKE: Bit Flipping Key Encapsulation,\n     4th Round submission to the NISTâ€™s post-quantum cryptography standardization pro-\n     cess. https://csrc.nist.gov/projects/post-quantum-cryptography/round-4-submiss\n     ions.\n[7]  Bernstein DJ, Chou T, Cid C, Gilcher J, Lange T, Maram V, von Maurich I, Misoczki R,\n     Niederhagen R, Persichetti E, Peters C, Sendrier N, Szefer J, Tjhai CJ, Tomlinson M,\n     Wang W (2022) Classic McEliece algorithm specifications and supporting documen-\n     tation, 4th Round submission to the NISTâ€™s post-quantum cryptography standardiza-\n     tion process. https://csrc.nist.gov/projects/post-quantum-cryptography/round-4-s\n     ubmissions.\n[8]  Melchor CA, Aragon N, Bettaieb S, Bidoux L, Blazy O, Deneuville JC, Gaborit P, Per-\n     sichetti E, ZÃ©mor G, Bos J, Dion A, Lacan J, Robert JM, Veron P (2022) HQC algorithm\n     specifications and supporting documentation, 4th Round submission to the NISTâ€™s\n     post-quantum cryptography standardization process. https://csrc.nist.gov/projects\n     /post-quantum-cryptography/round-4-submissions.\n[9]  Jao D, Azarderakhsh R, Campagna M, Costello C, Feo LD, Hess B, Jalali A, Koziel B,\n     LaMacchia B, Longa P, Naehrig M, Renes J, Soukharev V, Urbanik D, Pereira G, Kara-\n     bina K, Hutchinson A (2022) Supersingular Isogeny Key Encapsulation, 4th Round\n\n                           19"}
{"doc_id": "NIST.IR.8545", "source_path": "data/raw_pdfs/NIST.IR.8545.pdf", "page_number": 27, "text": "NIST IR 8545    Fourth Round Status Report\nMarch 2025\n\n      submission to the NISTâ€™s post-quantum cryptography standardization process. https:\n      //csrc.nist.gov/projects/post-quantum-cryptography/round-4-submissions.\n[10]  Chen L, Jordan S, Liu YK, Moody D, Peralta R, Perlner R, Smith-Tone D (2016) Re-\n      port on post-quantum cryptography (National Institute of Standards and Technology,\n      Gaithersburg, MD), NIST Interagency or Internal Report (IR) 8105. https://doi.org/\n      10.6028/NIST.IR.8105\n[11]  National Institute of Standards and Technology (2016) Announcing request for nom-\n      inations for public-key post-quantum cryptographic algorithms. Federal Register\n      81(244):92787â€“92788. https://federalregister.gov/a/2016-30615.\n[12]  Alagic G, Alperin-Sheriff J, Apon D, Cooper D, Dang Q, Liu YK, Miller C, Moody D, Per-\n      alta R, Perlner R, Robinson A, Smith-Tone D (2019) Status report on the first round of\n      the NIST post-quantum cryptography standardization process (National Institute of\n      Standards and Technology, Gaithersburg, MD), NIST Interagency or Internal Report\n      (IR) 8240. https://doi.org/10.6028/NIST.IR.8240\n[13]  Alagic G, Alperin-Sheriff J, Apon D, Cooper D, Dang Q, Kelsey J, Liu YK, Miller C, Moody\n      D, Peralta R, Perlner R, Robinson A, Smith-Tone D (2020) Status report on the second\n      round of the NIST post-quantum cryptography standardization process (National In-\n      stitute of Standards and Technology, Gaithersburg, MD), NIST Interagency or Internal\n      Report (IR) 8309. https://doi.org/10.6028/NIST.IR.8309\n[14]  National Institute of Standards and Technology (2024) Module-Lattice-Based Key-\n      Encapsulation Mechanism    Standard. (Department of   Commerce, Washington,\n      DC), Federal Information Processing  Standards Publication (FIPS) NIST FIPS 203.\n      https://doi.org/10.6028/NIST.FIPS.203\n[15]  National Institute of Standards and Technology (2016) NIST post-quantum cryptogra-\n      phy standardization. Available at https://csrc.nist.gov/projects/post-quantum-crypt\n      ography/post-quantum-cryptography-standardization.\n[16]  National Institute of Standards and Technology (2022) Call for Additional Digital Signa-\n      ture Schemes for the Post-Quantum Cryptography Standardization Process. Available\n      at https://csrc.nist.gov/csrc/media/Projects/pqc-dig-sig/documents/call-for-propo\n      sals-dig-sig-sept-2022.pdf.\n[17]  Castryck W, Decru T (2023) An Efficient Key Recovery Attack on SIDH. Advances in\n      Cryptology â€“ EUROCRYPT 2023, eds Hazay C, Stam M (Springer Nature Switzerland,\n      Cham), pp 423â€“447. https://doi.org/https://doi.org/10.1007/978-3-031-30589-4_1\n      5\n[18]  Kempf M, Gauder N, Jaeger B, Zirngibl J, Carle G (2024) A Quantum of QUIC: Dis-\n      secting  Cryptography with Post-Quantum Insights. IFIP Networking, pp 195â€“203.\n      https://doi.org/10.23919/IFIPNetworking62109.2024.10619916\n[19]  Sosnowski M, Wiedner F, Hauser E, Steger L, Schoinianakis D, GallenmÃ¼ller S, Carle\n      G (2023) The performance of post-quantum TLS 1.3. Companion of the 19th Interna-\n      tional Conference on emerging Networking EXperiments and Technologies, pp 19â€“27.\n      https://doi.org/https://doi.org/10.1145/3624354.3630585\n\n20"}
{"doc_id": "NIST.IR.8545", "source_path": "data/raw_pdfs/NIST.IR.8545.pdf", "page_number": 28, "text": "NIST IR 8545    Fourth Round Status Report\nMarch 2025\n\n[20]  Henrich J, Heinemann A, Wiesmaier A, Schmitt N (2023) Performance impact of PQC\n      KEMs on TLS 1.3 under varying network characteristics. ISC 2023: 26th International\n      Conference on Information Security, eds Athanasopoulos E, Mennink B (Springer,\n      Cham, Switzerland, Groningen, The Netherlands), Lecture Notes in Computer Science,\n      Vol. 14411, pp 267â€“287. https://doi.org/10.1007/978-3-031-49187-0_14\n[21]  MÃ¼ller J, OupickÃ½ J (2024) Post-quantum XML and SAML single sign-on. Proceedings\n      on Privacy Enhancing Technologies 2024(4):525â€“543. https://doi.org/10.56553/pop\n      ets-2024-0128\n[22]  National Institute of Standards and Technology (2016) Submission requirements and\n      evaluation criteria for the post-quantum cryptography standardization process. Avail-\n      able at https://csrc.nist.gov/CSRC/media/Projects/Post-Quantum-Cryptography/do\n      cuments/call-for-proposals-final-dec-2016.pdf.\n[23]  National Institute of Standards and Technology (2022) NIST post-quantum cryptogra-\n      phy standardization round 4 submissions. Available at https://csrc.nist.gov/Projects\n      /post-quantum-cryptography/round-4-submissions.\n[24]  Maino L, Martindale C (2022) An attack on SIDH with arbitrary starting curve, Cryp-\n      tology ePrint Archive preprint. Available at https://ia.cr/2022/1026.\n[25]  Robert D (2023) Breaking SIDH in Polynomial Time. Advances in Cryptology â€“ EURO-\n      CRYPT 2023, eds Hazay C, Stam M (Springer Nature Switzerland, Cham), pp 472â€“503.\n      https://doi.org/https://doi.org/10.1007/978-3-031-30589-4_17\n[26]  Arpin S, Lau JB, Perlner R, Robinson A, Tillich JP, Vasseur V (2025) Error floor prediction\n      with Markov models for QC-MDPC codes, Cryptology ePrint Archive, Paper 2025/153.\n      Available at https://eprint.iacr.org/2025/153.\n[27]  Aguilar-Melchor C, Blazy O, Deneuville JC, Gaborit P, ZÃ©mor G (2018) Efficient en-\n      cryption from random quasi-cyclic codes. IEEE Transactions on Information Theory\n      64(5):3927â€“3943. https://doi.org/https://doi.org/10.1109/TIT.2018.2804444\n[28]  Aragon N, Gaborit P, Zâ€™emor G (2020) HQC-RMRS, an instantiation of   the HQC\n      encryption framework with a more efficient auxiliary error-correcting code. ArXiv\n      abs/2005.10741.\n[29]  Regev O (2005) On lattices, learning with errors, random linear codes, and cryptog-\n      raphy. Proceedings of the Thirty-Seventh Annual ACM Symposium on Theory of Com-\n      puting STOC â€™05 (Association for Computing Machinery, New York, NY, USA), p 84â€“93.\n      https://doi.org/10.1145/1060590.1060603\n[30]  Lyubashevsky V, Peikert C, Regev O (2010) On ideal lattices and learning with errors\n      over rings. Advances in Cryptology â€“ EUROCRYPT 2010, ed Gilbert H (Springer Berlin\n      Heidelberg, Berlin, Heidelberg), pp 1â€“23. https://doi.org/https://doi.org/10.1007/\n      978-3-642-13190-5_1\n[31]  Hofheinz D, HÃ¶velmanns K, Kiltz E (2017) A modular analysis of the Fujisaki-Okamoto\n      transformation. Theory of Cryptography, eds Kalai Y, Reyzin L (Springer International\n      Publishing, Cham), pp 341â€“371. https://doi.org/https://doi.org/10.1007/978-3-319\n      -70500-2_12\n\n21"}
{"doc_id": "NIST.IR.8545", "source_path": "data/raw_pdfs/NIST.IR.8545.pdf", "page_number": 29, "text": "NIST IR 8545    Fourth Round Status Report\nMarch 2025\n\n[32]  Guo Q, Johansson T (2020) A new decryption failure attack against HQC. Advances in\n      Cryptology â€“ ASIACRYPT 2020, eds Moriai S, Wang H (Springer International Publish-\n      ing, Cham), pp 353â€“382. https://doi.org/https://doi.org/10.1007/978-3-030-64837\n      -4_12\n[33]  Henrich J, Heinemann A, Wiesmaier A, Schmitt N (2023) Performance Impact of PQC\n      KEMs on TLS 1.3 Under Varying Network Characteristics. Information Security, eds\n      Athanasopoulos E, Mennink B (Springer Nature Switzerland, Cham), pp 267â€“287.\n      https://doi.org/https://doi.org/10.1007/978-3-031-49187-0_14\n[34]  Deshpande S, Xu C, Nawan M, Nawaz K, Szefer J (2023) Fast and efficient hardware\n      implementation of HQC. Selected Areas in Cryptography - SAC 2023 - 30th Interna-\n      tional Conference, Fredericton, Canada, August 14-18, 2023, Revised Selected Papers,\n      eds Carlet C, Mandal K, Rijmen V (Springer), Lecture Notes in Computer Science, Vol.\n      14201, pp 297â€“321. https://doi.org/10.1007/978-3-031-53368-6\\_15\n[35]  Li C, Song S, Tian J, Wang Z, KoÃ§ Ã‡K (2023) An efficient hardware design for fast imple-\n      mentation of HQC. 36th IEEE International System-on-Chip Conference, SOCC 2023,\n      Santa Clara, CA, USA, September 5-8, 2023, eds Becker J, Marshall A, Harbaum T, Gan-\n      guly A, Siddiqui F, McLaughlin K (IEEE), pp 1â€“6. https://doi.org/10.1109/SOCC58585.\n      2023.10257054\n[36]  Antognazza F, Barenghi A, Pelosi G, Susella R (2024) A high efficiency hardware de-\n      sign for the post-quantum KEM HQC. IEEE International Symposium on Hardware Ori-\n      ented Security and Trust, HOST 2024, Tysons Corner, VA, USA, May 6-9, 2024 (IEEE),\n      pp 431â€“441. https://doi.org/10.1109/HOST55342.2024.10545409\n[37]  Misoczki R, Tillich JP, Sendrier N, Barreto PSLM (2013) MDPC-McEliece: New McEliece\n      variants from moderate density parity-check codes. 2013 IEEE International Sympo-\n      sium on Information Theory, pp 2069â€“2073. https://doi.org/https://doi.org/10.110\n      9/ISIT.2013.6620590\n[38]  Drucker N, Gueron S, Kostic D (2020) QC-MDPC decoders with several shades of gray.\n      Post-Quantum Cryptography, eds Ding J, Tillich JP (Springer International Publishing,\n      Cham), pp 35â€“50. https://doi.org/https://doi.org/10.1007/978-3-030-44223-1_3\n[39]  Drucker N, Gueron S, Kostic D (2020) On constant-time QC-MDPC decoders with\n      negligible failure rate. Code-Based Cryptography, eds Baldi M, Persichetti E, San-\n      tini P (Springer International Publishing, Cham), pp 50â€“79. https://doi.org/https:\n      //doi.org/10.1007/978-3-030-54074-6_4\n[40]  Aydin N, Yildiz B, Uludag S (2020) A class of weak keys for the QC-MDPC cryptosystem.\n      Algebraic and Combinatorial Coding Theory 2020, pp 1â€“4. https://doi.org/10.1109/\n      ACCT51235.2020.9383383\n[41]  Vasseur V (2021) Post-quantum cryptography: a study of the decoding of QC-MDPC\n      codes. Ph.D. thesis. UniversitÃ© de Paris, Paris, France.\n[42]  Wang T, Wang A, Wang X (2023) Exploring decryption failures of BIKE: New class\n      of weak keys and key recovery attacks. Advances in Cryptology â€“ CRYPTO 2023,\n      eds Handschuh H, Lysyanskaya A (Springer Nature Switzerland, Cham), pp 70â€“100.\n      https://doi.org/https://doi.org/10.1007/978-3-031-38548-3_3\n\n                               22"}
{"doc_id": "NIST.IR.8545", "source_path": "data/raw_pdfs/NIST.IR.8545.pdf", "page_number": 30, "text": "NIST IR 8545    Fourth Round Status Report\nMarch 2025\n\n[43]  McEliece RJ (1978) A Public-Key Cryptosystem Based On Algebraic Coding Theory.\n      Deep Space Network Progress Report 44:114â€“116.\n[44]  Bindel N, Hamburg M, HÃ¶velmanns K, HÃ¼lsing A, Persichetti E (2019) Tighter proofs\n      of CCA security in            the quantum random oracle model. Theory of Cryptography,\n      eds Hofheinz D, Rosen A (Springer International     Publishing, Cham),    pp 61â€“90.\n      https://doi.org/https://doi.org/10.1007/978-3-030-36033-7_3\n[45]  FaugÃ¨re JC, Gauthier-UmanÃ£ V, Otmani A, Perret L, Tillich JP (2011) A distinguisher\n      for high rate McEliece cryptosystems. 2011 IEEE Information Theory Workshop, pp\n      282â€“286. https://doi.org/https://doi.org/10.1109/ITW.2011.6089437\n[46]  Randriambololona   H (2024) The syzygy distinguisher. IACR      Cryptol ePrint Arch\n      :1193Available at https://eprint.iacr.org/2024/1193.\n[47]  Prange E (1962) The use of information sets in decoding cyclic codes. IRE Transactions\n      on Information Theory 8(5):5â€“9. https://doi.org/https://doi.org/10.1109/TIT.1962.1\n      057777\n[48]  Stern J (1989) A method for finding codewords of small weight. Coding Theory and\n      Applications, eds Cohen G, Wolfmann J (Springer Berlin Heidelberg, Berlin, Heidel-\n      berg), pp 106â€“113. https://doi.org/https://doi.org/10.1007/BFb0019850\n[49]  Dumer I (1991) On minimum distance decoding of linear codes. Proc. 5th Joint Soviet-\n\n[50]  Swedish Int. Workshop Inform. Theory, pp 50â€“52.                  Ëœ      0.054n\n      May A, Meurer A, Thomae E (2011) Decoding random linear codes in O(2           ). Ad-\n      vances in Cryptology â€“ ASIACRYPT 2011, eds Lee DH, Wang X (Springer Berlin Heidel-\n      berg, Berlin, Heidelberg), pp 107â€“124. https://doi.org/https://doi.org/10.1007/97\n      8-3-642-25385-0_6\n[51]  Bernstein DJ, Lange T, Peters C (2011) Smaller decoding exponents: Ball-collision de-\n      coding. Advances in Cryptology â€“ CRYPTO 2011, ed Rogaway P (Springer Berlin Hei-\n      delberg, Berlin, Heidelberg), pp 743â€“760. https://doi.org/https://doi.org/10.1007/\n      978-3-642-22792-9_42\n[52]  Becker A, Joux A, May A, Meurer A (2012) Decoding random binary linear codes in\n      2n/20:       How 1 + 1 = 0 improves information set decoding. Advances in Cryptology â€“\n      EUROCRYPT 2012, eds Pointcheval D, Johansson T (Springer Berlin Heidelberg, Berlin,\n      Heidelberg), pp 520â€“536. https://doi.org/https://doi.org/10.1007/978-3-642-290\n      11-4_31\n[53]  May A, Ozerov I (2015) On computing nearest neighbors with applications to decoding\n      of binary linear codes. Advances in Cryptology â€“ EUROCRYPT 2015, eds Oswald E, Fis-\n      chlin M (Springer Berlin Heidelberg, Berlin, Heidelberg), pp 203â€“228. https://doi.org/\n      https://doi.org/10.1007/978-3-662-46800-5_9\n[54]  Canto Torres R, Sendrier N (2016) Analysis of information set decoding for a sub-linear\n      error weight. Post-Quantum Cryptography, ed Takagi T (Springer International Pub-\n      lishing, Cham), pp 144â€“161. https://doi.org/https://doi.org/10.1007/978-3-319-293\n      60-8_10\n[55]  Both L, May A (2017) Optimizing BJMM with nearest neighbors: full decoding in 22n/21\n      and McEliece security. The Tenth International Workshop on Coding and Cryptogra-\n\n                                        23"}
{"doc_id": "NIST.IR.8545", "source_path": "data/raw_pdfs/NIST.IR.8545.pdf", "page_number": 31, "text": "NIST IR 8545    Fourth Round Status Report\nMarch 2025\n\n      phy, pp â€“. Available at https://www.cits.ruhr-uni-bochum.de/imperia/md/content/\n      may/paper/bjmm+.pdf.\n[56]  Guo Q, Johansson T, Nguyen V (2024) A new sieving-style information-set decoding\n      algorithm. IEEE Trans Inf Theory 70(11):8303â€“8319. https://doi.org/10.1109/TIT.20\n      24.3457150\n[57]  Kirshanova E (2018) Improved quantum information set decoding. Post-Quantum\n      Cryptography, eds Lange T, Steinwandt R (Springer International Publishing, Cham),\n      pp 507â€“527. https://doi.org/https://doi.org/10.1007/978-3-319-79063-3_24\n[58]  Sendrier N (2011) Decoding one out of many. Post-Quantum Cryptography, ed Yang\n      BY (Springer Berlin Heidelberg, Berlin, Heidelberg), pp 51â€“67. https://doi.org/https:\n      //doi.org/10.1007/978-3-642-25405-5_4\n[59]  Sidelnikov VM, Shestakov SO (1992) On insecurity of cryptosystems based on gen-\n      eralized Reed-Solomon codes. Discrete Mathematics and Applications 2(4):439â€“444.\n      https://doi.org/doi:10.1515/dma.1992.2.4.439\n[60]  Wieschebrink C (2010) Cryptanalysis of the Niederreiter public key scheme based on\n      GRS subcodes. Post-Quantum Cryptography, ed Sendrier N (Springer Berlin Heidel-\n      berg, Berlin, Heidelberg), pp 61â€“72. https://doi.org/https://doi.org/10.1007/978-3\n      -642-12929-2_5\n[61]  Couvreur A, Gaborit P, Gauthier-UmaÃ±a V, Otmani A, Tillich JP (2014) Distinguisher-\n      based attacks on public-key cryptosystems using Reedâ€”Solomon codes. Designs,\n      Codes and Cryptography 73(2):641â€“666. https://doi.org/10.1007/s10623-014-996\n      7-z\n[62]  Minder L, Shokrollahi A (2007)      Cryptanalysis of the Sidelnikov cryptosystem. Ad-\n      vances in Cryptology - EUROCRYPT 2007, ed Naor M (Springer Berlin Heidelberg,\n      Berlin, Heidelberg), pp 347â€“360. https://doi.org/https://doi.org/10.1007/978-3\n      -540-72540-4_20\n[63]  Borodin MA, Chizhov IV (2014)  Effective attack on the McEliece          cryptosystem\n      based on Reed-Muller codes. Discrete Mathematics and Applications 24(5):273â€“280.\n      https://doi.org/10.1515/dma-2014-0024\n[64]  FaugÃ¨re JC, Otmani A, Perret L, de Portzamparc F, Tillich JP (2015) Structural crypt-\n      analysis of McEliece schemes with compact keys. Designs, Codes and Cryptography\n      79:87 â€“ 112. https://doi.org/https://doi.org/10.1007/s10623-015-0036-z\n[65]  Couvreur A, Otmani A, Tillich J (2014) Polynomial time attack on wild McEliece over\n      quadratic extensions. Advances in Cryptology - EUROCRYPT 2014 - 33rd Annual In-\n      ternational Conference on the Theory and Applications of Cryptographic Techniques,\n      Copenhagen, Denmark, May 11-15, 2014. Proceedings, eds Nguyen PQ, Oswald E\n      (Springer), Lecture Notes in Computer Science, Vol. 8441, pp 17â€“39. https://doi.org/\n      10.1007/978-3-642-55220-5\\_2\n[66]  Mora R, Tillich J (2023) On the dimension and structure of the square of the dual of\n      a Goppa code. Des Codes Cryptogr 91(4):1351â€“1372. https://doi.org/10.1007/S106\n      23-022-01153-W\n\n24"}
{"doc_id": "NIST.IR.8545", "source_path": "data/raw_pdfs/NIST.IR.8545.pdf", "page_number": 32, "text": "NIST IR 8545    Fourth Round Status Report\nMarch 2025\n\n[67]  Bardet M, Mora R, Tillich J (2024) Polynomial time key-recovery attack on high rate\n      random alternant codes. IEEE Trans Inf Theory 70(6):4492â€“4511. https://doi.org/10\n      .1109/TIT.2023.3334592\n[68]  Couvreur A, Mora R, Tillich J (2023) A new approach based on quadratic forms to\n      attack the mceliece cryptosystem. Advances in Cryptology - ASIACRYPT 2023 - 29th\n      International Conference on the Theory and Application of Cryptology and Informa-\n      tion Security, Guangzhou, China, December 4-8, 2023, Proceedings, Part IV, eds Guo\n      J, Steinfeld R (Springer), Lecture Notes in Computer Science, Vol. 14441, pp 3â€“38.\n      https://doi.org/10.1007/978-981-99-8730-6\\_1\n[69]  Mora R (2024) On the matrix code of quadratic relationships for a Goppa code. Ad-\n      vances in Mathematics of Communications 19. https://doi.org/10.3934/amc.202402\n      6\n[70]  HÃ¼lsing A, Ning KC, Schwabe P, Weber FJ, Zimmermann PR (2021) Post-quantum\n      wireguard. 2021 IEEE Symposium on Security  and        Privacy (SP), pp   304â€“321.\n      https://doi.org/https://doi.org/10.1109/SP40001.2021.00030\n[71]  Esser A, Bellini E (2022) Syndrome decoding estimator. Public-Key Cryptography â€“\n      PKC 2022, eds Hanaoka G, Shikata J, Watanabe Y (Springer International Publishing,\n      Cham), pp 112â€“141. https://doi.org/https://doi.org/10.1007/978-3-030-97121-2_5\n[72]  Jao D, De Feo L (2011) Towards quantum-resistant cryptosystems from supersingu-\n      lar elliptic curve isogenies. Post-Quantum Cryptography, ed Yang BY (Springer Berlin\n      Heidelberg, Berlin, Heidelberg), pp 19â€“34. https://doi.org/https://doi.org/10.1007/\n      978-3-642-25405-5_2\n[73]  Maino L, Martindale C, Panny L, Pope G, Wesolowski B (2023) A Direct Key Recovery\n      Attack on SIDH. Advances in Cryptology â€“ EUROCRYPT 2023, eds Hazay C, Stam M\n      (Springer Nature Switzerland, Cham), pp 448â€“471. https://doi.org/https://doi.org/\n      10.1007/978-3-031-30589-4_16\n[74]  Castryck W, Vercauteren F (2023) A Polynomial Time Attack on Instances of M-SIDH\n      and FESTA. Advances in Cryptology â€“ ASIACRYPT 2023, eds Guo J, Steinfeld R (Springer\n      Nature Singapore, Singapore), pp 127â€“156. https://doi.org/https://doi.org/10.1007/\n      978-981-99-8739-9_5\n[75]  Alagic G, Bros M, Ciadoux P, Cooper D, Dang Q, Dang T, Kelsey J, Lichtinger J, Liu YK,\n      Miller C, Moody D, Peralta R, Perlner R, Robinson A, Silberg H, Smith-Tone D, Waller N\n      (2024) Status Report on the First Round of the Additional Digital Signature Schemes\n      for the NIST Post-Quantum Cryptography Standardization Process. (National Institute\n      of Standards and Technology, Gaithersburg, MD), NIST Interagency or Internal Report\n      (IR) NIST IR 8528. https://doi.org/10.6028/NIST.IR.8528\n[76]  Alagic G, Barker EB, Chen L, Moody D, Robinson A, Silberg H, Waller N (2025) Rec-\n      ommendation for key-encapsulation mechanisms (U.S. Department of Commerce,\n      Washington, D.C.), Special Publication 800-227 (Initial Public Draft). https://doi.org/\n      10.6028/NIST.SP.800-227.ipd\n\n25"}
{"doc_id": "NIST.IR.8545", "source_path": "data/raw_pdfs/NIST.IR.8545.pdf", "page_number": 33, "text": "NIST IR 8545    Fourth Round Status Report\nMarch 2025\n\nAppendix A. List of Symbols, Abbreviations, and Acronyms\n\nBIKE         Bit-Flipping Key Encapsulation\nCCA          Chosen Ciphertext Attack\nCPA          Chosen Plaintext Attack\nDFR          Decryption Failure Rate\nFIPS         Federal Information Processing Standards\nFO           Fujisaki Okamoto\nIEC          International Electrotechnical Commission\nIND-CCA2     Indistinguishability under Adaptive Chosen-Ciphertext Attack\nIND-CPA      Indistinguishability under Chosen-Plaintext Attack\nIPsec        Internet Protocol Security\nISD          Information Set Decoding\nISO          International Organization for Standardization\nHQC          Hamming Quasi-Cyclic\nKEM          Key-Encapsulation Mechanism\nLWE          Learning With Errors\nML-KEM       Module Lattice-Based Key-Encapsulation Mechanism (based on Kyber)\nNIST         National Institute of Standards and Technology\nNIST IR      NIST Interagency or Internal Report\nOW-CPA       One-Way under Chosen Plaintext Attack\nPKE          Public-Key Encryption\nPQC          Post-Quantum Cryptography\nQC-MDPC      Quasi-Cyclic Moderate Density Parity Check\nQCCF         Quasi-Cyclic Codeword Finding\nQCSD         Quasi-Cyclic Syndrome Decoding\nQUIC         Quick UDP Internet Connections\nRMRS         Reed-Muller Reed-Solomon\nROM          Random Oracle Model\nSAML SSO     Security Assertion Markup Language Single Sign-On\n\n26"}
{"doc_id": "NIST.IR.8545", "source_path": "data/raw_pdfs/NIST.IR.8545.pdf", "page_number": 34, "text": "NIST IR 8545    Fourth Round Status Report\nMarch 2025\n\nSIKE     Supersingular Isogeny Key Encapsulation\nSIDH     Supersingular Isogeny Diffie-Hellman\nSP       Special Publication\nSSH      Secure Shell\nTLS      Transport Layer Security\nVPN      Virtual Private Network\nXML      Extensible Markup Language\n\n27"}
{"doc_id": "NIST.IR.8547.ipd", "source_path": "data/raw_pdfs/NIST.IR.8547.ipd.pdf", "page_number": 1, "text": "      NIST Internal Report\n    NIST IR 8547 ipd\n\nTransition to Post-Quantum\n    Cryptography Standards\n\nInitial Public Draft\n\n        Dustin Moody\n    Ray Perlner\n    Andrew Regenscheid\n     Angela Robinson\n    David Cooper\n\n    This publication is available free of charge from:\n    https://doi.org/10.6028/NIST.IR.8547.ipd\n\n  0  NST NATIONAL INSTITUTE OF\n     STANDARDS AND TECHNOLOGY\n     U.S. DEPARTMENT OF COMMERCE\n  Check\n     for\n  updates"}
{"doc_id": "NIST.IR.8547.ipd", "source_path": "data/raw_pdfs/NIST.IR.8547.ipd.pdf", "page_number": 2, "text": "      NIST Internal Report\n    NIST IR 8547 ipd\n\nTransition to Post-Quantum\n    Cryptography Standards\n\n      Initial Public Draft\n\n              Dustin Moody\n    Ray Perlner\n    Andrew Regenscheid\n           Angela Robinson\n    David Cooper\n    Computer Security Division\nInformation Technology Lab\n\n    This publication is available free of charge from:\n    https://doi.org/10.6028/NIST.IR.8547.ipd\n\n    November 2024\n\n    OF\n\n    *    *\n\n         FESOF\n    U.S. Department of Commerce\n    Gina M. Raimondo, Secretary\n    National Institute of Standards and Technology\n    Laurie E. Locascio, NIST Director and Under Secretary of Commerce for Standards and Technology"}
{"doc_id": "NIST.IR.8547.ipd", "source_path": "data/raw_pdfs/NIST.IR.8547.ipd.pdf", "page_number": 3, "text": "NIST IR 8547 ipd (Initial Public Draft)                  Transition to Post-Quantum Cryptography Standards\nNovember 2024\n\nCertain equipment, instruments, software, or materials, commercial or non-commercial, are identified in this\npaper in order to specify the experimental procedure adequately. Such identification does not imply\nrecommendation or endorsement of any product or service by NIST, nor does it imply that the materials or\nequipment identified are necessarily the best available for the purpose.\n\nThere may be references in this publication to other publications currently under development by NIST in\naccordance with its assigned statutory responsibilities. The information in this publication, including concepts and\nmethodologies, may be used by federal agencies even before the completion of such companion publications.\nThus, until each publication is completed, current requirements, guidelines, and procedures, where they exist,\nremain operative. For planning and transition purposes, federal agencies may wish to closely follow the\ndevelopment of these new publications by NIST.\n\nOrganizations are encouraged to review all draft publications during public comment periods and provide feedback\nto NIST. Many NIST cybersecurity publications, other than the ones noted above, are available at\nhttps://csrc.nist.gov/publications.\n\nNIST Technical Series Policies\nCopyright, Use, and Licensing Statements\nNIST Technical Series Publication Identifier Syntax\n\nPublication History\nApproved by the NIST Editorial Review Board on YYYY-MM-DD [Will be added to final publication.]\n\nHow to Cite this NIST Technical Series Publication\nMoody D, Perlner R, Regenscheid A, Robinson A, Cooper D (2024) Transition to Post-Quantum Cryptography\nStandards. (National Institute of Standards and Technology, Gaithersburg, MD), NIST Internal Report (IR) NIST IR\n8547 ipd. https://doi.org/10.6028/NIST.IR.8547.ipd\n\nAuthor ORCID iDs\nDavid Cooper: 0009-0001-2410-5830\nDustin Moody: 0000-0002-4868-6684\nRay Perlner: 0000-0001-8793-2238\nAndrew Regenscheid: 0000-0002-3930-527X\nAngela Robinson: 0000-0002-1209-0379\n\nPublic Comment Period\nNovember 12, 2024 â€“ January 10, 2025\n\nSubmit Comments\npqc-transition@nist.gov\nNational Institute of Standards and Technology\nAttn: Computer Security Division, Information Technology Laboratory\n100 Bureau Drive (Mail Stop 8930) Gaithersburg, MD 20899-8930\n\nAdditional Information\nAdditional information about this publication is available at https://csrc.nist.gov/pubs/ir/8547/ipd, including\nrelated content, potential updates, and document history.\n\nAll comments are subject to release under the Freedom of Information Act (FOIA)."}
{"doc_id": "NIST.IR.8547.ipd", "source_path": "data/raw_pdfs/NIST.IR.8547.ipd.pdf", "page_number": 4, "text": "       NIST IR 8547 ipd (Initial Public Draft)    Transition to Post-Quantum Cryptography Standards\n       November 2024\n\n 1     Abstract\n 2     This report describes NISTâ€™s expected approach to transitioning from quantum-vulnerable\n 3     cryptographic algorithms to post-quantum digital signature algorithms and key-establishment\n 4     schemes. It identifies existing quantum-vulnerable cryptographic standards and the quantum-\n 5     resistant standards to which information technology products and services will need to\n 6     transition. It is intended to foster engagement with industry, standards organizations, and\n 7     relevant agencies to facilitate and accelerate the adoption of post-quantum cryptography.\n\n 8     Keywords\n 9     cryptography; post-quantum cryptography; public key cryptography; quantum computing.\n\n10     Reports on Computer Systems Technology\n11     The Information Technology Laboratory (ITL) at the National Institute of Standards and\n12     Technology (NIST) promotes the U.S. economy and public welfare by providing technical\n13     leadership for the Nationâ€™s measurement and standards infrastructure. ITL develops tests, test\n14     methods, reference data, proof of concept implementations, and technical analyses to advance\n15     the development and productive use of information technology. ITLâ€™s responsibilities include\n16     the development of management, administrative, technical, and physical standards and\n17     guidelines for the cost-effective security and privacy of other than national security-related\n18     information in federal information systems.\n\ni"}
{"doc_id": "NIST.IR.8547.ipd", "source_path": "data/raw_pdfs/NIST.IR.8547.ipd.pdf", "page_number": 5, "text": "       NIST IR 8547 ipd (Initial Public Draft)    Transition to Post-Quantum Cryptography Standards\n       November 2024\n\n19     Call for Patent Claims\n20     This public review includes a call for information on essential patent claims (claims whose use\n21     would be required for compliance with the guidance or requirements in this Information\n22     Technology Laboratory (ITL) draft publication). Such guidance and/or requirements may be\n23     directly stated in this ITL Publication or by reference to another publication. This call also\n24     includes disclosure, where known, of the existence of pending U.S. or foreign patent\n25     applications relating to this ITL draft publication and of any relevant unexpired U.S. or foreign\n26     patents.\n27     ITL may require from the patent holder, or a party authorized to make assurances on its behalf,\n28     in written or electronic form, either:\n29      a)  assurance in the form of a general disclaimer to the effect that such party does not hold\n30          and does not currently intend holding any essential patent claim(s); or\n31      b)  assurance that a license to such essential patent claim(s) will be made available to\n32          applicants desiring to utilize the license for the purpose of complying with the guidance\n33          or requirements in this ITL draft publication either:\n34             i.      under reasonable terms and conditions that are demonstrably free of any unfair\n35                     discrimination; or\n36             ii.     without compensation and under reasonable terms and conditions that are\n37                     demonstrably free of any unfair discrimination.\n38     Such assurance shall indicate that the patent holder (or third party authorized to make\n39     assurances on its behalf) will include in any documents transferring ownership of patents\n40     subject to the assurance, provisions sufficient to ensure that the commitments in the assurance\n41     are binding on the transferee, and that the transferee will similarly include appropriate\n42     provisions in the event of future transfers with the goal of binding each successor-in-interest.\n43     The assurance shall also indicate that it is intended to be binding on successors-in-interest\n44     regardless of whether such provisions are included in the relevant transfer documents.\n45     Such statements should be addressed to: pqc-transition@nist.gov\n\nii"}
{"doc_id": "NIST.IR.8547.ipd", "source_path": "data/raw_pdfs/NIST.IR.8547.ipd.pdf", "page_number": 6, "text": "       NIST IR 8547 ipd (Initial Public Draft)    Transition to Post-Quantum Cryptography Standards\n       November 2024\n\n46     Table of Contents\n47     1. Introduction ...................................................................................................................................1\n48\n49\n50     2. Background....................................................................................................................................3\n51\n52      2.1.1. Digital Signature Algorithms......................................................................................................... 3\n53      2.1.2. Key Establishment ........................................................................................................................ 4\n54      2.1.3. Symmetric Cryptography.............................................................................................................. 4\n55\n56      2.2.1. Network Protocol and Security Technology Standards................................................................ 5\n57      2.2.2. Software Cryptographic Libraries ................................................................................................. 5\n58      2.2.3. Cryptographic Hardware .............................................................................................................. 6\n59      2.2.4. PKI and Other Infrastructure Components .................................................................................. 6\n60      2.2.5. IT Applications and Services ......................................................................................................... 6\n61    3. Migration Considerations ...............................................................................................................7\n62\n63      3.1.1. Code Signing ................................................................................................................................. 7\n64      3.1.2. User and Machine Authentication ............................................................................................... 7\n65      3.1.3. Network Security Protocols.......................................................................................................... 8\n66      3.1.4. Email and Document Signing and Encryption .............................................................................. 8\n67\n68      3.2.1. Hybrid Key-Establishment Techniques......................................................................................... 9\n69      3.2.2. Hybrid Digital Signature Techniques .......................................................................................... 10\n70     4. Towards a PQC Standards Transition Timeline...............................................................................11\n71\n72      4.1.1. Digital Signatures........................................................................................................................ 13\n73      4.1.2. Key Establishment ...................................................................................................................... 14\n74      4.1.3. Symmetric Cryptography............................................................................................................ 15\n75\n76     References.......................................................................................................................................18\n77     Appendix A. Glossary .......................................................................................................................20\n\n78\n\niii"}
{"doc_id": "NIST.IR.8547.ipd", "source_path": "data/raw_pdfs/NIST.IR.8547.ipd.pdf", "page_number": 7, "text": "       NIST IR 8547 ipd (Initial Public Draft)    Transition to Post-Quantum Cryptography Standards\n       November 2024\n\n79     List of Tables\n80     Table 1: Post-Quantum Security Categories ......................................................................................12\n81     Table 2: Quantum-vulnerable digital signature algorithms ................................................................13\n82     Table 3. Post-quantum digital signature algorithms ..........................................................................13\n83     Table 4: Quantum-vulnerable key-establishment schemes ................................................................14\n84     Table 5: Post-quantum key-establishment schemes ..........................................................................15\n85     Table 6: Block ciphers.......................................................................................................................15\n86     Table 7: Hash functions and XOFs .....................................................................................................16\n\n87\n\niv"}
{"doc_id": "NIST.IR.8547.ipd", "source_path": "data/raw_pdfs/NIST.IR.8547.ipd.pdf", "page_number": 8, "text": "        NIST IR 8547 ipd (Initial Public Draft)    Transition to Post-Quantum Cryptography Standards\n        November 2024\n\n 88     1. Introduction\n 89     Cryptographic algorithms are vital for safeguarding confidential electronic information from\n 90     unauthorized access. For decades, these algorithms have proved strong enough to defend\n 91     against attacks using conventional computers that attempt to defeat cryptography. However,\n 92     future quantum computing may be able to break these algorithms, rendering data and\n 93     information vulnerable. Countering this future quantum capability requires new cryptographic\n 94     methods that can protect data from both current conventional computers and the quantum\n 95     computers of tomorrow. These methods are referred to as post-quantum cryptography (PQC).\n 96     In response, NIST has released three PQC standards to start the next and significantly large\n 97     stage of working on the transition to post-quantum cryptography: the Module-Lattice-Based\n 98     Key-Encapsulation Mechanism [FIPS203], the Module-Lattice-Based Digital Signature Algorithm\n 99     [FIPS204], and the Stateless Hash-Based Signature Algorithm [FIPS205]. Historically, the journey\n100     from algorithm standardization to full integration into information systems can take 10 to 20\n101     years. This timeline reflects the complexity of companies building the algorithms into products\n102     and services, procuring those products and services, and integrating those products and\n103     services into technology infrastructures.\n104     Even though the transition to post-quantum cryptography is starting before a cryptographically\n105     relevant quantum computer has been built, there is a pressing threat. Encrypted data remains\n106     at risk because of the â€œharvest now, decrypt laterâ€ threat in which adversaries collect encrypted\n107     data now with the goal of decrypting it once quantum technology matures. Since sensitive data\n108     often retains its value for many years, starting the transition to post-quantum cryptography\n109     now is critical to preventing these future breaches. This threat model is one of the main reasons\n110     why the transition to post-quantum cryptography is urgent.\n\n111     1.1. Scope and Purpose\n112     Updating cryptographic technology has occurred many times at different scales, such as\n113     increasing key sizes or phasing out insecure hash functions and block ciphers. While the\n114     transition to PQC is unprecedented in scale, it benefits from a level of awareness and\n115     understanding that previous cryptographic changes did not have. NIST recognizes the\n116     complexity of migrating the vast array of systems that currently rely on public-key cryptography\n117     and acknowledges that this transition will demand substantial effort across diverse applications\n118     and infrastructures with specific requirements and constraints.\n119     This report serves as the initial step in a broader strategy to manage and guide the transition to\n120     post-quantum cryptography. This transition will involve the adoption of new PQC algorithms as\n121     well as the careful deprecation, controlled legacy use, and eventual removal of quantum-\n122     vulnerable algorithms that are currently widespread in technological infrastructures. Public-\n123     private engagement will be crucial on the path toward PQC. Additionally, this report continues\n124     NISTâ€™s ongoing dialogue with industry, standards organizations, and relevant agencies to\n125     develop a clear roadmap and realistic timeline for transitioning to PQC. NIST is committed to\n\n   1"}
{"doc_id": "NIST.IR.8547.ipd", "source_path": "data/raw_pdfs/NIST.IR.8547.ipd.pdf", "page_number": 9, "text": "        NIST IR 8547 ipd (Initial Public Draft)    Transition to Post-Quantum Cryptography Standards\n        November 2024\n\n126     ensuring that this transition is as smooth and coordinated as possible, balancing the urgency of\n127     adopting PQC with the need to minimize disruption across critical systems.\n\n128     1.2. Audience\n129     This document is intended for a broad audience, including federal agencies, technology\n130     providers, standards organizations, and Cryptographic Module Validation Program (CMVP)\n131     laboratories. These groups play a critical role in preparing for the migration to PQC by\n132     developing, implementing, and standardizing the new cryptographic methods necessary to\n133     secure information in the era of quantum computing. This document should inform these\n134     stakeholderâ€™s efforts and timelines for migrating information technology products, services, and\n135     infrastructure to PQC.\n\n2"}
{"doc_id": "NIST.IR.8547.ipd", "source_path": "data/raw_pdfs/NIST.IR.8547.ipd.pdf", "page_number": 10, "text": "        NIST IR 8547 ipd (Initial Public Draft)    Transition to Post-Quantum Cryptography Standards\n        November 2024\n\n136     2. Background\n\n137     2.1. Cryptographic Standards\n138     Federal Information Processing Standards (FIPS) and the NIST Special Publication (SP) 800-series\n139     specify a broad set of cryptographic primitives, algorithms, and schemes, including many public-\n140     key cryptosystems that will be deprecated and ultimately disallowed as part of the transition to\n141     post-quantum cryptography. This section identifies quantum-vulnerable algorithms in NISTâ€™s\n142     existing cryptographic standards as well as the post-quantum algorithm standards that have\n143     been recently published. Section 4.1 provides the transition plan for the quantum-vulnerable\n144     algorithms in these standards.\n\n145     2.1.1. Digital Signature Algorithms\n146     Digital signature algorithms are used to provide identity authentication, integrity\n147     authentication, source authentication, and support for non-repudiation. Digital signature\n148     algorithms are used in conjunction with hash functions or eXtendable-Output Functions (XOFs)\n149     to sign messages of arbitrary length.\n150     NIST-approved digital signature algorithms were historically specified in FIPS 186 [FIPS186]. The\n151     current revision of FIPS 186 specifies the Elliptic Curve Digital Signature Algorithm (ECDSA) and\n152     adopts the RSA algorithm specified in RFC 8017 and PKCS 1 (version 1.5 and higher) and the\n153     Edwards-Curve Digital Signature Algorithm (EdDSA) specified in RFC 8032. The related SP 800-\n154     186 [SP800186] specifies the elliptic curves to be used with ECDSA and the elliptic curve\n155     cryptography (ECC) based key establishment schemes in SP 800-56A [SP80056A]. These\n156     algorithms are vulnerable to Shorâ€™s Algorithm on a cryptographically relevant quantum\n157     computer.\n158     FIPS 204 and 205 each specify quantum-resistant digital signature schemes. FIPS 204 specifies\n159     the Module-Lattice-Based Digital Signature Algorithm (ML-DSA) [FIPS204], which is derived\n160     from the CRYSTALS-Dilithium submission. FIPS 205 specifies the Stateless Hash-Based Digital\n161     Signature Algorithm (SLH-DSA), which is derived from the SPHINCS+ submission [FIPS205].\n162     SP 800-208, Recommendation for Stateful Hash-Based Signature Schemes, specifies two stateful\n163     hash-based signature (HBS) schemes â€” the Leighton-Micali Signature (LMS) system and the\n164     eXtended Merkle Signature Scheme (XMSS) â€” along with their multi-tree variants, the\n165     Hierarchical Signature System (HSS) and multi-tree XMSS (XMSSá´¹áµ€) [SP800208]. These schemes\n166     are also resistant to attacks by quantum computers. In stateful hash-based signature (HBS)\n167     schemes, the HBS private key consists of a large set of one-time signature (OTS) private keys.\n168     The security of these schemes relies on the signer to ensure that no individual OTS key is ever\n169     used to sign more than one message. Due to this need to maintain state, HBS schemes are not\n170     intended for general use.\n171     In the future, NIST intends to develop a FIPS that specifies a digital signature algorithm derived\n172     from FALCON as an additional alternative to these standards. In addition, NIST is evaluating\n173     other proposed digital signature algorithms for possible standardization through the Additional\n\n3"}
{"doc_id": "NIST.IR.8547.ipd", "source_path": "data/raw_pdfs/NIST.IR.8547.ipd.pdf", "page_number": 11, "text": "        NIST IR 8547 ipd (Initial Public Draft)       Transition to Post-Quantum Cryptography Standards\n        November 2024\n\n174     Digital Signature Schemes for the NIST Post-Quantum Cryptography Standardization Process\n175     [NISTIR8528].\n\n176     2.1.2. Key Establishment\n177     Key establishment is the means by which keys are generated and provided to the entities that\n178     are authorized to use them. Current NIST-approved key-establishment schemes are specified in\n179     SP 800-56A, Recommendation for Pair-Wise Key-Establishment Schemes Using Discrete\n180     Logarithm-Based Cryptography [SP80056A], and SP 800-56B, Recommendation for Pair-Wise\n181     Key Establishment Schemes Using Integer Factorization Cryptography [SP80056B].\n182     SP 800-56A specifies key-establishment schemes based on the discrete logarithm problem over\n183     finite fields and elliptic curves, including several variations of Diffie-Hellman and Menezes-Qu-\n184     Vanstone (MQV) key establishment schemes.\n185     SP 800-56B specifies key-establishment schemes based on the RSA public key cryptosystem.\n186     This publication includes approved methods for both key agreement and key transport.\n187     FIPS 203 specifies a cryptographic scheme called Module-Lattice-Based Key-Encapsulation\n188     Mechanism (ML-KEM), which is derived from the CRYSTALS-KYBER submission. A key-\n189     encapsulation mechanism (KEM) is a particular type of key-establishment scheme that can be\n190     used to establish a shared secret key between two parties communicating over a public\n191     channel. The fourth round of the NIST PQC Standardization process is evaluating additional KEM\n192     algorithms, and NIST anticipates selecting one or more alternatives to ML-KEM in the future.\n\n193     2.1.3. Symmetric Cryptography\n194     Symmetric-key algorithms (sometimes called secret-key algorithms) use a single key to both\n195     apply cryptographic protection and to remove or check the protection (i.e., the same key is\n196     used for a cryptographic operation and its inverse). For example, the key used to encrypt data\n197     (i.e., apply protection) is also used to decrypt the encrypted data (i.e., remove the protection).\n198     In the case of encryption, the original data is called the plaintext, while the encrypted form of\n199     the data is called the ciphertext. The key must be kept secret if the data is to remain protected.\n200     Several classes of symmetric-key algorithms have been approved: those based on block cipher\n201     algorithms (e.g., AES) and those based on the use of hash functions (e.g., a keyed-hash message\n202     authentication code based on a hash function).\n203     Symmetric-key algorithms are used for:\n204      â€¢  Block ciphers\n205      â€¢  Hash functions\n206      â€¢  Encryption using block cipher modes of operation\n207      â€¢  Data authentication using block cipher modes of operation\n208      â€¢  Data authentication using key-hash constructions\n\n4"}
{"doc_id": "NIST.IR.8547.ipd", "source_path": "data/raw_pdfs/NIST.IR.8547.ipd.pdf", "page_number": 12, "text": "        NIST IR 8547 ipd (Initial Public Draft)           Transition to Post-Quantum Cryptography Standards\n        November 2024\n\n209      â€¢  Key derivation\n210      â€¢  Key wrapping\n211      â€¢  Random bit generation\n212     As discussed in Sec. 4.1.3, the existing algorithm standards for symmetric cryptography are less\n213     vulnerable to attacks by quantum computers. NIST does not expect to need to transition away\n214     from these standards as part of the PQC migration.\n\n215     2.2. Cryptographic Technologies and Components\n216     Once PQC algorithms have been standardized, applications will need to be modified to make\n217     use of them. Many applications include components that are based on standardized protocols\n218     and security technologies that will need to be revised to support the use of the PQC algorithms.\n219     In addition, applications are built on top of software cryptographic libraries that either provide\n220     the implementations of the cryptographic algorithms or provide an interface to hardware\n221     cryptographic modules. Any software cryptographic libraries and hardware cryptographic\n222     modules used by an application will also need to be revised to support the PQC algorithms.\n223     Applications may also rely upon infrastructure components, such as public key infrastructures\n224     (PKI), that would need to be updated to support the PQC algorithms before the applications\n225     themselves can migrate to using the PQC algorithms.\n\n226     2.2.1. Network Protocol and Security Technology Standards\n227     Network protocols and security technology standards define the rules for data exchange over\n228     networks and ensure secure and reliable communication. Examples include Transport Layer\n229     Security (TLS), Secure Shell (SSH), Internet Protocol Security (IPsec), and Cryptographic Message\n230     Syntax (CMS).\n231     These protocols and security technologies often rely on classical cryptographic algorithms that\n232     are vulnerable to quantum attacks. Updating them to incorporate PQC algorithms is essential to\n233     maintaining data confidentiality and integrity. This involves revising protocol specifications to\n234     support new key exchange mechanisms and authentication methods that are quantum-\n235     resistant. In some cases, this will involve simply assigning an identifier for the new algorithm. In\n236     other cases, more significant changes will be required to accommodate the larger sizes of the\n237     PQC algorithms or as a result of the new algorithms having different interfaces.\n\n238     2.2.2. Software Cryptographic Libraries\n239     Software cryptographic libraries are collections of cryptographic algorithms and protocols that\n240     are implemented in software to provide essential cryptographic functions to applications.\n241     OpenSSL, BoringSSL, Libsodium, and the Java Cryptography Architecture (JCA) are a few\n242     examples of cryptographic libraries that are used to provide cryptographic support for\n243     applications.\n\n5"}
{"doc_id": "NIST.IR.8547.ipd", "source_path": "data/raw_pdfs/NIST.IR.8547.ipd.pdf", "page_number": 13, "text": "        NIST IR 8547 ipd (Initial Public Draft)       Transition to Post-Quantum Cryptography Standards\n        November 2024\n\n244     These libraries need to incorporate PQC algorithms that are standardized by bodies like NIST.\n245     Updating them ensures that developers have access to quantum-resistant cryptographic\n246     functions without implementing complex algorithms themselves. This transition involves adding\n247     new algorithms, optimizing their implementations for performance, and ensuring those\n248     implementations are secure against side-channel attacks.\n\n249     2.2.3. Cryptographic Hardware\n250     Cryptographic hardware modules, such as hardware security modules (HSMs) and Trusted\n251     Platform Modules (TPMs), provide secure environments for performing cryptographic\n252     operations and storing sensitive keys. They are used in various applications, from securing\n253     server infrastructure to protecting cryptographic keys on personal devices.\n254     Hardware modules must be upgraded or redesigned to support PQC algorithms, which often\n255     have larger key sizes and different computational requirements. This includes updating\n256     firmware or hardware to handle new algorithms and ensuring that the modules can perform\n257     quantum-resistant cryptographic operations efficiently while maintaining the high security\n258     standards expected of these devices.\n\n259     2.2.4. PKI and Other Infrastructure Components\n260     Public key infrastructure (PKI) systems manage digital certificates and public-private key pairs to\n261     enable secure communication and authentication across networks. Other infrastructure\n262     components include certification authorities (CAs), registration authorities, key management\n263     systems, and directory services.\n264     PKI components must be updated to issue, distribute, and manage certificates that use PQC\n265     algorithms and to sign certificates and revocation status information using PQC algorithms. This\n266     includes supporting new cryptographic algorithms in certificate issuance processes and\n267     modifying validation and revocation mechanisms. Ensuring backward compatibility and\n268     interoperability during the transition period is crucial to maintaining trust and security across\n269     the network.\n\n270     2.2.5. IT Applications and Services\n271     IT applications and services encompass a wide array of software and platforms used by\n272     organizations, including web applications, databases, communication tools, cloud services, and\n273     enterprise software. These applications rely on cryptography for securing data, authenticating\n274     users, and ensuring secure transactions.\n275     Applications and services must be modified to support PQC algorithms for encryption, digital\n276     signatures, and key exchange. This requires updating the underlying cryptographic\n277     implementations, adjusting to changes in key sizes and algorithm performance, and ensuring\n278     compatibility with updated protocols and libraries. Developers need to refactor code, conduct\n279     extensive testing, and potentially redesign user interfaces to accommodate these changes.\n\n6"}
{"doc_id": "NIST.IR.8547.ipd", "source_path": "data/raw_pdfs/NIST.IR.8547.ipd.pdf", "page_number": 14, "text": "        NIST IR 8547 ipd (Initial Public Draft)               Transition to Post-Quantum Cryptography Standards\n        November 2024\n\n280     3. Migration Considerations\n281     Even though there are no existing cryptographically relevant quantum computers that currently\n282     threaten levels of security, it will take a significant amount of time to transition to new post-\n283     quantum algorithms. Past cryptographic migrations have taken over a decade, and this more\n284     complex migration will likely take at least that long.\n285     Moscaâ€™s theorem emphasizes the urgency of migrating to post-quantum algorithms by\n286     introducing a simple but powerful timeline: if â€œXâ€ represents the number of years that data\n287     must be kept secure, and â€œYâ€ is the estimated time needed to complete the transition, then\n288     organizations must start transitioning to post-quantum algorithms before X + Y exceeds the\n289     expected time Z for a cryptographically relevant quantum computer to be built. This means that\n290     even if quantum computers are a decade away, organizations must begin the migration to post-\n291     quantum cryptography today to avoid having their encrypted data exposed once quantum\n292     computers become operational in the future. This threat, often referred to as â€œharvest now,\n293     decrypt later,â€ underscores the necessity of acting immediately, especially for data with long-\n294     term sensitivity, such as government secrets or medical records. Ensuring security today will\n295     safeguard it for the future.\n\n296     3.1. Use Cases\n\n297     3.1.1. Code Signing\n298     Code signing involves digitally signing executables and software packages to verify the authorâ€™s\n299     identity and ensure that the code has not been tampered with. This process is critical for\n300     maintaining trust in software distribution channels and preventing the spread of malicious\n301     code.\n302     The devices that install and execute this code need the ability to verify the signatures on the\n303     code. In some cases, it is not feasible to update the code that performs the signature\n304     verification after the devices have been manufactured. When this is the case, it is important for\n305     the devices to be designed to require quantum-resistant signatures on the executables, if there\n306     is a risk that the devices will still be in use after cryptographically relevant quantum computers\n307     become available.\n\n308     3.1.2. User and Machine Authentication\n309     User and machine authentication systems verify identities to control access to resources. This\n310     often involves cryptographic protocols that use asymmetric algorithms for secure key exchange\n311     and authentication, ensuring that only authorized users or devices can access sensitive data or\n312     services. Depending on the protocol, authentication may be performed using either a digital\n313     signature algorithm or a key-establishment scheme.\n314     Unlike with encryption, where there is a threat of â€œharvest now, decrypt later,â€ an\n315     authentication system remains secure as long as the cryptographic algorithms and keys used to\n316     perform the authentication are secure when the authentication is performed. Authentication\n\n                                                   7"}
{"doc_id": "NIST.IR.8547.ipd", "source_path": "data/raw_pdfs/NIST.IR.8547.ipd.pdf", "page_number": 15, "text": "        NIST IR 8547 ipd (Initial Public Draft)         Transition to Post-Quantum Cryptography Standards\n        November 2024\n\n317     systems may continue to use quantum-vulnerable algorithms until quantum computers that are\n318     capable of breaking current, quantum-vulnerable algorithms become available, at which point\n319     authentication using these algorithms will need to be disabled.\n320     Supporting quantum-resistant algorithms for authentication will require upgrades to both the\n321     system performing and accepting the authentication, as well as to any supporting\n322     infrastructure, such as a PKI. It may also require obtaining hardware cryptographic tokens that\n323     support the quantum-resistant algorithms.\n\n324     3.1.3. Network Security Protocols\n325     Network security protocols like TLS and virtual private networks secure data transmission over\n326     public networks. They use cryptographic techniques to provide confidentiality, integrity, and\n327     authentication between communicating parties.\n328     Modern network security protocols tend to use separate asymmetric keys for key\n329     establishment and authentication. While long-term keys are used for authentication, key-\n330     establishment keys are used for a short period of time, usually for a single key establishment.\n331     This provides the property of forward secrecy, where the compromise of a long-term key does\n332     not result in the compromise of communication sessions that occurred before the compromise.\n333     As symmetric keys that are established through the key-establishment process are used to\n334     provide confidentiality, the â€œharvest now, decrypt laterâ€ threat needs to be considered when\n335     determining a migration timeline for the key-establishment scheme. The cryptographic\n336     algorithm used for authentication may be transitioned at a different time, and for that the\n337     considerations in Sec. 3.1.2 apply.\n\n338     3.1.4. Email and Document Signing and Encryption\n339     Email and document signing employ digital signatures to verify the authenticity and integrity of\n340     electronic communications and documents. Common algorithms like RSA and ECDSA are widely\n341     used to create a cryptographic binding between the content and the senderâ€™s identity, ensuring\n342     that the message has not been altered and that it originates from a legitimate source.\n343     Secure/Multipurpose Internet Mail Extensions (S/MIME) is a standard for public-key encryption\n344     and the signing of MIME data. It provides end-to-end encryption and authentication for email\n345     and file exchanges to ensure that only intended recipients can access the content. As with other\n346     applications providing data confidentiality, email encryption is subject to â€œharvest now, decrypt\n347     later.â€\n\n348     3.2. PQC-Classical Hybrid Protocols\n349     The migration to post-quantum cryptography may initially include hybrid solutions that\n350     incorporate the use of quantum-resistant and quantum-vulnerable algorithms when\n351     establishing cryptographic keys or generating digital signatures. These hybrid solutions are\n352     typically designed to remain secure if at least one of the component algorithms is secure.\n\n8"}
{"doc_id": "NIST.IR.8547.ipd", "source_path": "data/raw_pdfs/NIST.IR.8547.ipd.pdf", "page_number": 16, "text": "        NIST IR 8547 ipd (Initial Public Draft)    Transition to Post-Quantum Cryptography Standards\n        November 2024\n\n353     Such hybrid solutions are often utilized as a hedge against a cryptographic or implementation\n354     flaw in one of the underlying component algorithms. It may also provide a path for\n355     accommodating the use of PQC if sector-specific requirements still require legacy quantum-\n356     vulnerable algorithms. However, hybrid solutions add complexity to implementations and\n357     architectures, which can increase security risks and costs during the transition to PQC. When\n358     used, hybrid solutions are typically expected to be temporary measures that lead to a second\n359     transition to cryptographic tools that use only PQC algorithms.\n360     These trade-offs will vary based on the hybrid techniques used, the applications involved, and\n361     the vendor and user communities that will develop and deploy them. Implementers and\n362     standards organizations that specify cryptographic protocols and technologies need to carefully\n363     consider the security, costs, and complexity of hybrid solutions in their environments.\n364     Industry and standards organizations are considering a variety of techniques for hybrid\n365     solutions with key-establishment schemes and digital signatures. NIST intends to accommodate\n366     the use of hybrid techniques in its cryptographic standards to facilitate the transition to PQC\n367     where their use is desired.\n368     Whether hybrid solutions are used or not, quantum-vulnerable and quantum-resistant\n369     cryptographic algorithms will be fielded and used alongside each other in many applications\n370     and systems during the transition to PQC to facilitate interoperability. For example, many\n371     network security protocols support the use of multiple sets of cryptographic algorithms and\n372     allow two communicating parties to negotiate which algorithms to use in each session.\n373     Similarly, during the transition to PQC, public key infrastructures using quantum-vulnerable\n374     digital signature algorithms are expected to be deployed and used alongside those using\n375     quantum-resistant algorithms. Such approaches are not considered hybrid solutions if each\n376     session only uses a single cryptographic algorithm for key establishment and/or digital\n377     signatures.\n\n378     3.2.1. Hybrid Key-Establishment Techniques\n379     A hybrid key-establishment mode is defined here to be a key establishment scheme that is a\n380     combination of two or more components that are themselves cryptographic key-establishment\n381     schemes. The hybrid key-establishment scheme becomes a composite of these component\n382     schemes.\n383     NIST currently allows a generic composite key-establishment technique described in SP 800-56C\n384     [SP80056C]. Assume that the value Z is a shared secret that was generated as specified by SP\n385     800-56A or 800-56B and that a shared secret T is generated or distributed through other\n386     schemes. The value Zâ€™=Z||T may then be treated as a shared secret and any of the key\n387     derivation methods given in SP 800-56C may be applied to Zâ€™ to derive secret keying material.\n388     NIST intends to update SP 800-56C so that the value Z may be generated as specified by any\n389     current and future NIST key-establishment standards. This will include SP 800-56A, SP 800-56B,\n390     FIPS 203, and any additional post-quantum key-establishment standards. The desired property\n391     of hybrid techniques is that derived keys remain secure if at least one of the component\n392     schemes is secure. Security properties can be complex, and for composite key establishment\n\n                                                   9"}
{"doc_id": "NIST.IR.8547.ipd", "source_path": "data/raw_pdfs/NIST.IR.8547.ipd.pdf", "page_number": 17, "text": "        NIST IR 8547 ipd (Initial Public Draft)         Transition to Post-Quantum Cryptography Standards\n        November 2024\n\n393     schemes they will need to be analyzed on a case-by-case basis with the requirements of the\n394     application in mind. NIST intends to offer guidance on various key combiners in the forthcoming\n395     SP 800-227, Recommendations for Key Encapsulation Mechanisms.\n396     Additionally, the output of the key-establishment scheme specified in FIPS 203 is a shared\n397     secret key which is a shared secret that does not require further key derivation. NIST\n398     emphasizes that any shared secret key generated as specified in FIPS 203 may be used as the\n399     value Z in the generic composite mode described in SP 800-56C. These same properties will\n400     apply to any future FIPS which standardize KEMs.\n\n401     3.2.2. Hybrid Digital Signature Techniques\n402     Common techniques for hybrid digital signatures involve the use of dual signatures, which\n403     consist of two or more signatures on a common message. It may also be known as a hybrid\n404     signature or composite signature. The verification of the dual signature requires all of the\n405     component signatures to be successfully verified, such as by creating a single logical composite\n406     signature from two or more component signature algorithms.\n407     Dual signatures could be used to sign user data (e.g., a document or e-mail) or digital\n408     certificates that contain references to user key pairs within a PKI. Existing NIST standards and\n409     guidelines accommodate their use provided that at least one component digital signature\n410     algorithm is NIST-approved.\n411     NIST leaves the decision to each specific application as to whether it can afford the\n412     implementation cost, performance reduction, and engineering complexity (including proper\n413     and independent security reviews) of a hybrid mode for key establishment or the use of dual\n414     signatures. To assist external parties that desire such a mechanism, NIST will accommodate the\n415     use of a hybrid key-establishment mode and dual signatures in FIPS 140 validation when\n416     suitably combined with a NIST-approved scheme.\n\n10"}
{"doc_id": "NIST.IR.8547.ipd", "source_path": "data/raw_pdfs/NIST.IR.8547.ipd.pdf", "page_number": 18, "text": "        NIST IR 8547 ipd (Initial Public Draft)       Transition to Post-Quantum Cryptography Standards\n        November 2024\n\n417     4. Towards a PQC Standards Transition Timeline\n418     NISTâ€™s cryptography standards provide comprehensive guidance on a broad spectrum of\n419     cryptographic mechanisms that are essential for securing sensitive information across both\n420     federal and nonfederal systems. These standards cover fundamental areas that are crucial for\n421     ensuring the confidentiality, integrity, and authenticity of data, such as encryption algorithms,\n422     digital signatures, hash functions, key establishment, and random number generation.\n423     Additionally, NISTâ€™s standards define key-management practices and offer frameworks for\n424     securely generating, storing, distributing, and destroying cryptographic keys.\n425     Beyond individual algorithms, NIST standards provide guidance on cryptographic protocols that\n426     secure communications, such as the TLS protocol, which protects internet data exchanges. They\n427     also specify requirements for cryptographic modules through the CMVP to ensure that\n428     implementations meet stringent security standards. NIST has also developed PQC standards to\n429     safeguard systems against future quantum attacks. Through collaboration with industry,\n430     academia, and other stakeholders, NIST continually updates its cryptographic standards to\n431     address evolving security threats and technological advances.\n432     National Security Memorandum 10 (NSM-10) establishes the year 2035 as the primary target\n433     for completing the migration to PQC across Federal systems [NSM10]:\n434      â€œAny digital system that uses existing public standards for publicâ€‘key cryptography, or\n435      that is planning to transition to such cryptography, could be vulnerable to an attack by a\n436      Cryptographically Relevant Quantum Computer (CRQC). To mitigate this risk, the United\n437      States must prioritize the timely and equitable transition of cryptographic systems to\n438      quantum-resistant cryptography, with the goal of mitigating as much of the quantum\n439      risk as is feasible by 2035.â€\n440     This date reflects the urgency of transitioning to cryptographic methods that can withstand\n441     future quantum threats. However, it is important to recognize that migration timelines may\n442     vary based on the specific use case or application. Some systems, particularly those with long-\n443     term confidentiality needs or more complex cryptographic infrastructures, may require earlier\n444     transitions, while others may adopt PQC at a slower pace due to legacy constraints or lower risk\n445     profiles. Flexibility in migration planning is essential to balance the urgency of securing critical\n446     systems with the practical challenges that different sectors face during this transition. NIST will\n447     work to ensure that these varying timelines are acknowledged and supported while maintaining\n448     the overall goal of achieving widespread PQC adoption by 2035.\n\n449     4.1. NIST Cryptographic Algorithm Standards and Guidelines\n450     SP 800-131A [SP800131A] [SP800131A] describes the transitions associated with the use of\n451     cryptography by Federal Government agencies to protect controlled unclassified information.\n452     The document addresses the use of algorithms and key lengths specified in FIPS and NIST SPs.\n453     During the transition to post-quantum cryptography, NIST will revise SP 800-131A with more\n454     detailed guidelines and schedules.\n\n11"}
{"doc_id": "NIST.IR.8547.ipd", "source_path": "data/raw_pdfs/NIST.IR.8547.ipd.pdf", "page_number": 19, "text": "        NIST IR 8547 ipd (Initial Public Draft)      Transition to Post-Quantum Cryptography Standards\n        November 2024\n\n455     The terms â€œacceptable,â€ â€œdeprecated, â€œdisallowed,â€ and â€œlegacy useâ€ are used throughout SP\n456     800-131A to indicate the approval status of an algorithm:\n457      â€¢  Acceptable means that the algorithm and key length/ strength in a FIPS or SP are\n458         approved for use in accordance with any associated guidance.\n459      â€¢  Deprecated means that the algorithm and key length/strength may be used, but there is\n460         some security risk. The data owner must examine this risk potential and decide whether\n461         to continue to use a deprecated algorithm or key length.\n462      â€¢  Disallowed means that the algorithm, key length/strength, parameter set, or scheme is\n463         no longer allowed for the stated purpose.\n464      â€¢  Legacy use means that the algorithm, scheme, or parameter set may only be used to\n465         process already protected information (e.g., to decrypt ciphertext data or to verify a\n466         digital signature).\n467\n468     Transition schedules are primarily driven by the level of cryptographic protection that a given\n469     algorithm and associated parameter set can provide, which is described as a rough measure\n470     known as security strength. Historically, the security strength that an algorithm could provide\n471     was defined in terms of the amount of work (i.e., the number of operations) that is required to\n472     break the algorithm (i.e., an algorithm has s bits of security strength if breaking the algorithm\n473     requires 2Ë¢ operations of some kind, where s = 112, 128, 192, or 256). However, there are\n474     significant uncertainties in estimating the security strengths of post-quantum cryptosystems\n475     given the difficulty of accurately predicting the performance characteristics of future quantum\n476     computers, such as their cost, speed, and memory size.\n477     While NIST guidelines continue to use bit-length security strengths to describe the level of\n478     protection offered by an algorithm and parameter set against attacks by classical computers,\n479     post-quantum security is described using a collection of broad security categories. Each\n480     category is defined by a comparatively easy-to-analyze reference primitive, whose security\n481     serves as a floor for a wide variety of metrics that are deemed potentially relevant to practical\n482     security. NIST based its classification on the range of security strengths offered by the existing\n483     standards in symmetric cryptography. Table 1 provides a summary of these security categories.\n484                            Table 1: Post-Quantum Security Categories\n             Security                              Attack Type               Example\n             Category\n             1           Key search on a block cipher with a 128-bit key     AES-128\n             2           Collision search on a 256-bit hash function         SHA-256\n             3           Key search on a block cipher with a 192-bit key     AES-192\n             4           Collision search on a 384-bit hash function         SHA3-384\n             5           Key search on a block cipher with a 256-bit key     AES-256\n\n12"}
{"doc_id": "NIST.IR.8547.ipd", "source_path": "data/raw_pdfs/NIST.IR.8547.ipd.pdf", "page_number": 20, "text": "        NIST IR 8547 ipd (Initial Public Draft)                      Transition to Post-Quantum Cryptography Standards\n        November 2024\n\n485     4.1.1. Digital Signatures\n486     Table 2 lists currently approved quantum-vulnerable digital signature algorithm standards.\n487\n488                   Table 2: Quantum-vulnerable digital signature algorithms\n\n         Digital Signature                         Parameters                      Transition\n          Algorithm Family\n\n         ECDSA        112 bits of security strength                   Deprecated after 2030\n         [FIPS186]                                                    Disallowed after 2035\n                      â‰¥ 128 bits of security strength                 Disallowed after 2035\n         EdDSA        â‰¥ 128 bits of security strength                 Disallowed after 2035\n         [FIPS186]\n\n         RSA          112 bits of security strength                   Deprecated after 2030\n         [FIPS186]                                                    Disallowed after 2035\n                      â‰¥ 128 bits of security strength                 Disallowed after 2035\n489\n490\n\n491     NISTâ€™s long-term cryptographic algorithm transition plans are outlined in SP 800-57pt1 (Part 1)\n492     [SP80057]. These guidelines had projected that NIST would disallow public-key schemes that\n493     provide 112 bits of security on January 1, 2031. However, based on the need to migrate to\n494     quantum-resistant algorithms during this timeframe, NIST intends to instead deprecate classical\n495     digital signatures at the 112-bit security level. Organizations may continue using these\n496     algorithms and parameter sets as they migrate to the post-quantum signatures identified in\n497     Table 3.\n\n498\n499                              Table 3. Post-quantum digital signature algorithms\n\n         Digital Signature                         Parameter Sets     Security     Security\n          Algorithm Family                                            Strength     Category\n         ML-DSA                  ML-DSA-44                           128 bits      2\n         [FIPS204]               ML-DSA-65                           192 bits      3\n\n                                 ML-DSA-87                           256 bits      5\n\n13"}
{"doc_id": "NIST.IR.8547.ipd", "source_path": "data/raw_pdfs/NIST.IR.8547.ipd.pdf", "page_number": 21, "text": "        NIST IR 8547 ipd (Initial Public Draft)                      Transition to Post-Quantum Cryptography Standards\n        November 2024\n\n         Digital Signature                         Parameter Sets     Security    Security\n          Algorithm Family                                            Strength    Category\n         SLH-DSA                SLH-DSA-SHA2-128[s/f]                128 bits     1\n         [FIPS205]              SLH-DSA-SHAKE-128[s/f]\n                                SLH-DSA-SHA2-192[s/f]                192 bits     3\n                                SLH-DSA-SHAKE-192[s/f]\n                                SLH-DSA-SHA2-256[s/f]                256 bits     5\n                                SLH-DSA-SHAKE-256[s/f]\n         LMS, HSS               With SHA-256/192                     192 bits     3\n         [SP800208]             With SHAKE256/192\n                                With SHA-256                         256 bits     5\n                                With SHAKE256\n         XMSS, XMSSá´¹áµ€           With SHA-256/192                     192 bits     3\n         [SP800208]             With SHAKE256/192\n                                With SHA-256                         256 bits     5\n                                With SHAKE256\n500\n\n501     4.1.2. Key Establishment\n502     Table 4 lists currently approved quantum-vulnerable key-establishment.\n503                         Table 4: Quantum-vulnerable key-establishment schemes\n\n         Key\n         Establishment                             Parameters                    Transition\n             Scheme\n\n         Finite Field       112 bits of security strength             Deprecated after 2030\n         DH and MQV                                                   Disallowed after 2035\n         [SP80056A]         â‰¥ 128 bits of security strength           Disallowed after 2035\n\n         Elliptic Curve     112 bits of security strength             Deprecated after 2030\n         DH and MQC                                                   Disallowed after 2035\n         [SP80056A]         â‰¥ 128 bits of security strength           Disallowed after 2035\n\n   RSA           112 bits of security strength       Deprecated after 2030\n   [SP80056B]                                        Disallowed after 2035\n                 â‰¥ 128 bits of security strength     Disallowed after 2035\n504\n\n14"}
{"doc_id": "NIST.IR.8547.ipd", "source_path": "data/raw_pdfs/NIST.IR.8547.ipd.pdf", "page_number": 22, "text": "        NIST IR 8547 ipd (Initial Public Draft)                      Transition to Post-Quantum Cryptography Standards\n        November 2024\n\n505     Similar to the transition for digital signature algorithms, NIST intends to instead deprecate\n506     rather than fully disallow classical key-establishment schemes at the 112-bit security level.\n507     Organizations may continue using these algorithms and parameter sets as they migrate to ML-\n508     KEM or other approved quantum-resistant techniques. However, in order to mitigate the risk of\n509     â€œharvest now, decrypt laterâ€ attacks on network communications, application-specific\n510     guidance, as described in Sec. 4.2, may require or recommend migration to quantum-resistant\n511     key establishment schemes before the classical schemes are generally disallowed.\n512     Table 5 lists current quantum-resistant key establishment schemes. At this time, ML-KEM is the\n513     only approved post-quantum key-establishment scheme based on public key cryptography.\n514     Additional algorithms are still being considered as part of the fourth round of the NIST PQC\n515     Standardization process. NIST expects to select one or more alternatives to ML-KEM in the\n516     future.\n517                                  Table 5: Post-quantum key-establishment schemes\n\n         Key Establishment Scheme                  Parameter Sets    Security Strength    Security Category\n         ML-KEM                      ML-KEM-512                           128 bits                1\n         [FIPS203]                   ML-DSA-768                           192 bits                3\n\n                                     ML-DSA-1024                          256 bits                5\n518\n\n519     4.1.3. Symmetric Cryptography\n520     NISTâ€™s existing standards in symmetric cryptography â€” including hash functions, XOFs, block\n521     ciphers, KDFs, and DRBGs â€” are significantly less vulnerable to known quantum attacks than\n522     the public-key cryptography standards in SP 800-56A, SP 800-56B, and FIPS 186. In particular, all\n523     NIST-approved symmetric primitives that provide at least 128 bits of classical security are\n524     believed to meet the requirements of at least Category 1 security within the system of five\n525     security strength categories for evaluating parameter sets in the NIST PQC standardization\n526     process (see Table 1). NIST has a few symmetric cryptography standards at the 112-bit security\n527     level, which will be disallowed in 2030. Applications should move away from these when\n528     transitioning to post-quantum cryptography.\n529                                                Table 6: Block ciphers\n\n                Block Cipher                       Parameter Sets         Security             Security\n                                                                          Strength             Category\n\n         AES                         AES-128                              128 bits                1\n         [FIPS197]                   AES-192                              192 bits                3\n\n                                     AES-256                              256 bits                5\n\n15"}
{"doc_id": "NIST.IR.8547.ipd", "source_path": "data/raw_pdfs/NIST.IR.8547.ipd.pdf", "page_number": 23, "text": "        NIST IR 8547 ipd (Initial Public Draft)           Transition to Post-Quantum Cryptography Standards\n        November 2024\n\n530\n531                                                Table 7: Hash functions and XOFs\n\n          Hash/XOF     Variants    Collision    Collision    Preimage                        Preimage\n         Algorithm                  Security     Security                          Security  Security\n         Family                     Strength     Category    Strength                        Category\n         SHA-1         SHA-1        80 bits        < 1       160 bits                           1\n         [FIPS180]\n         SHA-2         SHA-224      112 bits       < 1       224 bits                           3\n         [FIPS180]     SHA-512/224\n                       SHA-256      128 bits        2        256 bits                           5\n                       SHA-512/256\n                       SHA-384      192 bits        4        384 bits                           5\n\n                       SHA-512      256 bits        5        512 bits                           5\n\n         SHA-3         SHA3-224     112 bits       < 1       224 bits                           3\n         [FIPS202]\n                       SHA3-256     128 bits        2        256 bits                           5\n\n                       SHAKE128     128 bits        2        128 bits                           2\n\n                       SHA3-384     192 bits        4        384 bits                           5\n\n                       SHA3-512     256 bits        5        512 bits                           5\n\n                       SHAKE256     256 bits        5        512 bits                           5\n532\n\n533     4.2. Application-Specific Standards and Guidelines\n534     NIST develops and maintains standards and guidelines addressing cryptography used in certain\n535     security technologies, protocols, and systems. For example, FIPS 201-3 and its supporting\n536     technical guidelines in NIST Special Publications specify the Personal Identity Verification\n537     standard, including security and interoperability requirements for PKI-based credentials used to\n538     authenticate federal employees and contractors. Other Special Publications provide guidance\n539     on the configuration and use of cryptographic technologies, such as NIST SP 800-52 Revision 2\n540     on the use of TLS servers and clients. These standards and guidelines are regularly updated to\n541     address changes to underlying standards and technologies as well as new threats.\n542     Throughout the migration to PQC, NIST will revise its documents to provide more detailed\n543     guidelines for deprecating quantum-vulnerable algorithms, tailored to relevant applications.\n544     While NISTâ€™s cryptographic algorithm standards may continue to specify quantum-vulnerable\n\n16"}
{"doc_id": "NIST.IR.8547.ipd", "source_path": "data/raw_pdfs/NIST.IR.8547.ipd.pdf", "page_number": 24, "text": "        NIST IR 8547 ipd (Initial Public Draft)                Transition to Post-Quantum Cryptography Standards\n        November 2024\n\n545     techniques until 2035 and generally allow their use, these application-specific standards and\n546     guidelines may specify earlier transitions for certain cryptographic algorithms, techniques, and\n547     protocols used within these applications. These guidelines will be developed based on the\n548     expected impact that a cryptographically relevant quantum computer would have on these\n549     applications as well as the level of support for PQC in the relevant standards, products, and\n550     services. NIST expects to prioritize the migration to quantum-resistant key-establishment\n551     schemes within these updates to protect against â€œharvest now, decrypt laterâ€ attacks,\n552     particularly in interactive protocols like TLS and IKE.\n553     NIST will also coordinate with standards-developing organizations and industry to ensure that\n554     critical security protocols and technologies are updated to support PQC in a timely manner,\n555     recognizing that different application areas will have different risks, security needs, and\n556     adoption challenges.\n557\n\n17"}
{"doc_id": "NIST.IR.8547.ipd", "source_path": "data/raw_pdfs/NIST.IR.8547.ipd.pdf", "page_number": 25, "text": "        NIST IR 8547 ipd (Initial Public Draft)          Transition to Post-Quantum Cryptography Standards\n        November 2024\n\n558     References\n559     [FIPS140]        National Institute of Standards and Technology (2019) Security Requirements\n560                      for Cryptographic Modules. (Department of Commerce, Washington, DC),\n561                      Federal Information Processing Standards Publication (FIPS) FIPS 140-3.\n562                      https://doi.org/10.6028/NIST.FIPS.140-3\n563     [FIPS180]        National Institute of Standards and Technology (2015) Secure Hash Standard\n564                      (SHS). (Department of Commerce, Washington, DC), Federal Information\n565                      Processing Standards Publication (FIPS) FIPS 180-4.\n566                      https://doi.org/10.6028/NIST.FIPS.180-4\n567     [FIPS186]        National Institute of Standards and Technology. Digital signature standard\n568                      (DSS). (Department of Commerce, Washington, DC), Federal Information\n569                      Processing Standards Publication (FIPS) FIPS 186-5.\n570                      https://doi.org/10.6028/NIST.FIPS.186-5\n571     [FIPS197]        National Institute of Standards and Technology (2001) Advanced Encryption\n572                      Standard (AES). (Department of Commerce, Washington, DC), Federal\n573                      Information Processing Standards Publication (FIPS) FIPS 197.\n574                      https://doi.org/10.6028/NIST.FIPS.197\n575     [FIPS198]        National Institute of Standards and Technology (2008) The Keyed-Hash\n576                      Message Authentication Code (HMAC). (Department of Commerce,\n577                      Washington, DC), Federal Information Processing Standards Publication (FIPS)\n578                      FIPS 198-1. https://doi.org/10.6028/NIST.FIPS.198-1\n579     [FIPS202]        National Institute of Standards and Technology (2015) SHA-3 Standard:\n580                      Permutation-Based Hash and Extendable-Output Functions. (Department of\n581                      Commerce, Washington, DC), Federal Information Processing Standards\n582                      Publication (FIPS) FIPS 202. https://doi.org/10.6028/NIST.FIPS.202\n583     [FIPS203]        National Institute of Standards and Technology (2024) Module-Lattice-Based\n584                      Key-Encapsulation Mechanism Standard. (Department of Commerce,\n585                      Washington, DC), Federal Information Processing Standards Publication (FIPS)\n586                      FIPS 203. https://doi.org/10.6028/NIST.FIPS.203\n587     [FIPS204]        National Institute of Standards and Technology (2024) Module-Lattice-Based\n588                      Digital Signature Standard. (Department of Commerce, Washington, DC),\n589                      Federal Information Processing Standards Publication (FIPS) FIPS 204.\n590                      https://doi.org/10.6028/NIST.FIPS.204\n591     [FIPS205]        National Institute of Standards and Technology (2024) Stateless Hash-Based\n592                      Digital Signature Standard. (Department of Commerce, Washington, DC),\n593                      Federal Information Processing Standards Publication (FIPS) FIPS 205.\n594                      https://doi.org/10.6028/NIST.FIPS.205\n595     [NISTIR8528]     Alagic G, Bros M, Ciadoux P, Cooper D, Dang Q, Dang T, Kelsey J, Lichtinger J,\n596                      Liu YK, Miller C, Moody D, Peralta R, Perlner R, Robinson A, Silberg H, Smith-\n597                      Tone D, Waller N (2024) Status Report on the First Round of the Additional\n598                      Digital Signature Schemes for the NIST Post-Quantum Cryptography\n599                      Standardization Process. (National Institute of Standards and Technology,\n600                      Gaithersburg, MD), NIST IR 8528.\n\n18"}
{"doc_id": "NIST.IR.8547.ipd", "source_path": "data/raw_pdfs/NIST.IR.8547.ipd.pdf", "page_number": 26, "text": "        NIST IR 8547 ipd (Initial Public Draft)    Transition to Post-Quantum Cryptography Standards\n        November 2024\n\n601                     https://doi.org/10.6028/NIST.IR.8528\n602     [NSM10]         Biden J (2022) National Security Memorandum on Promoting United States\n603                     Leadership in Quantum Computing While Mitigating Risks to Vulnerable\n604                     Cryptographic Systems. (The White House, Washington, DC), National Security\n605                     Memorandum 10, May 4 2022. Available at\n606                     https://www.whitehouse.gov/briefing-room/statements-\n607                     releases/2022/05/04/national-security-memorandum-on-promoting-united-\n608                     states-leadership-in-quantum-computing-while-mitigating-risks-to-vulnerable-\n609                     cryptographic-systems/\n610     [SP80056A]      Barker EB, Chen L, Roginsky A, Vassilev A, Davis R (2018) Recommendation for\n611                     Pair-Wise Key-Establishment Using Schemes Using Discrete Logarithm\n612                     Cryptography. (National Institute of Standards and Technology, Gaithersburg,\n613                     MD), NIST Special Publication (SP) NIST SP 800-56Ar3.\n614                     https://doi.org/10.6028/NIST.SP.800-56Ar3\n615     [SP80056B]      Barker EB, Chen L, Roginsky A, Vassilev A, Davis R, Simon Scott (2019)\n616                     Recommendation for Pair-Wise Key-Establishment Schemes Integer\n617                     Factorization Cryptography. (National Institute of Standards and Technology,\n618                     Gaithersburg, MD), NIST Special Publication (SP) NIST SP 800-56Br2.\n619                     https://doi.org/10.6028/NIST.SP.800-56Br2\n620     [SP80056C]      Barker E, Chen L, Davis R (2020) Recommendation for Key-Derivation Methods\n621                     in Key-Establishment Schemes. (National Institute of Standards and\n622                     Technology, Gaithersburg, MD), NIST Special Publication (SP) NIST SP 800-\n623                     56Cr2. https://doi.org/10.6028/NIST.SP.800-56Cr2\n624     [SP80057]       Barker EB, Barker WC (2020) Recommendation for Key Management: Part 1 â€“\n625                     General. (National Institute of Standards and Technology, Gaithersburg, MD),\n626                     NIST Special Publication (SP) NIST SP 800-57pt1r5.\n627                     https://doi.org/10.6028/NIST.SP.800-57pt1r5\n628     [SP800131A]     Barker E, Roginsky A (2019) Transitions: Recommendation for Transitioning the\n629                     Use of Cryptographic Algorithms and Key Lengths. (National Institute of\n630                     Standards and Technology, Gaithersburg, MD), NIST Special Publication (SP)\n631                     NIST SP 800-131Ar2. https://doi.org/10.6028/NIST.SP.800-131Ar2\n632     [SP800185]      Kelsey JM, Chang S-jH, Perlner RA (2016) SHA-3 Derived Functions: cSHAKE,\n633                     KMAC, TupleHash, and ParallelHash. (National Institute of Standards and\n634                     Technology, Gaithersburg, MD), NIST Special Publication (SP) NIST SP 800-185.\n635                     https://doi.org/10.6028/NIST.SP.800-185\n636     [SP800186]      Chen L, Moody D, Regenscheid A, Robinson A, Randall K (2023)\n637                     Recommendations for Discrete Logarithm-based Cryptography: Elliptic Curve\n638                     Domain Parameters (National Institute of Standards and Technology,\n639                     Gaithersburg, MD), NIST Special Publication (SP) NIST SP 800-186.\n640                     https://doi.org/10.6028/NIST.SP.800-186\n641     [SP800208]      Cooper DA, Apon DC, Dang QH, Davidson MS, Dworkin MJ, Miller CA (2020)\n642                     Recommendation for Stateful Hash-Based Signature Schemes, (National\n643                     Institute of Standards and Technology, Gaithersburg, MD), NIST Special\n644                     Publication (SP) NIST SP 800-208. https://doi.org/10.6028/NIST.SP.800-208\n\n19"}
{"doc_id": "NIST.IR.8547.ipd", "source_path": "data/raw_pdfs/NIST.IR.8547.ipd.pdf", "page_number": 27, "text": "        NIST IR 8547 ipd (Initial Public Draft)     Transition to Post-Quantum Cryptography Standards\n        November 2024\n\n645     Appendix A. Glossary\n646     acceptable\n647     Approved for use. An allowed algorithm and key length/strength in a FIPS or SP is approved for use in accordance\n648     with any associated guidance.\n649     approved\n650     FIPS-approved and/or NIST-recommended. An algorithm or technique that is either 1) specified in a FIPS or NIST\n651     recommendation, 2) adopted in a FIPS or NIST recommendation, or 3) specified in a list of NIST-approved security\n652     functions.\n653     asymmetric (cryptography)\n654     Cryptography that uses two separate keys to exchange data â€” one to encrypt or digitally sign the data and one to\n655     decrypt the data or verify the digital signature. Also known as public-key cryptography.\n656     block cipher\n657     An invertible symmetric-key cryptographic algorithm that transforms one block of information at a time using a\n658     cryptographic key. The resulting output block is the same length as the input block.\n659     certificate\n660     A set of data that uniquely identifies a public key that has a corresponding private key and an owner that is\n661     authorized to use the key pair. The certificate contains the ownerâ€™s public key and possibly other information and\n662     is digitally signed by a certification authority (i.e., a trusted party), thereby binding the public key to the owner.\n663     cryptographic module\n664     The set of hardware, software, and/or firmware that implements approved cryptographic functions (including key\n665     generation) that are contained within the cryptographic boundary of the module.\n666     cryptographically relevant quantum computer\n667     A quantum computer which is capable of actually attacking real world cryptographic systems that would be\n668     infeasible to attack with a normal computer.\n669     deprecated\n670     The algorithm and key length may be used, but the user must accept some security risk. The term is used when\n671     discussing the key lengths or algorithms that may be used to apply cryptographic protection.\n672     digital certificate\n673     See certificate.\n674     digital signature\n675     The result of a cryptographic transformation of data that, when properly implemented, provides a mechanism to\n676     verify origin authenticity and data integrity and to enforce signatory non-repudiation.\n677     disallowed\n678     The algorithm or key length is no longer allowed for applying cryptographic protection.\n679     dual signature\n680     A dual signature consists of two (or more) signatures on a common message. It may also be known as a hybrid\n681     signature or composite signature.\n682     encryption\n683     The process of transforming plaintext into ciphertext using a cryptographic algorithm and key.\n684     eXtendable-Output Function (XOF)\n685     A function on bit strings in which the output can be extended to any desired length.\n686\n\n20"}
{"doc_id": "NIST.IR.8547.ipd", "source_path": "data/raw_pdfs/NIST.IR.8547.ipd.pdf", "page_number": 28, "text": "        NIST IR 8547 ipd (Initial Public Draft)                   Transition to Post-Quantum Cryptography Standards\n        November 2024\n\n687     forward secrecy\n688     Providing protection against the use of compromised old keys that could be used to attack the newer derived keys\n689     still in use for integrity and confidentiality protection.\n690     hash function\n691     A function on bit strings in which the length of the output is fixed. Approved hash functions (such as those\n692     specified in FIPS 180 and FIPS 202) are designed to satisfy the following properties:\n693      1. (One-way) It is computationally infeasible to find any input that maps to any new pre-specified output.\n694      2. (Collision-resistant) It is computationally infeasible to find any two distinct inputs that map to the same\n695      output.\n696     KEM combiner\n697     A function that takes in two or more shared secret keys and returns a combined shared secret key.\n698     key agreement\n699     A (pair-wise) key-establishment procedure where the resultant secret keying material is a function of information\n700     contributed by two participants so that no party can predetermine the value of the secret keying material\n701     independently from the contributions of the other party. Contrast with key-transport.\n702     key derivation\n703     The process of deriving a key in a non-reversible manner from shared information, some of which is secret.\n704     key encapsulation mechanism (KEM)\n705     A set of three cryptographic algorithms (KeyGen, Encaps, and Decaps) that can be used by two parties to establish\n706     a shared secret key over a public channel.\n707     key establishment\n708     A procedure that results in establishing secret keying material that is shared among different parties.\n709     key transport\n710     A (pair-wise) key-establishment procedure whereby one party (the sender) selects a value for the secret keying\n711     material and then securely distributes that value to another party (the receiver). Contrast with key agreement.\n712     key wrapping\n713     A method of protecting secret keying material (along with associated integrity information) that provides both\n714     confidentiality and integrity protection when using symmetric-key algorithms.\n715     legacy use\n716     The algorithm or key length may be used only to process already protected information (e.g., to decrypt ciphertext\n717     data or to verify a digital signature).\n718     message authentication code (MAC)\n719     A cryptographic checksum on data that uses a symmetric key to detect both accidental and intentional\n720     modifications of data.\n721     mode of operation\n722     An algorithm for the cryptographic transformation of data that features a symmetric key block cipher.\n723     public key infrastructure (PKI)\n724     A framework that is established to issue, maintain and revoke public key certificates.\n725     public key cryptography\n726     Cryptography that uses two separate keys to exchange data â€” one to encrypt or digitally sign the data and one to\n727     decrypt the data or verify the digital signature. Also known as asymmetric cryptography.\n\n21"}
{"doc_id": "NIST.IR.8547.ipd", "source_path": "data/raw_pdfs/NIST.IR.8547.ipd.pdf", "page_number": 29, "text": "        NIST IR 8547 ipd (Initial Public Draft)    Transition to Post-Quantum Cryptography Standards\n        November 2024\n\n728     security category\n729     A number associated with the security strength of a post-quantum cryptographic algorithm, as specified by NIST.\n730     security strength\n731     A number associated with the amount of work (i.e., the number of operations) that is required to break a\n732     cryptographic algorithm or system.\n733     shared secret\n734     A secret value that has been computed during a key-establishment scheme, is known by both participants, and is\n735     used as input to a key-derivation method to produce keying material.\n736     shared secret key\n737     A shared secret that can be used directly as a cryptographic key in symmetric-key cryptography. It does not require\n738     additional key derivation. The shared secret key must be kept private and must be destroyed when no longer\n739     needed.\n740     symmetric key cryptography\n741     A cryptographic algorithm that uses the same secret key for its operation and, if applicable, for reversing the\n742     effects of the operation (e.g., an AES key for encryption and decryption).\n\n22"}
{"doc_id": "NIST.SP.800-227", "source_path": "data/raw_pdfs/NIST.SP.800-227.pdf", "page_number": 1, "text": "    NIST Special Publication 800\n    NIST SP 800-227\n\n    Recommendations for Key-Encapsulation\n    Mechanisms\n\nGorjan Alagic\nElaine Barker\n           Lily Chen\n    Dustin Moody\n    Angela Robinson\n    Hamilton Silberg\n         Noah Waller\n\n    This publication is available free of charge from:\n    https://doi.org/10.6028/NIST.SP.800-227\n\n  0\n    NST NATIONAL INSTITUTE OF\n    STANDARDS AND TECHNOLOGY\n  Check for    U.S. DEPARTMENT OF COMMERCE\n  updates"}
{"doc_id": "NIST.SP.800-227", "source_path": "data/raw_pdfs/NIST.SP.800-227.pdf", "page_number": 2, "text": "    NIST Special Publication 800\n    NIST SP 800-227\n\nRecommendations for Key-Encapsulation\n    Mechanisms\n\n                        Gorjan Alagic\n    Elaine Barker\n    Lily Chen\n    Dustin Moody\n    Angela Robinson\n                     Hamilton Silberg\n    Noah Waller\n           Computer Security Division\n    Information Technology Laboratory\n\n    This publication is available free of charge from:\n    https://doi.org/10.6028/NIST.SP.800-227\n\n    September 2025\n\n                                                                      U.S. Department of Commerce\n                                                                        Howard Lutnick, Secretary\n    National Institute of Standards and Technology\n    Craig Burkhardt, Acting Under Secretary for Standards and Technology and Acting NIST Director"}
{"doc_id": "NIST.SP.800-227", "source_path": "data/raw_pdfs/NIST.SP.800-227.pdf", "page_number": 3, "text": "Certain commercial equipment, instruments, software, or materials, commercial or non-commercial, are\nidentified in this paper in order to specify the experimental procedure adequately. Such identification does\nnot imply recommendation or endorsement of any product or service by NIST, nor does it imply that the\nmaterials or equipment identified are necessarily the best available for the purpose.\nThere may be references in this publication to other publications currently under development by NIST in\naccordance with its assigned statutory responsibilities. The information in this publication, including\nconcepts and methodologies, may be used by federal agencies even before the completion of such\ncompanion publications. Thus, until each publication is completed, current requirements, guidelines, and\nprocedures, where they exist, remain operative. For planning and transition purposes, federal agencies\nmay wish to closely follow the development of these new publications by NIST.\nOrganizations are encouraged to review all draft publications during public comment periods and provide\nfeedback to NIST. Many NIST cybersecurity publications, other than the ones noted above, are available at\nhttps://csrc.nist.gov/publications.\n\nAuthority\nThis publication has been developed by NIST in accordance with its statutory responsibilities under the\nFederal Information Security Modernization Act (FISMA) of 2014, 44 U.S.C. Â§ 3551 et seq., Public Law (P.L.)\n113-283. NIST is responsible for developing information security standards and guidelines, including\nminimum requirements for federal information systems, but such standards and guidelines shall not apply\nto national security systems without the express approval of appropriate federal officials exercising policy\nauthority over such systems. This guideline is consistent with the requirements of the Office of\nManagement and Budget (OMB) Circular A-130.\nNothing in this publication should be taken to contradict the standards and guidelines made mandatory\nand binding on federal agencies by the Secretary of Commerce under statutory authority. Nor should these\nguidelines be interpreted as altering or superseding the existing authorities of the Secretary of Commerce,\nDirector of the OMB, or any other federal official. This publication may be used by nongovernmental\norganizations on a voluntary basis and is not subject to copyright in the United States. Attribution would,\nhowever, be appreciated by NIST.\n\nNIST Technical Series Policies\nCopyright, Use, and Licensing Statements\nNIST Technical Series Publication Identifier Syntax\n\nPublication History\nApproved by the NIST Editorial Review Board on 2025-09-03\n\nHow to cite this NIST Technical Series Publication:\nAlagic G, Barker EB, Chen L, Moody D, Robinson A, Silberg H, Waller N (2025) Recommendations for\nKey-Encapsulation Mechanisms. (National Institute of Standards and Technology, Gaithersburg, MD), NIST\nSpecial Publication (SP) NIST SP 800-227. https://doi.org/10.6028/NIST.SP.800-227\n\nAuthor ORCID iDs\nGorjan Alagic: 0000-0002-0107-6037\nElaine Barker: 0000-0003-0454-0461\nLily Chen: 0000-0003-2726-4279\nDustin Moody: 0000-0002-4868-6684\nAngela Robinson: 0000-0002-1209-0379\nHamilton Silberg: 0009-0004-4178-8954\nNoah Waller: 0000-0002-6979-9725"}
{"doc_id": "NIST.SP.800-227", "source_path": "data/raw_pdfs/NIST.SP.800-227.pdf", "page_number": 4, "text": "Contact Information\nsp800-227-comments@nist.gov\n\nAdditional Information\nAdditional information about this publication is available at\nhttps://csrc.nist.gov/pubs/sp/800/227/final, including related content, potential updates,\nand document history.\nAll comments are subject to release under the Freedom of Information Act (FOIA)."}
{"doc_id": "NIST.SP.800-227", "source_path": "data/raw_pdfs/NIST.SP.800-227.pdf", "page_number": 5, "text": "NIST SP 800-227\nSeptember 2025\n\nAbstract\n\nA key-encapsulation mechanism (KEM) is a set of algorithms that can be used by two par-\nties under certain conditions to securely establish a shared secret key over a public channel.\nA shared secret key that is established using a KEM can then be used with symmetric-key\ncryptographic algorithms to perform essential tasks in secure communications, such as\nencryption and authentication. This document describes the basic definitions, properties,\nand applications of KEMs. It also provides recommendations for implementing and using\nKEMs in a secure manner.\n\nKeywords\n\ncryptography; encryption; key-encapsulation mechanism; key establishment; public-key\ncryptography.\n\nReports on Computer Systems Technology\n\nThe Information Technology Laboratory (ITL) at the National Institute of Standards and\nTechnology (NIST) promotes the U.S. economy and public welfare by providing technical\nleadership for the Nationâ€™s measurement and standards infrastructure. ITL develops tests,\ntest methods, reference data, proof of concept implementations, and technical analyses\nto advance the development and productive use of information technology. ITLâ€™s respon-\nsibilities include the development of management, administrative, technical, and physical\nstandards and guidelines for the cost-effective security and privacy of other than national\nsecurity-related information in federal information systems. The Special Publication 800-\nseries reports on ITLâ€™s research, guidelines, and outreach efforts in information system se-\ncurity, and its collaborative activities with industry, government, and academic organiza-\ntions.\n\ni"}
{"doc_id": "NIST.SP.800-227", "source_path": "data/raw_pdfs/NIST.SP.800-227.pdf", "page_number": 6, "text": "NIST SP 800-227\nSeptember 2025\n\nPatent Disclosure Notice\n\nNOTICE: ITL has requested that holders of patent claims whose use may be required for compliance\nwith the guidance or requirements of this publication disclose such patent claims to ITL. However,\nholders of patents are not obligated to respond to ITL calls for patents and ITL has not undertaken\na patent search in order to identify which, if any, patents may apply to this publication.\nAs of the date of publication and following call(s) for the identification of patent claims whose use\nmay be required for compliance with the guidance or requirements of this publication, no such\npatent claims have been identified to ITL.\nNo representation is made or implied by ITL that licenses are not required to avoid patent infringe-\nment in the use of this publication.\n\nii"}
{"doc_id": "NIST.SP.800-227", "source_path": "data/raw_pdfs/NIST.SP.800-227.pdf", "page_number": 7, "text": "NIST SP 800-227\nSeptember 2025\n\n                               Table of Contents\n\n1.  Introduction        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     1\n    1.1.     Background       . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     1\n    1.2.            Scope and Purpose . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     1\n    1.3.           Requirements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     2\n2.  Overview of Key-Encapsulation Mechanisms                  . . . . . . . . . . . . . . . . . . . . .     4\n    2.1.     Overview and Motivation          . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     4\n    2.2.             Basic Definitions and Examples . . . . . . . . . . . . . . . . . . . . . . . . . .     5\n    2.3.     Theoretical Security of KEMs         . . . . . . . . . . . . . . . . . . . . . . . . . . .     8\n3.  Requirements for Secure KEM Implementations                   . . . . . . . . . . . . . . . . . . .    11\n    3.1.     Compliance With NIST Standards and Validation              . . . . . . . . . . . . . . . .    11\n    3.2.     Managing Cryptographic Data            . . . . . . . . . . . . . . . . . . . . . . . . . .    12\n    3.3.     Additional Requirements          . . . . . . . . . . . . . . . . . . . . . . . . . . . . .    14\n4.  Using KEMs Securely in Applications             . . . . . . . . . . . . . . . . . . . . . . . . . .    15\n    4.1.     How to Establish a Key With a KEM            . . . . . . . . . . . . . . . . . . . . . . .    15\n    4.2.     Conditions for Using KEMs Securely           . . . . . . . . . . . . . . . . . . . . . . .    17\n    4.3.     Post Processing of the Shared Secret Key           . . . . . . . . . . . . . . . . . . . .    19\n    4.4.           Key Confirmation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .    20\n             4.4.1.           Creating the MAC Data . . . . . . . . . . . . . . . . . . . . . . . . . .    21\n             4.4.2.     Obtaining the Key-Confirmation Key          . . . . . . . . . . . . . . . . . .    21\n             4.4.3.            Key-Confirmation Example . . . . . . . . . . . . . . . . . . . . . . . .    22\n    4.5.     Proof of Possession for KEM Keys           . . . . . . . . . . . . . . . . . . . . . . . .    24\n    4.6.     Multi-Algorithm KEMs and PQ/T Hybrids              . . . . . . . . . . . . . . . . . . . .    26\n             4.6.1.     Constructing a Composite KEM          . . . . . . . . . . . . . . . . . . . . .    27\n             4.6.2.     Approved Key Combiners          . . . . . . . . . . . . . . . . . . . . . . . .    28\n             4.6.3.     Security Considerations for Composite Schemes             . . . . . . . . . . .    31\n5.         Examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .    33\n    5.1.     Examples of KEMs         . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .    33\n             5.1.1.     A KEM From Diffie-Hellman         . . . . . . . . . . . . . . . . . . . . . . .    33\n             5.1.2.     A KEM From RSA Secret-Value Encapsulation             . . . . . . . . . . . . .    34\n             5.1.3.     ML-KEM      . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .    35\n\n                                                 iii"}
{"doc_id": "NIST.SP.800-227", "source_path": "data/raw_pdfs/NIST.SP.800-227.pdf", "page_number": 8, "text": "5.2.         Examples of KEM Applications        . . . . . . . . . . . . . . . . . . . . . . . . . .    35\n             5.2.1.     KEM-DEM Public-Key Encryption        . . . . . . . . . . . . . . . . . . . .    35\n             5.2.2.     Unilateral Authenticated Key Establishment Using a KEM           . . . . . .    37\n             5.2.3.     Ephemeral Authenticated Key Establishment          . . . . . . . . . . . . .    38\n             5.2.4.     Static-Ephemeral Unilateral Authenticated Key Establishment Using\n                        KEMs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .    39\n             5.2.5.             Authenticated Key Establishment Using KEMs . . . . . . . . . . . . .    41\nReferences     . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .    44\nAppendix A.         List of Acronyms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .    48\nAppendix B.   Glossary       . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .    49\nAppendix C.   Cryptographic Components             . . . . . . . . . . . . . . . . . . . . . . . . .    53\n C.1.        Message Authentication Codes (MACs)           . . . . . . . . . . . . . . . . . . . . .    53\n C.2.         Nonces . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .    54\nAppendix D.              Changes From Draft SP 800-227 . . . . . . . . . . . . . . . . . . . . . . .    56\n\n                             List of Tables\n\nTable 1.     Approved MAC algorithms for key confirmation            . . . . . . . . . . . . . . . .    54\n\n                             List of Figures\n\nFig. 1.             Outline of key establishment using a KEM . . . . . . . . . . . . . . . . . . . .     5\nFig. 2.      The IND-CPA security experiment for a KEM Î            . . . . . . . . . . . . . . . . .     9\nFig. 3.                The IND-CCA security experiment for a KEM Î  . . . . . . . . . . . . . . . . .     9\nFig. 4.      Simple key establishment using a KEM          . . . . . . . . . . . . . . . . . . . . .    16\nFig. 5.      Key-confirmation example with an ephemeral key pair             . . . . . . . . . . . .    23\nFig. 6.      KEM PoP between a key-pair owner and CA             . . . . . . . . . . . . . . . . . .    25\nFig. 7.                   Sending a message using the KEM-DEM paradigm . . . . . . . . . . . . . . .    36\nFig. 8.      Unilateral authenticated key establishment using a KEM            . . . . . . . . . . .    37\nFig. 9.                 Using a KEM for key establishment with unilateral authentication . . . . . .    39\nFig. 10.     Static-ephemeral unilateral authenticated key establishment using KEMs                .    40\nFig. 11.              Authenticated key establishment using KEMs . . . . . . . . . . . . . . . . . .    42\n\niv"}
{"doc_id": "NIST.SP.800-227", "source_path": "data/raw_pdfs/NIST.SP.800-227.pdf", "page_number": 9, "text": "NIST SP 800-227\nSeptember 2025    Recommendations for KEMs\n\n1.    Introduction\n\n1.1.  Background\nA key-establishment scheme is a set of algorithms that can be used to securely establish\na shared secret key between two or more parties.  Such a shared secret key can then be\nused to perform tasks that are suitable for symmetric-key cryptography, such as efficient\nconfidential communication.\nMany widely deployed key-establishment schemes â€” including those specified in NIST Spe-\ncial Publication (SP) 800-56A [1] and SP 800-56B [2] â€” are vulnerable to cryptographic at-\ntacks that make use of a large-scale, cryptanalytically relevant quantum computer. In 2016,\nNIST initiated a process to select and standardize a set of post-quantum key-establishment\nschemes (i.e., key-establishment schemes that would not be vulnerable to attacks even\nby cryptanalytically-relevant quantum computers). In response, NIST received feedback\nfrom the cryptographic community that the post-quantum key-establishment schemes\nbest suited for standardization and widespread deployment are key-encapsulation mecha-\nnisms (KEMs). The first KEM standard that resulted from this NIST Post-Quantum Cryptog-\nraphy (PQC) standardization process was ML-KEM, which is specified in Federal Information\nProcessing Standards (FIPS) publication 203 [3].\nAt the time of the standardization of ML-KEM, NIST had not provided extensive guidelines\non the basic definitions, properties, and applications of KEMs. This recommendation is\nmeant to provide these guidelines, supplement the current and future standardization of\nKEMs, and provide recommendations for implementing and using KEMs in a secure man-\nner.\n\n1.2.  Scope and Purpose\nThis recommendation provides guidelines on the basic definitions, properties, and appli-\ncations of KEMs; supplements the current and future standardization of KEMs; and makes\nsome requirements and recommendations for implementing and using KEMs in FIPS 140-\nvalidated cryptographic modules. This recommendation also provides guidelines for ven-\ndors who wish to securely combine keying material produced via approved post-quantum\nmethods with keying material produced via other (potentially quantum-vulnerable) meth-\nods.\nThis recommendation does not discuss how or when to migrate from quantum-vulnerable\nkey-establishment procedures to post-quantum KEMs (see [4]), nor does it provide a spec-\nification for any particular KEM. Such specifications will be provided in a FIPS or an SP, such\nas the specification of ML-KEM in FIPS 203 [3].\nThis recommendation includes explanatory and educational material to aid in the general\nunderstanding of KEMs. While SPs typically only include material that pertains to what is\n\n1"}
{"doc_id": "NIST.SP.800-227", "source_path": "data/raw_pdfs/NIST.SP.800-227.pdf", "page_number": 10, "text": "NIST SP 800-227\nSeptember 2025    Recommendations for KEMs\n\napproved, this SP describes KEMs both generally and with respect to what is approved.\nSpecific requirements will be clearly noted with â€œshallâ€ and â€œmustâ€ statements.\n\n1.3.  Requirements\nConforming implementations of approved KEMs are required to satisfy all of the require-\nments below. Requirements that are testable by a Cryptographic Module Validation Pro-\ngram (CMVP) validation lab are enumerated with the prefix â€œRS,â€ and requirements that\nare not testable by a validation lab are enumerated with the prefix â€œRM.â€ Each require-\nment is directly quoted from the corresponding referenced section. Requirements RS6,\nRS7, RS8, RS10, and RS11 pertain to key confirmation (Sec. 4.4), which is recommended\nbut not required.\nThe following requirements are testable by a CMVP validation lab (i.e., shall statements):\n RS1  (Section 3.1) KEM implementations shall comply with a specific NIST FIPS or SP that\n      specifies the algorithms of the relevant KEM. For example, a conforming implemen-\n      tation of ML-KEM shall comply with FIPS 203 [3]. 1\n RS2  (Section 3.1) KEM implementations shall follow the guidelines given in FIPS 140-3 [5]\n      and associated implementation guidance.\n RS3  (Section 3.1) KEM implementations shall use approved components with security\n      strengths that meet or exceed the required strength for each KEM parameter set.\n RS4  (Section 3.1) Random bits shall be generated using approved techniques, as de-\n      scribed in the latest revisions of SP 800-90A, SP 800-90B, and SP 800-90C [6â€“8].\n RS5  (Section 3.2) Except for random seeds and data that can be easily computed from\n      public information, all intermediate values used in any given KEM algorithm (i.e.,\n      KeyGen, Encaps, and Decaps) shall be destroyed before the algorithm terminates.\n RS6  (Section 4.2) If an application uses an ephemeral key pair, the key pair shall be used\n      for only one execution of key-establishment via a KEM and shall be destroyed as\n      soon as possible after its use.\n RS7  (Section 4.4.1) When a nonce is used by the decapsulator during key confirmation\n      (as specified herein), a nonce with a bit length that is (at least) equal to the targeted\n      security strength of the KEM key-establishment process shall be used (see Appendix\n      C.2).\n RS8  (Section 4.4.1) For key confirmation, the MAC algorithm and key-confirmation key\n      used shall have security strengths that are equal to or greater than the desired se-\n      curity strength of the application.\n1The CMVP will perform random input-output tests in an attempt to ascertain whether this requirement is\nsatisfied. Ensuring full functional equivalence to the specification via testing is not possible (see the â€œmustâ€\nrequirement RM1).\n\n                                         2"}
{"doc_id": "NIST.SP.800-227", "source_path": "data/raw_pdfs/NIST.SP.800-227.pdf", "page_number": 11, "text": " NIST SP 800-227\n September 2025    Recommendations for KEMs\n\n RS9  (Section 4.4.2) The key-confirmation key shall only be used for key confirmation and\n      destroyed after use.\nRS10  (Appendix C.1) When key confirmation requires the use of a MAC algorithm, it shall\n      be an approved MAC algorithm (e.g., HMAC, AES-CMAC, KMAC). In addition, AES-\n      GMAC (specified in [9]) is an approved MAC algorithm and may be used.\nRS11  (Appendix C.1) When a MAC tag is used for key confirmation, an entity shall compute\n      the MAC tag on received or derived data using a MAC algorithm with a MacKey that\n      is determined from a shared secret key.\n The following requirements are not testable by a CMVP validation lab (i.e., must state-\n ments):\n RM1 (Section 3.1). Implementations must correctly implement the mathematical func-\n      tionality of the target KEM. 2\n RM2 (Section 4.2) In applications of KEMs, a parameter set with an application-appropriate\n      security strength must be selected (see [10, Section 2.2]).\n RM3 (Section 4.2) If an encapsulating party obtains the static encapsulation key of another\n      party, it must have assurance of the other partyâ€™s ownership of the key before or\n      during the execution of key-establishment.\n RM4 (Section 4.2) The devices used to execute KEM algorithms and store any sensitive\n      data (e.g., decapsulation keys) must be appropriately secured.\n RM5 (Section 4.2) The key-establishment process that takes place over the channel used\n      by Alice and Bob must satisfy an application-appropriate notion of integrity.\n\n 2The CMVP will perform random input-output tests in an attempt to ascertain whether this requirement is\n satisfied. Ensuring full functional equivalence to the specification is not possible.\n\n 3"}
{"doc_id": "NIST.SP.800-227", "source_path": "data/raw_pdfs/NIST.SP.800-227.pdf", "page_number": 12, "text": "NIST SP 800-227\nSeptember 2025    Recommendations for KEMs\n\n2.     Overview of Key-Encapsulation Mechanisms\n\nThis section provides a high-level overview of KEMs, which are collections of mathemat-\nical functions (some of which include random inputs) and data that specify parameters.\nSection 3 describes how to implement a KEM as a collection of computer programs, and\nSec. 4 describes how to deploy KEMs in applications.\n\n2.1.    Overview and Motivation\nModern symmetric-key cryptography provides a wide range of useful functionalities, in-\ncluding secure and highly efficient computation and communication.      Before symmetric-\nkey cryptography can be used, the participating parties need to establish a shared secret\n(i.e., symmetric) key. One approach to establishing such a key is over a public communi-\ncation channel. Any algorithmic method that establishes a shared secret key over a public\nchannel is called a key-establishment scheme. A general key-establishment scheme can\nrequire multiple rounds of communication and involve any number of parties.\nA KEM is a specific type of key-establishment scheme. Typical key establishment via a KEM\ninvolves two parties (here referred to as Alice and Bob) and consists of the following three\nstages (see Fig. 1):\n    1.  (Key generation) Alice generates a (private) decapsulation key and a (public) encap-\n        sulation key.\n    2.  (Encapsulation) Bob uses Aliceâ€™s encapsulation key to generate a shared secret key\n        and an associated ciphertext. The ciphertext is sent to Alice.\n    3.  (Decapsulation) Alice uses the ciphertext and her decapsulation key to compute an-\n        other copy of the shared secret key.\n\nSecurity of KEMs. When a KEM is used as in Fig. 1, the result should be a shared secret\nkey that is random, unknown to adversaries, and identical for Alice and Bob with high\nprobability. Ensuring that security holds in practice is a complex task that relies on three\nconditions:\n    1.  Theoretical security: Selecting a KEM that is well-defined, correct, and satisfies an\n        application-appropriate mathematical notion of security (see Sec. 2.2 and 2.3)\n    2.  Implementation security: Implementing the selected KEM in a real-world algorithm\n        (e.g., a collection of routines) in a secure manner (see Sec. 3)\n    3.  Deployment security: Deploying the implemented KEM in a manner that is secure\n        for the relevant application and using the shared secret key in a secure manner (see\n        Sec. 4.2)\nEach of these three conditions is essential for security. For example, a KEM that is theo-\nretically secure (i.e., satisfies condition 1) but is implemented without side-channel coun-\n\n                                            4"}
{"doc_id": "NIST.SP.800-227", "source_path": "data/raw_pdfs/NIST.SP.800-227.pdf", "page_number": 13, "text": "NIST SP 800-227\nSeptember 2025    Recommendations for KEMs\n\nAlice  Bob\n\nKey Generation\n\ndecapsulation key    encapsulation key\n\nDecapsulation  ciphertext    Encapsulation\n\nshared secret key                   shared secret key\n  (Aliceâ€™s copy)                    (Bobâ€™s copy)\n\n                     Fig. 1. Outline of key establishment using a KEM\n\ntermeasures (i.e., does not satisfy condition 2) or is deployed on a device with physical\nvulnerabilities (i.e., does not satisfy condition 3) is likely to be insecure in practice.\n\nHistory and development. KEMs were first introduced by Cramer and Shoup [11, 12] as a\nbuilding block for constructing highly efficient public-key encryption (PKE) schemes. Their\napproach combines a KEM with a data encryption mechanism (DEM), which is simply a\nsymmetric-key encryption scheme. The KEM is used to generate a shared secret key, while\nthe DEM is used to encrypt an arbitrarily long stream of messages under that key. This is\ncommonly referred to as the KEM/DEM paradigm (see the HPKE example in Sec. 5.2.1).\nThis approach to constructing highly efficient public-key encryption has been the subject\nof several standards   [1, 2, 11, 13â€“16]. Most recently, KEMs have attracted significant at-\ntention due to most of the post-quantum key-establishment candidates in the NIST PQC\nstandardization process being KEMs.          This ongoing process has produced one KEM stan-\ndard so far â€” ML-KEM in FIPS 203 [3] â€” with more KEM standards likely to follow.\n\n2.2.  Basic Definitions and Examples\nThis section establishes the basic definitions and properties of KEMs. Note that probabilis-\ntic algorithms require randomness, while deterministic algorithms do not.\nDefinition 1. A KEM denoted by Î  consists of the following four components:\n1.    Î .ParamSets (parameters): A collection of parameter sets\n\n                                    5"}
{"doc_id": "NIST.SP.800-227", "source_path": "data/raw_pdfs/NIST.SP.800-227.pdf", "page_number": 14, "text": "NIST SP 800-227\nSeptember 2025    Recommendations for KEMs\n\n 2.  Î .KeyGen (key-generation algorithm): An efficient probabilistic algorithm that ac-\n     cepts a parameter set p âˆˆ Î .ParamSets as input and produces an encapsulation key\n     ek and a decapsulation key dk as output\n 3.  Î .Encaps (encapsulation algorithm):        An efficient probabilistic algorithm that ac-\n     cepts a parameter set p âˆˆ Î .ParamSets and an encapsulation key ek as input and\n     produces a shared secret key K and a ciphertext c as output\n 4.  Î .Decaps (decapsulation algorithm):        An efficient deterministic algorithm that ac-\n     cepts a parameter set p âˆˆ Î .ParamSets, a decapsulation key dk, and a ciphertext c\n     as input and produces a shared secret key Kâ€² as output\nAs this section views KEMs purely as mathematical objects, the labels p, ek, dk, c, K, and\nKâ€² in Definition 1 are viewed as abstract variables that represent, for example, numbers\nor bit strings. In implementations, these variables will be represented with concrete data\ntypes (see Sec. 3).\nIn general, Definition 1 only requires some very basic properties from the four components\nthat make up a KEM (see Example 1 below). In order to be useful and secure, a KEM should\nfulfill a number of additional properties. The first such property is correctness of the KEM\nalgorithm. Correctness ensures that, in an ideal setting, the process in Fig. 1 almost always\nproduces the same shared secret key value for both parties.\nDefinition 2. The key-encapsulation correctness experiment for a KEM Î  and parameter\nset p âˆˆ Î .ParamSets consists of the following three steps:\n              1. (ek, dk) â† Î .KeyGen(p)            (perform key generation)      (1)\n              2. (K, c) â† Î .Encaps(p, ek)          (perform encapsulation)       (2)\n              3. Kâ€² â† Î .Decaps(p, dk, c)           (perform decapsulation)       (3)\nThe KEM Î  is correct if, for all p âˆˆ Î .ParamSets, the correctness experiment for p results\nin K = Kâ€² with all but negligible probability.\nRecall that Î .KeyGen and Î .Encaps are probabilistic algorithms. When they are invoked as\nabove (i.e., Î .KeyGen with only a parameter set as input, and Î .Encaps with only a param-\neter set and encapsulation key as input), it is implied that their randomness is generated\ninternally and uniformly at random.       If one wishes to explicitly refer to the randomness\nused by these algorithms, then the following expressions can be used:\n           Key generation (using randomness r):    (ek, dk) â† Î .KeyGen(p; r)     (4)\n            Encapsulation (using randomness s):    (K, c) â† Î .Encaps(p, ek; s)   (5)\nThese expressions can, for example, refer to the process of re-expanding a key pair (ek, dk)\nby running KeyGen using a stored seed r.\nThe following two simple but instructive examples show abstract KEMs that satisfy Defini-\ntion 1 and Definition 2.\n\n                                              6"}
{"doc_id": "NIST.SP.800-227", "source_path": "data/raw_pdfs/NIST.SP.800-227.pdf", "page_number": 15, "text": "NIST SP 800-227\nSeptember 2025    Recommendations for KEMs\n\nExample 1: Simple but insecure. As the following example shows, a correct and efficient\nKEM can still be completely insecure. Define a KEM DONOTUSE as follows:\n  â€¢ DONOTUSE.ParamSets: Contains a single, empty parameter set\n  â€¢ DONOTUSE.KeyGen: On randomness r, outputs dk := r and ek := r\n  â€¢ DONOTUSE.Encaps: On input ek and randomness s, outputs K := s and c := s\n  â€¢ DONOTUSE.Decaps: On input dk and c, outputs Kâ€² := c\nWhile DONOTUSE is obviously a correct KEM since Kâ€² always equals K, it is also completely\ninsecure since the shared secret key K is transmitted in plaintext. This shows that a KEM\nneeds to satisfy additional properties in order to be secure (see Sec. 2.3).\n\nExample 2: Key transport using PKE. The following is a simple construction of a KEM from\nany PKE scheme. A PKE scheme consists of a collection PKE.ParamSets of parameter sets\nand three algorithms: key generation PKE.KeyGen (that accepts a parameter set), encryp-\ntion PKE.Encrypt (that accepts a parameter set, an encryption key, and a plaintext), and\ndecryption PKE.Decrypt (that accepts a parameter set, a decryption key, and a ciphertext).\nOne can construct a KEM KEMFROMPKE from the PKE scheme as follows:\n  â€¢ KEMFROMPKE.ParamSets = PKE.ParamSets\n  â€¢ KEMFROMPKE.KeyGen = PKE.KeyGen\n  â€¢ KEMFROMPKE.Encaps: On input p, ek and randomness s, output key K := s and\n     ciphertext c â† PKE.Encrypt(p, ek, s).\n  â€¢ KEMFROMPKE.Decaps: On input p, dk, and c, output key Kâ€² := PKE.Decrypt(p, dk, c).\nThe efficiency, correctness, and security properties of KEMFROMPKE depend on the respec-\ntive properties of PKE.\n\nKEM examples. Section 5.1 briefly discusses three additional examples of KEMs:\n 1.  ECDH-KEM is a quantum-insecure KEM based on ECDH key exchange (see Sec. 5.1.1).\n 2.  RSASVE-KEM is a quantum-insecure example of RSA key transport (see Sec. 5.1.2).\n 3.  ML-KEM is a lattice-based, NIST-approved post-quantum KEM (see Sec. 5.1.3).\nECDH-KEM and RSASVE-KEM are based on NIST-standardized key-establishment schemes\nthat can easily be viewed as KEMs. ML-KEM is the first key-establishment scheme to be\nstandardized by NIST directly as a KEM.\n\nA remark on key transport and key agreement. There are various ways to categorize two-\nparty key-establishment schemes. One particular categorization distinguishes between key\nagreement and key transport. In key agreement (e.g., a Diffie-Hellman key exchange), both\nparties contribute information that influences the final shared secret key so that neither\n\n                                          7"}
{"doc_id": "NIST.SP.800-227", "source_path": "data/raw_pdfs/NIST.SP.800-227.pdf", "page_number": 16, "text": "NIST SP 800-227\nSeptember 2025    Recommendations for KEMs\n\nparty can predetermine it. In key transport (e.g., RSA-OAEP [2]), one party selects the key\nand then transmits it (in some form) to the other party.\nDepending on the internal structure of the encapsulation function, a KEM could be viewed\nas either a key-agreement scheme or a key-transport scheme. For example, the shared\nsecret key in ML-KEM [3] is a function of both the randomness provided by Bob and the\n(randomly generated) encapsulation key of Alice. Therefore, ML-KEM could be viewed as a\nkey-agreement scheme. However, as the example KEMFROMPKE shows, the encapsulation\noperation in a KEM might simply consist of Bob generating the shared secret key and then\nencrypting it, which is key transport.\nAn application can achieve a particular type of key establishment (i.e.,  key agreement\nor key transport) using any KEM by taking appropriate additional steps using standard\nsymmetric-key cryptography techniques. That is, given a KEM Î , Alice and Bob can achieve\nkey agreement by both executing Î .KeyGen, sending the encapsulation keys to each other,\nand completing the steps of key establishment using a KEM. This will result in two sepa-\nrate shared secret keys that can be combined using an appropriate key-derivation method.\nConversely, Î  can be used to achieve key transport by following the steps in Fig. 7 and re-\nplacing m with the shared secret key produced by Î .\n\n2.3.  Theoretical Security of KEMs\nThis section discusses the theoretical security of KEMs. Section 3 discusses KEM imple-\nmentation security, and Sec. 4.2 discusses the secure deployment of KEMs.\n\nSemantic security. Informally speaking, a secure key-establishment procedure produces a\nshared secret key K that is uniformly random and unknown to adversaries. This property\nshould hold despite the fact that adversaries can freely observe the messages transmitted\nby Alice and Bob. In the case of KEMs, the encapsulation key ek and ciphertext c should\nreveal no information about the resulting shared secret key K or the decapsulation key dk.\nMoreover, even adversaries who somehow learn some partial information (e.g., if the first\nhalf of K is accidentally leaked) should not be able to combine that information with ek and\nc to learn more (e.g., the last bit of K). This informal notion of security can be rigorously\nformalized, and the resulting definition is called semantic security [17].\n\nPassive adversaries and IND-CPA. The formal way to define semantic security for KEMs\ninvolves an imaginary â€œciphertext indistinguishabilityâ€ experiment (see Fig. 2). In this ex-\nperiment, an adversary is given an encapsulation key ek, a ciphertext c, and either the true\nshared secret key underlying c or a freshly generated random string. The adversaryâ€™s goal\nis to distinguish between these scenarios, and they are free to use ek to generate their\nown encapsulations to help them in this task. This experiment is called â€œindistinguishable\nunder chosen-plaintext attackâ€ (IND-CPA) [17].\n\n8"}
{"doc_id": "NIST.SP.800-227", "source_path": "data/raw_pdfs/NIST.SP.800-227.pdf", "page_number": 17, "text": "  NIST SP 800-227\n  September 2025    Recommendations for KEMs\n\nChallenger:  Adversary:\n(ek, dk) â† Î .KeyGen( p)\n(K0, c) â† Î .Encaps( p, ek)\nK1 â† {0, 1}|Kâ°|\nb â† {0, 1}\nâˆ’ ek, c, Kb\nâˆ’\nâˆ’\nâˆ’\nâˆ’\nâˆ’\nâˆ’\nâˆ’\nâˆ’â†’\nâ†âˆ’  bâ€²\nâˆ’\nâˆ’\nâˆ’\nâˆ’\nâˆ’\nâˆ’\nâˆ’\nâˆ’\noutput WIN iff b = bâ€².\n\nFig. 2. The IND-CPA security experiment for a KEM Î \n\n  Definition 3 (IND-CPA, informal). A KEM Î  has indistinguishable ciphertexts (or is IND-CPA)\n  if, for every computationally bounded adversary A, the difference between the probability\n  that A wins the experiment IND-CPA[Î ] and 1/2 is negligible.\n  In the IND-CPA experiment, the adversary is free to study the encapsulation key ek and\n  the ciphertext c in order to identify whether Kb is the true key. However, the adversary is\n  not capable of actively interfering with the challengerâ€™s use of the decapsulation key. As a\n  result, IND-CPA only captures security against passive adversaries (i.e., eavesdroppers).\n\n  Challenger:                           Adversary:\n   (ek, dk) â† Î .KeyGen( p)\n   (K0, c) â† Î .Encaps( p, ek)\n   K1 â† {0, 1}|Kâ°|\n   b â† {0, 1}\n                             âˆ’ ek, c, Kb\n                             âˆ’\n                               âˆ’\n                               âˆ’\n                                âˆ’\n                                 âˆ’\n                                 âˆ’\n                                   âˆ’\n                                        âˆ’â†’\n                                                              Î .Decaps(dk, ?)\n\n                             â†âˆ’  bâ€²\n                               âˆ’\n                                âˆ’\n                                âˆ’\n                                 âˆ’\n                                   âˆ’\n                                   âˆ’\n                                        âˆ’\n                                        âˆ’\n   output WIN iff b = bâ€².\n\n                                 Fig. 3. The IND-CCA security experiment for a KEM Î \n\n  Active adversaries and IND-CCA. Real-world experience indicates that adversaries can\n  sometimes actively interfere with key-establishment processes and use this ability to un-\n  cover the shared secret key. For example, an active adversary may be able to convince an\n\n                                                          9"}
{"doc_id": "NIST.SP.800-227", "source_path": "data/raw_pdfs/NIST.SP.800-227.pdf", "page_number": 18, "text": "NIST SP 800-227\nSeptember 2025    Recommendations for KEMs\n\nhonest user to decapsulate some ciphertexts of the adversaryâ€™s choosing. In such a sce-\nnario, it is natural to ask whether other ciphertexts are still protected. In this setting, IND-\nCPA security is insufficient. Instead, one must consider security against so-called chosen-\nciphertext attacks (CCA)3 [17].\nThe IND-CCA[Î ] experiment for a KEM Î  is described in Fig. 3. It is similar to the IND-CPA\nexperiment, except that the adversary is now also granted â€œblack-box oracle accessâ€ to the\ndecapsulation function c â†’ Î .Decaps(p, dk, c). This means that the adversary is allowed\nto submit ciphertexts câˆ— that they generate and get the response Kâˆ— â† Î .Decaps(p, dk, câˆ—).\nThe only restriction is that they cannot submit the actual ciphertext c produced by the chal-\nlenger since that would make the game trivial to win for any KEM.\nDefinition 4 (IND-CCA, informal). A KEM Î  is IND-CCA if, for every computationally bounded\nadversary A, the difference between the probability that A wins the experiment IND-CCA[Î ]\nand 1/2 is negligible.\nML-KEM, the first post-quantum KEM standardized by NIST, is believed to satisfy IND-CCA\nsecurity [3].\n\n3IND-CCA as used here is typically referred to as IND-CCA2 in cryptographic literature.\n\n10"}
{"doc_id": "NIST.SP.800-227", "source_path": "data/raw_pdfs/NIST.SP.800-227.pdf", "page_number": 19, "text": "NIST SP 800-227\nSeptember 2025    Recommendations for KEMs\n\n3.    Requirements for Secure KEM Implementations\n\nAs discussed in Sec. 2.1, a KEM (as a mathematical object) should satisfy both correctness\n(Definition 2) and an appropriate notion of security (Definition 3 or Definition 4). In order\nfor such a KEM to be used in real-world applications, it needs to be implemented in actual\ncode as part of a cryptographic module. The quality of the resulting implementation has a\ndramatic impact on usability and security in real-world applications.\nThe following subsections detail requirements for cryptographic modules that implement\napproved KEMs. However, adherence to these requirements does not guarantee that a\ngiven implementation will be secure. For a discussion of requirements for applications\nthat make use of a KEM cryptographic module, see Sec. 4.2.\n\n3.1.  Compliance With NIST Standards and Validation\nConforming implementations of approved KEMs are required to comply with the require-\nments outlined in this section as well as all other applicable NIST standards. In addition,\nsuch implementations are required to use only approved cryptographic elements and pass\nFIPS-140 validation.\n\nImplementing according to NIST standards. Implementations shall comply with a specific\nNIST FIPS or SP that specifies the algorithms of the relevant KEM. For example, a conform-\ning implementation of ML-KEM shall comply with FIPS 203 [3]. Each FIPS or SP that speci-\nfies a KEM will have special requirements for the particular scheme in question, including\nspecifications for all algorithms and parameter sets of the relevant KEM. In particular, con-\ncrete data types will be specified for the parameter sets, keys, ciphertexts, and shared\nsecret keys (Definition 1) of the relevant KEM. Assurance of parameter validity is obtained\nby checking the lists of approved parameters in the appropriate publication.\nThe requirements in any FIPS or SP that standardizes a particular KEM are in addition to\nthe general requirements described in this section. Any implementations shall follow the\nguidelines given in FIPS 140-3 [5] and associated implementation guidance.\n\nApproved cryptographic elements. KEMs commonly make use of other cryptographic el-\nements, such as RBGs and hash functions (see Appendix D). Typically, the security of a\nsystem consisting of multiple cryptographic elements is at best as secure as the weakest\nelement.           When not already specified by the KEM parameter set, KEM implementations\nshall use approved cryptographic elements with security strengths that meet or exeed the\nrequired strength for each KEM parameter set. The security strength of the selected pa-\nrameter set should be at least the desired security strength of the application. In addition,\nrandom bits shall be generated using approved techniques, as described in the latest re-\nvisions of SP 800-90A, SP 800-90B, and SP 800-90C [6â€“8].        For using randomness in key\ngeneration, see SP 800-133 [18].\n\n11"}
{"doc_id": "NIST.SP.800-227", "source_path": "data/raw_pdfs/NIST.SP.800-227.pdf", "page_number": 20, "text": "NIST SP 800-227\nSeptember 2025    Recommendations for KEMs\n\nTesting and validation. Mistakes in implementations can easily lead to security vulner-\nabilities or a loss of usability. Therefore, it is crucial that implementations are validated\nfor conformance to NIST cryptographic standards and FIPS 140 by the Cryptographic Al-\ngorithm Validation Program (CAVP) and CMVP. Validation testing checks whether a given\nimplementation correctly computes the desired output for only a small number of (often\nrandomly sampled) inputs. This means that validation testing does not guarantee correct\nfunctioning on all inputs, which is often impossible to ensure. Nonetheless, implementa-\ntions must correctly implement the mathematical functionality of the target KEM. As vali-\ndation only tests input-output behavior, implementations need not follow the exact step-\nby-step algorithmic specifications in the NIST standard that specifies the relevant KEM. Any\nimplementation that produces the correct output for every input will pass validation.\nRequiring equivalence only at the level of input-output functionality (e.g., rather than in\nterms of step-by-step behavior) is desirable, as different implementations can then be op-\ntimized for different goals. For example, some implementations will focus on maximizing\nefficiency, while other implementations will employ numerous side-channel and leakage\nprotection techniques.\n\n3.2.  Managing Cryptographic Data\nKEM implementations need to manage all cryptographic data appropriately, including data\nused during the execution of KEM algorithms (i.e., intermediate values) and data at rest\n(e.g., decapsulation key).     As a cryptographic module has no control over data that exists\noutside of the module (e.g., while in transit from one module to another), such data is\nnot discussed here. However, a cryptographic module can exert control over what data it\noutputs to the outside world (e.g., by ensuring correct implementations of all functions). It\ncan also exert control over what data it accepts from the outside world (e.g., by performing\nappropriate input-checking and importing).\nIn general, cryptographic data needs to be destroyed as soon as it is no longer needed.\nSome examples include destroying intermediate computation values at the end of an algo-\nrithm, destroying the randomness generated by RBGs after encapsulation, and destroying\nkeys after all relevant communication sessions are completed.\n\nInput checking. The correct and secure operation of cryptographic operations depends\ncrucially on the validity of the provided inputs. Even relatively benign faults, such as ac-\ncepting an input that is too long or too short, can have serious security consequences.\nKEM implementations need to perform input checking in an appropriate manner for all\nKEM algorithms (i.e., KeyGen, Encaps, and Decaps). The exact form of the required input\nchecking is described in the FIPS or SP that specifies the relevant KEM.\nSometimes, an input will not need to be checked. Instead, the implementer can acquire\nassurance that the input was validly generated or has already been checked, as in the fol-\nlowing cases:\n\n                                          12"}
{"doc_id": "NIST.SP.800-227", "source_path": "data/raw_pdfs/NIST.SP.800-227.pdf", "page_number": 21, "text": "NIST SP 800-227\nSeptember 2025    Recommendations for KEMs\n\n 1.  If the cryptographic module generated an input internally using an algorithm that\n     ensures validity and stored that input in a manner that prevents modification, then\n     the module is not required to check that input. For example, if the module gener-\n     ated a decapsulation key dk via KeyGen and then stored dk in a manner that prevents\n     modification, then the module can later invoke Decaps directly on dk without per-\n     forming any input checking.\n 2.  If the cryptographic module checks an input once and stores that input in a man-\n     ner that prevents modification, then the module is not required to check that input\n     again. For example, if the module performed input-checking on a given encapsula-\n     tion key ek and stored it in a manner that prevents modification, then the module\n     may invoke Encaps directly on ek (even repeatedly) without performing any further\n     input checking.\n 3.  If the cryptographic module imports the relevant input from a trusted third party\n     (TTP), and the TTP can provide assurance that the input does not need input-checking,\n     and the module stores that input in a manner that prevents modification, then the\n     module is not required to check the input.\n\nIntermediate values. All intermediate values used in any given KEM algorithm (i.e., KeyGen,\nEncaps, Decaps) shall be destroyed before the algorithm terminates. However, there are\ntwo exceptions to this rule:\n 1.  A random seed used for key generation may be stored as private data for the purpose\n     of recomputing the same key pair at a later time.\n 2.  Data that can be easily computed from public information (e.g., from the encapsu-\n     lation key) may be stored as public data to improve efficiency.\nWhen values are stored under either of these exceptions, the storage needs to be per-\nformed according to the rules for data at rest.\nThe outputs of a KEM algorithm are not considered to be intermediate values and will thus\nnot be immediately destroyed in typical situations. The format in which outputs and inputs\nare stored depends on the implementation (see the discussion of data formats below.)\n\nData at rest. A cryptographic module that implements a KEM needs to maintain certain\ndata at rest. This can include both private data (e.g., seeds, decapsulation keys) and public\ndata (e.g., encapsulation keys). In general, private data needs to be stored within the cryp-\ntographic module in a manner that is secure against both leakage and unauthorized mod-\nification. Private data needs to be destroyed as soon as it is no longer needed. The import\nand export of private data (e.g., seeds, decapsulation keys, shared secret keys) needs to\nbe performed in a secure manner. In general, public data stored within the cryptographic\nmodule needs to be stored in a manner that is secure against unauthorized modification\n[5, 19].\n\n13"}
{"doc_id": "NIST.SP.800-227", "source_path": "data/raw_pdfs/NIST.SP.800-227.pdf", "page_number": 22, "text": "NIST SP 800-227\nSeptember 2025    Recommendations for KEMs\n\nData formats, import, and export. FIPS validation tests input and output the behavior of\nrelevant KEM algorithms using a specific data format. Typically, this format is byte arrays\nthat contain the inputs and outputs described in the FIPS or SP that specifies the relevant\nKEM. This format is required for testing but is not a requirement for internal storage, data\nimport, or data export. A given cryptographic module may choose to store, import, or\nexport data (whether sensitive or not) using other formats. The desired format can vary\nsignificantly depending on the application. For example, some applications might call for\nstoring keys using only a short seed, while other applications might call for storing keys in\nan expanded format that allows for faster computations. In any case, the storage, import,\nand export of sensitive data needs to be performed securely, regardless of the chosen data\nformat.\n\n3.3.  Additional Requirements\nThe following are additional requirements for cryptographic modules that implement ap-\nproved KEMs.\n\nFailures and aborts. Any of the KEM algorithms (i.e., KeyGen, Encaps, Decaps) and their\ncryptographic elements (e.g., DRBGs, hash functions) can potentially fail or abort. This\ncould be a result of normal KEM operations (e.g., decapsulating a ciphertext that was cor-\nrupted by the environment during transmission), a hardware or software failure (e.g., a\nfailed DRBG execution due to a memory fault), or an adversarial attack.          Implementers\nneed to take precautions to ensure that the cryptographic module handles failures and\naborts appropriately. In particular, leaking information about failures and aborts outside\nof the perimeter of the cryptographic module should be avoided.\n\nSide-channel protection.           Cryptographic modules for KEMs should be designed with ap-\npropriate countermeasures against side-channel attacks. This includes protecting against\ntiming attacks with constant-time implementations and protecting memory from leakage.\nUniversal guidelines are unlikely to be helpful as exposure to side-channel attacks varies\nsignificantly with the desired application, and countermeasures are often costly.\n\n14"}
{"doc_id": "NIST.SP.800-227", "source_path": "data/raw_pdfs/NIST.SP.800-227.pdf", "page_number": 23, "text": "NIST SP 800-227\nSeptember 2025    Recommendations for KEMs\n\n4.    Using KEMs Securely in Applications\n\nThis section describes how to deploy a KEM in real-world applications in a manner that is\nuseful and secure, assuming that the KEM under discussion satisfies an appropriate notion\nof theoretical security (see Sec. 2.3) and has been securely implemented in a cryptographic\nmodule (see Sec. 3).\n\n4.1.    How to Establish a Key With a KEM\nThis section describes how a KEM can be used to establish a shared secret key between\ntwo parties. The description will go into greater detail than the brief outline in Sec. 2.1.\nHowever, since KEMs are highly flexible and can be used in a wide range of applications\nand contexts, no single description can account for all variations. Section 5 provides more\ndetailed examples of special cases of key establishment using a KEM.\nFor simplicity of exposition, the two parties in the key establishment process will be re-\nferred to as Alice and Bob. It is assumed that Alice and Bob are communicating over a\nsingle bidirectional channel and will only use that channel to transmit data to each other.\nThe key-establishment process using a KEM Î  proceeds as follows:\n    1.  Preparation. Before key establishment can begin, a parameter set p âˆˆ Î .ParamSets\n        needs to be selected. Depending on the application, p may be selected by Alice, by\n        Bob, or through an interactive negotiation between Alice and Bob. The choice of the\n        KEM Î  itself could also be made at this stage.\n    2.  Key generation. Alice begins by running the key-generation algorithm in her crypto-\n        graphic module:\n         (ekA, dkA) â† Î .KeyGen(p).                                  (6)\n        During the execution of KeyGen, Aliceâ€™s module internally generates private random-\n        ness using an appropriate RBG. Alice then transmits ekA to Bob and keeps dkA pri-\n        vate.\n    3.  Encapsulation. Bob receives ekA from Alice and uses it to execute the encapsulation\n        algorithm in his cryptographic module:\n        (KB, cB) â† Î .Encaps(p, ekA).                                (7)\n        During the execution of Encaps, Bobâ€™s module internally generates private random-\n        ness using an appropriate RBG. Bob then transmits cB to Alice and keeps KB private.\n    4.  Decapsulation. Alice receives cB from Bob and runs the decapsulation algorithm in\n        her module using her decapsulation key and Bobâ€™s ciphertext:\n          KA â† Î .Decaps(dkA, cB).                                   (8)\n        Alice keeps KA private.\n\n                                         15"}
{"doc_id": "NIST.SP.800-227", "source_path": "data/raw_pdfs/NIST.SP.800-227.pdf", "page_number": 24, "text": "NIST SP 800-227\nSeptember 2025    Recommendations for KEMs\n\n5.  Using the shared secret key. If the appropriate conditions are satisfied (see Sec. 4.2),\n    then KA will equal KB and can be used by Alice and Bob for any symmetric-key cryp-\n    tographic protocol. A typical choice is to use KA = KB as the key for an authenticated\n    encryption scheme (e.g., AES-GCM [9]), thereby establishing a communication chan-\n    nel between Alice and Bob that satisfies both confidentiality and integrity.\nFigure 4 depicts the high-level stages of this process. Note that some desirable security\nproperties might not be achieved by a protocol of this form and may require additional\nsteps and ingredients.\n\n           Alice:                                       Bob:\n     1.                          â†âˆ’ Î , p\n                                      âˆ’\n                                      âˆ’\n                                       âˆ’\n                                        âˆ’\n                                        âˆ’\n                                         âˆ’â†’\n     2. (ekA, dkA) â† Î .KeyGen( p)\n                                 âˆ’    ekA\n                                 âˆ’\n                                      âˆ’\n                                      âˆ’\n                                       âˆ’\n                                       âˆ’\n                                        âˆ’\n                                        âˆ’\n                                         âˆ’â†’\n     3.                                                 (KB, cB) â† Î .Encaps(ekA)\n                                 â†âˆ’ cá´®\n                                      âˆ’\n                                       âˆ’\n                                       âˆ’\n                                        âˆ’\n                                        âˆ’\n                                         âˆ’\n                                         âˆ’\n     4. KA â† Î .Decaps(dkA, cB)\n\n     5. output: KA                                      output: KB\n\n                      Fig. 4. Simple key establishment using a KEM\n\nAdditional considerations. Steps 1-5 in the key-establishment process might need to be\nmodified, depending on the security and functionality needs of the application.    Some\ncommon modifications are as follows.\nStatic versus ephemeral key pairs. Consider an application in which Alice independently\ndecides on a parameter set, performs key generation, and publishes the resulting encap-\nsulation key ekA. Alice might then accept many connections from multiple parties over\na long period of time, each initiated via ekA. Each such connection would follow stages\n3-5 described above. While the other party in each connection would always encapsulate\nwith ekA, each ciphertext is generated with new randomness and only applicable to the\nconnection between Alice and that party. In this scenario, Aliceâ€™s encapsulation key is said\nto be static.\nIn other applications, Alice might want to use a particular key pair to establish only a single\nconnection (e.g., as part of a protocol that ensures forward secrecy). In that case, she will\nperform key generation, send her encapsulation key ekA to Bob, and discard ekA once the\nconnection with Bob is established. In this scenario, Aliceâ€™s encapsulation key is said to be\nephemeral.\n\n                                    16"}
{"doc_id": "NIST.SP.800-227", "source_path": "data/raw_pdfs/NIST.SP.800-227.pdf", "page_number": 25, "text": "NIST SP 800-227\nSeptember 2025    Recommendations for KEMs\n\nAuthentication. In most applications, some form of authentication and cryptographic in-\ntegrity checking is required (e.g., to prevent â€œmachine-in-the-middleâ€ attacks).     Assuring\nthis is     highly application-dependent and typically requires additional cryptographic ele-\nments, such as digital signatures and certificates. Section 5.2.4 and Sec. 5.2.3 provide some\nillustrative examples.\nUsing the shared secret key. In some applications, Alice and Bob will use KA and KB directly\nas symmetric keys as soon as the decapsulation and encapsulation stages are successfully\ncompleted, respectively.     If KA = KB, a failure in the desired symmetric-key functionality\nwill likely follow. For other applications, Alice and Bob might need to first post-process KA\nand KB appropriately and then use the results of that post-processing step â€” if successful\nâ€” as their symmetric keys.       This post-processing might include key derivation steps that\nsecurely produce multiple symmetric keys from the initial shared secret key (see Sec. 4.3).\nIt might also include key confirmation steps to confirm that KA = KB and reject them oth-\nerwise (see Sec. 4.4). In some cases, key confirmation might also involve performing ad-\nditional computations during the encapsulation and decapsulation stages to reduce the\nnumber of communication rounds.\n\n4.2.    Conditions for Using KEMs Securely\nThis section discusses general requirements for securely using approved KEMs in applica-\ntions. As discussed in point 1 below, the first step involves selecting an approved KEM that\nhas been implemented in a validated cryptographic module (see Section 3).   Deploying\nsuch a cryptographic module in applications entails a number of additional requirements\nthat are outlined below. Adherence to these requirements does not guarantee that the\nrelevant KEM application will be secure.      The overall requirements fall into four general\ncategories: KEM algorithm security, device security, channel security, and key usage secu-\nrity.\n1.      KEM algorithm security: The selected KEM Î  is approved, appropriate for the ap-\n        plication, and implemented and deployed in a secure manner.\n        Being an approved KEM, Î  will satisfy correctness (Definition 2) and either IND-CPA\n        or IND-CCA security (see Section 2.3).         Whenever possible, IND-CCA-secure KEMs\n        should be used. For some specific applications (e.g., ephemeral key establishment),\n        IND-CPA security might be sufficient.\n        Cryptographic module implementation.   The implementations of Î  used by Alice\n        and Bob need to satisfy the requirements in Sec. 3. Whether a given implemen-\n        tation is sufficiently secure is an application-dependent question.   For example, an\n        implementation might be secure enough for use on a web server in a physically se-\n        cure location but have insufficient side-channel protections for use on an embedded\n        device.\n\n17"}
{"doc_id": "NIST.SP.800-227", "source_path": "data/raw_pdfs/NIST.SP.800-227.pdf", "page_number": 26, "text": "NIST SP 800-227\nSeptember 2025    Recommendations for KEMs\n\n    Parameter set selection. A parameter set of Î  with application-appropriate security\n    strength must be selected.\n    KEM key-pair usage. If an application uses an ephemeral key pair, the key pair shall\n    be used for only one execution of key-establishment via a KEM and shall be de-\n    stroyed as soon as possible after its use.\n    If an encapsulating party obtains the static encapsulation key of another party, it\n    must have assurance of the other partyâ€™s ownership of the key before or during the\n    execution of key-establishment. This assurance can be obtained from a trusted party\n    (e.g., a certificate authority) or a combination of proof of possession (see Sec. 4.5)\n    and verification of real-world identity.\n2.  Device security: The devices used to execute KEM algorithms and store any sensitive\n    data (e.g., decapsulation keys) must be appropriately secured.\n    Physical protection. Devices need to be appropriately protected against attacks (see\n    [19, Section 5]). This includes protection against leakage, physical intrusion, remote\n    access, and corruption.\n    Secure storage.   Devices need to provide appropriate secure storage for sensitive\n    data (e.g., KEM keys, seeds, shared secret keys, any derived keys) and destroy that\n    data when required by the cryptographic module (see Sec. 3.2). For further guide-\n    lines on key storage considerations, see SP 800-57pt1 [19] and SP 800-152 [10, Sec-\n    tion 2.2].\n3.  Channel security: The key-establishment process that takes place over the channel\n    used by Alice and Bob must satisfy an application-appropriate notion of integrity.\n    Preestablished versus simultaneous. Ensuring the integrity of the key-establishment\n    process could be achieved by first ensuring the integrity of the channel and then\n    performing key establishment. More commonly, integrity is assured simultaneously\n    with key establishment by augmenting the key-establishment process with addi-\n    tional steps and checks (see, e.g., Section 5.2.3).\n    Unilateral versus bilateral authentication. For some applications, only one of the\n    parties is assured of the otherâ€™s identity and the integrity of their messages. This is\n    commonly called a unilaterally authenticated key exchange (see Sec. 5.2.3). In other\n    applications, both Alice and Bob require assurances of the other partyâ€™s identity and\n    the integrity of their messages. This is commonly called a bilaterally authenticated\n    key exchange.\n    Secure authentication algorithms. For all applications, the cryptographic algorithms\n    (e.g., digital signature algorithms) and other elements (e.g., certificates) required to\n    establish channel integrity need to be selected and deployed securely.\n\n18"}
{"doc_id": "NIST.SP.800-227", "source_path": "data/raw_pdfs/NIST.SP.800-227.pdf", "page_number": 27, "text": "NIST SP 800-227\nSeptember 2025    Recommendations for KEMs\n\n4.    Shared-secret-key usage security: The shared secret key produced by the KEM is\n      used appropriately and securely.\n      Shared-secret-key processing and management. Key-derivation and key-confirmation\n      steps are performed appropriately, as required by the application (see Sec. 4.3 and\n      4.4). Each shared secret key and any derived keys are destroyed as soon as they are\n      no longer needed (see Sec. 4.2).\n      Secure symmetric-key algorithms. The KEM shared secret key and any derived keys\n      should only be used with appropriately secure symmetric-key cryptographic algo-\n      rithms. In particular, the security of the symmetric-key algorithms used is appropri-\n      ate for the security provided by the KEM so that the combined algorithm (consisting\n      of key establishment followed by symmetric cryptography operations) fulfills the de-\n      sired security properties.\n\n4.3.  Post Processing of the Shared Secret Key\nCertain key-establishment schemes (e.g., Diffie-Hellman key exchange) can be viewed as\nfirst generating a shared secret and then performing a key-derivation step that transforms\nthe shared secret into one or more shared secret keys. In contrast, KEMs by definition\noutput a key K that is ready to use.\nKey derivation may be required for applications in which the amount of keying material\nneeded does not match the output size of the KEM algorithm (i.e., the length of shared\nsecret key K).\nAs specified in SP 800-108 [20], key derivation consists of applying a key-derivation method\n(KDM) to a key-derivation key. A KDM is an algorithm for transforming a given key-derivation\nkey (possibly with some other data) into keying material (e.g., a list of keys).\nIf additional keying material is needed, a KDM can be used to expand K. If keys with lengths\nless than K are needed, a KDM may be used, or the shared secret key K can be used directly\nas keying material by:\n â€¢ Truncating K or\n â€¢ Parsing K into non-overlapping segments to derive shorter keys.\nThe derived shorter key is considered a shared secret key if K was a shared secret key. The\nsecurity strength of any derived shorter key is the minimum of the security strength of K,\nthe length of the derived key, and the strength of any KDM used.\nWhen key derivation for a KEM Î  is needed, the shared secret key output by Î  (i.e., as\nan output of Î .Encaps or Î .Decaps) may be used as a key-derivation key supplied to an\napproved key-derivation method specified in SP 800-108 [20], SP 800-56C [21], or SP 800-\n133 [18]. If a KDM from SP 800-56C is used, the shared secret key of the KEM is used as\n\n19"}
{"doc_id": "NIST.SP.800-227", "source_path": "data/raw_pdfs/NIST.SP.800-227.pdf", "page_number": 28, "text": "NIST SP 800-227\nSeptember 2025    Recommendations for KEMs\n\nan input to the KDM in place of the shared secret. A key derivation step is included in the\nexample protocol in Sec. 5.2.3.\n\n4.4.  Key Confirmation\nKey confirmation (KC) refers to the actions taken to provide assurance to one party (i.e., the\nkey-confirmation recipient) that another party (i.e., the key-confirmation provider) pos-\nsesses matching keying material. In the case of KEMs, this confirmation is done for keying\nmaterial that was produced by encapsulation and/or decapsulation.\nKey confirmation should be used during KEM usage, as it may enhance the security prop-\nerties of the overall key-establishment process.        Confirming successful establishment of\nthe shared secret key can also address potential errors in transmission or decapsulation.\nKey confirmation can also act as a proof of possession (see Sec. 4.5).      While this section\nincludes a description of an explicit process, key confirmation can be accomplished in a va-\nriety of other ways. For example, successful use of the shared secret key for authenticated\nencryption can act as key confirmation.\nKey confirmation is typically achieved by exchanging a value that can only be calculated\ncorrectly with very high probability if the key establishment was successful. Some com-\nmon protocols perform key confirmation in a manner that is integrated into the steps of\nthe protocol. For example, bilateral key confirmation is provided during a TLS handshake\nprotocol by the generation and verification of a message authentication code (MAC) over\nall previous messages in the handshake using a symmetric MAC key that was established\nduring the handshake.\nIn some circumstances, it may be appropriate to perform key confirmation by including\ndedicated key-confirmation steps in a key-establishment scheme.           An acceptable method\nfor providing key confirmation during a key-establishment scheme involves the KC provider\ncalculating a MAC tag on MAC_Data and sending the MAC tag to the KC recipient for confir-\nmation of the providerâ€™s correct calculation of the shared secret key. Unilateral key confir-\nmation is provided when only one of the parties serves as the key-confirmation provider. If\nmutual key confirmation is desired (i.e., bilateral key confirmation), then the parties swap\nroles for the second KC process, and the new provider (i.e., the previous recipient) sends\na MAC value on a different data string (i.e., different MAC_Data) to the new recipient (i.e.,\nthe previous provider).\nThis recommendation makes no statement as to the adequacy of other methods.\n\nKey-confirmation key.          The key-confirmation steps specified in this recommendation can\nbe incorporated into any scheme using a KEM to establish a shared secret key. To perform\nkey confirmation, a dedicated KC key will be determined from the shared secret key pro-\nduced by the KEM. The KC provider will use the KC key with an approved MAC algorithm to\ncreate a MAC tag on certain data and provide the tag to the KC recipient. The KC recipient\n\n                                       20"}
{"doc_id": "NIST.SP.800-227", "source_path": "data/raw_pdfs/NIST.SP.800-227.pdf", "page_number": 29, "text": "NIST SP 800-227\nSeptember 2025    Recommendations for KEMs\n\nwill then obtain the KC key from their copy of the shared secret key produced by the KEM\nand use it to verify the MAC tag.\n\n4.4.1.  Creating the MAC Data\nDuring key confirmation, the KC provider creates a message with a MAC tag that is com-\nputed on MAC_Data that contains context-specific information.        The MAC_Data is for-\nmatted as follows:\n        MAC_Data = KC_Step_Label â€– IDP â€– IDR â€– EphP â€– EphR â€– ExtraP â€– ExtraR\n â€¢ KC_Step_Label is a six-byte character string that indicates that the MAC_Data is\n        used for key confirmation, whether the MAC_Data is used for the first or second\n        key-confirmation message, and the party serving as the KC provider, either the en-\n        capsulator (E) or decapsulator (D). The four valid options are â€KC_1_Eâ€, â€KC_2_Eâ€,\n        â€KC_1_Dâ€, or â€KC_2_Dâ€. As an example, â€KC_1_Dâ€ indicates that the decapsu-\n        lator (D) is the KC provider and sends the first KC message. â€KC_2_Eâ€ could then\n        be used by the encapsulator (E) to provide bilateral key confirmation.\n â€¢ IDP and IDR are the identifiers used to label the KC provider and recipient, respec-\n        tively.\n â€¢ EphP and EphR are ephemeral data provided by the KC provider and recipient, re-\n        spectively. The encapsulatorâ€™s ephemeral data is the ciphertext. The decapsulatorâ€™s\n        ephemeral data is the encapsulation key ek if ek is ephemeral. Otherwise, the de-\n        capsulatorâ€™s ephemeral data shall be a nonce with a bit length that is at least equal to\n        the targeted security strength of the KEM key-establishment process (see Appendix\n        C.2).\n        When a nonce is used during key confirmation, it needs to be provided to the en-\n        capsulator to construct MAC_Data for MAC tag generation or verification.\n â€¢ ExtraP and ExtraR are optional additional data provided by the KC provider and re-\n        cipient, respectively. This could include additional identifiers, values computed dur-\n        ing the key-establishment process but not transmitted, or any other information that\n        the party wants to include. This information can be known ahead of time by both\n        parties or transmitted during key confirmation.\nThe MAC algorithm and KC_Key used shall have security strengths equal to or greater\nthan the desired security strength of the application. See Appendix C.1 for permitted MAC\nalgorithms and further details.\n\n4.4.2.  Obtaining the Key-Confirmation Key\nIn order to create and validate the MAC tag for the created MAC_Data, the parties cre-\nate a dedicated key-confirmation key (KC_Key). This can be either a portion of the KEM\n\n                                    21"}
{"doc_id": "NIST.SP.800-227", "source_path": "data/raw_pdfs/NIST.SP.800-227.pdf", "page_number": 30, "text": "NIST SP 800-227\nSeptember 2025    Recommendations for KEMs\n\nshared secret key or part of the keying material derived from the KEM shared secret key\nwhen using a derivation function (see Sec. 4.3).   The KC_Key shall only be used for key\nconfirmation and destroyed after use. See Appendix C.1 for KC_Key lengths.\nWhen a derivation     function is used.  After      computing the   shared secret value\nand applying the      key-derivation method     to obtain the derived keying    material\nDerived_Keying_Material, the key-confirmation provider uses agreed-upon bit lengths to\nparse Derived_Keying_Material into two parts â€” the key-confirmation key (KC_Key) and\nthe keys to subsequently protect data (Data_Key):\n         Derived_Keying_Material = KC_Keyâ€–Data_Key.\nWhen a derivation function is NOT used. The key-confirmation provider parses the output\nof the encapsulation process (i.e., KEM_shared_secret_key) into KC_Key and Data_Key:\n          KEM_shared_secret_key = KC_Keyâ€–Data_Key.\n\n4.4.3.  Key-Confirmation Example\nThe key-confirmation process can be achieved in multiple ways. The following example\nshowcases unilateral key confirmation from the encapsulator to the decapsulator, which\ncan be used for a client (e.g., Alice) requesting confirmation of successful key establishment\nfrom a server (e.g., Bob). Figure 5 shows this process. Some desirable security properties\nmight not be achieved by a protocol of this form and may require additional steps and\ningredients.\n 1.     Alice (i.e., decapsulating party) generates a set of ephemeral keys (ek, dk) for KEM\n        Î  under the agreed parameter set p. Alice then sends ek, Aliceâ€™s identifying string\n        (IDA), and any extra data ExtraA to include in the key confirmation to Bob (i.e., en-\n        capsulating party).\n 2.     Bob performs encapsulation with the received ek to generate ciphertext c and ini-\n        tial key KB0. Bob then derives two keys from KB0: a key-confirmation key KBkc to\n        perform key confirmation and additional keying material KB1.\n 3.     Bob constructs MAC_Data using the following in order:\n         â€¢ The constant string â€KC_1_E,â€ which indicates that Bob (i.e., the encapsulator)\n         is providing key confirmation and that this is the first KC message\n         â€¢ IDB, which is Bobâ€™s identifier string\n         â€¢ IDA, which is Aliceâ€™s identifier string\n         â€¢ Ciphertext c, which serves as Bobâ€™s (i.e., the KC providerâ€™s) ephemeral value for\n         the key-confirmation process\n\n22"}
{"doc_id": "NIST.SP.800-227", "source_path": "data/raw_pdfs/NIST.SP.800-227.pdf", "page_number": 31, "text": "NIST SP 800-227\nSeptember 2025    Recommendations for KEMs\n\n      Alice (Decapsulator, Client):      Bob (Encapsulator, Server):\n1. (ek, dk) â† Î .KeyGen( p)\n                                       ek, IDA, ExtraA\n                                       âˆ’\n                                       âˆ’\n                                        âˆ’\n                                        âˆ’\n                                         âˆ’\n                                         âˆ’\n                                          âˆ’\n                                          âˆ’\n                                           âˆ’â†’\n2.                                                      (c, KB0) â† Î .Encaps( p, ek)\n                                                        KBkc||KB1 â† KDF(KB0)\n3.                                                      Construct MAC_Data\n                                                        t â† MAC(KBkc, MAC_Data)\n                                       c, t, IDB, ExtraB\n                                       â†âˆ’\n                                        âˆ’\n                                         âˆ’\n                                         âˆ’\n                                          âˆ’\n                                          âˆ’\n                                           âˆ’\n                                           âˆ’\n                                                      âˆ’\n4. KA0 â† Î .Decaps( p, dk, c)\n      KAkc||KA1 â† KDF(KA0)\n5. Construct MAC_Data\n      if MAC.Ver(KAkc, MAC_Data, t)\n      rejects, abort.\n6. result: KA1  (KAkc destroyed )                       result: KB1  (KBkc destroyed )\n\n                Fig. 5. Key-confirmation example with an ephemeral key pair\n\n       â€¢ Encapsulation key ek, which is Aliceâ€™s (i.e., the KC recipientâ€™s) ephemeral value\n       for the key-confirmation process\n       â€¢ ExtraB, which refers to any extra data that Bob (i.e., the KC provider) would like\n       to include\n       â€¢ ExtraA, which refers to the extra data provided by Alice (i.e., the KC recipient)\n      Bob calculates the tag t using KBkc on MAC_Data and sends the following to Alice:\n      1) ciphertext c, 2) the generated tag t, 3) and any extra data ExtraB that Bob included\n      in the MAC_Data.\n 4.   Alice performs decapsulation on the received ciphertext c using the previously gen-\n      erated decapsulation key dk to calculate initial key KA0. Alice then derives two keys\n      from KA0 similarly to Bob (in step 2): key-confirmation key KAkc and additional keying\n      material KA1.\n 5.   Alice constructs MAC_Data as Bob did in step 3 and verifies the received t for the\n      MAC_Data using key KAkc.         Alice aborts if the tag is rejected or continues if it is\n      verified.\n 6.   Alice now has additional assurance that KA1 matches KB1. Alice and Bob destroy the\n      key-confirmation keys KAkc and KBkc and can proceed to use KA1 and KB1 as planned.\n\n23"}
{"doc_id": "NIST.SP.800-227", "source_path": "data/raw_pdfs/NIST.SP.800-227.pdf", "page_number": 32, "text": "NIST SP 800-227\nSeptember 2025    Recommendations for KEMs\n\nThis example only provides unilateral key confirmation. If Bob also wanted assurance, an-\nother round of key confirmation can be performed by swapping roles.     During this addi-\ntional round, Alice generates new MAC_Data using KC_2_D as the label and indicating\nherself as the KC provider (see Sec. 4.4.1), generates a tag on new MAC_Data, and sends\nthe new tag to Bob for verification.\n\n4.5.  Proof of Possession for KEM Keys\nA key-pair owner may need to provide proof-of-possession (PoP), which is the assurance\nthat they possess the private decapsulation key corresponding to the public encapsulation\nkey.      In practice, PoP for RSA encryption key pairs (i.e., encryption key, decryption key)\nhas historically been provided by reusing the same keys as a digital signature key pair (i.e.,\nverification key, signing key). A key-pair owner can provide assurance that they possess the\nsecret decryption key by signing a message using the private signing/decryption key. The\nparty seeking assurance can verify the signature using the public verification/encryption\nkey. Unfortunately, this shortcut does not necessarily apply to all KEMs, so it is important\nto consider alternative approaches to providing PoP for KEMs.\nConsider the case in which Bob has obtained another partyâ€™s static public encapsulation\nkey and is communicating with a party purporting to be the key-pair owner corresponding\nto that encapsulation key. Bob may seek PoP from the other party before any further\nengagement. One method to obtain PoP is for Bob to participate in a KEM protocol that\nincludes key confirmation (see Sec. 4.4) and in which assurance of the identity of the other\nparty is provided. This method can be used for both static and ephemeral key pairs.\nHowever, for static key pairs, PoP can also be provided in a certificate by a certificate au-\nthority (CA). Consider the case in which Alice is the owner of a static KEM key pair and\nwould like to acquire a certificate establishing her ownership. A certificate authority (CA)\nwould require PoP from Alice prior to issuing and publishing a certificate. Bob could then\nacquire the certificate from either Alice or the CA and would have assurance that Alice pos-\nsesses the private key. Methods for performing PoP by a CA for KEMs are being developed.\nFor illustrative purposes, this section also describes a method proposed in [22] that can\nbe used by a CA to obtain PoP for a private decapsulation key for which a certificate is\nrequested for the corresponding public encapsulation key. In practice, a certificate not\nonly links the identity of the key-pair owner to the static public key,     but it also proves\nthat a key-pair owner possesses the static private key that corresponds to a static public\nkey. For the sake of simplicity, assume that Aliceâ€™s identifying information IDAlice has been\nsubmitted to and verified by the CA prior to the protocol run described below.\nSuppose that Alice has generated a static KEM key pair (ek, dk) and wants to obtain a\ncertificate for ek. Let Î , p be the KEM and parameter set associated with (ek, dk).        Let\nSym = (Sym.KeyGen, Sym.Enc, Sym.Dec) denote a symmetric encryption scheme with\ncorresponding key generation, encryption, and decryption algorithms, respectively.         Let\n\n                                      24"}
{"doc_id": "NIST.SP.800-227", "source_path": "data/raw_pdfs/NIST.SP.800-227.pdf", "page_number": 33, "text": "NIST SP 800-227\nSeptember 2025    Recommendations for KEMs\n\nH denote a cryptographic hash function. Let Cert.Gen denote the process used by the CA\nto generate a certificate.\n\n      Alice (key pair owner)                               Bob (CA)\n1. static:   (ek, dk)\n      IDAlice\n                                             âˆ’  ek, IDAlice\n                                             âˆ’\n                                                âˆ’\n                                                âˆ’\n                                                   âˆ’\n                                                   âˆ’\n                                                    âˆ’\n                                                    âˆ’\n                                                     âˆ’\n                                                        âˆ’\n                                                           âˆ’â†’\n2.                                                           (c, K) â† Î .Encaps( p, ek)\n                                                             cert[ek, p, Alice] â† Cert.Gen(ek, IDAlice)\n                                                             HB â† H(cert[ek, p, Alice])\n                                                             ccert â† Sym.EncK (cert[ek, p, Alice])\n                                             â†âˆ’ c, cá¶œáµ‰Ê³áµ—\n                                                âˆ’\n                                                 âˆ’\n                                                   âˆ’\n                                                    âˆ’\n                                                    âˆ’\n                                                     âˆ’\n                                                        âˆ’\n                                                           âˆ’\n                                                           âˆ’\n                                                            âˆ’\n3. KA â† Î .Decaps( p, dk, c)\n      certâ€²[ek, p, Alice] â† Sym.DecKA(ccert)\n      HA â† H(certâ€²[ek, p, Alice])\n                                             âˆ’      HA\n                                             âˆ’\n                                                âˆ’\n                                                 âˆ’\n                                                   âˆ’\n                                                    âˆ’\n                                                    âˆ’\n                                                     âˆ’\n                                                        âˆ’\n                                                           âˆ’\n                                                           âˆ’â†’\n                                                             if HA = HB, abort.\n4.                                                           publish: cert[ek, p, Alice]\n\n                     Fig. 6. KEM PoP between a key-pair owner and CA\n\n       0.  Prior to the protocol initiation, Alice    has submitted her identifying information\n           IDAlice to the CA, and the CA has verified her identity. Throughout the protocol ex-\n           ecution, messages coming from Alice are assumed to be authenticated so that no\n           one can impersonate Alice within the protocol.\n       1.  Alice sends ek, IDAlice to the CA to initiate the protocol.\n       2.  The CA runs Î .Encaps(ek, p) to produce (K, c).    The CA generates the certificate\n           cert[ek, p, Alice] and links Aliceâ€™s identity to her encapsulation key ek. The CA com-\n           putes HB, which is the hash of the certificate.   The CA then computes ccert =\n           Sym.EncK(cert[ek, p, Alice]) by encrypting the certificate with the key produced by\n           KEM Î . Finally, the CA sends the two ciphertexts c and ccert to Alice.\n       3.  Alice runs Î .Decaps(p, dk, c) to recover K and decrypts the certificate by comput-\n           ing Sym.DecK(ccert) to obtain the plaintext certificate.   Alice hashes the plaintext\n           certificate and sends the resulting hash value HA to the CA.\n       4.  The CA verifies the received hash value HA against HB, which is the hash of the plain-\n           text certificate cert[ek, p, Alice] generated in step 2. If the two hash values are equal,\n\n                                                25"}
{"doc_id": "NIST.SP.800-227", "source_path": "data/raw_pdfs/NIST.SP.800-227.pdf", "page_number": 34, "text": "NIST SP 800-227\nSeptember 2025    Recommendations for KEMs\n\n      the CA sends an acknowledgment to Alice that the certification process was success-\n      ful, and cert[ek, p, Alice] is published for use.\nOnce the CA publishes cert[ek, p, Alice], relying parties using that certificate have assurance\nthat the owner of that certificate (Alice, with identity â€ Aliceâ€) possessed the private decap-\nsulation key corresponding to ek when the certificate    was generated and published. If Alice\nmanages to recover the certificate in step 3, this indirectly proves that she possesses the\ncorresponding decapsulation key dk. However, the CA would not receive PoP from Alice\nunless step 4 is completed. This solution requires that the CA has the capabilities to run\nÎ .Encaps(), which may not be true in practice.\n\n4.6.  Multi-Algorithm KEMs and PQ/T Hybrids\nCombining multiple key-establishment schemes into a single key-establishment scheme\ncan be advantageous for some applications (e.g., during the migration to post-quantum\ncryptography). The discussions of such schemes in this document will adhere to the ter-\nminology established in [23].\nA multi-algorithm key-establishment scheme combines shared secret values that are gen-\nerated using two or more key-establishment schemes. The underlying schemes are called\nthe components of the overall scheme.    In general, the multi-algorithm scheme does not\nneed to have the same interface as its components. In this document, for example, multi-\nalgorithm schemes will always be KEMs, while their components need not be.\nA well-designed multi-algorithm scheme will be secure if at least one of the component\nschemes is secure. This may provide some protection against vulnerabilities that are dis-\ncovered in one of the component schemes after deployment. Forexample, the migra-\ntion to post-quantum key-establishment techniques might initially include multi-algorithm\nsolutions that combine one new post-quantum algorithm with one tried-and-tested but\nquantum-vulnerable (or traditional) algorithm. This is   sometimes referred to as hybrid\npost-quantum/traditional (PQ/T) key      establishment.  For example, X-Wing     KEM is a\nhybrid PQ/T KEM built from two components:     ML-KEM (a lattice-based post-quantum\nKEM) and X25519 (a traditional Diffie-Hellman-style key exchange) [24].\nThis section outlines approved approaches for multi-algorithm key establishment, which\nhave two stages:\n 1.   Establish shared secrets. All component key-establishment schemes are run (typi-\n      cally in parallel), resulting in Alice and Bob sharing a collection of shared secrets â€”\n      one for each component scheme.\n 2.   Combine shared secrets. Alice and Bob individually use a key combiner to combine\n      their individual shared secrets into a single shared secret each. Approved key com-\n      biners are described in Sec. 4.6.2.\n\n26"}
{"doc_id": "NIST.SP.800-227", "source_path": "data/raw_pdfs/NIST.SP.800-227.pdf", "page_number": 35, "text": "NIST SP 800-227\nSeptember 2025    Recommendations for KEMs\n\nFor simplicity, the exposition below focuses on a particular case: constructing a single KEM\nfrom two component KEMs. Since both the components and the multi-algorithm scheme\nin this case are of the same type (i.e., KEMs), the result is called a composite KEM. Most key-\nestablishment schemes of interest can easily be expressed as KEMs (see, e.g., ECDH-KEM\nin Sec. 5.1.1 and RSA-KEM in Sec. 5.1.2). Moreover, the hybrid PQ/T application typically\ncalls for two component schemes: one post-quantum scheme, and one traditional scheme.\nThe two-algorithm composite KEM described below is easily adapted to other cases, such\nas combining more than two schemes or combining KEMs with non-KEMs.\n\n4.6.1.     Constructing a Composite KEM\nGiven two KEMs Î 1 and Î 2, one can construct a composite KEM C[Î 1, Î 2] via the following\nsequence of steps:\n 1.     Choose parameter sets. Choose a collection C[Î 1, Î 2].ParamSets of parameter\n        sets. Each parameter set will be a pair p = (p1, p2), where p1 âˆˆ Î 1.ParamSets and\n        p2 âˆˆ Î 2.ParamSets.\n 2.     Select a key combiner. Choose a key combiner algorithm KeyCombine. The inputs\n        to KeyCombine include a pair of shared secret keys (one from Î 1 and one from Î 2),\n        a pair of ciphertexts, a pair of encapsulation keys, and a parameter set. The output\n        is a single shared secret key. Section 4.6.2 discusses NIST-approved key combiners.\n 3.     Construct a composite key-generation algorithm.            When a parameter set p =\n        (p1, p2) is input, the algorithm C[Î 1, Î 2].KeyGen will perform:\n        1.  (ek1, dk1) â† Î 1.KeyGen(p1).\n        2.  (ek2, dk2) â† Î 2.KeyGen(p2).\n        3.  Output composite encapsulation key ek1â€–ek2.\n        4.  Output composite decapsulation key dk1â€–dk2.\n 4.     Construct a composite encapsulation  algorithm.            When a parameter set p =\n        (p1, p2) and encapsulation key ek1â€–ek2 are input, the algorithm C[Î 1, Î 2].Encaps\n        will perform:\n        1.  (K1, c1) â† Î 1.Encaps(p1, ek1).\n        2.  (K2, c2) â† Î 2.Encaps(p2, ek2).\n        3.  Output combined shared secret key\n\n                          K â† KeyCombine(K1, K2, c1, c2, ek1, ek2, p).    (9)\n\n        4.  Output composite ciphertext c := c1â€–c2.\n\n27"}
{"doc_id": "NIST.SP.800-227", "source_path": "data/raw_pdfs/NIST.SP.800-227.pdf", "page_number": 36, "text": "NIST SP 800-227\nSeptember 2025    Recommendations for KEMs\n\n 5.     Construct a composite decapsulation  algorithm.  When a parameter set p =\n        (p1, p2), decapsulation key dk1â€–dk2, and ciphertext c1â€–c2 are input, the algorithm\n        C[Î 1, Î 2].Decaps will perform:\n        1.  Kâ€² â† Î 1.Decaps(p1, dk1, c1).\n            1\n        2.  Kâ€² â† Î 2.Decaps(p2, dk2, c2).\n            2\n        3.  Output combined shared secret key\n\n                         Kâ€² â† KeyCombine(Kâ€² , Kâ€² , c1, c2, ek1, ek2, p).      (10)\n                                             1  2\n\nSince the inputs to KeyCombine include the composite encapsulation key, the decapsulat-\ning party must retain a copy of that key or maintain the ability to recreate it after perform-\ning key generation.\n\nGeneral multi-algorithm schemes. The above construction can be extended in the obvi-\nous way to composite constructions that use more than two component KEMs.              Extend-\ning to the case of a completely general multi-algorithm key-establishment scheme can be\nmore complex, as the components in such a scheme can vary widely. For example, such\nschemes could potentially include pre-shared keys or shared secrets established via quan-\ntum key distribution. Still, most multi-algorithm schemes will likely include a step in which\na series of shared secrets are combined via a key combiner algorithm of a form similar to\nKeyCombine above. In those cases, an approved key combiner discussed in Sec. 4.6.2 shall\nbe used.\n\n4.6.2.     Approved Key Combiners\nThis section describes approved methods for combining shared secrets as part of a multi-\nalgorithm key-establishment scheme. Choosing such a method amounts to selecting a key\ncombiner KeyCombine. At a minimum, KeyCombine accepts two shared secrets as input,\nwhere one or both may be shared secret keys.            Optionally, KeyCombine can also accept\nadditional information, such as ciphertexts, encapsulation keys, parameter sets, or other\ncontext-dependent data (e.g., the composite KEM in Sec. 4.6.1). As output, KeyCombine\nproduces a single shared secret key.\nThis section describes how cryptographic methods standardized in other NIST publications\ncan be used as key combiners under an appropriate interpretation. There are two cate-\ngories of such key combiners:\n 1.     Key combiners from key-derivation methods approved in SP 800-56C [21]\n 2.     Key combiners from key-combination methods approved in SP 800-133 [18]\n\nConcatenation of inputs. The following descriptions involve   invocations of functions\n(e.g., hash functions H : {0, 1}âˆ— â†’ {0, 1}n) on multiple comma-separated inputs (e.g.,\n\n                                        28"}
{"doc_id": "NIST.SP.800-227", "source_path": "data/raw_pdfs/NIST.SP.800-227.pdf", "page_number": 37, "text": "NIST SP 800-227\nSeptember 2025    Recommendations for KEMs\n\nz := H(x, y)).  This should be distinguished from invoking the same function on a single\ninput that is formed by simply concatenating those inputs (e.g., w := H(xâ€–y)). For exam-\nple, if the lengths of the two inputs can vary, concatenation can have unintended conse-\nquences (e.g., xâ€–y = xâ€²â€–yâ€² even though (x, y) = (xâ€², yâ€²)). However, an appropriate encoding\nof a pair (x, y) as a single bitstring can specify the lengths of x and y such that invoking H\non (x, y) is distinct from invoking H on (xâ€², yâ€²).\nThe interpretation of invoking a function on comma-separated inputs generally depends\non the application and encoding and might also involve specifying the lengths of each in-\ndividual input. In some scenarios, simple concatenation can also be appropriate. In any\ncase, it is important to choose and fix this interpretation in a manner that is appropriate\nfor the given application.\n\nKey derivation in SP 800-56C. SP 800-56C [21] specifies a collection of approved methods\nfor performing key derivation. In SP 800-56C, a key derivation method (KDM) is applied to\na shared secret Z generated as specified in SP 800-56A [1] or SP 800-56B [2] along with\nsome additional input and results in keying material K:\n     K â† KDM(Z, OtherInput).                                                       (11)\nThe key-derivation method KDM can take one of two forms:\n 1.  One-step key derivation. In this case, K is computed by applying a key-derivation\n     function KDF to the two inputs Z and OtherInput.\n                              K â† KDF(Z, OtherInput).                              (12)\n\n 2.  Two-step key derivation. In this case, two functions are required: Extract (which is\n     a randomness extractor) and Expand. The process begins with applying Extract to\n     Z using a salt provided in OtherInput as the seed.   Expand is then applied to the\n     result along with FixedInfo, which is also provided in OtherInput.\n                          K â† Expand Extract salt      FixedInfo\n                              (                   (  , Z),      ).                 (13)\n     In this method, it is required that extraction is applied to the shared secret Z.\nSP 800-56C describes the specific approved choices of KDF, Extract, and Expand as well\nas the format and content of OtherInput. These details will not be discussed in this doc-\nument.\nAs discussed in Sec. 4.3, this publication approves the application of SP 800-56C KDMs\nto the shared secret keys of approved KEMs.       In particular, this means that the quantity\nZ in Equation (11) (and hence, also in (12) and (13)) can be the shared secret key of an\napproved KEM.\n\nKey combiners derived from SP 800-56C. In both one-step and two-step key derivation,\nSP 800-56C allows the shared secret Z to have the form Z = (S1, S2), where S1 is a shared\n\n                29"}
{"doc_id": "NIST.SP.800-227", "source_path": "data/raw_pdfs/NIST.SP.800-227.pdf", "page_number": 38, "text": "NIST SP 800-227\nSeptember 2025    Recommendations for KEMs\n\nsecret generated as specified in SP 800-56A [1] or SP 800-56B [2], while S2 is a shared secret\ngenerated in some other (not necessarily approved) manner.         This yields a key combiner\nK â† KDM((S1, S2), OtherInput) for a two-algorithm key-establishment scheme. One can\nalso combine many shared secrets:\n\n                     K â† KDM((S1, S2, Â· Â· Â· , St ), OtherInput).                         (14)\n\nThis publication approves the use of the key combiner (14) for any t > 1 if at least one\nshared secret (i.e., S j for some    j) is generated from the key-establishment methods in SP\n800-56A [1] or SP 800-56B [2] or an approved KEM. If the KDM in the combiner (14) is a\ntwo-step method (i.e., using (13)), extraction is performed with all shared secrets as the\ninput.\nSP 800-56C allows OtherInput to contain an input that is chosen arbitrarily by the pro-\ntocol specification.      This optional input is contained in a parameter called FixedInfo in\nSP 800-56C. By choosing FixedInfo appropriately, one can also construct approved key\ncombiners of the form (14) that receive inputs in addition to shared secrets, such as en-\ncapsulation keys, ciphertexts, parameter sets, and domain separators.\nSeveral key combiners can be generated according to Expression (14). As a simple exam-\nple, consider the following special case.        Choose KDM to be the one-step key-derivation\nmethod, where KDF is an approved hash function. Set OtherInput to contain the list of\nciphertexts and encapsulation keys together with a domain separator domain_sep (possi-\nbly including the parameter set p). Define a key combiner algorithm KeyCombine simply\nby setting\n\nKeyCombine(K1, K2, c1, c2, ek1, ek2, p) := H(K1, K2, c1, c2, ek1, ek2, domain_sep).  (15)\n\nOne can then instantiate the composite KEM example from Sec. 4.6 by using this key com-\nbiner. The resulting composite KEM will have a shared secret key whose length is the out-\nput length of H.\n\nKey combiners derived from SP 800-133. SP 800-133 [18] provides three approved meth-\nods for combining cryptographic keys that were generated in an approved way.            These\nmethods can be broadly described as concatenation, XORing, and key extraction using\nHMAC. Some of these methods can also be applied to just a single key.         As discussed in\nSec. 4.3, these methods are approved for key derivation for approved KEMs.\nWhen combining multiple keys K1, K2, . . . , Kt , the key-combination methods found in SP\n800-133 [18] require every key K j for j  âˆˆ {1, 2, . . . , t } to be generated using approved\nmethods.          These methods can be used directly as key combiners for constructing multi-\nalgorithm schemes in cases where all of the component schemes are approved, and each\none produces a key.          Any protocol using multi-algorithm KEMs with a concatenation key\ncombiner should ensure that the final shared secret key from the key combiner is passed\nthrough a KDF before use.\n\n                                          30"}
{"doc_id": "NIST.SP.800-227", "source_path": "data/raw_pdfs/NIST.SP.800-227.pdf", "page_number": 39, "text": "NIST SP 800-227\nSeptember 2025    Recommendations for KEMs\n\n4.6.3.  Security Considerations for Composite Schemes\nThe typical goal of a composite KEM construction is to ensure that security will hold if any\nof the component KEMs is secure. There are some important security considerations when\nconstructing composite KEMs.\n\nTheoretical security. The two main security properties that KEMs can satisfy (see Sec. 2.3)\nare:\n    1.  IND-CPA security (i.e., security against passive eavesdropping attacks)\n    2.  IND-CCA security (i.e., security against active attacks)\nA well-constructed composite KEM C[Î 1, Î 2] should preserve the security properties of\nits component KEMs Î 1 and Î 2.       This crucially depends on how the composite KEM is\nconstructed and the choice of the key combiner.\nAn important example is when the goal is active (i.e., IND-CCA) security, but only one of\nthe two schemes Î 1 and Î 2 is itself IND-CCA, and the designer of the composite scheme\nmay not know which one it is. In this case, the choice of the key combiner is particularly\nrelevant. As shown in [24], the straightforward key combiner\n\n                                    K â† KDF(K1, K2)                               (16)\n\nthat only uses the two shared secret keys K1 (of Î 1) and K2 (of Î 2) does not preserve\nIND-CCA security, regardless of the properties of the KDF. So, for example, the scheme\nÎ 2 could be so broken that C[Î 1, Î 2] is not IND-CCA, even if Î 1 is IND-CCA and regardless\nof what KDF is used.\nTherefore, NIST encourages the use of key combiners that generically preserve IND-CCA\nsecurity, in the sense that the combined scheme is IND-CCA, provided at least one of the\ningredient KEMs is IND-CCA. One example of such a key combiner is as in (15).    Let H\ndenote a hash function from the SHA-3 family, which is approved for use in one-step key\nderivation in SP 800-56C [21]. Define the key combiner KeyCombineCCA as follows (recalling\nthe notation in Sec. 4.6):                                      H\n     â€¢ Inputs from Î 1: ek1, c1, K1\n     â€¢ Inputs from Î 2: ek2, c2, K2\n     â€¢ Output: H(K1, K2, c1, c2, ek1, ek2, domain_sep)\nThe domain separator domain_sep should be used to uniquely identify the composite\nscheme in use (e.g., Î 1, Î 2, order of composition, choice of parameter set, key combiner,\nKDF). As shown in [25], KeyCombineCCA preserves IND-CCA security if H is modeled as a\nrandom oracle. Note that [25] does  H\n                                 not incorporate encapsulation keys into the combiner,\nas this is not needed to achieve the IND-CCA-preserving property. However, including en-\n\n31"}
{"doc_id": "NIST.SP.800-227", "source_path": "data/raw_pdfs/NIST.SP.800-227.pdf", "page_number": 40, "text": "NIST SP 800-227\nSeptember 2025    Recommendations for KEMs\n\ncapsulation keys can have other potential advantages in secure protocols, such as binding\nthe final shared secret to the identities of the participating parties.\n\nSecurity in practice. While composite schemes are meant to increase security, they nec-\nessarily add a layer of additional complexity to the basic KEM framework. This additional\ncomplexity will be reflected in implementations and applications and could introduce se-\ncurity vulnerabilities. Moreover, adding composite schemes introduces additional choices\nin protocols, which could also introduce vulnerabilities (e.g., in the form of â€œdowngrade\nattacksâ€). Implementers and users should be aware of the potential challenges in imple-\nmenting and deploying composite schemes.\n\n32"}
{"doc_id": "NIST.SP.800-227", "source_path": "data/raw_pdfs/NIST.SP.800-227.pdf", "page_number": 41, "text": "NIST SP 800-227\nSeptember 2025    Recommendations for KEMs\n\n5.    Examples\n\nThis section is meant to help readers understand some aspects of how KEMs are con-\nstructed. It only provides examples, not requirements or specific guidelines.\n\n5.1.    Examples of KEMs\nThe following subsections discuss three key-encapsulation mechanisms: ECDH-KEM, RSA-\nKEM, and ML-KEM. While ECDH and RSA key transport are not typically described as KEMs,\nthe discussions below will give a high-level description of how both can be naturally viewed\nas KEMs. The goal of these descriptions is illustrative only. As FIPS 203 already contains a\ncomplete description of ML-KEM, the discussion below will simply reference the relevant\nparts of FIPS 203 [3].\n\n5.1.1.  A KEM From Diffie-Hellman\nA KEM may be constructed from a Diffie-Hellman (DH) key-agreement scheme. The high-\nlevel idea is that, if the two parties in a DH scheme send their messages in sequential order\n(e.g., Alice first, then Bob), then:\n    1.  The public message and private randomness of Alice can be viewed as an encapsu-\n        lation key and a decapsulation key, respectively, and\n    2.  The public message of Bob can be viewed as a ciphertext.\nFor example, a KEM can be constructed from the C(1e, 1s, ECC CDH) Scheme from SP 800-\n56A [1] as follows:\n     â€¢ ECDH-KEM.ParamSets. The parameter sets are the same as those specified for ECDH\n        in Sec. 5.5.1.2 of SP 800-56A.\n     â€¢ ECDH-KEM.KeyGen. The key-generation algorithm is the same as the one specified\n        in Sec. 5.6.1.2 of SP 800-56A. Alice generates a static key pair and makes the static\n        public key available as the encapsulation key. Bob generates an ephemeral key pair\n        when initiating the key establishment with Alice.\n     â€¢ ECDH-KEM.Encaps. To encapsulate, perform Party Uâ€™s actions from Sec. 6.2.2.2 of SP\n        800-56A. The output is the key (i.e., the derived secret keying material) along with\n        the ciphertext (i.e., the ephemeral public key Qe,U ).\n     â€¢ ECDH-KEM.Decaps. To decapsulate, perform Party Vâ€™s actions from Sec. 6.2.2.2 of\n        SP 800-56A. The output key is the derived secret keying material.\nThe use of this KEM requires that all assumptions for the scheme specified in SP 800-56A\nare met and that all necessary assurances have been obtained.   This KEM is IND-CPA-\nsecure if the computational Elliptic Curve Diffie Hellman problem is hard for parameter set\nParamSets. The computational Elliptic Curve Diffie Hellman problem is efficiently solved by\n\n                                      33"}
{"doc_id": "NIST.SP.800-227", "source_path": "data/raw_pdfs/NIST.SP.800-227.pdf", "page_number": 42, "text": "NIST SP 800-227\nSeptember 2025    Recommendations for KEMs\n\na quantum computer so this KEM is considered to be quantum-vulnerable, as mentioned in\nSection 2.2. This KEM is not claimed to be IND-CCA-secure. In similar ways, KEMs could be\nconstructed from the C(1e, 1s, FFC DH), C(2e, 0s, ECC CDH), and C(2e, 0s, FFC DH) schemes.\n\n5.1.2.  A KEM From RSA Secret-Value Encapsulation\nAs discussed in Sec. 2.2, any PKE scheme can be used to construct a KEM. A concrete exam-\nple of this is RSA Secret-Value Encapsulation (RSASVE)4 with an agreed-upon key-derivation\nmethod applied to the shared secret value Z to derive a shared secret key. The high-level\nidea is described as follows:\n 1.     Alice sends an RSA public key to Bob.     Optionally, Alice can also send some other\n        public information to Bob, such as a nonce for key derivation.\n 2.     Bob generates a secret value and encapsulates it with Aliceâ€™s RSA public key to pro-\n        duce the ciphertext. A key is derived from the secret value. The output of encapsu-\n        lation is the ciphertext and the derived key. The ciphertext is sent to Alice.\n 3.     Alice decapsulates the ciphertext using her RSA private key to obtain the secret value\n        that is used to derive the key.\nFor example, a KEM can be constructed from RSASVE from SP 800-56B [2] as follows:\n 1.     RSASVE-KEM.ParamSets. The parameter set is the binary length of the modulus\n        (specified in Table 2, Sec. 6.3 of SP 800-56B) along with the exponent e.\n 2.     RSASVE-KEM.KeyGen.   The key-generation algorithm is specified in Sec. 6.3 of SP\n        800-56B (also see Appendix C.2 of FIPS 186-5).\n 3.     RSASVE-KEM.Encaps.   To encapsulate,  Bob (in       his role as Party U) performs\n        RSASVE.GENERATE, as specified in Sec. 7.2.1.2 of SP 800-56B. The output is the ci-\n        phertext and a secret value Z. Bob applies the agreed-upon key-derivation method\n        to the secret value Z to derive a shared secret key.\n 4.     RSASVE-KEM.Decaps.   To decapsulate,  Alice   (in   her role as Party V) performs\n        RSASVE.RECOVER using the ciphertext from Bob, as specified in Sec. 7.2.1.3 of SP\n        800-56B. The output is the secret value Z.    Alice applies     the agreed-upon key-\n        derivation method to the secret value Z to derive a shared secret key.\nUsing this KEM requires that all assumptions for the scheme specified in SP 800-56B are\nmet and that all necessary assurances have been obtained. This KEM is IND-CPA-secure if\nthe computational RSA problem is hard for parameter set ParamSets. The computational\nRSA problem is efficiently solved by a quantum computer so this KEM is considered to be\n\n4Note that RSASVE is NOT a standalone approved scheme. It is a component of the approved KAS1 and KAS2\nschemes.\n\n        34"}
{"doc_id": "NIST.SP.800-227", "source_path": "data/raw_pdfs/NIST.SP.800-227.pdf", "page_number": 43, "text": "NIST SP 800-227\nSeptember 2025    Recommendations for KEMs\n\nquantum-vulnerable, as mentioned in Section 2.2. This KEM is not claimed to be IND-CCA-\nsecure. In similar ways, KEMs could be constructed from RSA-OAEP-basic, as specified in\nSec. 9.2.3 of SP 800-56B.\n\n5.1.3.  ML-KEM\nML-KEM is a high-performance, general-purpose, lattice-based key-encapsulation mecha-\nnism. It is a NIST-approved KEM and was standardized in FIPS 203 [3]. ML-KEM is based on\nCRYSTALS-Kyber [26], which was a candidate in the NIST PQC standardization process. It is\nbelieved to satisfy IND-CCA security (Definition 4), even against adversaries in possession\nof a cryptanalytically relevant quantum computer [17, 27, 28]. The asymptotic, theoreti-\ncal security of ML-KEM is based on the presumed hardness of the Module Learning with\nErrors (MLWE) problem [29, 30].\nFIPS 203 directly describes ML-KEM as a KEM in a manner that closely matches the notation\nof this document. Specifically, the components of ML-KEM are described in FIPS 203 as\nfollows [3]:\n â€¢ ML-KEM.ParamSets. There are three parameter sets described in Sec. 8 of FIPS 203:\n        ML-KEM-512, ML-KEM-768, and ML-KEM-1024.\n â€¢ ML-KEM.KeyGen. The key-generation algorithm of ML-KEM is specified as Algorithm\n        19 in Sec. 7.1 of FIPS 203.\n â€¢ ML-KEM.Encaps. The encapsulation algorithm of ML-KEM is specified as Algorithm\n        20 in Sec. 7.2 of FIPS 203.\n â€¢ ML-KEM.Decaps. The decapsulation algorithm of ML-KEM is specified as Algorithm\n        21 in Sec. 7.3 of FIPS 203.\nThis document treats parameter sets as an explicit input for the KEM algorithms KeyGen,\nEncaps, and Decaps. By contrast, the algorithms of ML-KEM described in FIPS 203 expect\nthe chosen parameter set to be stored in a set of global variables that are accessible to\neach of the algorithms of ML-KEM. This is only a difference in presentation and does not\nimply any particular implementation requirement.\n\n5.2.    Examples of KEM Applications\nThis section provides a high-level overview of several example applications of KEMs.\n\n5.2.1.  KEM-DEM Public-Key Encryption\nA KEM can be combined with a symmetric-key encryption scheme to yield very effi-\ncient public-key encryption. This is sometimes referred to as the KEM-DEM paradigm for\nPKE [17]. Examples include El Gamal encryption [31] and the Elliptic Curve Integrated En-\ncryption Scheme (ECIES) standardized in ANSI X9.63 [15].\n\n                                     35"}
{"doc_id": "NIST.SP.800-227", "source_path": "data/raw_pdfs/NIST.SP.800-227.pdf", "page_number": 44, "text": "NIST SP 800-227\nSeptember 2025    Recommendations for KEMs\n\nThe prescription for constructing a KEM-DEM PKE scheme is as follows. Let Î  be a KEM,\nand let Î = (Encrypt, Decrypt) be a symmetric-key encryption scheme.    One then con-\nstructs a PKE called KD-PKE as follows:\n â€¢ KD-PKE.ParamSets = Î .ParamSets\n â€¢ KD-PKE.KeyGen = Î .KeyGen\n â€¢ KD-PKE.Encrypt: given input parameter set p, ek, and message m:\n  1.  Compute (K, cÎ ) â† Î .Encaps(p, ek).\n  2.  Compute cÎ â† Î.Encrypt(K, m).\n  3.  Output (cÎ , cÎ).\n â€¢ KD-PKE.Decrypt: given input p, dk, and (cÎ , cÎ),\n  1.  Compute Kâ€² â† Î .Decaps(p, dk, cÎ ).\n  2.  Output mâ€² â† Î.Decrypt(Kâ€², cÎ).\nHere, the keys of Î are assumed to be the same length as the shared secret keys pro-\nduced by Î .   If not, appropriate key-derivation steps (see Sec. 4.3) can be added to\nKD-PKE.Encrypt and KD-PKE.Decrypt to transform the shared secret key of Î  into a key\nthat is appropriate for use with Î.\nFigure 7 shows the procedure for sending an encrypted message m from Bob to Alice using\nKD-PKE. In this description, Alice selects the parameter set p.\n\n     Alice                                  Bob\n     (ek, dk) â† Î .KeyGen( p)\n                                   âˆ’    ek, p\n                                       âˆ’\n                                       âˆ’\n                                        âˆ’\n                                        âˆ’\n                                         âˆ’\n                                         âˆ’\n                                             âˆ’â†’\n                                               (K, cÎ ) â† Î .Encaps( p, ek)\n                                               cÎ â† Î.Encrypt(K, m)\n                                   â†âˆ’ cÎ , cÎ\n                                        âˆ’\n                                        âˆ’\n                                         âˆ’\n                                         âˆ’\n                                             âˆ’\n                                             âˆ’\n                                              âˆ’\n     Kâ€² â† Î .Decaps( p, dk, cÎ )\n     m â† Î.Decrypt(Kâ€², cÎ)\n\n                 Fig. 7. Sending a message using the KEM-DEM paradigm\n\nThis same procedure can also be used to perform key transport by choosing m uniformly\nat random as the key to be transported. This allows one to perform key transport using\nany KEM, even one that does not natively perform key transport (e.g., ML-KEM).\n\n36"}
{"doc_id": "NIST.SP.800-227", "source_path": "data/raw_pdfs/NIST.SP.800-227.pdf", "page_number": 45, "text": "NIST SP 800-227\nSeptember 2025    Recommendations for KEMs\n\n5.2.2.    Unilateral Authenticated Key Establishment Using a KEM\nMost applications of key establishment require at least one party (typically, a server) to\nauthenticate their identity. One approach to achieving this is for the server to acquire a\ncertificate of authenticity for their long-term, static KEM encapsulation key. This certificate\ncan then be provided to a client as proof that the key is associated with the serverâ€™s identity.\nAn example description of key establishment in this setting is given below and depicted in\nFig. 8. The example uses a simplified key confirmation process (see Sec. 4.4).\n\n          Alice (server)                              Bob (client)\n    1. static:  (ek, dk)\n                cert[ek, p, Alice]\n                                  âˆ’cert[ek, p, Alice]\n                                  âˆ’\n                                     âˆ’\n                                        âˆ’\n                                        âˆ’\n                                         âˆ’\n                                         âˆ’\n                                          âˆ’\n                                          âˆ’\n                                           âˆ’â†’\n    2.                                                 if cert[ek, p, Alice] invalid, abort.\n                                                       (KB, c) â† Î .Encaps( p, ek)\n                                  â†âˆ’     c\n                                     âˆ’\n                                        âˆ’\n                                        âˆ’\n                                         âˆ’\n                                         âˆ’\n                                          âˆ’\n                                          âˆ’\n                                           âˆ’\n                                                     âˆ’\n                                                     âˆ’\n    3. KA â† Î .Decaps( p, dk, c)\n    4. t â† MAC(KA, c)\n                                  âˆ’      t\n                                  âˆ’\n                                     âˆ’\n                                        âˆ’\n                                        âˆ’\n                                         âˆ’\n                                          âˆ’\n                                          âˆ’\n                                           âˆ’\n                                                    âˆ’â†’\n                                                       if MAC.Ver(KB, c,t) rejects, abort.\n    5. result: KA                                      result: KB\n\n                Fig. 8. Unilateral authenticated key establishment using a KEM\n\n 1.     At the outset, Alice has a long-term, static key pair that she generated earlier via\n        (ek, dk) â† Î .KeyGen(p).   Here, Î  is some KEM, and p is some parameter set of\n        Î . Alice also has a certificate cert[ek, p, Alice] that contains ek and p and associates\n        them both with Aliceâ€™s identity.\n 2.     When Bob wants to connect to Alice, he acquires cert[ek, p, Alice] (e.g., from Alice),\n        verifies that the certificate is valid, and extracts ek and p from the certificate. He\n        then performs encapsulation with ek, saves the resulting shared secret key KB, and\n        sends the ciphertext c to Alice.\n 3.     Alice decapsulates c and gets a shared secret key KA.\n 4.     Alice and Bob then perform a simplified key-confirmation step. Alice uses a MAC\n        algorithm to generate a tag t â† MAC(KA, c) for the ciphertext c and sends t to Bob.\n        Bob then runs MAC verification using KB and aborts unless the tag t is accepted.    If\n        the tag is accepted, Bob knows that Aliceâ€™s key KA and his key KB are the same (i.e.,\n        they share the same key).\n\n                                           37"}
{"doc_id": "NIST.SP.800-227", "source_path": "data/raw_pdfs/NIST.SP.800-227.pdf", "page_number": 46, "text": "NIST SP 800-227\nSeptember 2025    Recommendations for KEMs\n\n 5.     Alice and Bob can now use their shared secret key to communicate efficiently and\n        securely using symmetric-key cryptography.\nIf the KEM Î  is secure, then only a holder of the decapsulation key dk (corresponding to\nthe encapsulation key ek in the certificate) should be able to generate a valid MAC tag in\nstep 4.\n\n5.2.3.  Ephemeral Authenticated Key Establishment\nThis section describes an alternative approach to unilaterally authenticated key establish-\nment using a KEM. Compared to the example in Sec. 5.2.2, Alice and Bob will now have the\nopposite roles in the protocol. Specifically, Bob is now the authenticated party (e.g., a web\nserver), while Alice is the unauthenticated party (e.g., a browser client). Ephemeral KEM\nkey-pair generation will now be performed by the client (i.e., Alice), and Alice will discard\nthe KEM key pair once the connection is established. The server will not use a long-term,\nstatic KEM key pair but will need to establish his identity through other means.      In this\nexample, identity establishment will be done via a certificate that associates a particular\ndigital signature verification key with Bobâ€™s identity.\nThe following ingredients are required. Let Î£ be a digital signature scheme with algorithms\nÎ£.KeyGen, Î£.Sign, and Î£.Ver. As before, KEM key pairs are denoted by (ek, dk).        Digital\nsignature key pairs are denoted by (vk, sk), where vk is a public verification key and sk is\nthe corresponding private signing key.\nThe protocol proceeds as follows (see Fig. 9.)\n 1.     At the outset, Bob has previously generated    a static    digital signature key pair\n        (vkB, skB) and procured a certificate cert[vkB, Bob] that associates the public veri-\n        fication key with his identity.\n 2.     When connecting to Bob, Alice generates an ephemeral KEM key pair (ekA, dkA) and\n        sends the encapsulation key ekA and her chosen parameter set p to Bob, keeping\n        the decapsulation key dkA private.\n 3.     Bob performs encapsulation using ekA, which results in a KEM ciphertext cB and a\n        shared secret key KB. Bob then uses his private signing key skB to sign the transcript\n        of all communications with Alice, including what he will send in this transmission.\n        This transcript includes ekA, p, vkB, cB, and Bobâ€™s certificate cert[vkB, Bob]. He then\n        sends the certificate, signature, and ciphertext to Alice. Finally, he applies a key-\n        derivation function KDF to KB in order to produce two symmetric keys Kâ€²      and Kâ€²â€²,\n        destroys KB, and keeps Kâ€² and Kâ€²â€² private.                          B            B\n                             B         B\n 4.     Next, Alice performs two checks. First, she checks the validity of Bobâ€™s claimed cer-\n        tificate with the appropriate certification authority. Second, she verifies Bobâ€™s signa-\n        ture on the transcript. If either check fails, Alice aborts. Otherwise, she decapsulates\n\n38"}
{"doc_id": "NIST.SP.800-227", "source_path": "data/raw_pdfs/NIST.SP.800-227.pdf", "page_number": 47, "text": "  NIST SP 800-227\n  September 2025    Recommendations for KEMs\n\nAlice (client)  Bob (server)\n1.  static:  (vkB, skB)\ncert[vkB, Bob]\n2. (ekA, dkA) â† Î .KeyGen( p)\nâˆ’  ekA, p\nâˆ’\nâˆ’\nâˆ’\nâˆ’\nâˆ’\nâˆ’\nâˆ’\nâˆ’\nâˆ’\nâˆ’â†’\n3.  (KB, cB) â† Î .Encaps( p, ekA)\nÏƒ â† Î£.Sign(skB, transcript)\n(Kâ€² , Kâ€²â€²) â† KDF(KB)\nB  B\ncert[vkB, Bob], Ïƒ, cB\nâ†âˆ’\nâˆ’\nâˆ’\nâˆ’\nâˆ’\nâˆ’\nâˆ’\nâˆ’\nâˆ’\nâˆ’\nâˆ’\n4. if cert[vkB, Bob] invalid, abort.\nif Î£.Ver(vkB, Ïƒ, transcript) = âŠ¥, abort.\nKA â† Î .Decaps( p, dkA, cB)\n\n(Kâ€² , Kâ€²â€²) â† KDF(KA)\nA  A\n\n5. result: Kâ€² , Kâ€²â€²  result: Kâ€² , Kâ€²â€²\nA  A  B  B\n\nFig. 9. Using a KEM for key establishment with unilateral authentication\n\n          cB and keeps the resulting shared secret key KA private. She also derives two keys\n          Kâ€² and Kâ€²â€² via KDF applied to KA and destroys KA.\n          A  A\n  5.      Alice and Bob can now use the keys Kâ€² and Kâ€²â€² for symmetric-key cryptography. For\n          example, they could use Kâ€² for  A     A  â€²â€²\n                                  A       encryption and KA for authentication.\n\n  5.2.4.  Static-Ephemeral Unilateral Authenticated Key Establishment Using KEMs\n  This section presents a static-ephemeral key-establishment scheme with unilateral authen-\n  tication, as described in [32]. The scheme combines a shared secret key generated by a\n  static KEM key pair with a shared secret key produced by a freshly generated, ephemeral\n  KEM key pair. Just as in Example 5.2.2, one party possesses a static KEM key pair that is\n  associated with a certificate.\n  In this example, Alice and Bobâ€™s key pairs are generated using the same KEM Î  and param-\n  eter set p. In this case, Î  and p are determined by Bobâ€™s certificate. Note that Bob may use\n  the same static key pair to perform key establishment with many different parties. To see\n  how different KEMs might be used within one authenticated key-establishment scheme,\n  see Example 5.2.5.\n\n  39"}
{"doc_id": "NIST.SP.800-227", "source_path": "data/raw_pdfs/NIST.SP.800-227.pdf", "page_number": 48, "text": "NIST SP 800-227\nSeptember 2025    Recommendations for KEMs\n\nKEMTLS is a protocol with similar elements to this example, though it includes additional\nfeatures that are not presented here [33]. In particular, KEMTLS utilizes KEM-based au-\nthentication and also combines two shared secret keys: one generated by a static KEM key\npair and one by an ephemeral KEM key pair.\nIn this example, H denotes a KDF, and Bob is authenticated while Alice is not. Note that the\nchoice of KDF for H in [32] is a cryptographic hash function. There is no key-confirmation\nstep in this scheme, but one may easily incorporate such a step if desired.\n\n        Alice (client)                                      Bob (server)\n  1.                                                         static:  (ekB, dkB)\n                                                                      cert[ekB, p, Bob]\n                                           cert[ekB, p, Bob]\n                                         â†âˆ’\n                                           âˆ’\n                                            âˆ’\n                                            âˆ’\n                                             âˆ’\n                                             âˆ’\n                                              âˆ’\n                                              âˆ’\n                                                     âˆ’\n                                                      âˆ’\n  2. if cert[ekB, p, Bob] invalid, abort.\n        (ek, dk) â† Î .KeyGen( p)\n        (KB, cB) â† Î .Encaps( p, ekB)\n                                         âˆ’  ek, p, cB\n                                         âˆ’\n                                           âˆ’\n                                           âˆ’\n                                            âˆ’\n                                            âˆ’\n                                             âˆ’\n                                             âˆ’\n                                              âˆ’\n                                                     âˆ’\n                                                     âˆ’â†’\n  3.                                                         (K, c) â† Î .Encaps( p, ek)\n                                                             Kâ€² â† Î .Decaps( p, dkB, cB)\n                                                             B\n                                         â†âˆ’  c\n                                           âˆ’\n                                            âˆ’\n                                            âˆ’\n                                             âˆ’\n                                             âˆ’\n                                              âˆ’\n                                              âˆ’\n                                                     âˆ’\n                                                      âˆ’\n                                                            âˆ’\n  4. Kâ€² â† Î .Decaps( p, dk, c)\n\n  5. result: H(Kâ€², KB)                                       result: H(K, Kâ€² )\n                                                                        B\n\n        Fig. 10. Static-ephemeral unilateral authenticated key establishment using KEMs\n\n 1.  At the outset, Bob has a long-term, static key pair that he generated earlier via\n     (ekB, dkB) â† Î .KeyGen(p). Here, Î  is some KEM, and p is some parameter set of\n     Î . Bob also has a certificate cert[ekB, p, Bob] that contains ekB and p and associates\n     them both with Bobâ€™s identity.\n 2.  When Alice wants to connect to Bob, she acquires cert[ekB, p, Bob] (e.g., from Bob),\n     verifies that the certificate is valid, and extracts ekB and p from the certificate. She\n     then performs encapsulation with ekB, saves the resulting shared secret key KB, and\n     sends the ciphertext cB to Bob. Alice additionally generates an ephemeral KEM key\n     pair (ek, dk) using the same KEM Î  and parameter set p and sends the encapsulation\n     key ek and relevant parameter set p to Bob, keeping the private decapsulation key\n     dk private.\n\n40"}
{"doc_id": "NIST.SP.800-227", "source_path": "data/raw_pdfs/NIST.SP.800-227.pdf", "page_number": 49, "text": "NIST SP 800-227\nSeptember 2025    Recommendations for KEMs\n\n 3.     Bob uses (p, ek) to perform encapsulation, which results in a KEM ciphertext c and\n        shared secret key K. Bob also performs decapsulation using (p, dkB, cB) to produce\n        another shared secret key Kâ€² . Bob sends ciphertext c to Alice.\n                             B\n 4.     Alice uses c, p, and dk to run decapsulation and recover her copy of the ephemeral\n        shared secret key Kâ€².\n 5.     Alice and Bob combine their copies of the shared ephemeral secret key Kâ€² (K) and\n        the shared secret key KB (Kâ€² ) that was computed using Bobâ€™s static key pair. A hash\n        function H is applied to theB\n                             result to establish a final shared secret key.\nIt is assumed that if the certificate is valid, then only Bob is capable of performing decap-\nsulation of ciphertexts that were encapsulated using ekB.\n\n5.2.5.  Authenticated Key Establishment Using KEMs\nThis section presents a bilaterally authenticated key-establishment scheme using KEMs, as\ndescribed in [32]. In this example, both Alice and Bob are authenticated using static KEM\nkey pairs associated with certificates. The KEM shared secret keys produced using their\nstatic key pairs contribute to the final key and a shared secret key produced using a freshly\ngenerated ephemeral KEM key pair. This scheme achieves weak forward secrecy [32, 34].\nAliceâ€™s static key pair may correspond to a different KEM than the one associated with Bobâ€™s\nstatic key pair as the choices of KEM and parameter set used by Alice and Bob are deter-\nmined by their certificates. As such, both parties must be able to operate using each otherâ€™s\nKEM encapsulation algorithm. Moreover, the ephemeral KEM key pair may correspond to\na third, completely different KEM. To capture this possibility, let (Î A, pA), (Î B, pB), and\n(Î , p) denote the KEM algorithm and parameter set associated with Aliceâ€™s static key pair,\nBobâ€™s static key pair, and the ephemeral KEM key pair, respectively.   This notation allows\nfor the possibility that Î A = Î B = Î  and pA = pB = p. Additionally, parameter sets are\nformatted differently for different KEMs (e.g., lattice-based KEMs might include lattice di-\nmension, while code-based KEMs include code length and dimension).          Therefore, if two\nKEMs Î i and Î  j are distinct, the corresponding parameter sets are likely also distinct.\nAs with other examples, Alice and Bob will need to negotiate which KEM Î  and parameter\nset p they will use for the ephemeral key pair prior to protocol execution. As in Example\n5.2.3, H denotes a KDF. Note that in [32] H is chosen to be a cryptographic hash function.\nThere is no key-confirmation step included in this example, but one could be added.\n 1.     At  the outset, Alice and    Bob each have a long-term, static   key     pair.  Al-\n        ice has (ekA, dkA), and Bob has (ekB, dkB), which were     generated     earlier  via\n        Î A.KeyGen(pA) and Î B.KeyGen(pB), respectively. Alice and Bob also have certifi-\n        cates cert[ekA, pA, Alice] and cert[ekB, pB, Bob], respectively, which contain their cor-\n        responding public keys and associate them to their respective identities.\n\n41"}
{"doc_id": "NIST.SP.800-227", "source_path": "data/raw_pdfs/NIST.SP.800-227.pdf", "page_number": 50, "text": "  NIST SP 800-227\n  September 2025    Recommendations for KEMs\n\nAlice (client)  Bob (server)\n1. static:  (ekA, dkA)  static:  (ekB, dkB)\ncert[ekA, pA, Alice]  cert[ekB, pB, Bob]\n\nâˆ’cert[eká´¬, pá´¬, Alice]\nâˆ’\nâˆ’\nâˆ’\nâˆ’\nâˆ’\nâˆ’\nâˆ’\nâˆ’\nâˆ’\nâˆ’â†’\ncert[ekB, pB, Bob]\nâ†âˆ’\nâˆ’\nâˆ’\nâˆ’\nâˆ’\nâˆ’\nâˆ’\nâˆ’\nâˆ’\nâˆ’\nâˆ’\n2. if cert[ekB, pB, Bob] invalid, abort.  if cert[ekA, pA, Alice] invalid, abort.\n(ek, dk) â† Î .KeyGen( p)\n(KB, cB) â† Î B.Encaps( pB, ekB)\nâˆ’  ek, cB\nâˆ’\nâˆ’\nâˆ’\nâˆ’\nâˆ’\nâˆ’\nâˆ’\nâˆ’\nâˆ’\nâˆ’â†’\n3.  (K, c) â† Î .Encaps( p, ek)\n(KA, cA) â† Î A.Encaps( pA, ekA)\nKâ€² â† Î B.Decaps( pB, dkB, cB)\nB\nâ†âˆ’   c, cA\nâˆ’\nâˆ’\nâˆ’\nâˆ’\nâˆ’\nâˆ’\nâˆ’\nâˆ’\nâˆ’\nâˆ’\n4. Kâ€² â† Î .Decaps( p, dk, c)\nKâ€² â† Î A.Decaps( pA, dkA, cA)\nA\n\n5. result: H(Kâ€², Kâ€² , KB)  result: H(K, KA, Kâ€² )\nA  B\n\nFig. 11. Authenticated key establishment using KEMs\n\n  2.  When Alice wants to connect to Bob, she acquires cert[ekB, pB, Bob] (e.g., from Bob),\n      verifies that the certificate is valid, and extracts ekB, pB from the certificate. Bob also\n      acquires and verifies Aliceâ€™s certificate in this step.\n      Alice then performs encapsulation with Bobâ€™s static public key ekB, saves the result-\n      ing shared secret key KB, and sends the ciphertext cB to Bob. Alice additionally gen-\n      erates an ephemeral KEM key pair (ek, dk) and sends the encapsulation key ek and\n      relevant parameter set p to Bob, keeping the private decapsulation key dk private.\n  3.  Bob uses (p, ek) to perform encapsulation, which results in a KEM ciphertext c and\n      shared secret key K. Bob extracts ekA and pA from Aliceâ€™s certificate and then per-\n      forms encapsulation with ekA and pA to generate KA and cA.\n      Bob also performs decapsulation using (pB, dkB, cB) to produce another shared se-\n      cret key Kâ€² . Bob sends ciphertexts c and cA to Alice.\n      B\n  4.  Alice uses c, p, and dk to run decapsulation and recover her copy of the ephemeral\n      shared secret key Kâ€². Alice additionally uses cA, pA, and dkA to run decapsulation\n      and recover her copy of the long-term shared secret key Kâ€² .\n                                                             A\n\n                            42"}
{"doc_id": "NIST.SP.800-227", "source_path": "data/raw_pdfs/NIST.SP.800-227.pdf", "page_number": 51, "text": "NIST SP 800-227\nSeptember 2025    Recommendations for KEMs\n\n5.  Alice and Bob combine their copies of the shared ephemeral secret key Kâ€² (K) and\n    static shared secret keys Kâ€² and KB (KA and Kâ€² .) and apply a KDF H to establish a\n    final shared secret key.  A    B\n\n43"}
{"doc_id": "NIST.SP.800-227", "source_path": "data/raw_pdfs/NIST.SP.800-227.pdf", "page_number": 52, "text": "    NIST SP 800-227\n    September 2025    Recommendations for KEMs\n\n    References\n\n [1]  Barker EB, Chen L, Roginsky A, Vassilev A, Davis R (2018) Recommendation for\n      Pair-Wise Key-Establishment Schemes Using Discrete Logarithm Cryptography\n      (Depart-ment of Commerce, Washington, D.C.), NIST Special Publication (SP) NIST\n      SP 800-56Ar3. https://doi.org/10.6028/NIST.SP.800-56Ar3\n [2]  Barker EB, Chen L, Roginsky A, Vassilev A, Davis R, Simon S (2019) Recommendation\n      for Pair-Wise Key-Establishment Using Integer Factorization Cryptography\n      (Depart-ment of Commerce, Washington, D.C.), NIST Special Publication (SP) NIST\n      SP 800-56Br2. https://doi.org/10.6028/NIST.SP.800-56Br2\n [3]  National Institute of Standards and Technology (2024) Module-Lattice-Based Key-\n      Encapsulation Mechanism Standard (Department of Commerce, Washington, D.C.),\n      Federal Information Processing  Standards Publications (FIPS) NIST       FIPS   203.\n      https://doi.org/10.6028/NIST.FIPS.203\n [4]  Moody D, Perlner R, Regenscheid A, Robinson A, Cooper D (2024) Transition to Post-\n      Quantum Cryptography Standards (Department of Commerce, Washington, D.C.),\n      NIST Internal Report (IR) NIST IR 8547ipd. https://doi.org/10.6028/NIST.IR.8547.ipd\n [5]  National Institute of Standards and Technology (2019) Security Requirements for\n      Cryptographic Modules (Department of Commerce, Washington, D.C.), Federal In-\n      formation Processing Standards Publications (FIPS) NIST FIPS 140-3,. https://doi.org/\n      10.6028/NIST.FIPS.140-3\n [6]  Barker EB, Kelsey J (2015) Recommendation for Random Number Generation Using\n      Deterministic Random Bit Generators (Department of Commerce, Washington, D.C.),\n      NIST Special Publication (SP) NIST SP 800-90Ar1. https://doi.org/10.6028/\n      NIST.SP.800-90Ar1\n [7]  SÃ¶nmez Turan M, Barker E, Kelsey J, McKay K, Baish M, Boyle M (2018) Recom-\n      mendation for the Entropy Sources Used for Random Bit Generation (Department\n      of Commerce, Washington, D.C.), NIST Special Publication (SP) NIST SP 800-90B.\n      https://doi.org/10.6028/NIST.SP.800-90B\n [8]  Barker EB, Kelsey JM, McKay KA, Roginsky AL, SÃ¶nmez Turan M (2025) Recommenda-\n      tion for Random Bit Generator (RBG) Constructions (National Institute of Standards\n      and Technology, Gaithersburg, MD), NIST Special Publication (SP) NIST SP\n      800-90C. https://doi.org/10.6028/NIST.SP.800-90C\n [9]  Dworkin M (2007) Recommendation for Block Cipher Modes of Operation:            Ga-\n      lois/Counter Mode (GCM) and GMAC (National Institute of Standards and Technology,\n      Gaithersburg, MD), NIST Special Publication (SP) NIST SP 800-38D. https://doi.org/\n      10.6028/NIST.SP.800-38D\n[10]  Barker E, Branstad D, Smid M (2015) A Profile for U.S. Federal Cryptographic Key\n      Man-agement Systems (CKMS) (National Institute of Standards and Technology,\n      Gaithers-burg, MD), NIST Special Publication (SP) NIST SP 800-152. https://\n      doi.org/10.6028/NIST.SP.800-152\n\n    44"}
{"doc_id": "NIST.SP.800-227", "source_path": "data/raw_pdfs/NIST.SP.800-227.pdf", "page_number": 53, "text": "NIST SP 800-227\nSeptember 2025    Recommendations for KEMs\n\n[11]  Shoup V (2001) A Proposal for an ISO Standard for Public Key Encryption, Cryptology\n      ePrint Archive, Paper 2001/112. Available at https://eprint.iacr.org/2001/112.\n[12]  Cramer R, Shoup V (2003) Design and analysis of practical public-key encryption\n      schemes secure against adaptive chosen ciphertext attack. SIAM Journal on Comput-\n      ing 33(1):167â€“226. https://doi.org/10.1137/S0097539702403773\n[13]  Herranz J, Hofheinz D, Kiltz E (2006) Some (in)sufficient conditions for secure hybrid\n      encryption, Cryptology ePrint Archive, Paper 2006/265. Available at https://eprint.i\n      acr.org/2006/265.\n[14]  Brainard J, Kaliski B, Turner S, Randall J (2010) Use of the RSA-KEM Key Transport\n      Algorithm in the Cryptographic Message Syntax (CMS), RFC 5990. https://doi.org/\n      10.17487/RFC5990.\n[15]  American National Standards Institute (2011) ANSI X9.63-2011, (R2017) - Public Key\n      Cryptography for the Financial Services Industry: Key Agreement and Key Transport\n      Using Elliptic Curve Cryptography (Accredited Standards Committee X9, Annapolis,\n      MD). Available at https://webstore.ansi.org/standards/ascx9/ansix9442007r2017.\n[16]  American National Standards Institute (2007) ANSI X9.44-2007 (R2017), Public Key\n      Cryptography for the Financial Services Industry: Key Establishment Using Integer\n      Factorization Cryptography (Accredited Standards Committee X9, Annapolis, MD).\n      Available at https://webstore.ansi.org/standards/ascx9/ansix9442007r2017.\n[17]  Katz J, Lindell Y (2020) Introduction to Modern Cryptography (Chapman & Hall/CRC,\n      Boca Raton, FL), 3rd Ed.\n[18]  Barker EB, Roginsky A, Davis R (2020) Recommendation for Cryptographic Key Gen-\n      eration (Department of Commerce, Washington, D.C.), NIST Special Publication (SP)\n      NIST SP 800-133r2. https://doi.org/10.6028/NIST.SP.800-133r2\n[19]  Barker E (2020) Recommendation for Key Management: Part 1 â€“ General (National\n      Institute of Standards and Technology, Gaithersburg, MD), NIST Special Publication\n      (SP) NIST SP 800-57pt1r5. https://doi.org/10.6028/NIST.SP.800-57pt1r5\n[20]  Chen L (2022) Recommendation for Key Derivation Using Pseudorandom Functions\n      (National Institute of Standards and Technology, Gaithersburg, MD), NIST Special\n      Publication (SP) NIST SP 800-108r1-upd1, Includes updates as of February 2, 2024.\n      https://doi.org/10.6028/NIST.SP.800-108r1-upd1\n[21]  Barker EB, Chen L, Davis R (2020) Recommendation for Key-Derivation Methods in\n      Key-Establishment Schemes (Department of Commerce, Washington, D.C.), NIST Spe-\n      cial Publication (SP) NIST SP 800-56Cr2. https://doi.org/10.6028/NIST.SP.800-56Cr2\n[22]  Brockhaus H, von Oheimb D, Ounsworth M, Gray J (2025) Internet X.509 Public Key\n      Infrastructure â€“ Certificate Management Protocol (CMP), RFC 9810. https://doi.org/\n      10.17487/RFC9810.\n[23]  Driscoll F, Parsons M, Hale B (2024) Terminology for Post-Quantum Traditional Hy-\n      brid Schemes (Internet Engineering Task Force), Internet-Draft draft-ietf-pquip-pqt-\n      hybrid-terminology-05. Work in Progress. Available at https://datatracker.ietf.org/d\n      oc/draft-ietf-pquip-pqt-hybrid-terminology/05/.\n\n45"}
{"doc_id": "NIST.SP.800-227", "source_path": "data/raw_pdfs/NIST.SP.800-227.pdf", "page_number": 54, "text": "NIST SP 800-227\nSeptember 2025    Recommendations for KEMs\n\n[24]  Barbosa M, Connolly D, Duarte JD, Kaiser A, Schwabe P, Varner K, Westerbaan B (2024)\n     X-Wing. IACR Communications in Cryptology 1(1). https://doi.org/10.62056/a3qj89n\n      4e\n[25]  Giacon F, Heuer F, Poettering B (2018) KEM combiners. Public-Key Cryptography â€“ PKC\n      2018, eds Abdalla M, Dahab R (Springer International Publishing, Cham), pp 190â€“218.\n[26]  Avanzi R, Bos J, Ducas L, Kiltz E, Lepoint T, Lyubashekvsky V, Schanck JM, Schwabe\n      P, Seiler G, StehlÃ© D (2021) CRYSTALS-Kyber Algorithm Specifications and Supporting\n      Documentation (version 3.02). Available at https://pq-crystals.org/kyber/data/kyb\n      er-specification-round3-20210804.pdf.\n[27]  Avanzi R, Bos J, Ducas L, Kiltz E, Lepoint T, Lyubashevsky V, Schanck JM, Schwabe P,\n      Seiler G, StehlÃ© D (2020) CRYSTALS-Kyber Algorithm Specifications and Supporting\n      Documentation, Third-round submission to the NISTâ€™s post-quantum cryptography\n      standardization process. Available at https://csrc.nist.gov/Projects/post-quantum-c\n      ryptography/post-quantum-cryptography-standardization/round-3-submissions.\n[28]  Almeida JB, Olmos SA, Barbosa M, Barthe G, Dupressoir F, GrÃ©goire B, Laporte V,\n      LÃ©chenet JC, Low C, Oliveira T, Pacheco H, Quaresma M, Schwabe P, Strub PY (2024)\n      Formally verifying Kyber Episode V: Machine-checked IND-CCA security and correct-\n      ness of ML-KEM in EasyCrypt, Cryptology ePrint Archive, Paper 2024/843. Available\n      at https://eprint.iacr.org/2024/843.\n[29]  Regev O (2005) On Lattices, Learning with Errors, Random Linear Codes, and Cryp-\n      tography. Proceedings of the Thirty-Seventh Annual ACM Symposium on Theory of\n      Computing STOC â€™05 (Association for Computing Machinery, New York, NY, USA), pp\n      84â€“93. https://doi.org/10.1145/1060590.1060603.\n[30]  Langlois A, StehlÃ© D (2015) Worst-case to average-case reductions for module\n      lattices. Designs, Codes and Cryptography 75(3):565â€“599. https://doi.org/10.1007/\n      s10623-09938-4.\n[31]  ElGamal T (1985) A public key cryptosystem and a signature scheme based on discrete\n      logarithms. IEEE transactions on information theory 31(4):469â€“472. https://doi.org/\n      10.1109/TIT.1985.1057074\n[32]  Bos J, Ducas L, Kiltz E, Lepoint T, Lyubashevsky V, Schanck JM, Schwabe P, Seiler\n      G, Stehle D (2018) CRYSTALS - Kyber: A CCA-Secure Module-Lattice-Based KEM.\n      2018 IEEE European    Symposium on Security and Privacy (EuroSP), pp 353â€“367.\n      https://doi.org/10.1109/EuroSP.2018.00032\n[33]  Schwabe P, Stebila D, Wiggers T (2020) Post-quantum TLS without handshake signa-\n      tures. Proceedings of the 2020 ACM SIGSAC Conference on Computer and Communi-\n      cations Security, pp 1461â€“1480. https://doi.org/10.1145/3372297.3423350\n[34]  Canetti R, Krawczyk H (2001) Analysis of key-exchange protocols and their use\n      for building secure channels. Advances in Cryptology â€” EUROCRYPT 2001\n      (Springer, Berlin, Heidelberg), pp 453â€“474. https://\n      doi.org/10.1007/3-540-44987-6_28\n[35]  SÃ¶nmez Turan M, BrandÃ£o LTAN (2024) Keyed-Hash Message Authentication Code\n      (HMAC): Specification of HMAC and Recommendations for Message Authentication\n\n                                          46"}
{"doc_id": "NIST.SP.800-227", "source_path": "data/raw_pdfs/NIST.SP.800-227.pdf", "page_number": 55, "text": "NIST SP 800-227\nSeptember 2025    Recommendations for KEMs\n\n      (National Institute of Standards and Technology, Gaithersburg, MD), NIST Special Pub-\n      lication (SP) NIST SP 800-224 ipd. https://doi.org/10.6028/NIST.SP.800-224.ipd\n[36]  Dworkin M (2010) Recommendation for Block Cipher Modes of Operation:     Three\n      Variants of Ciphertext Stealing for CBC Mode (National Institute of Standards and\n      Technology, Gaithersburg, MD), NIST Special Publication (SP) NIST SP 800-38B.\n      https://doi.org/10.6028/NIST.SP.800-38B\n[37]  Kelsey J, Chang SJ, Perlner R (2016) SHA-3 Derived Functions: cSHAKE, KMAC, Tuple-\n      Hash and ParallelHash (Department of Commerce, Washington, D.C.), NIST Special\n      Publication (SP) NIST SP 800-185. https://doi.org/10.6028/NIST.SP.800-185\n\n47"}
{"doc_id": "NIST.SP.800-227", "source_path": "data/raw_pdfs/NIST.SP.800-227.pdf", "page_number": 56, "text": "NIST SP 800-227\nSeptember 2025    Recommendations for KEMs\n\nAppendix A. List of Acronyms\n\nCAVP Cryptographic Algorithm Verification Program\nCMVP Cryptographic Module Verification Program\nDRBG Deterministic Random Bit Generator\nFIPS Federal Information Processing Standards\nIND-CCA Indistinguishability under Chosen Ciphertext Attack\nIND-CPA Indistinguishability under Chosen Plaintext Attack\nITL Information Technology Laboratory\nKC  Key Confirmation\nKDF Key-Derivation Function\nKDM Key-Derivation Method\nKEM Key-Encapsulation Mechanism\nMAC Message Authentication Code\nML-KEM Module-Lattice-Based Key-Encapsulation Mechanism\nNIST National Institute of Standards and Technology\nPKE Public-Key Encryption\nPoP Proof of Possession\nRBG Random Bit Generator\nSP Special Publication\nTLS Transport Layer Security\nTTP  Trusted Third Party\n\n48"}
{"doc_id": "NIST.SP.800-227", "source_path": "data/raw_pdfs/NIST.SP.800-227.pdf", "page_number": 57, "text": "NIST SP 800-227\nSeptember 2025    Recommendations for KEMs\n\nAppendix B. Glossary\n\nThis section is informative.\napproved   FIPS-approved and/or NIST-recommended.     An algorithm or technique that is\n        either 1) specified in a FIPS or NIST recommendation, 2) adopted in a FIPS or NIST\n        recommendation, or 3) specified in a list of NIST-approved security functions.\nciphertext      With regard to KEMs, a bit string that is produced by the encapsulation algo-\n        rithm and used as an input to the decapsulation algorithm.\ncomputationally bounded adversary   An adversarial algorithm that is constrained in run-\n        ning time and memory, and is thus unlikely to break a cryptosystem under con-\n        sideration.       The nature of the constraints depends on the context, including the\n        desired security strength of the cryptosystem.\ncryptanalytically relevant quantum computer           A device capable of using quantum algo-\n        rithms to break a cryptosystem that is secure against classical (i.e., non-quantum)\n        computers.\ndecapsulation       The process of applying the Decaps algorithm of a KEM. This algorithm ac-\n        cepts a KEM ciphertext and the decapsulation key as input and produces a shared\n        secret key as output.\ndecapsulation key             A cryptographic key produced by a KEM during key generation and\n        used during decapsulation.\ndestroy     An action applied to a key or other piece of secret data. After a key or piece of\n        secret data is destroyed, no information about its value can be recovered.\nefficient (cryptographic) algorithm      An algorithm whose running time is practical for the\n        relevant security strength.\nencapsulation The process of applying the Encaps algorithm of a KEM. This algorithm ac-\n        cepts the encapsulation key as input, requires private randomness, and produces\n        a shared secret key and an associated ciphertext as output.\nencapsulation key             A cryptographic key produced by a KEM during key generation and\n        used by the encapsulation algorithm.\nephemeral key A cryptographic key that is   generated for each execution of a crypto-\n        graphic process (e.g., key establishment) and meets other requirements of the\n        key type (e.g., unique to each message or session).\nhash function A function on arbitrarily long bit strings in which the length of the output is\n        fixed. At a minimum, the hash function must be one-way and collision-resistant.\n\n49"}
{"doc_id": "NIST.SP.800-227", "source_path": "data/raw_pdfs/NIST.SP.800-227.pdf", "page_number": 58, "text": "NIST SP 800-227\nSeptember 2025    Recommendations for KEMs\n\nidentifier A bit string that is associated with a person, device, or organization. It may be\n an identifying name or something more abstract (e.g., a string consisting of an IP\n address).\nkey agreement   A (pair-wise) key-establishment procedure in which the resultant secret\n keying material is a function of information contributed by both participants so\n that neither party can predetermine the value of the secret keying material inde-\n pendent of the contributions of the other party. Contrast with key transport.\nkey combiner  A function that takes multiple keys or shared secret values as input (possibly\n along with other information) and produces a single combined key.\nkey confirmation    A procedure that provides assurance to one party (i.e., key-confirmation\n recipient) that another party (i.e., key-confirmation provider) possesses the cor-\n rect secret keying material and/or shared secret from which that secret keying\n material is derived.\nkey-confirmation provider    The party that provides assurance to the other party (i.e., the\n recipient) that the two parties have indeed established a shared secret key or other\n keying material.\nkey-confirmation recipient     The party that receives assurance from the other party (i.e.,\n the provider) that the two parties have indeed established a shared secret key or\n other keying material.\nkey-derivation method        A method used to derive keying material from initial shared se-\n crets and possibly other information.\nkey-derivation key    A key used as an input to a key-derivation method to derive additional\n keying material.\nkey-encapsulation mechanism (KEM) A set of three cryptographic algorithms:            KeyGen\n (key generation), Encaps (encapsulation), and Decaps (decapsulation). These al-\n gorithms can be used by two parties to securely establish a shared secret key over\n a public channel.\nkey establishment  A procedure that results in secret keying material that is shared among\n different parties.           Key agreement, using a KEM, and key transport are all types of\n key establishment.\nkeying material       A bit string such that any non-overlapping, contiguous segments of the\n string with required lengths can be used as secret keys, secret initialization vectors,\n and other secret parameters.\nkey pair      A set of two keys with the property that one key can be made public, while the\n other key must be kept private.         In this publication, this could refer to either the\n (encapsulation key, decapsulation key) key pair of a KEM or the (encryption key,\n decryption key) key pair of a public-key encryption (PKE) scheme .\n\n                                  50"}
{"doc_id": "NIST.SP.800-227", "source_path": "data/raw_pdfs/NIST.SP.800-227.pdf", "page_number": 59, "text": "NIST SP 800-227\nSeptember 2025    Recommendations for KEMs\n\nkey transport  A (pair-wise) key-establishment procedure whereby one party (i.e.,  the\n      sender) selects a value for the secret keying material and then securely distributes\n      the value to another party (i.e., the receiver). Contrast with key agreement.\nmessage authentication code (MAC) A family of symmetric-key cryptographic algorithms\n      that act on input data of arbitrary length to produce an output value of a specified\n      length (i.e., the MAC of the input data). The MAC can be employed to authenticate\n      the origin of the input data and/or provide data integrity protection.\nmessage authentication code (MAC) tag Data obtained from the output of a MAC algo-\n      rithm (possibly by truncation) that can be used by an entity to securely verify the\n      integrity and origin of the information used as input to the MAC algorithm.\nmust Indicates a requirement of this recommendation that might not be testable by a\n      CMVP testing lab.\nnegligible Extremely small.  Typically quantifies the probability of an undesirable event\n      that might occur during the lifetime of a cryptosystem (including during attacks by\n      computationally bounded adversaries).\nparty An individual (person), organization, device, or process. In this recommendation,\n      there are typically two parties (e.g., Party A and Party B, Alice and Bob) that jointly\n      perform the key-establishment process using a KEM.\npost-quantum algorithm A cryptographic algorithm that is believed to be secure, even\n      against adversaries who possess a cryptanalytically relevant quantum computer.\npseudorandom   A process (or data produced by a process) whose outcome is determinis-\n      tic yet also appears effectively random if the internal action of the process is hid-\n      den from observation.  For cryptographic purposes, â€œeffectively randomâ€ means\n      â€œcomputationally indistinguishable from random within the limits of the intended\n      security strength.â€\npublic channel A communication channel between two honest parties that can be ob-\n      served and compromised by third parties.\nquantum-vulnerable algorithm A cryptographic algorithm that is believed to be secure\n      against adversaries who possess only a classical computer but is known to be in-\n      secure against adversaries who possess a cryptanalytically relevant quantum com-\n      puter.\nsecurity strength A number associated with the amount of work that is required to break\n      a cryptographic algorithm or system.\nseed  A bit string used as input to a pseudorandom process.\nshall Used to indicate a requirement of this document that will be tested by a CMVP test-\n      ing lab.\n\n                                      51"}
{"doc_id": "NIST.SP.800-227", "source_path": "data/raw_pdfs/NIST.SP.800-227.pdf", "page_number": 60, "text": "NIST SP 800-227\nSeptember 2025    Recommendations for KEMs\n\nshared secret A secret value that has been computed during a key-establishment scheme,\n        is known by all participating parties, and is         used as input to a key-derivation\n        method to produce keying material.\nshared secret key     A shared secret that can be used directly as keying material or as a sym-\n        metric key.\nshould  Used to indicate a strong recommendation but not a requirement of this docu-\n        ment. Ignoring the recommendation could lead to undesirable results.\nside-channel attack             An attack enabled by the leakage of information from a deployed\n        cryptosystem. Characteristics that could be exploited in a side-channel attack in-\n        clude timing, power consumption, and electromagnetic and acoustic emissions.\nstatic key A key that is intended for use for a relatively long period of time and is typically\n        intended for use in many instances of a cryptographic key-establishment scheme.\n        Contrast with ephemeral key.\nsymmetric-key algorithm          A cryptographic algorithm that uses the same secret key for an\n        operation and its complement (e.g., encryption and decryption). Also called a\n        secret-key algorithm.\ntrusted third party An entity other than the owner and verifier that is trusted by the\n        owner, the verifier, or both to provide certain services.\n\n52"}
{"doc_id": "NIST.SP.800-227", "source_path": "data/raw_pdfs/NIST.SP.800-227.pdf", "page_number": 61, "text": "NIST SP 800-227\nSeptember 2025    Recommendations for KEMs\n\nAppendix C. Cryptographic Components\n\nAppendix C.1. Message Authentication Codes (MACs)\nA MAC algorithm defines a family of cryptographic functions that is parameterized by a\nsymmetric key. It is computationally infeasible to determine the MAC of a newly formed\nMAC_Data output value without knowledge of the KC_Key value, even if one has seen\nthe MACs corresponding to other MAC_Data values that were computed using that same\nKC_Key value.\nThe input to a MAC algorithm includes a symmetric key KC_Key and a binary data string\nMAC_Data that serves as the â€œmessage.â€  That is, a MAC computation is represented as\nMAC(KC_Key, MAC_Data). In this recommendation, a MAC algorithm is used if key con-\nfirmation is performed during key establishment (see Sec. 4.4).\nWhen key confirmation requires the use of a MAC algorithm, it shall be an approved MAC\nalgorithm (i.e., HMAC, AES-CMAC, or KMAC). HMAC is specified in SP 800-224 [35] and\nrequires the use of an approved hash function. AES-CMAC is specified in SP 800-38B [36]\nfor the AES block cipher algorithm specified in FIPS 197. KMAC is specified in SP 800-185\n[37]. In addition, AES-GMAC (specified in [9]) is an approved MAC algorithm and may be\nused.\nWhen a MAC tag (MacTag) is used for key confirmation, an entity shall compute the MAC\ntag on received or derived data using a MAC algorithm with a KC_Key that is determined\nfrom a shared secret key. The MAC tag is sent to the other entity participating in the key-\nestablishment scheme in order to provide assurance that the shared secret key or derived\nkeying material was correctly computed. MacTag computation and verification are de-\nscribed below.\n\nMAC Tag Computation for Key Confirmation. Key confirmation can be performed as one\nor more additional steps in a KEM scheme. The computation of a MAC tag is represented\nas follows:\n              MacTag = TMacTagBits[MAC(KC_Key, MAC_Data)].\nTo compute a MacTag:\n1.   The agreed-upon MAC algorithm (see Table 1) is used with KC_Key to compute the\n     MAC on MAC_Data, where KC_Key is a symmetric key, and MAC_Data represents\n     the input â€œmessageâ€ data. The minimum length of KC_Key is specified in Table 1.\n     KC_Key is obtained from the the shared secret key, as specified in Sec. 4.4.2.\n     The output of the MAC algorithm MacOut put is a bit string whose length in bits is\n     MacOut putBits.\n\n53"}
{"doc_id": "NIST.SP.800-227", "source_path": "data/raw_pdfs/NIST.SP.800-227.pdf", "page_number": 62, "text": "NIST SP 800-227\nSeptember 2025    Recommendations for KEMs\n\n                  Table 1. Approved MAC algorithms for key confirmation\n\n MAC Algorithm  MacOutputBits             Permissible KC_Key                        Supported Security\n                                          Lengths (Î¼ bits)                          Strengths for Key\n                                                                                    Confirmation (s bits)\n HMAC_SHA-256        256\n HMAC_SHA-512/256    256\n HMAC_SHA-384        384\n HMAC_SHA-512        512                                                            128 â‰¤ s â‰¤ 256\n HMAC_SHA3-256       256                          s â‰¤ Î¼ â‰¤ 512\n HMAC_SHA3-384       384\n HMAC_SHA3-512       512\n KMAC128         â‰¤ 22040 âˆ’ 1                                                           s = 128\n KMAC256                                                                            128 â‰¤ s â‰¤ 256\n AES-128-CMAC        128                          Î¼ = 128                              s = 128\n AES-192-CMAC        128                          Î¼ = 192                           128 â‰¤ s â‰¤ 192\n AES-256-CMAC        128                          Î¼ = 256                           128 â‰¤ s â‰¤ 256\n AES-128-GMAC        128                          Î¼ = 128                              s = 128\n AES-192-GMAC        128                          Î¼ = 192                           128 â‰¤ s â‰¤ 192\n AES-256-GMAC        128                          Î¼ = 256                           128 â‰¤ s â‰¤ 256\n\n 2.  The MacOut put  bits                         are input to the truncation function TMacTagBits, which re-\n     turns  the  leftmost (i.e., initial) bits of                     MacOut put to be used as the value of\n     MacTag. MacTagBits needs to be less than or equal to MacOut putBits long. When\n     MacTagBits equals MacOut putBits, TMacTagBits acts as the identity function.                       The\n     minimum value for MacTagBits is 64.\n\nMacTag Verification for Key Confirmation. To verify a received MacTag (i.e., received dur-\ning key confirmation), a new Mac tag MacTagâ€² is computed using the values of KC_Key,\nMacTagBits, and MAC_Data generated by the recipient (as specified                   in         Sec. 4.4.1).\nMacTagâ€² is compared with the received MacTag.     If their values are equal, then it may\nbe inferred that the same KC_Key, MacTagBits, and MAC_Data values were used in the\ntwo MacTag computations.\n\nAppendix C.2. Nonces\nA nonce is a time-varying value with a negligible chance of repeating. A decapsulator may\nbe required to provide a public nonce that is used for key-confirmation purposes.                  This\ncircumstance arises when the decapsulatorâ€™s public key is static.\nA nonce may be composed of one or more of the following components, though other\ncomponents may also be appropriate:\n\n54"}
{"doc_id": "NIST.SP.800-227", "source_path": "data/raw_pdfs/NIST.SP.800-227.pdf", "page_number": 63, "text": "NIST SP 800-227\nSeptember 2025    Recommendations for KEMs\n\n 1.  A random bit string that is generated anew for each nonce using an approved ran-\n     dom bit generator. A nonce containing a component of this type is called a random\n     nonce.\n 2.  A timestamp of sufficient resolution so that it is different each time it is used.\n 3.  A monotonically increasing sequence number.\n 4.  A combination of a timestamp and a monotonically increasing sequence num-\n     ber such that the sequence number is reset when and only when the timestamp\n     changes. For example, a timestamp may show the date but not the time of day, so\n     a sequence number is appended that will not repeat during a particular day.\nWhen a nonce is required for key-confirmation purposes as specified in this recommen-\ndation, it should be a random nonce that contains a random bit string output from an\napproved random bit generator, where both the security strength supported by the in-\nstantiation of the random bit generator and the bit length of the random bit string are\ngreater than or equal to the targeted security strength of the key-establishment scheme\nin which the nonce is used during key confirmation. When feasible, the bit length of the\nrandom bit string should be at least twice the targeted security strength. For details con-\ncerning the security strength supported by an instantiation of a random bit generator, see\nthe SP 800-90 series of publications [6â€“8].\nAs part of the proper implementation of this recommendation, system users and/or agents\ntrusted to act on their behalf should determine whether the components selected for in-\nclusion in any required nonces meet their security requirements.\n\n55"}
{"doc_id": "NIST.SP.800-227", "source_path": "data/raw_pdfs/NIST.SP.800-227.pdf", "page_number": 64, "text": "NIST SP 800-227\nSeptember 2025    Recommendations for KEMs\n\nAppendix D. Changes From Draft SP 800-227\n\n1.  Section numbers have shifted due to reorganization.\n2.  Section 4.5 was added to address discussions from the NIST KEM workshop and writ-\n    ten public comments about how the unique functionality of RSA allows for special\n    procedures to achieve proof of possession that does not generally apply to KEMs.\n3.  To align with existing requirements in SP800-56A and SP800-56B, additional require-\n    ments were added to Sec. 4.1 and 4.2 for ephemeral and static KEM key-pairs,\n    namely:\n       â€¢ Additional shall statement in Sec. 4.2: Ephemeral key pairs shall be used in only\n        one execution of key-establishment via a KEM and shall be destroyed as soon\n        as possible after use.\n       â€¢ Additional must statement in Sec. 4.2:  If an encapsulating party obtains\n        the static encapsulation key of another party, it must have assurance of the\n        other partyâ€™s ownership of the key before or during the execution of key-\n        establishment.  This assurance can be obtained from a trusted party (e.g., a\n        certificate authority) or a combination of proof of possession and verification\n        of real-world identity.\n4.  In Sec. 4.6.2, the concatenation of inputs to hash functions was modified to be\n    comma separated. Public comments noted that concatenation may not be appro-\n    priate, depending on the protocol or context.\n5.  Two examples were added to Sec. 5 (Sec. 5.2.4 and 5.2.5) to illustrate how to use\n    KEMs to achieve authenticated key establishment. Additionally, existing examples\n    were updated.\n6.  Section 4.3 was updated with guidelines on how to create keys that are smaller than\n    the output KEM key. Public comments noted this as particularly relevant for ML-\n    KEM, which outputs 256-bit keys at all security levels.\n7.  A public comment noted that a â€œshallâ€ requirement in Sec. 4.4 was overly restrictive\n    in permitting KEM parameters of one security level to be used alongside lower secu-\n    rity level protocols (e.g., running ML-KEM 768 at 128 bits of security). This has been\n    updated accordingly.\n\n56"}
