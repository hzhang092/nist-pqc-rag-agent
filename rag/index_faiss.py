"""
FAISS Index Building Script.

This script builds a FAISS index from the vector embeddings generated by the
`embed.py` script. The index allows for efficient similarity searches, which is
the core of the retrieval mechanism in the RAG system.

The key steps are:
1.  Load the embeddings from the `.npy` file.
2.  Load the metadata to get the vector dimension.
3.  Ensure the embeddings are L2-normalized, which is required for using the
    Inner Product (IP) metric as a proxy for cosine similarity.
4.  Create a `faiss.IndexFlatIP` index, which performs an exact, brute-force
    search for the nearest neighbors.
5.  Add the embeddings to the index.
6.  Save the populated index to disk, making it available for the search script.
"""

# rag/index_faiss.py (build + save index)
from pathlib import Path
import json
import numpy as np
import faiss

OUT_DIR = Path("data/processed")
EMB_PATH = OUT_DIR / "embeddings.npy"
META_PATH = OUT_DIR / "emb_meta.json"
INDEX_PATH = OUT_DIR / "faiss.index"

def main():
    """
    Loads embeddings, builds a FAISS index, and saves it to disk.
    """
    assert EMB_PATH.exists(), f"Missing {EMB_PATH}"
    meta = json.loads(META_PATH.read_text(encoding="utf-8"))
    dim = int(meta["dim"])

    embs = np.load(EMB_PATH).astype("float32")
    assert embs.shape[1] == dim

    # If you didn't normalize during encoding, do it here:
    faiss.normalize_L2(embs)

    index = faiss.IndexFlatIP(dim)  # cosine similarity via inner product on normalized vectors
    index.add(embs)

    faiss.write_index(index, str(INDEX_PATH))
    print(f"[OK] saved {INDEX_PATH}  vectors={index.ntotal} dim={dim}")

if __name__ == "__main__":
    main()
